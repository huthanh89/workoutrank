/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var $, Application, Highstock, _;

	$ = __webpack_require__(2);

	_ = __webpack_require__(3);

	Highstock = __webpack_require__(5);

	Application = __webpack_require__(6);

	Highstock.setOptions({
	  global: {
	    useUTC: false
	  }
	});

	window.jQuery = window.$ = __webpack_require__(2);

	__webpack_require__(78);

	__webpack_require__(79);

	if (!$().modal) {
	  console.log('bootstrap is not working.');
	}

	(function(i, s, o, g, r, a, m) {
	  i['GoogleAnalyticsObject'] = r;
	  i[r] = i[r] || function() {
	    (i[r].q = i[r].q || []).push(arguments);
	  };
	  i[r].l = 1 * new Date;
	  a = s.createElement(o);
	  m = s.getElementsByTagName(o)[0];
	  a.async = 1;
	  a.src = g;
	  m.parentNode.insertBefore(a, m);
	})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

	ga('create', 'UA-74126093-1', 'auto');

	$(function() {
	  Application.start();
	});


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/
	var jQuery = __webpack_require__(2);

	/*!
	 * jQuery JavaScript Library v2.2.0
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-01-08T20:02Z
	 */

	(function( global, factory ) {

		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];

	var document = window.document;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};



	var
		version = "2.2.0",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?

				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :

				// Return all the elements in a clean array
				slice.call( this );
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},

		isArray: Array.isArray,

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {

			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj && obj.toString();
			return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
		},

		isPlainObject: function( obj ) {

			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}

			if ( obj.constructor &&
					!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
				return false;
			}

			// If the function hasn't returned already, we're confident that
			// |obj| is a plain object, created by {} or constructed with new Object
			return true;
		},

		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}

			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;

			code = jQuery.trim( code );

			if ( code ) {

				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf( "use strict" ) === 1 ) {
					script = document.createElement( "script" );
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {

					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval

					indirect( code );
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	/* jshint ignore: end */

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.1
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-10-17
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,
		rescape = /'|\\/g,

		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, nidselect, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rescape, "\\$&" );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
						while ( i-- ) {
							groups[i] = nidselect + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");

		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( (parent = document.defaultView) && parent.top !== parent ) {
			// Support: IE 11
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( document.createComment("") );
			return !div.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					return m ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];

			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},

			"disabled": function( elem ) {
				return elem.disabled === true;
			},

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( (oldCache = uniqueCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ dir ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;



	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			} );

		}

		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );

		}

		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}

			qualifier = jQuery.filter( qualifier, elements );
		}

		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if ( elem && elem.parentNode ) {

							// Inject the element directly into the jQuery object
							this.length = 1;
							this[ 0 ] = elem;
						}

						this.context = document;
						this.selector = selector;
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;

			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( pos ?
						pos.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnotwhite = ( /\S+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this === promise ? newDefer.promise() : this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];

				// promise[ done | fail | progress ] = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add( function() {

						// state = [ resolved | rejected ]
						state = stateString;

					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}

				// deferred[ resolve | reject | notify ]
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,

				// the count of uncompleted subordinates
				remaining = length !== 1 ||
					( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

				// the master Deferred.
				// If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},

				progressValues, progressContexts, resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.progress( updateFunc( i, progressContexts, progressValues ) )
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject );
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}

			return deferred.promise();
		}
	} );


	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function( fn ) {

		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	} );

	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if ( document.readyState === "complete" ||
				( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout( jQuery.ready );

			} else {

				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed );

				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed );
			}
		}
		return readyList.promise( obj );
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		register: function( owner, initial ) {
			var value = initial || {};

			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if ( owner.nodeType ) {
				owner[ this.expando ] = value;

			// Otherwise secure it in a non-enumerable, non-writable property
			// configurability must be true to allow the property to be
			// deleted with the delete operator
			} else {
				Object.defineProperty( owner, this.expando, {
					value: value,
					writable: true,
					configurable: true
				} );
			}
			return owner[ this.expando ];
		},
		cache: function( owner ) {

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( !acceptData( owner ) ) {
				return {};
			}

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
				owner[ this.expando ] && owner[ this.expando ][ key ];
		},
		access: function( owner, key, value ) {
			var stored;

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				stored = this.get( owner, key );

				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase( key ) );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key === undefined ) {
				this.register( owner );

			} else {

				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {

					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );

					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {

						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}

				i = name.length;

				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <= 35-45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :

						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data, camelKey;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get( elem, key ) ||

						// Try to find dashed key if it exists (gh-2779)
						// This is for 2.2.x only
						dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

					if ( data !== undefined ) {
						return data;
					}

					camelKey = jQuery.camelCase( key );

					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				camelKey = jQuery.camelCase( key );
				this.each( function() {

					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get( this, camelKey );

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set( this, camelKey, value );

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
						dataUser.set( this, key, value );
					}
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHidden = function( elem, el ) {

			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" ||
				!jQuery.contains( elem.ownerDocument, elem );
		};



	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() { return tween.cur(); } :
				function() { return jQuery.css( elem, prop, "" ); },
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );

			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([\w:-]+)/ );

	var rscriptType = ( /^$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ?
				context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ?
					context.querySelectorAll( tag || "*" ) :
				[];

		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0-4.3, Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();


	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( event ) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );

			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox<=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if ( delegateCount && cur.nodeType &&
				( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push( { elem: cur, handlers: matches } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
			"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split( " " ),
			filter: function( event, original ) {

				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
				"screenX screenY toElement" ).split( " " ),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX +
						( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
						( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY +
						( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
						( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}

				return event;
			}
		},

		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];

			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

			event = new jQuery.Event( originalEvent );

			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android<4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

		// Support: IE 10-11, Edge 10240+
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	function manipulationTarget( elem, content ) {
		if ( jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

			return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {

		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,

		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );


	var iframe,
		elemdisplay = {

			// Support: Firefox
			// We have to pre-define these values for FF (#10227)
			HTML: "block",
			BODY: "block"
		};

	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */

	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

			display = jQuery.css( elem[ 0 ], "display" );

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];

		if ( !display ) {
			display = actualDisplay( nodeName, doc );

			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {

				// Use the already-created iframe if possible
				iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
					.appendTo( doc.documentElement );

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}

		return display;
	}
	var rmargin = ( /^margin/ );

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};


	var documentElement = document.documentElement;



	( function() {
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =

				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild( container );
		}

		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {

				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {

				// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =

					// Support: Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;box-sizing:content-box;" +
					"display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

				documentElement.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE9-11+
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,

		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?

			// If we already have the right measurement, avoid augmentation
			4 :

			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,

			val = 0;

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {

				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Support: IE11 only
		// In IE 11 fullscreen elements inside of an iframe have
		// 100x too small dimensions (gh-1764).
		if ( document.msFullscreenElement && window.top !== window ) {

			// Support: IE11 only
			// Running getBoundingClientRect on a disconnected node
			// in IE throws an error.
			if ( elem.getClientRects().length ) {
				val = Math.round( elem.getBoundingClientRect()[ name ] * 100 );
			}
		}

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}

			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );

			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;

		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			values[ index ] = dataPriv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {

				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = dataPriv.access(
						elem,
						"olddisplay",
						defaultDisplay( elem.nodeName )
					);
				}
			} else {
				hidden = isHidden( elem );

				if ( display !== "none" || !hidden ) {
					dataPriv.set(
						elem,
						"olddisplay",
						hidden ? display : jQuery.css( elem, "display" )
					);
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;

			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					style[ name ] = value;
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );

			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
						elem.offsetWidth === 0 ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				return swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", {} );
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done( function() {
					jQuery( elem ).hide();
				} );
			}
			anim.done( function() {
				var prop;

				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
			style.display = display;
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length ; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}

	jQuery.Animation = jQuery.extend( Animation, {
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnotwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
			opt.duration : opt.duration in jQuery.fx.speeds ?
				jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};

	jQuery.fx.stop = function() {
		window.clearInterval( timerId );

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					propName = jQuery.propFix[ name ] || name;

					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {

						// Set corresponding property to false
						elem[ propName ] = false;
					}

					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) && elem.href ?
								0 :
								-1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




	var rclass = /[\t\r\n\f]/g;

	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( type === "string" ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnotwhite ) || [];

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + getClass( elem ) + " " ).replace( rclass, " " )
						.indexOf( className ) > -1
				) {
					return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?

						// Handle most common string cases
						ret.replace( rreturn, "" ) :

						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					// Support: IE<11
					// option.value not trimmed (#14858)
					return jQuery.trim( elem.value );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ?
									!option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];
						if ( option.selected =
								jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true

					// Previously, `originalEvent: {}` was set here, so stopPropagation call
					// would not be triggered on donor event, since in our own
					// jQuery.event.stopPropagation function we had a check for existence of
					// originalEvent.stopPropagation method, so, consequently it would be a noop.
					//
					// But now, this "simulate" function is used only for events
					// for which stopPropagation() is noop, so there is no need for that anymore.
					//
					// For the compat branch though, guard for "click" and "submit"
					// events is still used, but was moved to jQuery.event.stopPropagation function
					// because `originalEvent` should point to the original event for the constancy
					// with other events and for more focused logic
				}
			);

			jQuery.event.trigger( e, null, elem );

			if ( e.isDefaultPrevented() ) {
				event.preventDefault();
			}
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	support.focusin = "onfocusin" in window;


	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = ( /\?/ );



	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};


	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE9
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

			if ( jQuery.isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// The jqXHR state
				state = 0,

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {

									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?

						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :

						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( state === 2 ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );

					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Called once
				if ( state === 2 ) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapAll( html.call( this, i ) );
				} );
			}

			if ( this[ 0 ] ) {

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function() {
			return this.parent().each( function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			} ).end();
		}
	} );


	jQuery.expr.filters.hidden = function( elem ) {
		return !jQuery.expr.filters.visible( elem );
	};
	jQuery.expr.filters.visible = function( elem ) {

		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};




	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( jQuery.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {

				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );

					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Support: Safari 8+
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();


	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		context = context || ( support.createHTMLDocument ?
			document.implementation.createHTMLDocument( "" ) :
			document );

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}

		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( self, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;

			if ( !doc ) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}

			box = elem.getBoundingClientRect();
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				// Subtract offsetParent scroll positions
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ) -
					offsetParent.scrollTop();
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true ) -
					offsetParent.scrollLeft();
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari<7-8+, Chrome<37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {

						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		} );
	} );


	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		},
		size: function() {
			return this.length;
		}
	} );

	jQuery.fn.andSelf = jQuery.fn.addBack;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}



	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
	}));



/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**
	 * @license
	 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern -o ./lodash.js`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	;(function() {

	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;

	  /** Used as the semantic version number. */
	  var VERSION = '3.2.0';

	  /** Used to compose bitmasks for wrapper metadata. */
	  var BIND_FLAG = 1,
	      BIND_KEY_FLAG = 2,
	      CURRY_BOUND_FLAG = 4,
	      CURRY_FLAG = 8,
	      CURRY_RIGHT_FLAG = 16,
	      PARTIAL_FLAG = 32,
	      PARTIAL_RIGHT_FLAG = 64,
	      REARG_FLAG = 128,
	      ARY_FLAG = 256;

	  /** Used as default options for `_.trunc`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';

	  /** Used to detect when a function becomes hot. */
	  var HOT_COUNT = 150,
	      HOT_SPAN = 16;

	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 0,
	      LAZY_MAP_FLAG = 1,
	      LAZY_WHILE_FLAG = 2;

	  /** Used as the `TypeError` message for "Functions" methods. */
	  var FUNC_ERROR_TEXT = 'Expected a function';

	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';

	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      objectTag = '[object Object]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      weakMapTag = '[object WeakMap]';

	  var arrayBufferTag = '[object ArrayBuffer]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';

	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
	      reUnescapedHtml = /[&<>"'`]/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;

	  /**
	   * Used to match ES template delimiters.
	   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literal-lexical-components)
	   * for more details.
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;

	  /** Used to detect named functions. */
	  var reFuncName = /^\s*function[ \n\r\t]+\w/;

	  /** Used to detect hexadecimal string values. */
	  var reHexPrefix = /^0[xX]/;

	  /** Used to detect host constructors (Safari > 5). */
	  var reHostCtor = /^\[object .+?Constructor\]$/;

	  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
	  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;

	  /**
	   * Used to match `RegExp` special characters.
	   * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)
	   * for more details.
	   */
	  var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
	      reHasRegExpChars = RegExp(reRegExpChars.source);

	  /** Used to detect functions containing a `this` reference. */
	  var reThis = /\bthis\b/;

	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	  /** Used to match words to create compound words. */
	  var reWords = (function() {
	    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
	        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

	    return RegExp(upper + '{2,}(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
	  }());

	  /** Used to detect and test for whitespace. */
	  var whitespace = (
	    // Basic whitespace characters.
	    ' \t\x0b\f\xa0\ufeff' +

	    // Line terminators.
	    '\n\r\u2028\u2029' +

	    // Unicode category "Zs" space separators.
	    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
	  );

	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
	    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document',
	    'isFinite', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
	    'window', 'WinRTError'
	  ];

	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;

	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
	  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
	  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
	  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
	  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
	  cloneableTags[dateTag] = cloneableTags[float32Tag] =
	  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
	  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[stringTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[mapTag] = cloneableTags[setTag] =
	  cloneableTags[weakMapTag] = false;

	  /** Used as an internal `_.debounce` options object by `_.throttle`. */
	  var debounceOptions = {
	    'leading': false,
	    'maxWait': 0,
	    'trailing': false
	  };

	  /** Used to map latin-1 supplementary letters to basic latin letters. */
	  var deburredLetters = {
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss'
	  };

	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;',
	    '`': '&#96;'
	  };

	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'",
	    '&#96;': '`'
	  };

	  /** Used to determine if values are of the language type `Object`. */
	  var objectTypes = {
	    'function': true,
	    'object': true
	  };

	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /**
	   * Used as a reference to the global object.
	   *
	   * The `this` value is used if it is the global object to avoid Greasemonkey's
	   * restricted `window` object, otherwise the `window` object is used.
	   */
	  var root = (objectTypes[typeof window] && window !== (this && this.window)) ? window : this;

	  /** Detect free variable `exports`. */
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

	  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
	  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
	  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
	    root = freeGlobal;
	  }

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

	  /*--------------------------------------------------------------------------*/

	  /**
	   * The base implementation of `compareAscending` which compares values and
	   * sorts them in ascending order without guaranteeing a stable sort.
	   *
	   * @private
	   * @param {*} value The value to compare to `other`.
	   * @param {*} other The value to compare to `value`.
	   * @returns {number} Returns the sort order indicator for `value`.
	   */
	  function baseCompareAscending(value, other) {
	    if (value !== other) {
	      var valIsReflexive = value === value,
	          othIsReflexive = other === other;

	      if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {
	        return 1;
	      }
	      if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {
	        return -1;
	      }
	    }
	    return 0;
	  }

	  /**
	   * The base implementation of `_.indexOf` without support for binary searches.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} value The value to search for.
	   * @param {number} [fromIndex=0] The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    if (value !== value) {
	      return indexOfNaN(array, fromIndex);
	    }
	    var index = (fromIndex || 0) - 1,
	        length = array.length;

	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.sortBy` and `_.sortByAll` which uses `comparer`
	   * to define the sort order of `array` and replaces criteria objects with their
	   * corresponding values.
	   *
	   * @private
	   * @param {Array} array The array to sort.
	   * @param {Function} comparer The function to define sort order.
	   * @returns {Array} Returns `array`.
	   */
	  function baseSortBy(array, comparer) {
	    var length = array.length;

	    array.sort(comparer);
	    while (length--) {
	      array[length] = array[length].value;
	    }
	    return array;
	  }

	  /**
	   * Converts `value` to a string if it is not one. An empty string is returned
	   * for `null` or `undefined` values.
	   *
	   * @private
	   * @param {*} value The value to process.
	   * @returns {string} Returns the string.
	   */
	  function baseToString(value) {
	    if (typeof value == 'string') {
	      return value;
	    }
	    return value == null ? '' : (value + '');
	  }

	  /**
	   * Used by `_.max` and `_.min` as the default callback for string values.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the code unit of the first character of the string.
	   */
	  function charAtCallback(string) {
	    return string.charCodeAt(0);
	  }

	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the first character not found in `chars`.
	   */
	  function charsLeftIndex(string, chars) {
	    var index = -1,
	        length = string.length;

	    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the last character not found in `chars`.
	   */
	  function charsRightIndex(string, chars) {
	    var index = string.length;

	    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.sortBy` to compare transformed elements of a collection and stable
	   * sort them in ascending order.
	   *
	   * @private
	   * @param {Object} object The object to compare to `other`.
	   * @param {Object} other The object to compare to `object`.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareAscending(object, other) {
	    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
	  }

	  /**
	   * Used by `_.sortByAll` to compare multiple properties of each element
	   * in a collection and stable sort them in ascending order.
	   *
	   * @private
	   * @param {Object} object The object to compare to `other`.
	   * @param {Object} other The object to compare to `object`.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareMultipleAscending(object, other) {
	    var index = -1,
	        objCriteria = object.criteria,
	        othCriteria = other.criteria,
	        length = objCriteria.length;

	    while (++index < length) {
	      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
	      if (result) {
	        return result;
	      }
	    }
	    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	    // that causes it, under certain circumstances, to provide the same value for
	    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	    // for more details.
	    //
	    // This also ensures a stable sort in V8 and other engines.
	    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
	    return object.index - other.index;
	  }

	  /**
	   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  function deburrLetter(letter) {
	    return deburredLetters[letter];
	  }

	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeHtmlChar(chr) {
	    return htmlEscapes[chr];
	  }

	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled
	   * string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }

	  /**
	   * Gets the index at which the first occurrence of `NaN` is found in `array`.
	   * If `fromRight` is provided elements of `array` are iterated from right to left.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {number} [fromIndex] The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
	   */
	  function indexOfNaN(array, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromRight ? (fromIndex || length) : ((fromIndex || 0) - 1);

	    while ((fromRight ? index-- : ++index < length)) {
	      var other = array[index];
	      if (other !== other) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * Checks if `value` is object-like.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	   */
	  function isObjectLike(value) {
	    return (value && typeof value == 'object') || false;
	  }

	  /**
	   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
	   * character code is whitespace.
	   *
	   * @private
	   * @param {number} charCode The character code to inspect.
	   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
	   */
	  function isSpace(charCode) {
	    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
	      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
	  }

	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];

	    while (++index < length) {
	      if (array[index] === placeholder) {
	        array[index] = PLACEHOLDER;
	        result[++resIndex] = index;
	      }
	    }
	    return result;
	  }

	  /**
	   * An implementation of `_.uniq` optimized for sorted arrays without support
	   * for callback shorthands and `this` binding.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} [iteratee] The function invoked per iteration.
	   * @returns {Array} Returns the new duplicate-value-free array.
	   */
	  function sortedUniq(array, iteratee) {
	    var seen,
	        index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];

	    while (++index < length) {
	      var value = array[index],
	          computed = iteratee ? iteratee(value, index, array) : value;

	      if (!index || seen !== computed) {
	        seen = computed;
	        result[++resIndex] = value;
	      }
	    }
	    return result;
	  }

	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the first non-whitespace character.
	   */
	  function trimmedLeftIndex(string) {
	    var index = -1,
	        length = string.length;

	    while (++index < length && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the last non-whitespace character.
	   */
	  function trimmedRightIndex(string) {
	    var index = string.length;

	    while (index-- && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  function unescapeHtmlChar(chr) {
	    return htmlUnescapes[chr];
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Create a new pristine `lodash` function using the given `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @category Utility
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'add': function(a, b) { return a + b; } });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'sub': function(a, b) { return a - b; } });
	   *
	   * _.isFunction(_.add);
	   * // => true
	   * _.isFunction(_.sub);
	   * // => false
	   *
	   * lodash.isFunction(lodash.add);
	   * // => false
	   * lodash.isFunction(lodash.sub);
	   * // => true
	   *
	   * // using `context` to mock `Date#getTime` use in `_.now`
	   * var mock = _.runInContext({
	   *   'Date': function() {
	   *     return { 'getTime': getTimeMock };
	   *   }
	   * });
	   *
	   * // or creating a suped-up `defer` in Node.js
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  function runInContext(context) {
	    // Avoid issues with some ES3 environments that attempt to use values, named
	    // after built-in constructors like `Object`, for the creation of literals.
	    // ES5 clears this up by stating that literals must use built-in constructors.
	    // See https://es5.github.io/#x11.1.5 for more details.
	    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

	    /** Native constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Number = context.Number,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;

	    /** Used for native method references. */
	    var arrayProto = Array.prototype,
	        objectProto = Object.prototype;

	    /** Used to detect DOM support. */
	    var document = (document = context.window) && document.document;

	    /** Used to resolve the decompiled source of functions. */
	    var fnToString = Function.prototype.toString;

	    /** Used to the length of n-tuples for `_.unzip`. */
	    var getLength = baseProperty('length');

	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;

	    /** Used to generate unique IDs. */
	    var idCounter = 0;

	    /**
	     * Used to resolve the `toStringTag` of values.
	     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	     * for more details.
	     */
	    var objToString = objectProto.toString;

	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = context._;

	    /** Used to detect if a method is native. */
	    var reNative = RegExp('^' +
	      escapeRegExp(objToString)
	      .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );

	    /** Native method references. */
	    var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer,
	        bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
	        ceil = Math.ceil,
	        clearTimeout = context.clearTimeout,
	        floor = Math.floor,
	        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
	        push = arrayProto.push,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        Set = isNative(Set = context.Set) && Set,
	        setTimeout = context.setTimeout,
	        splice = arrayProto.splice,
	        Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array,
	        WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;

	    /** Used to clone array buffers. */
	    var Float64Array = (function() {
	      // Safari 5 errors when using an array buffer to initialize a typed array
	      // where the array buffer's `byteLength` is not a multiple of the typed
	      // array's `BYTES_PER_ELEMENT`.
	      try {
	        var func = isNative(func = context.Float64Array) && func,
	            result = new func(new ArrayBuffer(10), 0, 1) && func;
	      } catch(e) {}
	      return result;
	    }());

	    /* Native method references for those with the same name as other `lodash` methods. */
	    var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
	        nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
	        nativeIsFinite = context.isFinite,
	        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = isNative(nativeNow = Date.now) && nativeNow,
	        nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random;

	    /** Used as references for `-Infinity` and `Infinity`. */
	    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
	        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

	    /** Used as references for the maximum length and index of an array. */
	    var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,
	        MAX_ARRAY_INDEX =  MAX_ARRAY_LENGTH - 1,
	        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

	    /** Used as the size, in bytes, of each `Float64Array` element. */
	    var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

	    /**
	     * Used as the maximum length of an array-like value.
	     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
	     * for more details.
	     */
	    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
	     * Methods that operate on and return arrays, collections, and functions can
	     * be chained together. Methods that return a boolean or single value will
	     * automatically end the chain returning the unwrapped value. Explicit chaining
	     * may be enabled using `_.chain`. The execution of chained methods is lazy,
	     * that is, execution is deferred until `_#value` is implicitly or explicitly
	     * called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
	     * fusion is an optimization that merges iteratees to avoid creating intermediate
	     * arrays and reduce the number of iteratee executions.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers also have the following `Array` methods:
	     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
	     * and `unshift`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
	     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
	     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
	     * and `where`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
	     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
	     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`,
	     * `difference`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `fill`,
	     * `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`, `forEach`,
	     * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,
	     * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,
	     * `keysIn`, `map`, `mapValues`, `matches`, `matchesProperty`, `memoize`, `merge`,
	     * `mixin`, `negate`, `noop`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
	     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
	     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `reverse`,
	     * `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`, `splice`, `spread`,
	     * `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`, `throttle`,
	     * `thru`, `times`, `toArray`, `toPlainObject`, `transform`, `union`, `uniq`,
	     * `unshift`, `unzip`, `values`, `valuesIn`, `where`, `without`, `wrap`, `xor`,
	     * `zip`, and `zipObject`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,
	     * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,
	     * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `has`,
	     * `identity`, `includes`, `indexOf`, `isArguments`, `isArray`, `isBoolean`,
	     * `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`, `isFinite`,
	     * `isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`,
	     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`,
	     * `isTypedArray`, `join`, `kebabCase`, `last`, `lastIndexOf`, `max`, `min`,
	     * `noConflict`, `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`,
	     * `random`, `reduce`, `reduceRight`, `repeat`, `result`, `runInContext`,
	     * `shift`, `size`, `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`,
	     * `startCase`, `startsWith`, `template`, `trim`, `trimLeft`, `trimRight`,
	     * `trunc`, `unescape`, `uniqueId`, `value`, and `words`
	     *
	     * The wrapper method `sample` will return a wrapped value when `n` is provided,
	     * otherwise an unwrapped value is returned.
	     *
	     * @name _
	     * @constructor
	     * @category Chain
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // returns an unwrapped value
	     * wrapped.reduce(function(sum, n) { return sum + n; });
	     * // => 6
	     *
	     * // returns a wrapped value
	     * var squares = wrapped.map(function(n) { return n * n; });
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }

	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
	     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
	     */
	    function LodashWrapper(value, chainAll, actions) {
	      this.__wrapped__ = value;
	      this.__actions__ = actions || [];
	      this.__chain__ = !!chainAll;
	    }

	    /**
	     * An object environment feature flags.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    var support = lodash.support = {};

	    (function(x) {

	      /**
	       * Detect if functions can be decompiled by `Function#toString`
	       * (all but Firefox OS certified apps, older Opera mobile browsers, and
	       * the PlayStation 3; forced `false` for Windows 8 apps).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

	      /**
	       * Detect if `Function#name` is supported (all but IE).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.funcNames = typeof Function.name == 'string';

	      /**
	       * Detect if the DOM is supported.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      try {
	        support.dom = document.createDocumentFragment().nodeType === 11;
	      } catch(e) {
	        support.dom = false;
	      }

	      /**
	       * Detect if `arguments` object indexes are non-enumerable.
	       *
	       * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
	       * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
	       * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
	       * checks for indexes that exceed their function's formal parameters with
	       * associated values of `0`.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      try {
	        support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
	      } catch(e) {
	        support.nonEnumArgs = true;
	      }
	    }(0, 0));

	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB). Change the following template settings to use
	     * alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    lodash.templateSettings = {

	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'escape': reEscape,

	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'evaluate': reEvaluate,

	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'interpolate': reInterpolate,

	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type string
	       */
	      'variable': '',

	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type Object
	       */
	      'imports': {

	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type Function
	         */
	        '_': lodash
	      }
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = null;
	      this.__dir__ = 1;
	      this.__dropCount__ = 0;
	      this.__filtered__ = false;
	      this.__iteratees__ = null;
	      this.__takeCount__ = POSITIVE_INFINITY;
	      this.__views__ = null;
	    }

	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var actions = this.__actions__,
	          iteratees = this.__iteratees__,
	          views = this.__views__,
	          result = new LazyWrapper(this.__wrapped__);

	      result.__actions__ = actions ? arrayCopy(actions) : null;
	      result.__dir__ = this.__dir__;
	      result.__dropCount__ = this.__dropCount__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = views ? arrayCopy(views) : null;
	      return result;
	    }

	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }

	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value();
	      if (!isArray(array)) {
	        return baseWrapperValue(array, this.__actions__);
	      }
	      var dir = this.__dir__,
	          isRight = dir < 0,
	          view = getView(0, array.length, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          dropCount = this.__dropCount__,
	          takeCount = nativeMin(length, this.__takeCount__),
	          index = isRight ? end : start - 1,
	          iteratees = this.__iteratees__,
	          iterLength = iteratees ? iteratees.length : 0,
	          resIndex = 0,
	          result = [];

	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;

	        var iterIndex = -1,
	            value = array[index];

	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              computed = iteratee(value, index, array),
	              type = data.type;

	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        if (dropCount) {
	          dropCount--;
	        } else {
	          result[resIndex++] = value;
	        }
	      }
	      return result;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a cache object to store key/value pairs.
	     *
	     * @private
	     * @static
	     * @name Cache
	     * @memberOf _.memoize
	     */
	    function MapCache() {
	      this.__data__ = {};
	    }

	    /**
	     * Removes `key` and its value from the cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
	     */
	    function mapDelete(key) {
	      return this.has(key) && delete this.__data__[key];
	    }

	    /**
	     * Gets the cached value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the cached value.
	     */
	    function mapGet(key) {
	      return key == '__proto__' ? undefined : this.__data__[key];
	    }

	    /**
	     * Checks if a cached value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapHas(key) {
	      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
	    }

	    /**
	     * Adds `value` to `key` of the cache.
	     *
	     * @private
	     * @name set
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to cache.
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache object.
	     */
	    function mapSet(key, value) {
	      if (key != '__proto__') {
	        this.__data__[key] = value;
	      }
	      return this;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     *
	     * Creates a cache object to store unique values.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var length = values ? values.length : 0;

	      this.data = { 'hash': nativeCreate(null), 'set': new Set };
	      while (length--) {
	        this.push(values[length]);
	      }
	    }

	    /**
	     * Checks if `value` is in `cache` mimicking the return signature of
	     * `_.indexOf` by returning `0` if the value is found, else `-1`.
	     *
	     * @private
	     * @param {Object} cache The cache to search.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `0` if `value` is found, else `-1`.
	     */
	    function cacheIndexOf(cache, value) {
	      var data = cache.data,
	          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

	      return result ? 0 : -1;
	    }

	    /**
	     * Adds `value` to the cache.
	     *
	     * @private
	     * @name push
	     * @memberOf SetCache
	     * @param {*} value The value to cache.
	     */
	    function cachePush(value) {
	      var data = this.data;
	      if (typeof value == 'string' || isObject(value)) {
	        data.set.add(value);
	      } else {
	        data.hash[value] = true;
	      }
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayCopy(source, array) {
	      var index = -1,
	          length = source.length;

	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.forEach` for arrays without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEach(array, iteratee) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (iteratee(array[index], index, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.forEachRight` for arrays without support for
	     * callback shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEachRight(array, iteratee) {
	      var length = array.length;

	      while (length--) {
	        if (iteratee(array[length], length, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.every` for arrays without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     */
	    function arrayEvery(array, predicate) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (!predicate(array[index], index, array)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * A specialized version of `_.filter` for arrays without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function arrayFilter(array, predicate) {
	      var index = -1,
	          length = array.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.map` for arrays without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function arrayMap(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = iteratee(array[index], index, array);
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.max` for arrays without support for iteratees.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the maximum value.
	     */
	    function arrayMax(array) {
	      var index = -1,
	          length = array.length,
	          result = NEGATIVE_INFINITY;

	      while (++index < length) {
	        var value = array[index];
	        if (value > result) {
	          result = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.min` for arrays without support for iteratees.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the minimum value.
	     */
	    function arrayMin(array) {
	      var index = -1,
	          length = array.length,
	          result = POSITIVE_INFINITY;

	      while (++index < length) {
	        var value = array[index];
	        if (value < result) {
	          result = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.reduce` for arrays without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the first element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduce(array, iteratee, accumulator, initFromArray) {
	      var index = -1,
	          length = array.length;

	      if (initFromArray && length) {
	        accumulator = array[++index];
	      }
	      while (++index < length) {
	        accumulator = iteratee(accumulator, array[index], index, array);
	      }
	      return accumulator;
	    }

	    /**
	     * A specialized version of `_.reduceRight` for arrays without support for
	     * callback shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the last element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
	      var length = array.length;
	      if (initFromArray && length) {
	        accumulator = array[--length];
	      }
	      while (length--) {
	        accumulator = iteratee(accumulator, array[length], length, array);
	      }
	      return accumulator;
	    }

	    /**
	     * A specialized version of `_.some` for arrays without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function arraySome(array, predicate) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (predicate(array[index], index, array)) {
	          return true;
	        }
	      }
	      return false;
	    }

	    /**
	     * Used by `_.defaults` to customize its `_.assign` use.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignDefaults(objectValue, sourceValue) {
	      return typeof objectValue == 'undefined' ? sourceValue : objectValue;
	    }

	    /**
	     * Used by `_.template` to customize its `_.assign` use.
	     *
	     * **Note:** This method is like `assignDefaults` except that it ignores
	     * inherited property values when checking if a property is `undefined`.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @param {string} key The key associated with the object and source values.
	     * @param {Object} object The destination object.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignOwnDefaults(objectValue, sourceValue, key, object) {
	      return (typeof objectValue == 'undefined' || !hasOwnProperty.call(object, key))
	        ? sourceValue
	        : objectValue;
	    }

	    /**
	     * The base implementation of `_.assign` without support for argument juggling,
	     * multiple sources, and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} [customizer] The function to customize assigning values.
	     * @returns {Object} Returns the destination object.
	     */
	    function baseAssign(object, source, customizer) {
	      var props = keys(source);
	      if (!customizer) {
	        return baseCopy(source, object, props);
	      }
	      var index = -1,
	          length = props.length;

	      while (++index < length) {
	        var key = props[index],
	            value = object[key],
	            result = customizer(value, source[key], key, object, source);

	        if ((result === result ? result !== value : value === value) ||
	            (typeof value == 'undefined' && !(key in object))) {
	          object[key] = result;
	        }
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.at` without support for strings and individual
	     * key arguments.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {number[]|string[]} [props] The property names or indexes of elements to pick.
	     * @returns {Array} Returns the new array of picked elements.
	     */
	    function baseAt(collection, props) {
	      var index = -1,
	          length = collection.length,
	          isArr = isLength(length),
	          propsLength = props.length,
	          result = Array(propsLength);

	      while(++index < propsLength) {
	        var key = props[index];
	        if (isArr) {
	          key = parseFloat(key);
	          result[index] = isIndex(key, length) ? collection[key] : undefined;
	        } else {
	          result[index] = collection[key];
	        }
	      }
	      return result;
	    }

	    /**
	     * Copies the properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @param {Array} props The property names to copy.
	     * @returns {Object} Returns `object`.
	     */
	    function baseCopy(source, object, props) {
	      if (!props) {
	        props = object;
	        object = {};
	      }
	      var index = -1,
	          length = props.length;

	      while (++index < length) {
	        var key = props[index];
	        object[key] = source[key];
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.bindAll` without support for individual
	     * method name arguments.
	     *
	     * @private
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {string[]} methodNames The object method names to bind.
	     * @returns {Object} Returns `object`.
	     */
	    function baseBindAll(object, methodNames) {
	      var index = -1,
	          length = methodNames.length;

	      while (++index < length) {
	        var key = methodNames[index];
	        object[key] = createWrapper(object[key], BIND_FLAG, object);
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.callback` which supports specifying the
	     * number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function baseCallback(func, thisArg, argCount) {
	      var type = typeof func;
	      if (type == 'function') {
	        return (typeof thisArg != 'undefined' && isBindable(func))
	          ? bindCallback(func, thisArg, argCount)
	          : func;
	      }
	      if (func == null) {
	        return identity;
	      }
	      if (type == 'object') {
	        return baseMatches(func);
	      }
	      return typeof thisArg == 'undefined'
	        ? baseProperty(func + '')
	        : baseMatchesProperty(func + '', thisArg);
	    }

	    /**
	     * The base implementation of `_.clone` without support for argument juggling
	     * and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The object `value` belongs to.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates clones with source counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
	      var result;
	      if (customizer) {
	        result = object ? customizer(value, key, object) : customizer(value);
	      }
	      if (typeof result != 'undefined') {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return arrayCopy(value, result);
	        }
	      } else {
	        var tag = objToString.call(value),
	            isFunc = tag == funcTag;

	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = initCloneObject(isFunc ? {} : value);
	          if (!isDeep) {
	            return baseCopy(value, result, keys(value));
	          }
	        } else {
	          return cloneableTags[tag]
	            ? initCloneByTag(value, tag, isDeep)
	            : (object ? value : {});
	        }
	      }
	      // Check for circular references and return corresponding clone.
	      stackA || (stackA = []);
	      stackB || (stackB = []);

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == value) {
	          return stackB[length];
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate it with its clone.
	      stackA.push(value);
	      stackB.push(result);

	      // Recursively populate clone (susceptible to call stack limits).
	      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
	        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} prototype The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function Object() {}
	      return function(prototype) {
	        if (isObject(prototype)) {
	          Object.prototype = prototype;
	          var result = new Object;
	          Object.prototype = null;
	        }
	        return result || context.Object();
	      };
	    }());

	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts an index
	     * of where to slice the arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Object} args The `arguments` object to slice and provide to `func`.
	     * @returns {number} Returns the timer id.
	     */
	    function baseDelay(func, wait, args, fromIndex) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, baseSlice(args, fromIndex)); }, wait);
	    }

	    /**
	     * The base implementation of `_.difference` which accepts a single array
	     * of values to exclude.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values) {
	      var length = array ? array.length : 0,
	          result = [];

	      if (!length) {
	        return result;
	      }
	      var index = -1,
	          indexOf = getIndexOf(),
	          isCommon = indexOf == baseIndexOf,
	          cache = isCommon && values.length >= 200 && createCache(values),
	          valuesLength = values.length;

	      if (cache) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	        values = cache;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index];

	        if (isCommon && value === value) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === value) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (indexOf(values, value) < 0) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.forEach` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    function baseEach(collection, iteratee) {
	      var length = collection ? collection.length : 0;
	      if (!isLength(length)) {
	        return baseForOwn(collection, iteratee);
	      }
	      var index = -1,
	          iterable = toObject(collection);

	      while (++index < length) {
	        if (iteratee(iterable[index], index, iterable) === false) {
	          break;
	        }
	      }
	      return collection;
	    }

	    /**
	     * The base implementation of `_.forEachRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    function baseEachRight(collection, iteratee) {
	      var length = collection ? collection.length : 0;
	      if (!isLength(length)) {
	        return baseForOwnRight(collection, iteratee);
	      }
	      var iterable = toObject(collection);
	      while (length--) {
	        if (iteratee(iterable[length], length, iterable) === false) {
	          break;
	        }
	      }
	      return collection;
	    }

	    /**
	     * The base implementation of `_.every` without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;

	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : end >>> 0;
	      start >>>= 0;

	      while (start < length) {
	        array[start++] = value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.filter` without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
	     * without support for callback shorthands and `this` binding, which iterates
	     * over `collection` using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @param {boolean} [retKey] Specify returning the key of the found element
	     *  instead of the element itself.
	     * @returns {*} Returns the found element or its key, else `undefined`.
	     */
	    function baseFind(collection, predicate, eachFunc, retKey) {
	      var result;
	      eachFunc(collection, function(value, key, collection) {
	        if (predicate(value, key, collection)) {
	          result = retKey ? key : value;
	          return false;
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.flatten` with added support for restricting
	     * flattening and specifying the start index.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param {boolean} [isStrict] Restrict flattening to arrays and `arguments` objects.
	     * @param {number} [fromIndex=0] The index to start from.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, isDeep, isStrict, fromIndex) {
	      var index = (fromIndex || 0) - 1,
	          length = array.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];

	        if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
	          if (isDeep) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            value = baseFlatten(value, isDeep, isStrict);
	          }
	          var valIndex = -1,
	              valLength = value.length;

	          result.length += valLength;
	          while (++valIndex < valLength) {
	            result[++resIndex] = value[valIndex];
	          }
	        } else if (!isStrict) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `baseForIn` and `baseForOwn` which iterates
	     * over `object` properties returned by `keysFunc` invoking `iteratee` for
	     * each property. Iterator functions may exit iteration early by explicitly
	     * returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    function baseFor(object, iteratee, keysFunc) {
	      var index = -1,
	          iterable = toObject(object),
	          props = keysFunc(object),
	          length = props.length;

	      while (++index < length) {
	        var key = props[index];
	        if (iteratee(iterable[key], key, iterable) === false) {
	          break;
	        }
	      }
	      return object;
	    }

	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForRight(object, iteratee, keysFunc) {
	      var iterable = toObject(object),
	          props = keysFunc(object),
	          length = props.length;

	      while (length--) {
	        var key = props[length];
	        if (iteratee(iterable[key], key, iterable) === false) {
	          break;
	        }
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.forIn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForIn(object, iteratee) {
	      return baseFor(object, iteratee, keysIn);
	    }

	    /**
	     * The base implementation of `_.forOwn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return baseFor(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.forOwnRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return baseForRight(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from those provided.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the new array of filtered property names.
	     */
	    function baseFunctions(object, props) {
	      var index = -1,
	          length = props.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var key = props[index];
	        if (isFunction(object[key])) {
	          result[++resIndex] = key;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.invoke` which requires additional arguments
	     * to be provided as an array of arguments rather than individually.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|string} methodName The name of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {Array} [args] The arguments to invoke the method with.
	     * @returns {Array} Returns the array of results.
	     */
	    function baseInvoke(collection, methodName, args) {
	      var index = -1,
	          isFunc = typeof methodName == 'function',
	          length = collection ? collection.length : 0,
	          result = isLength(length) ? Array(length) : [];

	      baseEach(collection, function(value) {
	        var func = isFunc ? methodName : (value != null && value[methodName]);
	        result[++index] = func ? func.apply(value, args) : undefined;
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.isEqual` without support for `this` binding
	     * `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isWhere] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
	      // Exit early for identical values.
	      if (value === other) {
	        // Treat `+0` vs. `-0` as not equal.
	        return value !== 0 || (1 / value == 1 / other);
	      }
	      var valType = typeof value,
	          othType = typeof other;

	      // Exit early for unlike primitive values.
	      if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
	          value == null || other == null) {
	        // Return `false` unless both values are `NaN`.
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
	    }

	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @param {boolean} [isWhere] Specify performing partial comparisons.
	     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
	     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = arrayTag,
	          othTag = arrayTag;

	      if (!objIsArr) {
	        objTag = objToString.call(object);
	        if (objTag == argsTag) {
	          objTag = objectTag;
	        } else if (objTag != objectTag) {
	          objIsArr = isTypedArray(object);
	        }
	      }
	      if (!othIsArr) {
	        othTag = objToString.call(other);
	        if (othTag == argsTag) {
	          othTag = objectTag;
	        } else if (othTag != objectTag) {
	          othIsArr = isTypedArray(other);
	        }
	      }
	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;

	      if (isSameTag && !(objIsArr || objIsObj)) {
	        return equalByTag(object, other, objTag);
	      }
	      var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	          othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	      if (valWrapped || othWrapped) {
	        return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      // For more information on detecting circular references see https://es5.github.io/#JO.
	      stackA || (stackA = []);
	      stackB || (stackB = []);

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == object) {
	          return stackB[length] == other;
	        }
	      }
	      // Add `object` and `other` to the stack of traversed objects.
	      stackA.push(object);
	      stackB.push(other);

	      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);

	      stackA.pop();
	      stackB.pop();

	      return result;
	    }

	    /**
	     * The base implementation of `_.isMatch` without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The source property names to match.
	     * @param {Array} values The source values to match.
	     * @param {Array} strictCompareFlags Strict comparison flags for source values.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
	      var length = props.length;
	      if (object == null) {
	        return !length;
	      }
	      var index = -1,
	          noCustomizer = !customizer;

	      while (++index < length) {
	        if ((noCustomizer && strictCompareFlags[index])
	              ? values[index] !== object[props[index]]
	              : !hasOwnProperty.call(object, props[index])
	            ) {
	          return false;
	        }
	      }
	      index = -1;
	      while (++index < length) {
	        var key = props[index];
	        if (noCustomizer && strictCompareFlags[index]) {
	          var result = hasOwnProperty.call(object, key);
	        } else {
	          var objValue = object[key],
	              srcValue = values[index];

	          result = customizer ? customizer(objValue, srcValue, key) : undefined;
	          if (typeof result == 'undefined') {
	            result = baseIsEqual(srcValue, objValue, customizer, true);
	          }
	        }
	        if (!result) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.map` without support for callback shorthands
	     * or `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var result = [];
	      baseEach(collection, function(value, key, collection) {
	        result.push(iteratee(value, key, collection));
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.matches` which does not clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatches(source) {
	      var props = keys(source),
	          length = props.length;

	      if (length == 1) {
	        var key = props[0],
	            value = source[key];

	        if (isStrictComparable(value)) {
	          return function(object) {
	            return object != null && object[key] === value && hasOwnProperty.call(object, key);
	          };
	        }
	      }
	      var values = Array(length),
	          strictCompareFlags = Array(length);

	      while (length--) {
	        value = source[props[length]];
	        values[length] = value;
	        strictCompareFlags[length] = isStrictComparable(value);
	      }
	      return function(object) {
	        return baseIsMatch(object, props, values, strictCompareFlags);
	      };
	    }

	    /**
	     * The base implementation of `_.matchesProperty` which does not coerce `key`
	     * to a string.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @param {*} value The value to compare.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatchesProperty(key, value) {
	      if (isStrictComparable(value)) {
	        return function(object) {
	          return object != null && object[key] === value;
	        };
	      }
	      return function(object) {
	        return object != null && baseIsEqual(value, object[key], null, true);
	      };
	    }

	    /**
	     * The base implementation of `_.merge` without support for argument juggling,
	     * multiple sources, and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} [customizer] The function to customize merging properties.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {Object} Returns the destination object.
	     */
	    function baseMerge(object, source, customizer, stackA, stackB) {
	      var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));

	      (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
	        if (isObjectLike(srcValue)) {
	          stackA || (stackA = []);
	          stackB || (stackB = []);
	          return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
	        }
	        var value = object[key],
	            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	            isCommon = typeof result == 'undefined';

	        if (isCommon) {
	          result = srcValue;
	        }
	        if ((isSrcArr || typeof result != 'undefined') &&
	            (isCommon || (result === result ? result !== value : value === value))) {
	          object[key] = result;
	        }
	      });
	      return object;
	    }

	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize merging properties.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
	      var length = stackA.length,
	          srcValue = source[key];

	      while (length--) {
	        if (stackA[length] == srcValue) {
	          object[key] = stackB[length];
	          return;
	        }
	      }
	      var value = object[key],
	          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	          isCommon = typeof result == 'undefined';

	      if (isCommon) {
	        result = srcValue;
	        if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
	          result = isArray(value)
	            ? value
	            : (value ? arrayCopy(value) : []);
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          result = isArguments(value)
	            ? toPlainObject(value)
	            : (isPlainObject(value) ? value : {});
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate
	      // it with its merged value.
	      stackA.push(srcValue);
	      stackB.push(result);

	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
	      } else if (result === result ? result !== value : value === value) {
	        object[key] = result;
	      }
	    }

	    /**
	     * The base implementation of `_.property` which does not coerce `key` to a string.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function baseProperty(key) {
	      return function(object) {
	        return object == null ? undefined : object[key];
	      };
	    }

	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * index arguments.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns the new array of removed elements.
	     */
	    function basePullAt(array, indexes) {
	      var length = indexes.length,
	          result = baseAt(array, indexes);

	      indexes.sort(baseCompareAscending);
	      while (length--) {
	        var index = parseFloat(indexes[length]);
	        if (index != previous && isIndex(index)) {
	          var previous = index;
	          splice.call(array, index, 1);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.random` without support for argument juggling
	     * and returning floating-point numbers.
	     *
	     * @private
	     * @param {number} min The minimum possible value.
	     * @param {number} max The maximum possible value.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(min, max) {
	      return min + floor(nativeRandom() * (max - min + 1));
	    }

	    /**
	     * The base implementation of `_.reduce` and `_.reduceRight` without support
	     * for callback shorthands or `this` binding, which iterates over `collection`
	     * using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} accumulator The initial value.
	     * @param {boolean} initFromCollection Specify using the first or last element
	     *  of `collection` as the initial value.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @returns {*} Returns the accumulated value.
	     */
	    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
	      eachFunc(collection, function(value, index, collection) {
	        accumulator = initFromCollection
	          ? (initFromCollection = false, value)
	          : iteratee(accumulator, value, index, collection);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `setData` without support for hot loop detection.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };

	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;

	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : (end - start) >>> 0;
	      start >>>= 0;

	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.some` without support for callback shorthands
	     * or `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;

	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }

	    /**
	     * The base implementation of `_.uniq` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The function invoked per iteration.
	     * @returns {Array} Returns the new duplicate-value-free array.
	     */
	    function baseUniq(array, iteratee) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = array.length,
	          isCommon = indexOf == baseIndexOf,
	          isLarge = isCommon && length >= 200,
	          seen = isLarge && createCache(),
	          result = [];

	      if (seen) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	      } else {
	        isLarge = false;
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value, index, array) : value;

	        if (isCommon && value === value) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (indexOf(seen, computed) < 0) {
	          if (iteratee || isLarge) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.values` and `_.valuesIn` which creates an
	     * array of `object` property values corresponding to the property names
	     * returned by `keysFunc`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} props The property names to get values for.
	     * @returns {Object} Returns the array of property values.
	     */
	    function baseValues(object, props) {
	      var index = -1,
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = object[props[index]];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to peform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved unwrapped value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      var index = -1,
	          length = actions.length;

	      while (++index < length) {
	        var args = [result],
	            action = actions[index];

	        push.apply(args, action.args);
	        result = action.func.apply(action.thisArg, args);
	      }
	      return result;
	    }

	    /**
	     * Performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest, instead
	     *  of the lowest, index at which a value should be inserted into `array`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndex(array, value, retHighest) {
	      var low = 0,
	          high = array ? array.length : low;

	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];

	          if (retHighest ? (computed <= value) : (computed < value)) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return binaryIndexBy(array, value, identity, retHighest);
	    }

	    /**
	     * This function is like `binaryIndex` except that it invokes `iteratee` for
	     * `value` and each element of `array` to compute their sort ranking. The
	     * iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {boolean} [retHighest] Specify returning the highest, instead
	     *  of the lowest, index at which a value should be inserted into `array`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);

	      var low = 0,
	          high = array ? array.length : 0,
	          valIsNaN = value !== value,
	          valIsUndef = typeof value == 'undefined';

	      while (low < high) {
	        var mid = floor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            isReflexive = computed === computed;

	        if (valIsNaN) {
	          var setLow = isReflexive || retHighest;
	        } else if (valIsUndef) {
	          setLow = isReflexive && (retHighest || typeof computed != 'undefined');
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }

	    /**
	     * A specialized version of `baseCallback` which only supports `this` binding
	     * and specifying the number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function bindCallback(func, thisArg, argCount) {
	      if (typeof func != 'function') {
	        return identity;
	      }
	      if (typeof thisArg == 'undefined') {
	        return func;
	      }
	      switch (argCount) {
	        case 1: return function(value) {
	          return func.call(thisArg, value);
	        };
	        case 3: return function(value, index, collection) {
	          return func.call(thisArg, value, index, collection);
	        };
	        case 4: return function(accumulator, value, index, collection) {
	          return func.call(thisArg, accumulator, value, index, collection);
	        };
	        case 5: return function(value, other, key, object, source) {
	          return func.call(thisArg, value, other, key, object, source);
	        };
	      }
	      return function() {
	        return func.apply(thisArg, arguments);
	      };
	    }

	    /**
	     * Creates a clone of the given array buffer.
	     *
	     * @private
	     * @param {ArrayBuffer} buffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function bufferClone(buffer) {
	      return bufferSlice.call(buffer, 0);
	    }
	    if (!bufferSlice) {
	      // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
	      bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
	        var byteLength = buffer.byteLength,
	            floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
	            offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
	            result = new ArrayBuffer(byteLength);

	        if (floatLength) {
	          var view = new Float64Array(result, 0, floatLength);
	          view.set(new Float64Array(buffer, 0, floatLength));
	        }
	        if (byteLength != offset) {
	          view = new Uint8Array(result, offset);
	          view.set(new Uint8Array(buffer, offset));
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders) {
	      var holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          leftIndex = -1,
	          leftLength = partials.length,
	          result = Array(argsLength + leftLength);

	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        result[holders[argsIndex]] = args[argsIndex];
	      }
	      while (argsLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders) {
	      var holdersIndex = -1,
	          holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          rightIndex = -1,
	          rightLength = partials.length,
	          result = Array(argsLength + rightLength);

	      while (++argsIndex < argsLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var pad = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[pad + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        result[pad + holders[holdersIndex]] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * Creates a function that aggregates a collection, creating an accumulator
	     * object composed from the results of running each element in the collection
	     * through an iteratee.
	     *
	     * @private
	     * @param {Function} setter The function to set keys and values of the accumulator object.
	     * @param {Function} [initializer] The function to initialize the accumulator object.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee, thisArg) {
	        var result = initializer ? initializer() : {};
	        iteratee = getCallback(iteratee, thisArg, 3);

	        if (isArray(collection)) {
	          var index = -1,
	              length = collection.length;

	          while (++index < length) {
	            var value = collection[index];
	            setter(result, value, iteratee(value, index, collection), collection);
	          }
	        } else {
	          baseEach(collection, function(value, key, collection) {
	            setter(result, value, iteratee(value, key, collection), collection);
	          });
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that assigns properties of source object(s) to a given
	     * destination object.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return function() {
	        var length = arguments.length,
	            object = arguments[0];

	        if (length < 2 || object == null) {
	          return object;
	        }
	        if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {
	          length = 2;
	        }
	        // Juggle arguments.
	        if (length > 3 && typeof arguments[length - 2] == 'function') {
	          var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);
	        } else if (length > 2 && typeof arguments[length - 1] == 'function') {
	          customizer = arguments[--length];
	        }
	        var index = 0;
	        while (++index < length) {
	          var source = arguments[index];
	          if (source) {
	            assigner(object, source, customizer);
	          }
	        }
	        return object;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with the `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createBindWrapper(func, thisArg) {
	      var Ctor = createCtorWrapper(func);

	      function wrapper() {
	        return (this instanceof wrapper ? Ctor : func).apply(thisArg, arguments);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `Set` cache object to optimize linear searches of large arrays.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
	     */
	    var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
	      return new SetCache(values);
	    };

	    /**
	     * Creates a function that produces compound words out of the words in a
	     * given string.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        var index = -1,
	            array = words(deburr(string)),
	            length = array.length,
	            result = '';

	        while (++index < length) {
	          result = callback(result, array[index], index);
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtorWrapper(Ctor) {
	      return function() {
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, arguments);

	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }

	    /**
	     * Creates a function that gets the extremum value of a collection.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to get the extremum value from an array.
	     * @param {boolean} [isMin] Specify returning the minimum, instead of the maximum,
	     *  extremum value.
	     * @returns {Function} Returns the new extremum function.
	     */
	    function createExtremum(arrayFunc, isMin) {
	      return function(collection, iteratee, thisArg) {
	        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	          iteratee = null;
	        }
	        var func = getCallback(),
	            noIteratee = iteratee == null;

	        if (!(func === baseCallback && noIteratee)) {
	          noIteratee = false;
	          iteratee = func(iteratee, thisArg, 3);
	        }
	        if (noIteratee) {
	          var isArr = isArray(collection);
	          if (!isArr && isString(collection)) {
	            iteratee = charAtCallback;
	          } else {
	            return arrayFunc(isArr ? collection : toIterable(collection));
	          }
	        }
	        return extremumBy(collection, iteratee, isMin);
	      };
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with optional `this`
	     * binding of, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & ARY_FLAG,
	          isBind = bitmask & BIND_FLAG,
	          isBindKey = bitmask & BIND_KEY_FLAG,
	          isCurry = bitmask & CURRY_FLAG,
	          isCurryBound = bitmask & CURRY_BOUND_FLAG,
	          isCurryRight = bitmask & CURRY_RIGHT_FLAG;

	      var Ctor = !isBindKey && createCtorWrapper(func),
	          key = func;

	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it to other functions.
	        var length = arguments.length,
	            index = length,
	            args = Array(length);

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight);
	        }
	        if (isCurry || isCurryRight) {
	          var placeholder = wrapper.placeholder,
	              argsHolders = replaceHolders(args, placeholder);

	          length -= argsHolders.length;
	          if (length < arity) {
	            var newArgPos = argPos ? arrayCopy(argPos) : null,
	                newArity = nativeMax(arity - length, 0),
	                newsHolders = isCurry ? argsHolders : null,
	                newHoldersRight = isCurry ? null : argsHolders,
	                newPartials = isCurry ? args : null,
	                newPartialsRight = isCurry ? null : args;

	            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
	            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

	            if (!isCurryBound) {
	              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
	            }
	            var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);
	            result.placeholder = placeholder;
	            return result;
	          }
	        }
	        var thisBinding = isBind ? thisArg : this;
	        if (isBindKey) {
	          func = thisBinding[key];
	        }
	        if (argPos) {
	          args = reorder(args, argPos);
	        }
	        if (isAry && ary < args.length) {
	          args.length = ary;
	        }
	        return (this instanceof wrapper ? (Ctor || createCtorWrapper(func)) : func).apply(thisBinding, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates the pad required for `string` based on the given padding length.
	     * The `chars` string may be truncated if the number of padding characters
	     * exceeds the padding length.
	     *
	     * @private
	     * @param {string} string The string to create padding for.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the pad for `string`.
	     */
	    function createPad(string, length, chars) {
	      var strLength = string.length;
	      length = +length;

	      if (strLength >= length || !nativeIsFinite(length)) {
	        return '';
	      }
	      var padLength = length - strLength;
	      chars = chars == null ? ' ' : (chars + '');
	      return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with the optional `this`
	     * binding of `thisArg` and the `partials` prepended to those provided to
	     * the wrapper.
	     *
	     * @private
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to the new function.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createPartialWrapper(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & BIND_FLAG,
	          Ctor = createCtorWrapper(func);

	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it `func`.
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(argsLength + leftLength);

	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        return (this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags.
	     *  The bitmask may be composed of the following flags:
	     *     1 - `_.bind`
	     *     2 - `_.bindKey`
	     *     4 - `_.curry` or `_.curryRight` of a bound function
	     *     8 - `_.curry`
	     *    16 - `_.curryRight`
	     *    32 - `_.partial`
	     *    64 - `_.partialRight`
	     *   128 - `_.rearg`
	     *   256 - `_.ary`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
	        partials = holders = null;
	      }
	      length -= (holders ? holders.length : 0);
	      if (bitmask & PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;

	        partials = holders = null;
	      }
	      var data = !isBindKey && getData(func),
	          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

	      if (data && data !== true) {
	        mergeData(newData, data);
	        bitmask = newData[1];
	        arity = newData[9];
	      }
	      newData[9] = arity == null
	        ? (isBindKey ? 0 : func.length)
	        : (nativeMax(arity - length, 0) || 0);

	      if (bitmask == BIND_FLAG) {
	        var result = createBindWrapper(newData[0], newData[2]);
	      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
	        result = createPartialWrapper.apply(undefined, newData);
	      } else {
	        result = createHybridWrapper.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setter(result, newData);
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing arrays.
	     * @param {boolean} [isWhere] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
	      var index = -1,
	          arrLength = array.length,
	          othLength = other.length,
	          result = true;

	      if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
	        return false;
	      }
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (result && ++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index];

	        result = undefined;
	        if (customizer) {
	          result = isWhere
	            ? customizer(othValue, arrValue, index)
	            : customizer(arrValue, othValue, index);
	        }
	        if (typeof result == 'undefined') {
	          // Recursively compare arrays (susceptible to call stack limits).
	          if (isWhere) {
	            var othIndex = othLength;
	            while (othIndex--) {
	              othValue = other[othIndex];
	              result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
	              if (result) {
	                break;
	              }
	            }
	          } else {
	            result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
	          }
	        }
	      }
	      return !!result;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} value The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag) {
	      switch (tag) {
	        case boolTag:
	        case dateTag:
	          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
	          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
	          return +object == +other;

	        case errorTag:
	          return object.name == other.name && object.message == other.message;

	        case numberTag:
	          // Treat `NaN` vs. `NaN` as equal.
	          return (object != +object)
	            ? other != +other
	            // But, treat `-0` vs. `+0` as not equal.
	            : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings primitives and string
	          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
	          return object == (other + '');
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isWhere] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
	      var objProps = keys(object),
	          objLength = objProps.length,
	          othProps = keys(other),
	          othLength = othProps.length;

	      if (objLength != othLength && !isWhere) {
	        return false;
	      }
	      var hasCtor,
	          index = -1;

	      while (++index < objLength) {
	        var key = objProps[index],
	            result = hasOwnProperty.call(other, key);

	        if (result) {
	          var objValue = object[key],
	              othValue = other[key];

	          result = undefined;
	          if (customizer) {
	            result = isWhere
	              ? customizer(othValue, objValue, key)
	              : customizer(objValue, othValue, key);
	          }
	          if (typeof result == 'undefined') {
	            // Recursively compare objects (susceptible to call stack limits).
	            result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
	          }
	        }
	        if (!result) {
	          return false;
	        }
	        hasCtor || (hasCtor = key == 'constructor');
	      }
	      if (!hasCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;

	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * Gets the extremum value of `collection` invoking `iteratee` for each value
	     * in `collection` to generate the criterion by which the value is ranked.
	     * The `iteratee` is invoked with three arguments; (value, index, collection).
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {boolean} [isMin] Specify returning the minimum, instead of the
	     *  maximum, extremum value.
	     * @returns {*} Returns the extremum value.
	     */
	    function extremumBy(collection, iteratee, isMin) {
	      var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY,
	          computed = exValue,
	          result = computed;

	      baseEach(collection, function(value, index, collection) {
	        var current = iteratee(value, index, collection);
	        if ((isMin ? current < computed : current > computed) || (current === exValue && current === result)) {
	          computed = current;
	          result = value;
	        }
	      });
	      return result;
	    }

	    /**
	     * Gets the appropriate "callback" function. If the `_.callback` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseCallback` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getCallback(func, thisArg, argCount) {
	      var result = lodash.callback || callback;
	      result = result === callback ? baseCallback : result;
	      return argCount ? result(func, thisArg, argCount) : result;
	    }

	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };

	    /**
	     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseIndexOf` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function|number} Returns the chosen function or its result.
	     */
	    function getIndexOf(collection, target, fromIndex) {
	      var result = lodash.indexOf || indexOf;
	      result = result === indexOf ? baseIndexOf : result;
	      return collection ? result(collection, target, fromIndex) : result;
	    }

	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} [transforms] The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms ? transforms.length : 0;

	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;

	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }

	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = new array.constructor(length);

	      // Add array properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }

	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      var Ctor = object.constructor;
	      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
	        Ctor = Object;
	      }
	      return new Ctor;
	    }

	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return bufferClone(object);

	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);

	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          var buffer = object.buffer;
	          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

	        case numberTag:
	        case stringTag:
	          return new Ctor(object);

	        case regexpTag:
	          var result = new Ctor(object.source, reFlags.exec(object));
	          result.lastIndex = object.lastIndex;
	      }
	      return result;
	    }

	    /**
	     * Checks if `func` is eligible for `this` binding.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` is eligible, else `false`.
	     */
	    function isBindable(func) {
	      var support = lodash.support,
	          result = !(support.funcNames ? func.name : support.funcDecomp);

	      if (!result) {
	        var source = fnToString.call(func);
	        if (!support.funcNames) {
	          result = !reFuncName.test(source);
	        }
	        if (!result) {
	          // Check if `func` references the `this` keyword and store the result.
	          result = reThis.test(source) || isNative(func);
	          baseSetData(func, result);
	        }
	      }
	      return result;
	    }

	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      value = +value;
	      length = length == null ? MAX_SAFE_INTEGER : length;
	      return value > -1 && value % 1 == 0 && value < length;
	    }

	    /**
	     * Checks if the provided arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number') {
	        var length = object.length,
	            prereq = isLength(length) && isIndex(index, length);
	      } else {
	        prereq = type == 'string' && index in object;
	      }
	      return prereq && object[index] === value;
	    }

	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This function is based on ES `ToLength`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
	     * for more details.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     */
	    function isLength(value) {
	      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
	    }

	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers required to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
	     * augment function arguments, making the order in which they are executed important,
	     * preventing the merging of metadata. However, we make an exception for a safe
	     * common case where curried functions have `_.ary` and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask;

	      var arityFlags = ARY_FLAG | REARG_FLAG,
	          bindFlags = BIND_FLAG | BIND_KEY_FLAG,
	          comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;

	      var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG),
	          isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG),
	          argPos = (isRearg ? data : source)[7],
	          ary = (isAry ? data : source)[8];

	      var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) &&
	        !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);

	      var isCombo = (newBitmask >= arityFlags && newBitmask <= comboFlags) &&
	        (bitmask < REARG_FLAG || ((isRearg || isAry) && argPos.length <= ary));

	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = arrayCopy(value);
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;

	      return data;
	    }

	    /**
	     * A specialized version of `_.pick` that picks `object` properties specified
	     * by the `props` array.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} props The property names to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByArray(object, props) {
	      object = toObject(object);

	      var index = -1,
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index];
	        if (key in object) {
	          result[key] = object[key];
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.pick` that picks `object` properties `predicate`
	     * returns truthy for.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByCallback(object, predicate) {
	      var result = {};
	      baseForIn(object, function(value, key, object) {
	        if (predicate(value, key, object)) {
	          result[key] = value;
	        }
	      });
	      return result;
	    }

	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = arrayCopy(array);

	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }

	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity function
	     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = (function() {
	      var count = 0,
	          lastCalled = 0;

	      return function(key, value) {
	        var stamp = now(),
	            remaining = HOT_SPAN - (stamp - lastCalled);

	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return key;
	          }
	        } else {
	          count = 0;
	        }
	        return baseSetData(key, value);
	      };
	    }());

	    /**
	     * A fallback implementation of `_.isPlainObject` which checks if `value`
	     * is an object created by the `Object` constructor or has a `[[Prototype]]`
	     * of `null`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     */
	    function shimIsPlainObject(value) {
	      var Ctor,
	          support = lodash.support;

	      // Exit early for non `Object` objects.
	      if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||
	          (!hasOwnProperty.call(value, 'constructor') &&
	            (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
	        return false;
	      }
	      // IE < 9 iterates inherited properties before own properties. If the first
	      // iterated property is an object's own property then there are no inherited
	      // enumerable properties.
	      var result;
	      // In most environments an object's own properties are iterated before
	      // its inherited properties. If the last iterated property is an object's
	      // own property then there are no inherited enumerable properties.
	      baseForIn(value, function(subValue, key) {
	        result = key;
	      });
	      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
	    }

	    /**
	     * A fallback implementation of `Object.keys` which creates an array of the
	     * own enumerable property names of `object`.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the array of property names.
	     */
	    function shimKeys(object) {
	      var props = keysIn(object),
	          propsLength = props.length,
	          length = propsLength && object.length,
	          support = lodash.support;

	      var allowIndexes = length && isLength(length) &&
	        (isArray(object) || (support.nonEnumArgs && isArguments(object)));

	      var index = -1,
	          result = [];

	      while (++index < propsLength) {
	        var key = props[index];
	        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to an array-like object if it is not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Array|Object} Returns the array-like object.
	     */
	    function toIterable(value) {
	      if (value == null) {
	        return [];
	      }
	      if (!isLength(value.length)) {
	        return values(value);
	      }
	      return isObject(value) ? value : Object(value);
	    }

	    /**
	     * Converts `value` to an object if it is not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Object} Returns the object.
	     */
	    function toObject(value) {
	      return isObject(value) ? value : Object(value);
	    }

	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      return wrapper instanceof LazyWrapper
	        ? wrapper.clone()
	        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `collection` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new array containing chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if (guard ? isIterateeCall(array, size, guard) : size == null) {
	        size = 1;
	      } else {
	        size = nativeMax(+size || 1, 1);
	      }
	      var index = 0,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = Array(ceil(length / size));

	      while (index < length) {
	        result[++resIndex] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }

	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array excluding all values of the provided arrays using
	     * `SameValueZero` for equality comparisons.
	     *
	     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
	     * e.g. `===`, except that `NaN` matches `NaN`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The arrays of values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.difference([1, 2, 3], [5, 2, 10]);
	     * // => [1, 3]
	     */
	    function difference() {
	      var index = -1,
	          length = arguments.length;

	      while (++index < length) {
	        var value = arguments[index];
	        if (isArray(value) || isArguments(value)) {
	          break;
	        }
	      }
	      return baseDifference(value, baseFlatten(arguments, false, true, ++index));
	    }

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that match the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRightWhile([1, 2, 3], function(n) { return n > 1; });
	     * // => [1]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.dropRightWhile(users, { 'user': pebbles, 'active': false }), 'user');
	     * // => ['barney', 'fred']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      predicate = getCallback(predicate, thisArg, 3);
	      while (length-- && predicate(array[length], length, array)) {}
	      return baseSlice(array, 0, length + 1);
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropWhile([1, 2, 3], function(n) { return n < 3; });
	     * // => [3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.dropWhile(users, 'active', false), 'user');
	     * // => ['pebbles']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.dropWhile(users, 'active'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      var index = -1;
	      predicate = getCallback(predicate, thisArg, 3);
	      while (++index < length && predicate(array[index], index, array)) {}
	      return baseSlice(array, index);
	    }

	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function fill(array, value, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }

	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for, instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(chr) { return chr.user == 'barney'; });
	     * // => 0
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findIndex(users, 'active', false);
	     * // => 0
	     *
	     * // using the `_.property` callback shorthand
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    function findIndex(array, predicate, thisArg) {
	      var index = -1,
	          length = array ? array.length : 0;

	      predicate = getCallback(predicate, thisArg, 3);
	      while (++index < length) {
	        if (predicate(array[index], index, array)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(chr) { return chr.user == 'pebbles'; });
	     * // => 2
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findLastIndex(users, { user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findLastIndex(users, 'active', false);
	     * // => 1
	     *
	     * // using the `_.property` callback shorthand
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    function findLastIndex(array, predicate, thisArg) {
	      var length = array ? array.length : 0;
	      predicate = getCallback(predicate, thisArg, 3);
	      while (length--) {
	        if (predicate(array[length], length, array)) {
	          return length;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias head
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.first([1, 2, 3]);
	     * // => 1
	     *
	     * _.first([]);
	     * // => undefined
	     */
	    function first(array) {
	      return array ? array[0] : undefined;
	    }

	    /**
	     * Flattens a nested array. If `isDeep` is `true` the array is recursively
	     * flattened, otherwise it is only flattened a single level.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2], [3, [[4]]]]);
	     * // => [1, 2, 3, [[4]]];
	     *
	     * // using `isDeep`
	     * _.flatten([1, [2], [3, [[4]]]], true);
	     * // => [1, 2, 3, 4];
	     */
	    function flatten(array, isDeep, guard) {
	      var length = array ? array.length : 0;
	      if (guard && isIterateeCall(array, isDeep, guard)) {
	        isDeep = false;
	      }
	      return length ? baseFlatten(array, isDeep) : [];
	    }

	    /**
	     * Recursively flattens a nested array.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to recursively flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2], [3, [[4]]]]);
	     * // => [1, 2, 3, 4];
	     */
	    function flattenDeep(array) {
	      var length = array ? array.length : 0;
	      return length ? baseFlatten(array, true) : [];
	    }

	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using `SameValueZero` for equality comparisons. If `fromIndex` is negative,
	     * it is used as the offset from the end of `array`. If `array` is sorted
	     * providing `true` for `fromIndex` performs a faster binary search.
	     *
	     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
	     * e.g. `===`, except that `NaN` matches `NaN`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
	     *  to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
	     * // => 1
	     *
	     * // using `fromIndex`
	     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
	     * // => 4
	     *
	     * // performing a binary search
	     * _.indexOf([4, 4, 5, 5, 6, 6], 5, true);
	     * // => 2
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      if (typeof fromIndex == 'number') {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
	      } else if (fromIndex) {
	        var index = binaryIndex(array, value),
	            other = array[index];

	        return (value === value ? value === other : other !== other) ? index : -1;
	      }
	      return baseIndexOf(array, value, fromIndex);
	    }

	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      return dropRight(array, 1);
	    }

	    /**
	     * Creates an array of unique values in all provided arrays using `SameValueZero`
	     * for equality comparisons.
	     *
	     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
	     * e.g. `===`, except that `NaN` matches `NaN`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of shared values.
	     * @example
	     *
	     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
	     * // => [1, 2]
	     */
	    function intersection() {
	      var args = [],
	          argsIndex = -1,
	          argsLength = arguments.length,
	          caches = [],
	          indexOf = getIndexOf(),
	          isCommon = indexOf == baseIndexOf;

	      while (++argsIndex < argsLength) {
	        var value = arguments[argsIndex];
	        if (isArray(value) || isArguments(value)) {
	          args.push(value);
	          caches.push(isCommon && value.length >= 120 && createCache(argsIndex && value));
	        }
	      }
	      argsLength = args.length;
	      var array = args[0],
	          index = -1,
	          length = array ? array.length : 0,
	          result = [],
	          seen = caches[0];

	      outer:
	      while (++index < length) {
	        value = array[index];
	        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value)) < 0) {
	          argsIndex = argsLength;
	          while (--argsIndex) {
	            var cache = caches[argsIndex];
	            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(value);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array ? array.length : 0;
	      return length ? array[length - 1] : undefined;
	    }

	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
	     *  or `true` to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
	     * // => 4
	     *
	     * // using `fromIndex`
	     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
	     * // => 1
	     *
	     * // performing a binary search
	     * _.lastIndexOf([4, 4, 5, 5, 6, 6], 5, true);
	     * // => 3
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (typeof fromIndex == 'number') {
	        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
	      } else if (fromIndex) {
	        index = binaryIndex(array, value, true) - 1;
	        var other = array[index];
	        return (value === value ? value === other : other !== other) ? index : -1;
	      }
	      if (value !== value) {
	        return indexOfNaN(array, index, true);
	      }
	      while (index--) {
	        if (array[index] === value) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Removes all provided values from `array` using `SameValueZero` for equality
	     * comparisons.
	     *
	     * **Notes:**
	     *  - Unlike `_.without`, this method mutates `array`.
	     *  - `SameValueZero` comparisons are like strict equality comparisons, e.g. `===`,
	     *    except that `NaN` matches `NaN`. See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     *    for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3, 1, 2, 3];
	     * _.pull(array, 2, 3);
	     * console.log(array);
	     * // => [1, 1]
	     */
	    function pull() {
	      var array = arguments[0];
	      if (!(array && array.length)) {
	        return array;
	      }
	      var index = 0,
	          indexOf = getIndexOf(),
	          length = arguments.length;

	      while (++index < length) {
	        var fromIndex = 0,
	            value = arguments[index];

	        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * Removes elements from `array` corresponding to the given indexes and returns
	     * an array of the removed elements. Indexes may be specified as an array of
	     * indexes or as individual arguments.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [5, 10, 15, 20];
	     * var evens = _.pullAt(array, [1, 3]);
	     *
	     * console.log(array);
	     * // => [5, 15]
	     *
	     * console.log(evens);
	     * // => [10, 20]
	     */
	    function pullAt(array) {
	      return basePullAt(array || [], baseFlatten(arguments, false, false, 1));
	    }

	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is bound to
	     * `thisArg` and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) { return n % 2 == 0; });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate, thisArg) {
	      var index = -1,
	          length = array ? array.length : 0,
	          result = [];

	      predicate = getCallback(predicate, thisArg, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          splice.call(array, index--, 1);
	          length--;
	        }
	      }
	      return result;
	    }

	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias tail
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.rest([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function rest(array) {
	      return drop(array, 1);
	    }

	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This function is used instead of `Array#slice` to support node
	     * lists in IE < 9 and to ensure dense arrays are returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      return baseSlice(array, start, end);
	    }

	    /**
	     * Uses a binary search to determine the lowest index at which `value` should
	     * be inserted into `array` in order to maintain its sort order. If an iteratee
	     * function is provided it is invoked for `value` and each element of `array`
	     * to compute their sort ranking. The iteratee is bound to `thisArg` and
	     * invoked with one argument; (value).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     *
	     * _.sortedIndex([4, 4, 5, 5, 6, 6], 5);
	     * // => 2
	     *
	     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
	     *
	     * // using an iteratee function
	     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
	     *   return this.data[word];
	     * }, dict);
	     * // => 1
	     *
	     * // using the `_.property` callback shorthand
	     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
	     * // => 1
	     */
	    function sortedIndex(array, value, iteratee, thisArg) {
	      var func = getCallback(iteratee);
	      return (func === baseCallback && iteratee == null)
	        ? binaryIndex(array, value)
	        : binaryIndexBy(array, value, func(iteratee, thisArg, 1));
	    }

	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 4, 5, 5, 6, 6], 5);
	     * // => 4
	     */
	    function sortedLastIndex(array, value, iteratee, thisArg) {
	      var func = getCallback(iteratee);
	      return (func === baseCallback && iteratee == null)
	        ? binaryIndex(array, value, true)
	        : binaryIndexBy(array, value, func(iteratee, thisArg, 1), true);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
	     * and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRightWhile([1, 2, 3], function(n) { return n > 1; });
	     * // => [2, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
	     * // => ['pebbles']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
	     * // => []
	     */
	    function takeRightWhile(array, predicate, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      predicate = getCallback(predicate, thisArg, 3);
	      while (length-- && predicate(array[length], length, array)) {}
	      return baseSlice(array, length + 1);
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is bound to
	     * `thisArg` and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeWhile([1, 2, 3], function(n) { return n < 3; });
	     * // => [1, 2]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false},
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.takeWhile(users, 'active', false), 'user');
	     * // => ['barney', 'fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.takeWhile(users, 'active'), 'user');
	     * // => []
	     */
	    function takeWhile(array, predicate, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      var index = -1;
	      predicate = getCallback(predicate, thisArg, 3);
	      while (++index < length && predicate(array[index], index, array)) {}
	      return baseSlice(array, 0, index);
	    }

	    /**
	     * Creates an array of unique values, in order, of the provided arrays using
	     * `SameValueZero` for equality comparisons.
	     *
	     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
	     * e.g. `===`, except that `NaN` matches `NaN`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
	     * // => [1, 2, 3, 5, 4]
	     */
	    function union() {
	      return baseUniq(baseFlatten(arguments, false, true));
	    }

	    /**
	     * Creates a duplicate-value-free version of an array using `SameValueZero`
	     * for equality comparisons. Providing `true` for `isSorted` performs a faster
	     * search algorithm for sorted arrays. If an iteratee function is provided it
	     * is invoked for each value in the array to generate the criterion by which
	     * uniqueness is computed. The `iteratee` is bound to `thisArg` and invoked
	     * with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
	     * e.g. `===`, except that `NaN` matches `NaN`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @alias unique
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {boolean} [isSorted] Specify the array is sorted.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new duplicate-value-free array.
	     * @example
	     *
	     * _.uniq([1, 2, 1]);
	     * // => [1, 2]
	     *
	     * // using `isSorted`
	     * _.uniq([1, 1, 2], true);
	     * // => [1, 2]
	     *
	     * // using an iteratee function
	     * _.uniq([1, 2.5, 1.5, 2], function(n) { return this.floor(n); }, Math);
	     * // => [1, 2.5]
	     *
	     * // using the `_.property` callback shorthand
	     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniq(array, isSorted, iteratee, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      // Juggle arguments.
	      if (typeof isSorted != 'boolean' && isSorted != null) {
	        thisArg = iteratee;
	        iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
	        isSorted = false;
	      }
	      var func = getCallback();
	      if (!(func === baseCallback && iteratee == null)) {
	        iteratee = func(iteratee, thisArg, 3);
	      }
	      return (isSorted && getIndexOf() == baseIndexOf)
	        ? sortedUniq(array, iteratee)
	        : baseUniq(array, iteratee);
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-`_.zip`
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['fred', 'barney'], [30, 40], [true, false]]
	     */
	    function unzip(array) {
	      var index = -1,
	          length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = arrayMap(array, baseProperty(index));
	      }
	      return result;
	    }

	    /**
	     * Creates an array excluding all provided values using `SameValueZero` for
	     * equality comparisons.
	     *
	     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
	     * e.g. `===`, except that `NaN` matches `NaN`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to filter.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
	     * // => [2, 3, 4]
	     */
	    function without(array) {
	      return baseDifference(array, baseSlice(arguments, 1));
	    }

	    /**
	     * Creates an array that is the symmetric difference of the provided arrays.
	     * See [Wikipedia](https://en.wikipedia.org/wiki/Symmetric_difference) for
	     * more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of values.
	     * @example
	     *
	     * _.xor([1, 2, 3], [5, 2, 1, 4]);
	     * // => [3, 5, 4]
	     *
	     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
	     * // => [1, 4, 5]
	     */
	    function xor() {
	      var index = -1,
	          length = arguments.length;

	      while (++index < length) {
	        var array = arguments[index];
	        if (isArray(array) || isArguments(array)) {
	          var result = result
	            ? baseDifference(result, array).concat(baseDifference(array, result))
	            : array;
	        }
	      }
	      return result ? baseUniq(result) : [];
	    }

	    /**
	     * Creates an array of grouped elements, the first of which contains the first
	     * elements of the given arrays, the second of which contains the second elements
	     * of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     */
	    function zip() {
	      var length = arguments.length,
	          array = Array(length);

	      while (length--) {
	        array[length] = arguments[length];
	      }
	      return unzip(array);
	    }

	    /**
	     * Creates an object composed from arrays of property names and values. Provide
	     * either a single two dimensional array, e.g. `[[key1, value1], [key2, value2]]`
	     * or two arrays, one of property names and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @alias object
	     * @category Array
	     * @param {Array} props The property names.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject(['fred', 'barney'], [30, 40]);
	     * // => { 'fred': 30, 'barney': 40 }
	     */
	    function zipObject(props, values) {
	      var index = -1,
	          length = props ? props.length : 0,
	          result = {};

	      if (length && !values && !isArray(props[0])) {
	        values = [];
	      }
	      while (++index < length) {
	        var key = props[index];
	        if (values) {
	          result[key] = values[index];
	        } else if (key) {
	          result[key[0]] = key[1];
	        }
	      }
	      return result;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object that wraps `value` with explicit method
	     * chaining enabled.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _.chain(users)
	     *   .sortBy('age')
	     *   .map(function(chr) { return chr.user + ' is ' + chr.age; })
	     *   .first()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }

	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor is
	     * bound to `thisArg` and invoked with one argument; (value). The purpose of
	     * this method is to "tap into" a method chain in order to perform operations
	     * on intermediate results within the chain.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) { array.pop(); })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor, thisArg) {
	      interceptor.call(thisArg, value);
	      return value;
	    }

	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .last()
	     *  .thru(function(value) { return [value]; })
	     *  .value();
	     * // => [3]
	     */
	    function thru(value, interceptor, thisArg) {
	      return interceptor.call(thisArg, value);
	    }

	    /**
	     * Enables explicit method chaining on the wrapper object.
	     *
	     * @name chain
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // without explicit chaining
	     * _(users).first();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // with explicit chaining
	     * _(users).chain()
	     *   .first()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }

	    /**
	     * Executes the chained sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapper = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapper = wrapper.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapper.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }

	    /**
	     * Creates a clone of the chained sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapper = _(array).map(function(value) {
	     *   return Math.pow(value, 2);
	     * });
	     *
	     * var other = [3, 4];
	     * var otherWrapper = wrapper.plant(other);
	     *
	     * otherWrapper.value();
	     * // => [9, 16]
	     *
	     * wrapper.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;

	      while (parent instanceof LodashWrapper) {
	        var clone = wrapperClone(parent);
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }

	    /**
	     * Reverses the wrapped array so the first element becomes the last, the
	     * second element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;
	      if (value instanceof LazyWrapper) {
	        if (this.__actions__.length) {
	          value = new LazyWrapper(this);
	        }
	        return new LodashWrapper(value.reverse(), this.__chain__);
	      }
	      return this.thru(function(value) {
	        return value.reverse();
	      });
	    }

	    /**
	     * Produces the result of coercing the unwrapped value to a string.
	     *
	     * @name toString
	     * @memberOf _
	     * @category Chain
	     * @returns {string} Returns the coerced string value.
	     * @example
	     *
	     * _([1, 2, 3]).toString();
	     * // => '1,2,3'
	     */
	    function wrapperToString() {
	      return (this.value() + '');
	    }

	    /**
	     * Executes the chained sequence to extract the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @alias run, toJSON, valueOf
	     * @category Chain
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements corresponding to the given keys, or indexes,
	     * of `collection`. Keys may be specified as individual arguments or as arrays
	     * of keys.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(number|number[]|string|string[])} [props] The property names
	     *  or indexes of elements to pick, specified individually or in arrays.
	     * @returns {Array} Returns the new array of picked elements.
	     * @example
	     *
	     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
	     * // => ['a', 'c', 'e']
	     *
	     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
	     * // => ['fred', 'pebbles']
	     */
	    function at(collection) {
	      var length = collection ? collection.length : 0;
	      if (isLength(length)) {
	        collection = toIterable(collection);
	      }
	      return baseAt(collection, baseFlatten(arguments, false, false, 1));
	    }

	    /**
	     * Checks if `value` is in `collection` using `SameValueZero` for equality
	     * comparisons. If `fromIndex` is negative, it is used as the offset from
	     * the end of `collection`.
	     *
	     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
	     * e.g. `===`, except that `NaN` matches `NaN`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @alias contains, include
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {*} target The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
	     * // => true
	     *
	     * _.includes('pebbles', 'eb');
	     * // => true
	     */
	    function includes(collection, target, fromIndex) {
	      var length = collection ? collection.length : 0;
	      if (!isLength(length)) {
	        collection = values(collection);
	        length = collection.length;
	      }
	      if (!length) {
	        return false;
	      }
	      if (typeof fromIndex == 'number') {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
	      } else {
	        fromIndex = 0;
	      }
	      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
	        ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)
	        : (getIndexOf(collection, target, fromIndex) > -1);
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the number of times the key was returned by `iteratee`.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) { return Math.floor(n); });
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) { return this.floor(n); }, Math);
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
	    });

	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * The predicate is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias all
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': false },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.every(users, 'active', false);
	     * // => true
	     *
	     * // using the `_.property` callback shorthand
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }

	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias select
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * var evens = _.filter([1, 2, 3, 4], function(n) { return n % 2 == 0; });
	     * // => [2, 4]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.filter(users, 'active', false), 'user');
	     * // => ['fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.filter(users, 'active'), 'user');
	     * // => ['barney']
	     */
	    function filter(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, predicate);
	    }

	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias detect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.result(_.find(users, function(chr) { return chr.age < 40; }), 'user');
	     * // => 'barney'
	     *
	     * // using the `_.matches` callback shorthand
	     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
	     * // => 'pebbles'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.result(_.find(users, 'active', false), 'user');
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.result(_.find(users, 'active'), 'user');
	     * // => 'barney'
	     */
	    function find(collection, predicate, thisArg) {
	      if (isArray(collection)) {
	        var index = findIndex(collection, predicate, thisArg);
	        return index > -1 ? collection[index] : undefined;
	      }
	      predicate = getCallback(predicate, thisArg, 3);
	      return baseFind(collection, predicate, baseEach);
	    }

	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) { return n % 2 == 1; });
	     * // => 3
	     */
	    function findLast(collection, predicate, thisArg) {
	      predicate = getCallback(predicate, thisArg, 3);
	      return baseFind(collection, predicate, baseEachRight);
	    }

	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning the first element that has equivalent property
	     * values.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
	     * // => 'barney'
	     *
	     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
	     * // => 'fred'
	     */
	    function findWhere(collection, source) {
	      return find(collection, baseMatches(source));
	    }

	    /**
	     * Iterates over elements of `collection` invoking `iteratee` for each element.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection). Iterator functions may exit iteration early
	     * by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a `length` property
	     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
	     * may be used for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @alias each
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2, 3]).forEach(function(n) { console.log(n); }).value();
	     * // => logs each value from left to right and returns the array
	     *
	     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(n, key) { console.log(n, key); });
	     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
	     */
	    function forEach(collection, iteratee, thisArg) {
	      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
	        ? arrayEach(collection, iteratee)
	        : baseEach(collection, bindCallback(iteratee, thisArg, 3));
	    }

	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2, 3]).forEachRight(function(n) { console.log(n); }).join(',');
	     * // => logs each value from right to left and returns the array
	     */
	    function forEachRight(collection, iteratee, thisArg) {
	      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
	        ? arrayEachRight(collection, iteratee)
	        : baseEachRight(collection, bindCallback(iteratee, thisArg, 3));
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is an array of the elements responsible for generating the key.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) { return Math.floor(n); });
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) { return this.floor(n); }, Math);
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * // using the `_.property` callback shorthand
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        result[key] = [value];
	      }
	    });

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the last element responsible for generating the key. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var keyData = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.indexBy(keyData, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) { return String.fromCharCode(object.code); });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) { return this.fromCharCode(object.code); }, String);
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     */
	    var indexBy = createAggregator(function(result, value, key) {
	      result[key] = value;
	    });

	    /**
	     * Invokes the method named by `methodName` on each element in `collection`,
	     * returning an array of the results of each invoked method. Any additional
	     * arguments are provided to each invoked method. If `methodName` is a function
	     * it is invoked for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|string} methodName The name of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invoke([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    function invoke(collection, methodName) {
	      return baseInvoke(collection, methodName, baseSlice(arguments, 2));
	    }

	    /**
	     * Creates an array of values by running each element in `collection` through
	     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * Many lodash methods are guarded to work as interatees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`, `drop`,
	     * `dropRight`, `fill`, `flatten`, `invert`, `max`, `min`, `parseInt`, `slice`,
	     * `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimLeft`, `trimRight`,
	     * `trunc`, `random`, `range`, `sample`, `uniq`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @alias collect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     *  create a `_.property` or `_.matches` style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * _.map([1, 2, 3], function(n) { return n * 3; });
	     * // => [3, 6, 9]
	     *
	     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(n) { return n * 3; });
	     * // => [3, 6, 9] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // using the `_.property` callback shorthand
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee, thisArg) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return func(collection, iteratee);
	    }

	    /**
	     * Gets the maximum value of `collection`. If `collection` is empty or falsey
	     * `-Infinity` is returned. If an iteratee function is provided it is invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments; (value, index, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => -Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.max(users, function(chr) { return chr.age; });
	     * // => { 'user': 'fred', 'age': 40 };
	     *
	     * // using the `_.property` callback shorthand
	     * _.max(users, 'age');
	     * // => { 'user': 'fred', 'age': 40 };
	     */
	    var max = createExtremum(arrayMax);

	    /**
	     * Gets the minimum value of `collection`. If `collection` is empty or falsey
	     * `Infinity` is returned. If an iteratee function is provided it is invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments; (value, index, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.min(users, function(chr) { return chr.age; });
	     * // => { 'user': 'barney', 'age': 36 };
	     *
	     * // using the `_.property` callback shorthand
	     * _.min(users, 'age');
	     * // => { 'user': 'barney', 'age': 36 };
	     */
	    var min = createExtremum(arrayMin, true);

	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, while the second of which
	     * contains elements `predicate` returns falsey for. The predicate is bound
	     * to `thisArg` and invoked with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * _.partition([1, 2, 3], function(n) { return n % 2; });
	     * // => [[1, 3], [2]]
	     *
	     * _.partition([1.2, 2.3, 3.4], function(n) { return this.floor(n) % 2; }, Math);
	     * // => [[1, 3], [2]]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * var mapper = function(array) { return _.pluck(array, 'user'); };
	     *
	     * // using the `_.matches` callback shorthand
	     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
	     * // => [['pebbles'], ['barney', 'fred']]
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.map(_.partition(users, 'active', false), mapper);
	     * // => [['barney', 'pebbles'], ['fred']]
	     *
	     * // using the `_.property` callback shorthand
	     * _.map(_.partition(users, 'active'), mapper);
	     * // => [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });

	    /**
	     * Gets the value of `key` from all elements in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {string} key The key of the property to pluck.
	     * @returns {Array} Returns the property values.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.pluck(users, 'user');
	     * // => ['barney', 'fred']
	     *
	     * var userIndex = _.indexBy(users, 'user');
	     * _.pluck(userIndex, 'age');
	     * // => [36, 40] (iteration order is not guaranteed)
	     */
	    function pluck(collection, key) {
	      return map(collection, baseProperty(key));
	    }

	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` through `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not provided the first element of `collection` is used as the initial
	     * value. The `iteratee` is bound to `thisArg`and invoked with four arguments;
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as interatees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `merge`, and `sortAllBy`
	     *
	     * @static
	     * @memberOf _
	     * @alias foldl, inject
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var sum = _.reduce([1, 2, 3], function(sum, n) { return sum + n; });
	     * // => 6
	     *
	     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     *   return result;
	     * }, {});
	     * // => { 'a': 3, 'b': 6, 'c': 9 } (iteration order is not guaranteed)
	     */
	    function reduce(collection, iteratee, accumulator, thisArg) {
	      var func = isArray(collection) ? arrayReduce : baseReduce;
	      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEach);
	    }

	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias foldr
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     * _.reduceRight(array, function(flattened, other) { return flattened.concat(other); }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, iteratee, accumulator, thisArg) {
	      var func = isArray(collection) ? arrayReduceRight : baseReduce;
	      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEachRight);
	    }

	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * var odds = _.reject([1, 2, 3, 4], function(n) { return n % 2 == 0; });
	     * // => [1, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.reject(users, 'active', false), 'user');
	     * // => ['fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.reject(users, 'active'), 'user');
	     * // => ['barney']
	     */
	    function reject(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, function(value, index, collection) {
	        return !predicate(value, index, collection);
	      });
	    }

	    /**
	     * Gets a random element or `n` random elements from a collection.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to sample.
	     * @param {number} [n] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {*} Returns the random sample(s).
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     *
	     * _.sample([1, 2, 3, 4], 2);
	     * // => [3, 1]
	     */
	    function sample(collection, n, guard) {
	      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
	        collection = toIterable(collection);
	        var length = collection.length;
	        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
	      }
	      var result = shuffle(collection);
	      result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);
	      return result;
	    }

	    /**
	     * Creates an array of shuffled values, using a version of the Fisher-Yates
	     * shuffle. See [Wikipedia](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      collection = toIterable(collection);

	      var index = -1,
	          length = collection.length,
	          result = Array(length);

	      while (++index < length) {
	        var rand = baseRandom(0, index);
	        if (index != rand) {
	          result[index] = result[rand];
	        }
	        result[rand] = collection[index];
	      }
	      return result;
	    }

	    /**
	     * Gets the size of `collection` by returning `collection.length` for
	     * array-like values or the number of own enumerable properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the size of `collection`.
	     * @example
	     *
	     * _.size([1, 2]);
	     * // => 2
	     *
	     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
	     * // => 3
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      var length = collection ? collection.length : 0;
	      return isLength(length) ? length : keys(collection).length;
	    }

	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * The function returns as soon as it finds a passing value and does not iterate
	     * over the entire collection. The predicate is bound to `thisArg` and invoked
	     * with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias any
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.some(users, { user': 'barney', 'active': false });
	     * // => false
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.some(users, 'active', false);
	     * // => true
	     *
	     * // using the `_.property` callback shorthand
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }

	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection through `iteratee`. This method performs
	     * a stable sort, that is, it preserves the original sort order of equal elements.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [iteratee=_.identity] The function
	     *  invoked per iteration. If a property name or an object is provided it is
	     *  used to create a `_.property` or `_.matches` style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * _.sortBy([1, 2, 3], function(n) { return Math.sin(n); });
	     * // => [3, 1, 2]
	     *
	     * _.sortBy([1, 2, 3], function(n) { return this.sin(n); }, Math);
	     * // => [3, 1, 2]
	     *
	     * var users = [
	     *   { 'user': 'fred' },
	     *   { 'user': 'pebbles' },
	     *   { 'user': 'barney' }
	     * ];
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.sortBy(users, 'user'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function sortBy(collection, iteratee, thisArg) {
	      var index = -1,
	          length = collection ? collection.length : 0,
	          result = isLength(length) ? Array(length) : [];

	      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	        iteratee = null;
	      }
	      iteratee = getCallback(iteratee, thisArg, 3);
	      baseEach(collection, function(value, key, collection) {
	        result[++index] = { 'criteria': iteratee(value, key, collection), 'index': index, 'value': value };
	      });
	      return baseSortBy(result, compareAscending);
	    }

	    /**
	     * This method is like `_.sortBy` except that it sorts by property names
	     * instead of an iteratee function.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(string|string[])} props The property names to sort by,
	     *  specified as individual property names or arrays of property names.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 26 },
	     *   { 'user': 'fred',   'age': 30 }
	     * ];
	     *
	     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
	     * // => [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
	     */
	    function sortByAll(collection) {
	      var args = arguments;
	      if (args.length > 3 && isIterateeCall(args[1], args[2], args[3])) {
	        args = [collection, args[1]];
	      }
	      var index = -1,
	          length = collection ? collection.length : 0,
	          props = baseFlatten(args, false, false, 1),
	          result = isLength(length) ? Array(length) : [];

	      baseEach(collection, function(value) {
	        var length = props.length,
	            criteria = Array(length);

	        while (length--) {
	          criteria[length] = value == null ? undefined : value[props[length]];
	        }
	        result[++index] = { 'criteria': criteria, 'index': index, 'value': value };
	      });
	      return baseSortBy(result, compareMultipleAscending);
	    }

	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning an array of all elements that have equivalent
	     * property values.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
	     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
	     * ];
	     *
	     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
	     * // => ['barney']
	     *
	     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
	     * // => ['fred']
	     */
	    function where(collection, source) {
	      return filter(collection, baseMatches(source));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Gets the number of milliseconds that have elapsed since the Unix epoch
	     * (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @category Date
	     * @example
	     *
	     * _.defer(function(stamp) { console.log(_.now() - stamp); }, _.now());
	     * // => logs the number of milliseconds it took for the deferred function to be invoked
	     */
	    var now = nativeNow || function() {
	      return new Date().getTime();
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it is called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => logs 'done saving!' after the two async saves have completed
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      n = nativeIsFinite(n = +n) ? n : 0;
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }

	    /**
	     * Creates a function that accepts up to `n` arguments ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      if (guard && isIterateeCall(func, n, guard)) {
	        n = null;
	      }
	      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
	      return createWrapper(func, ARY_FLAG, null, null, null, null, n);
	    }

	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it is called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery('#add').on('click', _.before(5, addContactToList));
	     * // => allows adding up to 4 contacts to the list
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        } else {
	          func = null;
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and prepends any additional `_.bind` arguments to those provided to the
	     * bound function.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind` this method does not set the `length`
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [args] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var greet = function(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * };
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // using placeholders
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    function bind(func, thisArg) {
	      var bitmask = BIND_FLAG;
	      if (arguments.length > 2) {
	        var partials = baseSlice(arguments, 2),
	            holders = replaceHolders(partials, bind.placeholder);

	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(func, bitmask, thisArg, partials, holders);
	    }

	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method. Method names may be specified as individual arguments or as arrays
	     * of method names. If no method names are provided all enumerable function
	     * properties, own and inherited, of `object` are bound.
	     *
	     * **Note:** This method does not set the `length` property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} [methodNames] The object method names to bind,
	     *  specified as individual method names or arrays of method names.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'onClick': function() { console.log('clicked ' + this.label); }
	     * };
	     *
	     * _.bindAll(view);
	     * jQuery('#docs').on('click', view.onClick);
	     * // => logs 'clicked docs' when the element is clicked
	     */
	    function bindAll(object) {
	      return baseBindAll(object,
	        arguments.length > 1
	          ? baseFlatten(arguments, false, false, 1)
	          : functions(object)
	      );
	    }

	    /**
	     * Creates a function that invokes the method at `object[key]` and prepends
	     * any additional `_.bindKey` arguments to those provided to the bound function.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist.
	     * See [Peter Michaux's article](http://michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object the method belongs to.
	     * @param {string} key The key of the method.
	     * @param {...*} [args] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // using placeholders
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    function bindKey(object, key) {
	      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
	      if (arguments.length > 2) {
	        var partials = baseSlice(arguments, 2),
	            holders = replaceHolders(partials, bindKey.placeholder);

	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(key, bitmask, object, partials, holders);
	    }

	    /**
	     * Creates a function that accepts one or more arguments of `func` that when
	     * called either invokes `func` returning its result, if all `func` arguments
	     * have been provided, or returns a function that accepts one or more of the
	     * remaining `func` arguments, and so on. The arity of `func` may be specified
	     * if `func.length` is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the `length` property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    function curry(func, arity, guard) {
	      if (guard && isIterateeCall(func, arity, guard)) {
	        arity = null;
	      }
	      var result = createWrapper(func, CURRY_FLAG, null, null, null, null, null, arity);
	      result.placeholder = curry.placeholder;
	      return result;
	    }

	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the `length` property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    function curryRight(func, arity, guard) {
	      if (guard && isIterateeCall(func, arity, guard)) {
	        arity = null;
	      }
	      var result = createWrapper(func, CURRY_RIGHT_FLAG, null, null, null, null, null, arity);
	      result.placeholder = curryRight.placeholder;
	      return result;
	    }

	    /**
	     * Creates a function that delays invoking `func` until after `wait` milliseconds
	     * have elapsed since the last time it was invoked. The created function comes
	     * with a `cancel` method to cancel delayed invocations. Provide an options
	     * object to indicate that `func` should be invoked on the leading and/or
	     * trailing edge of the `wait` timeout. Subsequent calls to the debounced
	     * function return the result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the debounced function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} wait The number of milliseconds to delay.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=false] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
	     *  delayed before it is invoked.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // avoid costly calculations while the window size is in flux
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
	     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // ensure `batchLog` is invoked once after 1 second of debounced calls
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', _.debounce(batchLog, 250, {
	     *   'maxWait': 1000
	     * }));
	     *
	     * // cancel a debounced call
	     * var todoChanges = _.debounce(batchLog, 1000);
	     * Object.observe(models.todo, todoChanges);
	     *
	     * Object.observe(models, function(changes) {
	     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
	     *     todoChanges.cancel();
	     *   }
	     * }, ['delete']);
	     *
	     * // ...at some point `models.todo` is changed
	     * models.todo.completed = true;
	     *
	     * // ...before 1 second has passed `models.todo` is deleted
	     * // which cancels the debounced `todoChanges` call
	     * delete models.todo;
	     */
	    function debounce(func, wait, options) {
	      var args,
	          maxTimeoutId,
	          result,
	          stamp,
	          thisArg,
	          timeoutId,
	          trailingCall,
	          lastCalled = 0,
	          maxWait = false,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = wait < 0 ? 0 : wait;
	      if (options === true) {
	        var leading = true;
	        trailing = false;
	      } else if (isObject(options)) {
	        leading = options.leading;
	        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
	        trailing = 'trailing' in options ? options.trailing : trailing;
	      }

	      function cancel() {
	        if (timeoutId) {
	          clearTimeout(timeoutId);
	        }
	        if (maxTimeoutId) {
	          clearTimeout(maxTimeoutId);
	        }
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	      }

	      function delayed() {
	        var remaining = wait - (now() - stamp);
	        if (remaining <= 0 || remaining > wait) {
	          if (maxTimeoutId) {
	            clearTimeout(maxTimeoutId);
	          }
	          var isCalled = trailingCall;
	          maxTimeoutId = timeoutId = trailingCall = undefined;
	          if (isCalled) {
	            lastCalled = now();
	            result = func.apply(thisArg, args);
	            if (!timeoutId && !maxTimeoutId) {
	              args = thisArg = null;
	            }
	          }
	        } else {
	          timeoutId = setTimeout(delayed, remaining);
	        }
	      }

	      function maxDelayed() {
	        if (timeoutId) {
	          clearTimeout(timeoutId);
	        }
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	        if (trailing || (maxWait !== wait)) {
	          lastCalled = now();
	          result = func.apply(thisArg, args);
	          if (!timeoutId && !maxTimeoutId) {
	            args = thisArg = null;
	          }
	        }
	      }

	      function debounced() {
	        args = arguments;
	        stamp = now();
	        thisArg = this;
	        trailingCall = trailing && (timeoutId || !leading);

	        if (maxWait === false) {
	          var leadingCall = leading && !timeoutId;
	        } else {
	          if (!maxTimeoutId && !leading) {
	            lastCalled = stamp;
	          }
	          var remaining = maxWait - (stamp - lastCalled),
	              isCalled = remaining <= 0 || remaining > maxWait;

	          if (isCalled) {
	            if (maxTimeoutId) {
	              maxTimeoutId = clearTimeout(maxTimeoutId);
	            }
	            lastCalled = stamp;
	            result = func.apply(thisArg, args);
	          }
	          else if (!maxTimeoutId) {
	            maxTimeoutId = setTimeout(maxDelayed, remaining);
	          }
	        }
	        if (isCalled && timeoutId) {
	          timeoutId = clearTimeout(timeoutId);
	        }
	        else if (!timeoutId && wait !== maxWait) {
	          timeoutId = setTimeout(delayed, wait);
	        }
	        if (leadingCall) {
	          isCalled = true;
	          result = func.apply(thisArg, args);
	        }
	        if (isCalled && !timeoutId && !maxTimeoutId) {
	          args = thisArg = null;
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      return debounced;
	    }

	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) { console.log(text); }, 'deferred');
	     * // logs 'deferred' after one or more milliseconds
	     */
	    function defer(func) {
	      return baseDelay(func, 1, arguments, 1);
	    }

	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) { console.log(text); }, 1000, 'later');
	     * // => logs 'later' after one second
	     */
	    function delay(func, wait) {
	      return baseDelay(func, wait, arguments, 2);
	    }

	    /**
	     * Creates a function that returns the result of invoking the provided
	     * functions with the `this` binding of the created function, where each
	     * successive invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function add(x, y) {
	     *   return x + y;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow(add, square);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    function flow() {
	      var funcs = arguments,
	          length = funcs.length;

	      if (!length) {
	        return function() { return arguments[0]; };
	      }
	      if (!arrayEvery(funcs, isFunction)) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        var index = 0,
	            result = funcs[index].apply(this, arguments);

	        while (++index < length) {
	          result = funcs[index].call(this, result);
	        }
	        return result;
	      };
	    }

	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the provided functions from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias backflow, compose
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function add(x, y) {
	     *   return x + y;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight(square, add);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    function flowRight() {
	      var funcs = arguments,
	          fromIndex = funcs.length - 1;

	      if (fromIndex < 0) {
	        return function() { return arguments[0]; };
	      }
	      if (!arrayEvery(funcs, isFunction)) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        var index = fromIndex,
	            result = funcs[index].apply(this, arguments);

	        while (index--) {
	          result = funcs[index].call(this, result);
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is coerced to a string and used as the
	     * cache key. The `func` is invoked with the `this` binding of the memoized
	     * function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the ES `Map` method interface
	     * of `get`, `has`, and `set`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-map-prototype-object)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoizing function.
	     * @example
	     *
	     * var upperCase = _.memoize(function(string) {
	     *   return string.toUpperCase();
	     * });
	     *
	     * upperCase('fred');
	     * // => 'FRED'
	     *
	     * // modifying the result cache
	     * upperCase.cache.set('fred', 'BARNEY');
	     * upperCase('fred');
	     * // => 'BARNEY'
	     *
	     * // replacing `_.memoize.Cache`
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'barney' };
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'fred' }
	     *
	     * _.memoize.Cache = WeakMap;
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'barney' }
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var cache = memoized.cache,
	            key = resolver ? resolver.apply(this, arguments) : arguments[0];

	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, arguments);
	        cache.set(key, result);
	        return result;
	      };
	      memoized.cache = new memoize.Cache;
	      return memoized;
	    }

	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        return !predicate.apply(this, arguments);
	      };
	    }

	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first call. The `func` is invoked
	     * with the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // `initialize` invokes `createApplication` once
	     */
	    function once(func) {
	      return before(func, 2);
	    }

	    /**
	     * Creates a function that invokes `func` with `partial` arguments prepended
	     * to those provided to the new function. This method is like `_.bind` except
	     * it does **not** alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the `length` property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [args] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // using placeholders
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    function partial(func) {
	      var partials = baseSlice(arguments, 1),
	          holders = replaceHolders(partials, partial.placeholder);

	      return createWrapper(func, PARTIAL_FLAG, null, partials, holders);
	    }

	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to those provided to the new function.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the `length` property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [args] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // using placeholders
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    function partialRight(func) {
	      var partials = baseSlice(arguments, 1),
	          holders = replaceHolders(partials, partialRight.placeholder);

	      return createWrapper(func, PARTIAL_RIGHT_FLAG, null, partials, holders);
	    }

	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified indexes where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, 2, 0, 1);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     *
	     * var map = _.rearg(_.map, [1, 0]);
	     * map(function(n) { return n * 3; }, [1, 2, 3]);
	     * // => [3, 6, 9]
	     */
	    function rearg(func) {
	      var indexes = baseFlatten(arguments, false, false, 1);
	      return createWrapper(func, REARG_FLAG, null, null, null, indexes);
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and the array of arguments provided to the created
	     * function much like [Function#apply](http://es5.github.io/#x15.3.4.3).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @returns {*} Returns the new function.
	     * @example
	     *
	     * var spread = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * spread(['Fred', 'hello']);
	     * // => 'Fred says hello'
	     *
	     * // with a Promise
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function(array) {
	        return func.apply(this, array);
	      };
	    }

	    /**
	     * Creates a function that only invokes `func` at most once per every `wait`
	     * milliseconds. The created function comes with a `cancel` method to cancel
	     * delayed invocations. Provide an options object to indicate that `func`
	     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
	     * Subsequent calls to the throttled function return the result of the last
	     * `func` call.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the throttled function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} wait The number of milliseconds to throttle invocations to.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=true] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // avoid excessively updating the position while scrolling
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
	     * var throttled =  _.throttle(renewToken, 300000, { 'trailing': false })
	     * jQuery('.interactive').on('click', throttled);
	     *
	     * // cancel a trailing throttled call
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (options === false) {
	        leading = false;
	      } else if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      debounceOptions.leading = leading;
	      debounceOptions.maxWait = +wait;
	      debounceOptions.trailing = trailing;
	      return debounce(func, wait, debounceOptions);
	    }

	    /**
	     * Creates a function that provides `value` to the wrapper function as its
	     * first argument. Any additional arguments provided to the function are
	     * appended to those provided to the wrapper function. The wrapper is invoked
	     * with the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      wrapper = wrapper == null ? identity : wrapper;
	      return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
	     * otherwise they are assigned by reference. If `customizer` is provided it is
	     * invoked to produce the cloned values. If `customizer` returns `undefined`
	     * cloning is handled by the method instead. The `customizer` is bound to
	     * `thisArg` and invoked with two argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the structured clone algorithm.
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var shallow = _.clone(users);
	     * shallow[0] === users[0];
	     * // => true
	     *
	     * var deep = _.clone(users, true);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var body = _.clone(document.body, function(value) {
	     *   return _.isElement(value) ? value.cloneNode(false) : undefined;
	     * });
	     *
	     * body === document.body
	     * // => false
	     * body.nodeName
	     * // => BODY
	     * body.childNodes.length;
	     * // => 0
	     */
	    function clone(value, isDeep, customizer, thisArg) {
	      // Juggle arguments.
	      if (typeof isDeep != 'boolean' && isDeep != null) {
	        thisArg = customizer;
	        customizer = isIterateeCall(value, isDeep, thisArg) ? null : isDeep;
	        isDeep = false;
	      }
	      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
	      return baseClone(value, isDeep, customizer);
	    }

	    /**
	     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
	     * to produce the cloned values. If `customizer` returns `undefined` cloning
	     * is handled by the method instead. The `customizer` is bound to `thisArg`
	     * and invoked with two argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the structured clone algorithm.
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the deep cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var deep = _.cloneDeep(users);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var el = _.cloneDeep(document.body, function(value) {
	     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
	     * });
	     *
	     * body === document.body
	     * // => false
	     * body.nodeName
	     * // => BODY
	     * body.childNodes.length;
	     * // => 20
	     */
	    function cloneDeep(value, customizer, thisArg) {
	      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
	      return baseClone(value, true, customizer);
	    }

	    /**
	     * Checks if `value` is classified as an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * (function() { return _.isArguments(arguments); })();
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    function isArguments(value) {
	      var length = isObjectLike(value) ? value.length : undefined;
	      return (isLength(length) && objToString.call(value) == argsTag) || false;
	    }

	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * (function() { return _.isArray(arguments); })();
	     * // => false
	     */
	    var isArray = nativeIsArray || function(value) {
	      return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
	    };

	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return (value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag) || false;
	    }

	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    function isDate(value) {
	      return (isObjectLike(value) && objToString.call(value) == dateTag) || false;
	    }

	    /**
	     * Checks if `value` is a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return (value && value.nodeType === 1 && isObjectLike(value) &&
	        objToString.call(value).indexOf('Element') > -1) || false;
	    }
	    // Fallback for environments without DOM support.
	    if (!support.dom) {
	      isElement = function(value) {
	        return (value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value)) || false;
	      };
	    }

	    /**
	     * Checks if a value is empty. A value is considered empty unless it is an
	     * `arguments` object, array, string, or jQuery-like collection with a length
	     * greater than `0` or an object with own enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Array|Object|string} value The value to inspect.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      var length = value.length;
	      if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||
	          (isObjectLike(value) && isFunction(value.splice)))) {
	        return !length;
	      }
	      return !keys(value).length;
	    }

	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent. If `customizer` is provided it is invoked to compare values.
	     * If `customizer` returns `undefined` comparisons are handled by the method
	     * instead. The `customizer` is bound to `thisArg` and invoked with three
	     * arguments; (value, other [, index|key]).
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. Functions and DOM nodes
	     * are **not** supported. Provide a customizer function to extend support
	     * for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'fred' };
	     *
	     * object == other;
	     * // => false
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * // using a customizer callback
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqual(array, other, function(value, other) {
	     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
	     * });
	     * // => true
	     */
	    function isEqual(value, other, customizer, thisArg) {
	      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
	      if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
	        return value === other;
	      }
	      var result = customizer ? customizer(value, other) : undefined;
	      return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;
	    }

	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      return (isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag) || false;
	    }

	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on ES `Number.isFinite`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(10);
	     * // => true
	     *
	     * _.isFinite('10');
	     * // => false
	     *
	     * _.isFinite(true);
	     * // => false
	     *
	     * _.isFinite(Object(10));
	     * // => false
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     */
	    var isFinite = nativeNumIsFinite || function(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    };

	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      // Avoid a Chakra JIT bug in compatibility modes of IE 11.
	      // See https://github.com/jashkenas/underscore/issues/1621 for more details.
	      return typeof value == 'function' || false;
	    }
	    // Fallback for environments that return incorrect `typeof` operator results.
	    if (isFunction(/x/) || (Uint8Array && !isFunction(Uint8Array))) {
	      isFunction = function(value) {
	        // The use of `Object#toString` avoids issues with the `typeof` operator
	        // in older versions of Chrome and Safari which return 'function' for regexes
	        // and Safari 8 equivalents which return 'object' for typed array constructors.
	        return objToString.call(value) == funcTag;
	      };
	    }

	    /**
	     * Checks if `value` is the language type of `Object`.
	     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(1);
	     * // => false
	     */
	    function isObject(value) {
	      // Avoid a V8 JIT bug in Chrome 19-20.
	      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	      var type = typeof value;
	      return type == 'function' || (value && type == 'object') || false;
	    }

	    /**
	     * Performs a deep comparison between `object` and `source` to determine if
	     * `object` contains equivalent property values. If `customizer` is provided
	     * it is invoked to compare values. If `customizer` returns `undefined`
	     * comparisons are handled by the method instead. The `customizer` is bound
	     * to `thisArg` and invoked with three arguments; (value, other, index|key).
	     *
	     * **Note:** This method supports comparing properties of arrays, booleans,
	     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
	     * and DOM nodes are **not** supported. Provide a customizer function to extend
	     * support for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.isMatch(object, { 'age': 40 });
	     * // => true
	     *
	     * _.isMatch(object, { 'age': 36 });
	     * // => false
	     *
	     * // using a customizer callback
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatch(object, source, function(value, other) {
	     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
	     * });
	     * // => true
	     */
	    function isMatch(object, source, customizer, thisArg) {
	      var props = keys(source),
	          length = props.length;

	      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
	      if (!customizer && length == 1) {
	        var key = props[0],
	            value = source[key];

	        if (isStrictComparable(value)) {
	          return object != null && value === object[key] && hasOwnProperty.call(object, key);
	        }
	      }
	      var values = Array(length),
	          strictCompareFlags = Array(length);

	      while (length--) {
	        value = values[length] = source[props[length]];
	        strictCompareFlags[length] = isStrictComparable(value);
	      }
	      return baseIsMatch(object, props, values, strictCompareFlags, customizer);
	    }

	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is not the same as native `isNaN` which returns `true`
	     * for `undefined` and other non-numeric values. See the [ES5 spec](https://es5.github.io/#x15.1.2.4)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
	      return isNumber(value) && value != +value;
	    }

	    /**
	     * Checks if `value` is a native function.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (value == null) {
	        return false;
	      }
	      if (objToString.call(value) == funcTag) {
	        return reNative.test(fnToString.call(value));
	      }
	      return (isObjectLike(value) && reHostCtor.test(value)) || false;
	    }

	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }

	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
	     * as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isNumber(8.4);
	     * // => true
	     *
	     * _.isNumber(NaN);
	     * // => true
	     *
	     * _.isNumber('8.4');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag) || false;
	    }

	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * **Note:** This method assumes objects created by the `Object` constructor
	     * have no inherited enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
	      if (!(value && objToString.call(value) == objectTag)) {
	        return false;
	      }
	      var valueOf = value.valueOf,
	          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

	      return objProto
	        ? (value == objProto || getPrototypeOf(value) == objProto)
	        : shimIsPlainObject(value);
	    };

	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    function isRegExp(value) {
	      return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;
	    }

	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
	    }

	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    function isTypedArray(value) {
	      return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
	    }

	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return typeof value == 'undefined';
	    }

	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3);
	     * // => [2, 3]
	     */
	    function toArray(value) {
	      var length = value ? value.length : 0;
	      if (!isLength(length)) {
	        return values(value);
	      }
	      if (!length) {
	        return [];
	      }
	      return arrayCopy(value);
	    }

	    /**
	     * Converts `value` to a plain object flattening inherited enumerable
	     * properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return baseCopy(value, keysIn(value));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object. Subsequent sources overwrite property assignments of previous sources.
	     * If `customizer` is provided it is invoked to produce the assigned values.
	     * The `customizer` is bound to `thisArg` and invoked with five arguments;
	     * (objectValue, sourceValue, key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize assigning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
	     * // => { 'user': 'fred', 'age': 40 }
	     *
	     * // using a customizer callback
	     * var defaults = _.partialRight(_.assign, function(value, other) {
	     *   return typeof value == 'undefined' ? other : value;
	     * });
	     *
	     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var assign = createAssigner(baseAssign);

	    /**
	     * Creates an object that inherits from the given `prototype` object. If a
	     * `properties` object is provided its own enumerable properties are assigned
	     * to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties, guard) {
	      var result = baseCreate(prototype);
	      if (guard && isIterateeCall(prototype, properties, guard)) {
	        properties = null;
	      }
	      return properties ? baseCopy(properties, result, keys(properties)) : result;
	    }

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object for all destination properties that resolve to `undefined`. Once a
	     * property is set, additional defaults of the same property are ignored.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    function defaults(object) {
	      if (object == null) {
	        return object;
	      }
	      var args = arrayCopy(arguments);
	      args.push(assignDefaults);
	      return assign.apply(undefined, args);
	    }

	    /**
	     * This method is like `_.findIndex` except that it returns the key of the
	     * first element `predicate` returns truthy for, instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(chr) { return chr.age < 40; });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findKey(users, 'active', false);
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    function findKey(object, predicate, thisArg) {
	      predicate = getCallback(predicate, thisArg, 3);
	      return baseFind(object, predicate, baseForOwn, true);
	    }

	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(chr) { return chr.age < 40; });
	     * // => returns `pebbles` assuming `_.findKey` returns `barney`
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findLastKey(users, 'active', false);
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, predicate, thisArg) {
	      predicate = getCallback(predicate, thisArg, 3);
	      return baseFind(object, predicate, baseForOwnRight, true);
	    }

	    /**
	     * Iterates over own and inherited enumerable properties of an object invoking
	     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
	     * with three arguments; (value, key, object). Iterator functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
	     */
	    function forIn(object, iteratee, thisArg) {
	      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
	        iteratee = bindCallback(iteratee, thisArg, 3);
	      }
	      return baseFor(object, iteratee, keysIn);
	    }

	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
	     */
	    function forInRight(object, iteratee, thisArg) {
	      iteratee = bindCallback(iteratee, thisArg, 3);
	      return baseForRight(object, iteratee, keysIn);
	    }

	    /**
	     * Iterates over own enumerable properties of an object invoking `iteratee`
	     * for each property. The `iteratee` is bound to `thisArg` and invoked with
	     * three arguments; (value, key, object). Iterator functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(n, key) {
	     *   console.log(key);
	     * });
	     * // => logs '0', '1', and 'length' (iteration order is not guaranteed)
	     */
	    function forOwn(object, iteratee, thisArg) {
	      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
	        iteratee = bindCallback(iteratee, thisArg, 3);
	      }
	      return baseForOwn(object, iteratee);
	    }

	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(n, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
	     */
	    function forOwnRight(object, iteratee, thisArg) {
	      iteratee = bindCallback(iteratee, thisArg, 3);
	      return baseForRight(object, iteratee, keys);
	    }

	    /**
	     * Creates an array of function property names from all enumerable properties,
	     * own and inherited, of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @alias methods
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the new array of property names.
	     * @example
	     *
	     * _.functions(_);
	     * // => ['all', 'any', 'bind', ...]
	     */
	    function functions(object) {
	      return baseFunctions(object, keysIn(object));
	    }

	    /**
	     * Checks if `key` exists as a direct property of `object` instead of an
	     * inherited property.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` is a direct property, else `false`.
	     * @example
	     *
	     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
	     * // => true
	     */
	    function has(object, key) {
	      return object ? hasOwnProperty.call(object, key) : false;
	    }

	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite property
	     * assignments of previous values unless `multiValue` is `true`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {boolean} [multiValue] Allow multiple values per key.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * _.invert({ 'first': 'fred', 'second': 'barney' });
	     * // => { 'fred': 'first', 'barney': 'second' }
	     *
	     * // without `multiValue`
	     * _.invert({ 'first': 'fred', 'second': 'barney', 'third': 'fred' });
	     * // => { 'fred': 'third', 'barney': 'second' }
	     *
	     * // with `multiValue`
	     * _.invert({ 'first': 'fred', 'second': 'barney', 'third': 'fred' }, true);
	     * // => { 'fred': ['first', 'third'], 'barney': ['second'] }
	     */
	    function invert(object, multiValue, guard) {
	      if (guard && isIterateeCall(object, multiValue, guard)) {
	        multiValue = null;
	      }
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index],
	            value = object[key];

	        if (multiValue) {
	          if (hasOwnProperty.call(result, value)) {
	            result[value].push(key);
	          } else {
	            result[value] = [key];
	          }
	        }
	        else {
	          result[value] = key;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    var keys = !nativeKeys ? shimKeys : function(object) {
	      if (object) {
	        var Ctor = object.constructor,
	            length = object.length;
	      }
	      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	         (typeof object != 'function' && (length && isLength(length)))) {
	        return shimKeys(object);
	      }
	      return isObject(object) ? nativeKeys(object) : [];
	    };

	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      if (object == null) {
	        return [];
	      }
	      if (!isObject(object)) {
	        object = Object(object);
	      }
	      var length = object.length;
	      length = (length && isLength(length) &&
	        (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

	      var Ctor = object.constructor,
	          index = -1,
	          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	          result = Array(length),
	          skipIndexes = length > 0;

	      while (++index < length) {
	        result[index] = (index + '');
	      }
	      for (var key in object) {
	        if (!(skipIndexes && isIndex(key, length)) &&
	            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an object with the same keys as `object` and values generated by
	     * running each own enumerable property of `object` through `iteratee`. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments;
	     * (value, key, object).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(n) { return n * 3; });
	     * // => { 'a': 3, 'b': 6, 'c': 9 }
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * // using the `_.property` callback shorthand
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    function mapValues(object, iteratee, thisArg) {
	      var result = {};
	      iteratee = getCallback(iteratee, thisArg, 3);

	      baseForOwn(object, function(value, key, object) {
	        result[key] = iteratee(value, key, object);
	      });
	      return result;
	    }

	    /**
	     * Recursively merges own enumerable properties of the source object(s), that
	     * don't resolve to `undefined` into the destination object. Subsequent sources
	     * overwrite property assignments of previous sources. If `customizer` is
	     * provided it is invoked to produce the merged values of the destination and
	     * source properties. If `customizer` returns `undefined` merging is handled
	     * by the method instead. The `customizer` is bound to `thisArg` and invoked
	     * with five arguments; (objectValue, sourceValue, key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize merging properties.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var users = {
	     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
	     * };
	     *
	     * var ages = {
	     *   'data': [{ 'age': 36 }, { 'age': 40 }]
	     * };
	     *
	     * _.merge(users, ages);
	     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
	     *
	     * // using a customizer callback
	     * var object = {
	     *   'fruits': ['apple'],
	     *   'vegetables': ['beet']
	     * };
	     *
	     * var other = {
	     *   'fruits': ['banana'],
	     *   'vegetables': ['carrot']
	     * };
	     *
	     * _.merge(object, other, function(a, b) {
	     *   return _.isArray(a) ? a.concat(b) : undefined;
	     * });
	     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
	     */
	    var merge = createAssigner(baseMerge);

	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable properties of `object` that are not omitted.
	     * Property names may be specified as individual arguments or as arrays of
	     * property names. If `predicate` is provided it is invoked for each property
	     * of `object` omitting the properties `predicate` returns truthy for. The
	     * predicate is bound to `thisArg` and invoked with three arguments;
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to omit, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.omit(object, 'age');
	     * // => { 'user': 'fred' }
	     *
	     * _.omit(object, _.isNumber);
	     * // => { 'user': 'fred' }
	     */
	    function omit(object, predicate, thisArg) {
	      if (object == null) {
	        return {};
	      }
	      if (typeof predicate != 'function') {
	        var props = arrayMap(baseFlatten(arguments, false, false, 1), String);
	        return pickByArray(object, baseDifference(keysIn(object), props));
	      }
	      predicate = bindCallback(predicate, thisArg, 3);
	      return pickByCallback(object, function(value, key, object) {
	        return !predicate(value, key, object);
	      });
	    }

	    /**
	     * Creates a two dimensional array of the key-value pairs for `object`,
	     * e.g. `[[key1, value1], [key2, value2]]`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the new array of key-value pairs.
	     * @example
	     *
	     * _.pairs({ 'barney': 36, 'fred': 40 });
	     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
	     */
	    function pairs(object) {
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        var key = props[index];
	        result[index] = [key, object[key]];
	      }
	      return result;
	    }

	    /**
	     * Creates an object composed of the picked `object` properties. Property
	     * names may be specified as individual arguments or as arrays of property
	     * names. If `predicate` is provided it is invoked for each property of `object`
	     * picking the properties `predicate` returns truthy for. The predicate is
	     * bound to `thisArg` and invoked with three arguments; (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to pick, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.pick(object, 'user');
	     * // => { 'user': 'fred' }
	     *
	     * _.pick(object, _.isString);
	     * // => { 'user': 'fred' }
	     */
	    function pick(object, predicate, thisArg) {
	      if (object == null) {
	        return {};
	      }
	      return typeof predicate == 'function'
	        ? pickByCallback(object, bindCallback(predicate, thisArg, 3))
	        : pickByArray(object, baseFlatten(arguments, false, false, 1));
	    }

	    /**
	     * Resolves the value of property `key` on `object`. If the value of `key` is
	     * a function it is invoked with the `this` binding of `object` and its result
	     * is returned, else the property value is returned. If the property value is
	     * `undefined` the `defaultValue` is used in its place.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the property to resolve.
	     * @param {*} [defaultValue] The value returned if the property value
	     *  resolves to `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': _.constant(40) };
	     *
	     * _.result(object, 'user');
	     * // => 'fred'
	     *
	     * _.result(object, 'age');
	     * // => 40
	     *
	     * _.result(object, 'status', 'busy');
	     * // => 'busy'
	     *
	     * _.result(object, 'status', _.constant('busy'));
	     * // => 'busy'
	     */
	    function result(object, key, defaultValue) {
	      var value = object == null ? undefined : object[key];
	      if (typeof value == 'undefined') {
	        value = defaultValue;
	      }
	      return isFunction(value) ? value.call(object) : value;
	    }

	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own enumerable
	     * properties through `iteratee`, with each invocation potentially mutating
	     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
	     * with four arguments; (accumulator, value, key, object). Iterator functions
	     * may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Array|Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var squares = _.transform([1, 2, 3, 4, 5, 6], function(result, n) {
	     *   n *= n;
	     *   if (n % 2) {
	     *     return result.push(n) < 3;
	     *   }
	     * });
	     * // => [1, 9, 25]
	     *
	     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     * });
	     * // => { 'a': 3, 'b': 6, 'c': 9 }
	     */
	    function transform(object, iteratee, accumulator, thisArg) {
	      var isArr = isArray(object) || isTypedArray(object);
	      iteratee = getCallback(iteratee, thisArg, 4);

	      if (accumulator == null) {
	        if (isArr || isObject(object)) {
	          var Ctor = object.constructor;
	          if (isArr) {
	            accumulator = isArray(object) ? new Ctor : [];
	          } else {
	            accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
	          }
	        } else {
	          accumulator = {};
	        }
	      }
	      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }

	    /**
	     * Creates an array of the own enumerable property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return baseValues(object, keys(object));
	    }

	    /**
	     * Creates an array of the own and inherited enumerable property values
	     * of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return baseValues(object, keysIn(object));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Produces a random number between `min` and `max` (inclusive). If only one
	     * argument is provided a number between `0` and the given number is returned.
	     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
	     * number is returned instead of an integer.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} [min=0] The minimum possible value.
	     * @param {number} [max=1] The maximum possible value.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(min, max, floating) {
	      if (floating && isIterateeCall(min, max, floating)) {
	        max = floating = null;
	      }
	      var noMin = min == null,
	          noMax = max == null;

	      if (floating == null) {
	        if (noMax && typeof min == 'boolean') {
	          floating = min;
	          min = 1;
	        }
	        else if (typeof max == 'boolean') {
	          floating = max;
	          noMax = true;
	        }
	      }
	      if (noMin && noMax) {
	        max = 1;
	        noMax = false;
	      }
	      min = +min || 0;
	      if (noMax) {
	        max = min;
	        min = 0;
	      } else {
	        max = +max || 0;
	      }
	      if (floating || min % 1 || max % 1) {
	        var rand = nativeRandom();
	        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
	      }
	      return baseRandom(min, max);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Converts `string` to camel case.
	     * See [Wikipedia](https://en.wikipedia.org/wiki/CamelCase) for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__foo_bar__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
	    });

	    /**
	     * Capitalizes the first character of `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('fred');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      string = baseToString(string);
	      return string && (string.charAt(0).toUpperCase() + string.slice(1));
	    }

	    /**
	     * Deburrs `string` by converting latin-1 supplementary letters to basic latin letters.
	     * See [Wikipedia](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('dj vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = baseToString(string);
	      return string && string.replace(reLatin1, deburrLetter);
	    }

	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search from.
	     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = baseToString(string);
	      target = (target + '');

	      var length = string.length;
	      position = (typeof position == 'undefined' ? length : nativeMin(position < 0 ? 0 : (+position || 0), length)) - target.length;
	      return position >= 0 && string.indexOf(target, position) == position;
	    }

	    /**
	     * Converts the characters "&", "<", ">", '"', "'", and '`', in `string` to
	     * their corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional characters
	     * use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't require escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value.
	     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * Backticks are escaped because in Internet Explorer < 9, they can break out
	     * of attribute values or HTML comments. See [#102](https://html5sec.org/#102),
	     * [#108](https://html5sec.org/#108), and [#133](https://html5sec.org/#133) of
	     * the [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
	     *
	     * When working with HTML you should always quote attribute values to reduce
	     * XSS vectors. See [Ryan Grove's article](http://wonko.com/post/html-escaping)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
	      string = baseToString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }

	    /**
	     * Escapes the `RegExp` special characters "\", "^", "$", ".", "|", "?", "*",
	     * "+", "(", ")", "[", "]", "{" and "}" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https://lodash\.com/\)'
	     */
	    function escapeRegExp(string) {
	      string = baseToString(string);
	      return (string && reHasRegExpChars.test(string))
	        ? string.replace(reRegExpChars, '\\$&')
	        : string;
	    }

	    /**
	     * Converts `string` to kebab case (a.k.a. spinal case).
	     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles) for
	     * more details.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__foo_bar__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });

	    /**
	     * Pads `string` on the left and right sides if it is shorter then the given
	     * padding length. The `chars` string may be truncated if the number of padding
	     * characters can't be evenly divided by the padding length.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = baseToString(string);
	      length = +length;

	      var strLength = string.length;
	      if (strLength >= length || !nativeIsFinite(length)) {
	        return string;
	      }
	      var mid = (length - strLength) / 2,
	          leftLength = floor(mid),
	          rightLength = ceil(mid);

	      chars = createPad('', rightLength, chars);
	      return chars.slice(0, leftLength) + string + chars;
	    }

	    /**
	     * Pads `string` on the left side if it is shorter then the given padding
	     * length. The `chars` string may be truncated if the number of padding
	     * characters exceeds the padding length.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padLeft('abc', 6);
	     * // => '   abc'
	     *
	     * _.padLeft('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padLeft('abc', 3);
	     * // => 'abc'
	     */
	    function padLeft(string, length, chars) {
	      string = baseToString(string);
	      return string && (createPad(string, length, chars) + string);
	    }

	    /**
	     * Pads `string` on the right side if it is shorter then the given padding
	     * length. The `chars` string may be truncated if the number of padding
	     * characters exceeds the padding length.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padRight('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padRight('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padRight('abc', 3);
	     * // => 'abc'
	     */
	    function padRight(string, length, chars) {
	      string = baseToString(string);
	      return string && (string + createPad(string, length, chars));
	    }

	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
	     * in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the ES5 implementation of `parseInt`.
	     * See the [ES5 spec](https://es5.github.io/#E) for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      if (guard && isIterateeCall(string, radix, guard)) {
	        radix = 0;
	      }
	      return nativeParseInt(string, radix);
	    }
	    // Fallback for environments with pre-ES5 implementations.
	    if (nativeParseInt(whitespace + '08') != 8) {
	      parseInt = function(string, radix, guard) {
	        // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
	        // Chrome fails to trim leading <BOM> whitespace characters.
	        // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
	        if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
	          radix = 0;
	        } else if (radix) {
	          radix = +radix;
	        }
	        string = trim(string);
	        return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));
	      };
	    }

	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=0] The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n) {
	      var result = '';
	      string = baseToString(string);
	      n = +n;
	      if (n < 1 || !string || !nativeIsFinite(n)) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = floor(n / 2);
	        string += string;
	      } while (n);

	      return result;
	    }

	    /**
	     * Converts `string` to snake case.
	     * See [Wikipedia](https://en.wikipedia.org/wiki/Snake_case) for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--foo-bar');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts `string` to start case.
	     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__foo_bar__');
	     * // => 'Foo Bar'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
	    });

	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = baseToString(string);
	      position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
	      return string.lastIndexOf(target, position) == position;
	    }

	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is provided it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes sourceURLs for easier debugging.
	     * See the [HTML5 Rocks article on sourcemaps](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for more details.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options] The options object.
	     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
	     * @param {Object} [options.imports] An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
	     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
	     * @param {string} [options.variable] The data object variable name.
	     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // using the "interpolate" delimiter to create a compiled template
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // using the HTML "escape" delimiter to escape data property values
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the internal `print` function in "evaluate" delimiters
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // using custom template delimiters
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // using backslashes to treat delimiters as plain text
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // using the `imports` option to import `jQuery` as `jq`
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the `sourceURL` option to specify a custom sourceURL for the template
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
	     *
	     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     *   var __t, __p = '';
	     *   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     *   return __p;
	     * }
	     *
	     * // using the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and a stack trace
	     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, otherOptions) {
	      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;

	      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
	        options = otherOptions = null;
	      }
	      string = baseToString(string);
	      options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

	      var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);

	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";

	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');

	      // Use a sourceURL for easier debugging.
	      var sourceURL = '//# sourceURL=' +
	        ('sourceURL' in options
	          ? options.sourceURL
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';

	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);

	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;

	        // The JS engine embedded in Adobe products requires returning the `match`
	        // string in order to produce the correct `offset` value.
	        return match;
	      });

	      source += "';\n";

	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');

	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';

	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
	      });

	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }

	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar]
	     */
	    function trim(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
	      }
	      chars = (chars + '');
	      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
	    }

	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimLeft('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimLeft('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimLeft(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string));
	      }
	      return string.slice(charsLeftIndex(string, (chars + '')));
	    }

	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimRight('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimRight('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimRight(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(0, trimmedRightIndex(string) + 1);
	      }
	      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
	    }

	    /**
	     * Truncates `string` if it is longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object|number} [options] The options object or maximum string length.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.trunc('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', 24);
	     * // => 'hi-diddly-ho there, n...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', { 'length': 24, 'separator': ' ' });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', { 'length': 24, 'separator': /,? +/ });
	     * //=> 'hi-diddly-ho there...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', { 'omission': ' [...]' });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function trunc(string, options, guard) {
	      if (guard && isIterateeCall(string, options, guard)) {
	        options = null;
	      }
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;

	      if (options != null) {
	        if (isObject(options)) {
	          var separator = 'separator' in options ? options.separator : separator;
	          length = 'length' in options ? +options.length || 0 : length;
	          omission = 'omission' in options ? baseToString(options.omission) : omission;
	        } else {
	          length = +options || 0;
	        }
	      }
	      string = baseToString(string);
	      if (length >= string.length) {
	        return string;
	      }
	      var end = length - omission.length;
	      if (end < 1) {
	        return omission;
	      }
	      var result = string.slice(0, end);
	      if (separator == null) {
	        return result + omission;
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              newEnd,
	              substring = string.slice(0, end);

	          if (!separator.global) {
	            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            newEnd = match.index;
	          }
	          result = result.slice(0, newEnd == null ? end : newEnd);
	        }
	      } else if (string.indexOf(separator, end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }

	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
	     * corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
	     * entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = baseToString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }

	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      if (guard && isIterateeCall(string, pattern, guard)) {
	        pattern = null;
	      }
	      string = baseToString(string);
	      return string.match(pattern || reWords) || [];
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} func The function to attempt.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // avoid throwing errors for invalid selectors
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    function attempt(func) {
	      try {
	        return func.apply(undefined, baseSlice(arguments, 1));
	      } catch(e) {
	        return isError(e) ? e : new Error(e);
	      }
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and arguments of the created function. If `func` is a property name the
	     * created callback returns the property value for a given element. If `func`
	     * is an object the created callback returns `true` for elements that contain
	     * the equivalent object properties, otherwise it returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias iteratee
	     * @category Utility
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // wrap to create custom callback shorthands
	     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
	     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
	     *   if (!match) {
	     *     return callback(func, thisArg);
	     *   }
	     *   return function(object) {
	     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
	     *   };
	     * });
	     *
	     * _.filter(users, 'age__gt36');
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     */
	    function callback(func, thisArg, guard) {
	      if (guard && isIterateeCall(func, thisArg, guard)) {
	        thisArg = null;
	      }
	      return isObjectLike(func)
	        ? matches(func)
	        : baseCallback(func, thisArg);
	    }

	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var getter = _.constant(object);
	     * getter() === object;
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }

	    /**
	     * This method returns the first argument provided to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * _.identity(object) === object;
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }

	    /**
	     * Creates a function which performs a deep comparison between a given object
	     * and `source`, returning `true` if the given object has equivalent property
	     * values, else `false`.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
	     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, true));
	    }

	    /**
	     * Creates a function which compares the property value of `key` on a given
	     * object to `value`.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {string} key The key of the property to get.
	     * @param {*} value The value to compare.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' },
	     *   { 'user': 'pebbles' }
	     * ];
	     *
	     * _.find(users, _.matchesProperty('user', 'fred'));
	     * // => { 'user': 'fred', 'age': 40 }
	     */
	    function matchesProperty(key, value) {
	      return baseMatchesProperty(key + '', baseClone(value, true));
	    }

	    /**
	     * Adds all own enumerable function properties of a source object to the
	     * destination object. If `object` is a function then methods are added to
	     * its prototype as well.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Function|Object} [object=this] object The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.chain=true] Specify whether the functions added
	     *  are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * // use `_.runInContext` to avoid potential conflicts (esp. in Node.js)
	     * var _ = require('lodash').runInContext();
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      if (options == null) {
	        var isObj = isObject(source),
	            props = isObj && keys(source),
	            methodNames = props && props.length && baseFunctions(source, props);

	        if (!(methodNames ? methodNames.length : isObj)) {
	          methodNames = false;
	          options = source;
	          source = object;
	          object = this;
	        }
	      }
	      if (!methodNames) {
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = true,
	          index = -1,
	          isFunc = isFunction(object),
	          length = methodNames.length;

	      if (options === false) {
	        chain = false;
	      } else if (isObject(options) && 'chain' in options) {
	        chain = options.chain;
	      }
	      while (++index < length) {
	        var methodName = methodNames[index],
	            func = source[methodName];

	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = (function(func) {
	            return function() {
	              var chainAll = this.__chain__;
	              if (chain || chainAll) {
	                var result = object(this.__wrapped__);
	                (result.__actions__ = arrayCopy(this.__actions__)).push({ 'func': func, 'args': arguments, 'thisArg': object });
	                result.__chain__ = chainAll;
	                return result;
	              }
	              var args = [this.value()];
	              push.apply(args, arguments);
	              return func.apply(object, args);
	            };
	          }(func));
	        }
	      }
	      return object;
	    }

	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      context._ = oldDash;
	      return this;
	    }

	    /**
	     * A no-operation function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * _.noop(object) === undefined;
	     * // => true
	     */
	    function noop() {
	      // No operation performed.
	    }

	    /**
	     * Creates a function which returns the property value of `key` on a given object.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {string} key The key of the property to get.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred' },
	     *   { 'user': 'barney' }
	     * ];
	     *
	     * var getName = _.property('user');
	     *
	     * _.map(users, getName);
	     * // => ['fred', barney']
	     *
	     * _.pluck(_.sortBy(users, getName), 'user');
	     * // => ['barney', 'fred']
	     */
	    function property(key) {
	      return baseProperty(key + '');
	    }

	    /**
	     * The inverse of `_.property`; this method creates a function which returns
	     * the property value of a given key on `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} object The object to inspect.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40, 'active': true };
	     * _.map(['active', 'user'], _.propertyOf(object));
	     * // => [true, 'fred']
	     *
	     * var object = { 'a': 3, 'b': 1, 'c': 2 };
	     * _.sortBy(['a', 'b', 'c'], _.propertyOf(object));
	     * // => ['b', 'c', 'a']
	     */
	    function propertyOf(object) {
	      return function(key) {
	        return object == null ? undefined : object[key];
	      };
	    }

	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. If `start` is less than `end` a
	     * zero-length range is created unless a negative `step` is specified.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the new array of numbers.
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    function range(start, end, step) {
	      if (step && isIterateeCall(start, end, step)) {
	        end = step = null;
	      }
	      start = +start || 0;
	      step = step == null ? 1 : (+step || 0);

	      if (end == null) {
	        end = start;
	        start = 0;
	      } else {
	        end = +end || 0;
	      }
	      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
	      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
	      var index = -1,
	          length = nativeMax(ceil((end - start) / (step || 1)), 0),
	          result = Array(length);

	      while (++index < length) {
	        result[index] = start;
	        start += step;
	      }
	      return result;
	    }

	    /**
	     * Invokes the iteratee function `n` times, returning an array of the results
	     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
	     * one argument; (index).
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
	     * // => [3, 6, 4]
	     *
	     * _.times(3, function(n) { mage.castSpell(n); });
	     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2` respectively
	     *
	     * _.times(3, function(n) { this.cast(n); }, mage);
	     * // => also invokes `mage.castSpell(n)` three times
	     */
	    function times(n, iteratee, thisArg) {
	      n = +n;

	      // Exit early to avoid a JSC JIT bug in Safari 8
	      // where `Array(0)` is treated as `Array(1)`.
	      if (n < 1 || !nativeIsFinite(n)) {
	        return [];
	      }
	      var index = -1,
	          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

	      iteratee = bindCallback(iteratee, thisArg, 1);
	      while (++index < n) {
	        if (index < MAX_ARRAY_LENGTH) {
	          result[index] = iteratee(index);
	        } else {
	          iteratee(index);
	        }
	      }
	      return result;
	    }

	    /**
	     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {string} [prefix] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return baseToString(prefix) + id;
	    }

	    /*------------------------------------------------------------------------*/

	    // Ensure `new LodashWrapper` is an instance of `lodash`.
	    LodashWrapper.prototype = baseCreate(lodash.prototype);

	    // Ensure `new LazyWraper` is an instance of `LodashWrapper`
	    LazyWrapper.prototype = baseCreate(LodashWrapper.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;

	    // Add functions to the `Map` cache.
	    MapCache.prototype['delete'] = mapDelete;
	    MapCache.prototype.get = mapGet;
	    MapCache.prototype.has = mapHas;
	    MapCache.prototype.set = mapSet;

	    // Add functions to the `Set` cache.
	    SetCache.prototype.push = cachePush;

	    // Assign cache to `_.memoize`.
	    memoize.Cache = MapCache;

	    // Add functions that return wrapped values when chaining.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.callback = callback;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.functions = functions;
	    lodash.groupBy = groupBy;
	    lodash.indexBy = indexBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.invert = invert;
	    lodash.invoke = invoke;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.mixin = mixin;
	    lodash.negate = negate;
	    lodash.omit = omit;
	    lodash.once = once;
	    lodash.pairs = pairs;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pluck = pluck;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortByAll = sortByAll;
	    lodash.spread = spread;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.times = times;
	    lodash.toArray = toArray;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.union = union;
	    lodash.uniq = uniq;
	    lodash.unzip = unzip;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.where = where;
	    lodash.without = without;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;

	    // Add aliases.
	    lodash.backflow = flowRight;
	    lodash.collect = map;
	    lodash.compose = flowRight;
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.extend = assign;
	    lodash.iteratee = callback;
	    lodash.methods = functions;
	    lodash.object = zipObject;
	    lodash.select = filter;
	    lodash.tail = rest;
	    lodash.unique = uniq;

	    // Add functions to `lodash.prototype`.
	    mixin(lodash, lodash);

	    /*------------------------------------------------------------------------*/

	    // Add functions that return unwrapped values when chaining.
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.deburr = deburr;
	    lodash.endsWith = endsWith;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.findWhere = findWhere;
	    lodash.first = first;
	    lodash.has = has;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isBoolean = isBoolean;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isMatch = isMatch;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isString = isString;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.max = max;
	    lodash.min = min;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padLeft = padLeft;
	    lodash.padRight = padRight;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.result = result;
	    lodash.runInContext = runInContext;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.template = template;
	    lodash.trim = trim;
	    lodash.trimLeft = trimLeft;
	    lodash.trimRight = trimRight;
	    lodash.trunc = trunc;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.words = words;

	    // Add aliases.
	    lodash.all = every;
	    lodash.any = some;
	    lodash.contains = includes;
	    lodash.detect = find;
	    lodash.foldl = reduce;
	    lodash.foldr = reduceRight;
	    lodash.head = first;
	    lodash.include = includes;
	    lodash.inject = reduce;

	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!lodash.prototype[methodName]) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), false);

	    /*------------------------------------------------------------------------*/

	    // Add functions capable of returning wrapped and unwrapped values when chaining.
	    lodash.sample = sample;

	    lodash.prototype.sample = function(n) {
	      if (!this.__chain__ && n == null) {
	        return sample(this.value());
	      }
	      return this.thru(function(value) {
	        return sample(value, n);
	      });
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type string
	     */
	    lodash.VERSION = VERSION;

	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });

	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var isFilter = index == LAZY_FILTER_FLAG,
	          isWhile = index == LAZY_WHILE_FLAG;

	      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
	        var result = this.clone(),
	            filtered = result.__filtered__,
	            iteratees = result.__iteratees__ || (result.__iteratees__ = []);

	        result.__filtered__ = filtered || isFilter || (isWhile && result.__dir__ < 0);
	        iteratees.push({ 'iteratee': getCallback(iteratee, thisArg, 3), 'type': index });
	        return result;
	      };
	    });

	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      var countName = '__' + methodName + 'Count__',
	          whileName = methodName + 'While';

	      LazyWrapper.prototype[methodName] = function(n) {
	        n = n == null ? 1 : nativeMax(floor(n) || 0, 0);

	        var result = this.clone();
	        if (result.__filtered__) {
	          var value = result[countName];
	          result[countName] = index ? nativeMin(value, n) : (value + n);
	        } else {
	          var views = result.__views__ || (result.__views__ = []);
	          views.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
	        }
	        return result;
	      };

	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };

	      LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {
	        return this.reverse()[whileName](predicate, thisArg).reverse();
	      };
	    });

	    // Add `LazyWrapper` methods for `_.first` and `_.last`.
	    arrayEach(['first', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');

	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });

	    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
	    arrayEach(['initial', 'rest'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');

	      LazyWrapper.prototype[methodName] = function() {
	        return this[dropName](1);
	      };
	    });

	    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
	    arrayEach(['pluck', 'where'], function(methodName, index) {
	      var operationName = index ? 'filter' : 'map',
	          createCallback = index ? baseMatches : baseProperty;

	      LazyWrapper.prototype[methodName] = function(value) {
	        return this[operationName](createCallback(value));
	      };
	    });

	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };

	    LazyWrapper.prototype.dropWhile = function(predicate, thisArg) {
	      var done;
	      predicate = getCallback(predicate, thisArg, 3);
	      return this.filter(function(value, index, array) {
	        return done || (done = !predicate(value, index, array));
	      });
	    };

	    LazyWrapper.prototype.reject = function(predicate, thisArg) {
	      predicate = getCallback(predicate, thisArg, 3);
	      return this.filter(function(value, index, array) {
	        return !predicate(value, index, array);
	      });
	    };

	    LazyWrapper.prototype.slice = function(start, end) {
	      start = start == null ? 0 : (+start || 0);
	      var result = start < 0 ? this.takeRight(-start) : this.drop(start);

	      if (typeof end != 'undefined') {
	        end = (+end || 0);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };

	    LazyWrapper.prototype.toArray = function() {
	      return this.drop(0);
	    };

	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName],
	          retUnwrapped = /^(?:first|last)$/.test(methodName);

	      lodash.prototype[methodName] = function() {
	        var value = this.__wrapped__,
	            args = arguments,
	            chainAll = this.__chain__,
	            isHybrid = !!this.__actions__.length,
	            isLazy = value instanceof LazyWrapper,
	            onlyLazy = isLazy && !isHybrid;

	        if (retUnwrapped && !chainAll) {
	          return onlyLazy
	            ? func.call(value)
	            : lodashFunc.call(lodash, this.value());
	        }
	        var interceptor = function(value) {
	          var otherArgs = [value];
	          push.apply(otherArgs, args);
	          return lodashFunc.apply(lodash, otherArgs);
	        };
	        if (isLazy || isArray(value)) {
	          var wrapper = onlyLazy ? value : new LazyWrapper(this),
	              result = func.apply(wrapper, args);

	          if (!retUnwrapped && (isHybrid || result.__actions__)) {
	            var actions = result.__actions__ || (result.__actions__ = []);
	            actions.push({ 'func': thru, 'args': [interceptor], 'thisArg': lodash });
	          }
	          return new LodashWrapper(result, chainAll);
	        }
	        return this.thru(interceptor);
	      };
	    });

	    // Add `Array.prototype` functions to `lodash.prototype`.
	    arrayEach(['concat', 'join', 'pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
	      var func = arrayProto[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:join|pop|shift)$/.test(methodName);

	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          return func.apply(this.value(), args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(value, args);
	        });
	      };
	    });

	    // Add functions to the lazy wrapper.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;

	    // Add chaining functions to the lodash wrapper.
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toString = wrapperToString;
	    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

	    // Add function aliases to the lodash wrapper.
	    lodash.prototype.collect = lodash.prototype.map;
	    lodash.prototype.head = lodash.prototype.first;
	    lodash.prototype.select = lodash.prototype.filter;
	    lodash.prototype.tail = lodash.prototype.rest;

	    return lodash;
	  }

	  /*--------------------------------------------------------------------------*/

	  // Export lodash.
	  var _ = runInContext();

	  // Some AMD build optimizers like r.js check for condition patterns like the following:
	  if (true) {
	    // Expose lodash to the global object when an AMD loader is present to avoid
	    // errors in cases where lodash is loaded by a script tag and not intended
	    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
	    // more details.
	    root._ = _;

	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
	  else if (freeExports && freeModule) {
	    // Export for Node.js or RingoJS.
	    if (moduleExports) {
	      (freeModule.exports = _)._ = _;
	    }
	    // Export for Narwhal or Rhino -require.
	    else {
	      freeExports._ = _;
	    }
	  }
	  else {
	    // Export for a browser or Rhino.
	    root._ = _;
	  }
	}.call(this));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module), (function() { return this; }())))

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 5 */
/***/ function(module, exports) {

	// ==ClosureCompiler==
	// @compilation_level SIMPLE_OPTIMIZATIONS

	/**
	 * @license Highstock JS v4.2.3 (2016-02-08)
	 *
	 * (c) 2009-2016 Torstein Honsi
	 *
	 * License: www.highcharts.com/license
	 */

	(function (root, factory) {
	    if (typeof module === 'object' && module.exports) {
	        module.exports = root.document ?
	            factory(root) : 
	            factory;
	    } else {
	        root.Highcharts = factory(root);
	    }
	}(typeof window !== 'undefined' ? window : this, function (win) { // eslint-disable-line no-undef
	// encapsulated variables
	    var UNDEFINED,
	        doc = win.document,
	        math = Math,
	        mathRound = math.round,
	        mathFloor = math.floor,
	        mathCeil = math.ceil,
	        mathMax = math.max,
	        mathMin = math.min,
	        mathAbs = math.abs,
	        mathCos = math.cos,
	        mathSin = math.sin,
	        mathPI = math.PI,
	        deg2rad = mathPI * 2 / 360,


	        // some variables
	        userAgent = (win.navigator && win.navigator.userAgent) || '',
	        isOpera = win.opera,
	        isMS = /(msie|trident|edge)/i.test(userAgent) && !isOpera,
	        docMode8 = doc && doc.documentMode === 8,
	        isWebKit = !isMS && /AppleWebKit/.test(userAgent),
	        isFirefox = /Firefox/.test(userAgent),
	        isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),
	        SVG_NS = 'http://www.w3.org/2000/svg',
	        hasSVG = doc && doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
	        hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38
	        useCanVG = doc && !hasSVG && !isMS && !!doc.createElement('canvas').getContext,
	        Renderer,
	        hasTouch,
	        symbolSizes = {},
	        idCounter = 0,
	        garbageBin,
	        defaultOptions,
	        dateFormat, // function
	        pathAnim,
	        timeUnits,
	        noop = function () {},
	        charts = [],
	        chartCount = 0,
	        PRODUCT = 'Highstock',
	        VERSION = '4.2.3',

	        // some constants for frequently used strings
	        DIV = 'div',
	        ABSOLUTE = 'absolute',
	        RELATIVE = 'relative',
	        HIDDEN = 'hidden',
	        PREFIX = 'highcharts-',
	        VISIBLE = 'visible',
	        PX = 'px',
	        NONE = 'none',
	        M = 'M',
	        L = 'L',
	        numRegex = /^[0-9]+$/,
	        NORMAL_STATE = '',
	        HOVER_STATE = 'hover',
	        SELECT_STATE = 'select',
	        marginNames = ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],

	        // Object for extending Axis
	        AxisPlotLineOrBandExtension,

	        // constants for attributes
	        STROKE_WIDTH = 'stroke-width',

	        // time methods, changed based on whether or not UTC is used
	        Date,  // Allow using a different Date class
	        makeTime,
	        timezoneOffset,
	        getTimezoneOffset,
	        getMinutes,
	        getHours,
	        getDay,
	        getDate,
	        getMonth,
	        getFullYear,
	        setMilliseconds,
	        setSeconds,
	        setMinutes,
	        setHours,
	        setDate,
	        setMonth,
	        setFullYear,


	        // lookup over the types and the associated classes
	        seriesTypes = {},
	        Highcharts;

	    /**
	     * Provide error messages for debugging, with links to online explanation
	     */
	    function error(code, stop) {
	        var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;
	        if (stop) {
	            throw new Error(msg);
	        }
	        // else ...
	        if (win.console) {
	            console.log(msg); // eslint-disable-line no-console
	        }
	    }

	    // The Highcharts namespace
	    Highcharts = win.Highcharts ? error(16, true) : { win: win };

	    Highcharts.seriesTypes = seriesTypes;
	    var timers = [],
	        getStyle,

	        // Previous adapter functions
	        inArray,
	        each,
	        grep,
	        offset,
	        map,
	        addEvent,
	        removeEvent,
	        fireEvent,
	        animate,
	        stop;

	    /**
	     * An animator object. One instance applies to one property (attribute or style prop) 
	     * on one element.
	     * 
	     * @param {object} elem    The element to animate. May be a DOM element or a Highcharts SVGElement wrapper.
	     * @param {object} options Animation options, including duration, easing, step and complete.
	     * @param {object} prop    The property to animate.
	     */
	    function Fx(elem, options, prop) {
	        this.options = options;
	        this.elem = elem;
	        this.prop = prop;
	    }
	    Fx.prototype = {
	    
	        /**
	         * Animating a path definition on SVGElement
	         * @returns {undefined} 
	         */
	        dSetter: function () {
	            var start = this.paths[0],
	                end = this.paths[1],
	                ret = [],
	                now = this.now,
	                i = start.length,
	                startVal;

	            if (now === 1) { // land on the final path without adjustment points appended in the ends
	                ret = this.toD;

	            } else if (i === end.length && now < 1) {
	                while (i--) {
	                    startVal = parseFloat(start[i]);
	                    ret[i] =
	                        isNaN(startVal) ? // a letter instruction like M or L
	                                start[i] :
	                                now * (parseFloat(end[i] - startVal)) + startVal;

	                }
	            } else { // if animation is finished or length not matching, land on right value
	                ret = end;
	            }
	            this.elem.attr('d', ret);
	        },

	        /**
	         * Update the element with the current animation step
	         * @returns {undefined}
	         */
	        update: function () {
	            var elem = this.elem,
	                prop = this.prop, // if destroyed, it is null
	                now = this.now,
	                step = this.options.step;

	            // Animation setter defined from outside
	            if (this[prop + 'Setter']) {
	                this[prop + 'Setter']();

	            // Other animations on SVGElement
	            } else if (elem.attr) {
	                if (elem.element) {
	                    elem.attr(prop, now);
	                }

	            // HTML styles, raw HTML content like container size
	            } else {
	                elem.style[prop] = now + this.unit;
	            }
	        
	            if (step) {
	                step.call(elem, now, this);
	            }

	        },

	        /**
	         * Run an animation
	         */
	        run: function (from, to, unit) {
	            var self = this,
	                timer = function (gotoEnd) {
	                    return timer.stopped ? false : self.step(gotoEnd);
	                },
	                i;

	            this.startTime = +new Date();
	            this.start = from;
	            this.end = to;
	            this.unit = unit;
	            this.now = this.start;
	            this.pos = 0;

	            timer.elem = this.elem;

	            if (timer() && timers.push(timer) === 1) {
	                timer.timerId = setInterval(function () {
	                
	                    for (i = 0; i < timers.length; i++) {
	                        if (!timers[i]()) {
	                            timers.splice(i--, 1);
	                        }
	                    }

	                    if (!timers.length) {
	                        clearInterval(timer.timerId);
	                    }
	                }, 13);
	            }
	        },
	    
	        /**
	         * Run a single step in the animation
	         * @param   {Boolean} gotoEnd Whether to go to then endpoint of the animation after abort
	         * @returns {Boolean} True if animation continues
	         */
	        step: function (gotoEnd) {
	            var t = +new Date(),
	                ret,
	                done,
	                options = this.options,
	                elem = this.elem,
	                complete = options.complete,
	                duration = options.duration,
	                curAnim = options.curAnim,
	                i;
	        
	            if (elem.attr && !elem.element) { // #2616, element including flag is destroyed
	                ret = false;

	            } else if (gotoEnd || t >= duration + this.startTime) {
	                this.now = this.end;
	                this.pos = 1;
	                this.update();

	                curAnim[this.prop] = true;

	                done = true;
	                for (i in curAnim) {
	                    if (curAnim[i] !== true) {
	                        done = false;
	                    }
	                }

	                if (done && complete) {
	                    complete.call(elem);
	                }
	                ret = false;

	            } else {
	                this.pos = options.easing((t - this.startTime) / duration);
	                this.now = this.start + ((this.end - this.start) * this.pos);
	                this.update();
	                ret = true;
	            }
	            return ret;
	        },

	        /**
	         * Prepare start and end values so that the path can be animated one to one
	         */
	        initPath: function (elem, fromD, toD) {
	            fromD = fromD || '';
	            var shift = elem.shift,
	                bezier = fromD.indexOf('C') > -1,
	                numParams = bezier ? 7 : 3,
	                endLength,
	                slice,
	                i,
	                start = fromD.split(' '),
	                end = [].concat(toD), // copy
	                isArea = elem.isArea,
	                positionFactor = isArea ? 2 : 1,
	                sixify = function (arr) { // in splines make move points have six parameters like bezier curves
	                    i = arr.length;
	                    while (i--) {
	                        if (arr[i] === M || arr[i] === L) {
	                            arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
	                        }
	                    }
	                };

	            if (bezier) {
	                sixify(start);
	                sixify(end);
	            }

	            // If shifting points, prepend a dummy point to the end path. For areas,
	            // prepend both at the beginning and end of the path.
	            if (shift <= end.length / numParams && start.length === end.length) {
	                while (shift--) {
	                    end = end.slice(0, numParams).concat(end);
	                    if (isArea) {
	                        end = end.concat(end.slice(end.length - numParams));
	                    }
	                }
	            }
	            elem.shift = 0; // reset for following animations

	        
	            // Copy and append last point until the length matches the end length
	            if (start.length) {
	                endLength = end.length;
	                while (start.length < endLength) {

	                    // Pull out the slice that is going to be appended or inserted. In a line graph,
	                    // the positionFactor is 1, and the last point is sliced out. In an area graph,
	                    // the positionFactor is 2, causing the middle two points to be sliced out, since
	                    // an area path starts at left, follows the upper path then turns and follows the
	                    // bottom back. 
	                    slice = start.slice().splice(
	                        (start.length / positionFactor) - numParams, 
	                        numParams * positionFactor
	                    );
	                
	                    // Disable first control point
	                    if (bezier) {
	                        slice[numParams - 6] = slice[numParams - 2];
	                        slice[numParams - 5] = slice[numParams - 1];
	                    }
	                
	                    // Now insert the slice, either in the middle (for areas) or at the end (for lines)
	                    [].splice.apply(
	                        start, 
	                        [(start.length / positionFactor), 0].concat(slice)
	                    );

	                }
	            }

	            return [start, end];
	        }
	    }; // End of Fx prototype


	    /**
	     * Extend an object with the members of another
	     * @param {Object} a The object to be extended
	     * @param {Object} b The object to add to the first one
	     */
	    var extend = Highcharts.extend = function (a, b) {
	        var n;
	        if (!a) {
	            a = {};
	        }
	        for (n in b) {
	            a[n] = b[n];
	        }
	        return a;
	    };

	    /**
	     * Deep merge two or more objects and return a third object. If the first argument is
	     * true, the contents of the second object is copied into the first object.
	     * Previously this function redirected to jQuery.extend(true), but this had two limitations.
	     * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,
	     * it copied properties from extended prototypes.
	     */
	    function merge() {
	        var i,
	            args = arguments,
	            len,
	            ret = {},
	            doCopy = function (copy, original) {
	                var value, key;

	                // An object is replacing a primitive
	                if (typeof copy !== 'object') {
	                    copy = {};
	                }

	                for (key in original) {
	                    if (original.hasOwnProperty(key)) {
	                        value = original[key];

	                        // Copy the contents of objects, but not arrays or DOM nodes
	                        if (value && typeof value === 'object' && Object.prototype.toString.call(value) !== '[object Array]' &&
	                                key !== 'renderTo' && typeof value.nodeType !== 'number') {
	                            copy[key] = doCopy(copy[key] || {}, value);

	                        // Primitives and arrays are copied over directly
	                        } else {
	                            copy[key] = original[key];
	                        }
	                    }
	                }
	                return copy;
	            };

	        // If first argument is true, copy into the existing object. Used in setOptions.
	        if (args[0] === true) {
	            ret = args[1];
	            args = Array.prototype.slice.call(args, 2);
	        }

	        // For each argument, extend the return
	        len = args.length;
	        for (i = 0; i < len; i++) {
	            ret = doCopy(ret, args[i]);
	        }

	        return ret;
	    }

	    /**
	     * Shortcut for parseInt
	     * @param {Object} s
	     * @param {Number} mag Magnitude
	     */
	    function pInt(s, mag) {
	        return parseInt(s, mag || 10);
	    }

	    /**
	     * Check for string
	     * @param {Object} s
	     */
	    function isString(s) {
	        return typeof s === 'string';
	    }

	    /**
	     * Check for object
	     * @param {Object} obj
	     */
	    function isObject(obj) {
	        return obj && typeof obj === 'object';
	    }

	    /**
	     * Check for array
	     * @param {Object} obj
	     */
	    function isArray(obj) {
	        return Object.prototype.toString.call(obj) === '[object Array]';
	    }

	    /**
	     * Check for number
	     * @param {Object} n
	     */
	    function isNumber(n) {
	        return typeof n === 'number';
	    }

	    function log2lin(num) {
	        return math.log(num) / math.LN10;
	    }
	    function lin2log(num) {
	        return math.pow(10, num);
	    }

	    /**
	     * Remove last occurence of an item from an array
	     * @param {Array} arr
	     * @param {Mixed} item
	     */
	    function erase(arr, item) {
	        var i = arr.length;
	        while (i--) {
	            if (arr[i] === item) {
	                arr.splice(i, 1);
	                break;
	            }
	        }
	        //return arr;
	    }

	    /**
	     * Returns true if the object is not null or undefined.
	     * @param {Object} obj
	     */
	    function defined(obj) {
	        return obj !== UNDEFINED && obj !== null;
	    }

	    /**
	     * Set or get an attribute or an object of attributes. Can't use jQuery attr because
	     * it attempts to set expando properties on the SVG element, which is not allowed.
	     *
	     * @param {Object} elem The DOM element to receive the attribute(s)
	     * @param {String|Object} prop The property or an abject of key-value pairs
	     * @param {String} value The value if a single property is set
	     */
	    function attr(elem, prop, value) {
	        var key,
	            ret;

	        // if the prop is a string
	        if (isString(prop)) {
	            // set the value
	            if (defined(value)) {
	                elem.setAttribute(prop, value);

	            // get the value
	            } else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
	                ret = elem.getAttribute(prop);
	            }

	        // else if prop is defined, it is a hash of key/value pairs
	        } else if (defined(prop) && isObject(prop)) {
	            for (key in prop) {
	                elem.setAttribute(key, prop[key]);
	            }
	        }
	        return ret;
	    }
	    /**
	     * Check if an element is an array, and if not, make it into an array.
	     */
	    function splat(obj) {
	        return isArray(obj) ? obj : [obj];
	    }

	    /**
	     * Set a timeout if the delay is given, otherwise perform the function synchronously
	     * @param   {Function} fn      The function to perform
	     * @param   {Number}   delay   Delay in milliseconds
	     * @param   {Ojbect}   context The context
	     * @returns {Nubmer}           An identifier for the timeout
	     */
	    function syncTimeout(fn, delay, context) {
	        if (delay) {
	            return setTimeout(fn, delay, context);
	        }
	        fn.call(0, context);
	    }


	    /**
	     * Return the first value that is defined.
	     */
	    var pick = Highcharts.pick = function () {
	        var args = arguments,
	            i,
	            arg,
	            length = args.length;
	        for (i = 0; i < length; i++) {
	            arg = args[i];
	            if (arg !== UNDEFINED && arg !== null) {
	                return arg;
	            }
	        }
	    };

	    /**
	     * Set CSS on a given element
	     * @param {Object} el
	     * @param {Object} styles Style object with camel case property names
	     */
	    function css(el, styles) {
	        if (isMS && !hasSVG) { // #2686
	            if (styles && styles.opacity !== UNDEFINED) {
	                styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
	            }
	        }
	        extend(el.style, styles);
	    }

	    /**
	     * Utility function to create element with attributes and styles
	     * @param {Object} tag
	     * @param {Object} attribs
	     * @param {Object} styles
	     * @param {Object} parent
	     * @param {Object} nopad
	     */
	    function createElement(tag, attribs, styles, parent, nopad) {
	        var el = doc.createElement(tag);
	        if (attribs) {
	            extend(el, attribs);
	        }
	        if (nopad) {
	            css(el, { padding: 0, border: 'none', margin: 0 });
	        }
	        if (styles) {
	            css(el, styles);
	        }
	        if (parent) {
	            parent.appendChild(el);
	        }
	        return el;
	    }

	    /**
	     * Extend a prototyped class by new members
	     * @param {Object} parent
	     * @param {Object} members
	     */
	    function extendClass(Parent, members) {
	        var object = function () {
	        };
	        object.prototype = new Parent();
	        extend(object.prototype, members);
	        return object;
	    }

	    /**
	     * Pad a string to a given length by adding 0 to the beginning
	     * @param {Number} number
	     * @param {Number} length
	     */
	    function pad(number, length) {
	        return new Array((length || 2) + 1 - String(number).length).join(0) + number;
	    }

	    /**
	     * Return a length based on either the integer value, or a percentage of a base.
	     */
	    function relativeLength(value, base) {
	        return (/%$/).test(value) ? base * parseFloat(value) / 100 : parseFloat(value);
	    }

	    /**
	     * Wrap a method with extended functionality, preserving the original function
	     * @param {Object} obj The context object that the method belongs to
	     * @param {String} method The name of the method to extend
	     * @param {Function} func A wrapper function callback. This function is called with the same arguments
	     * as the original function, except that the original function is unshifted and passed as the first
	     * argument.
	     */
	    var wrap = Highcharts.wrap = function (obj, method, func) {
	        var proceed = obj[method];
	        obj[method] = function () {
	            var args = Array.prototype.slice.call(arguments);
	            args.unshift(proceed);
	            return func.apply(this, args);
	        };
	    };


	    function getTZOffset(timestamp) {
	        return ((getTimezoneOffset && getTimezoneOffset(timestamp)) || timezoneOffset || 0) * 60000;
	    }

	    /**
	     * Based on http://www.php.net/manual/en/function.strftime.php
	     * @param {String} format
	     * @param {Number} timestamp
	     * @param {Boolean} capitalize
	     */
	    dateFormat = function (format, timestamp, capitalize) {
	        if (!defined(timestamp) || isNaN(timestamp)) {
	            return defaultOptions.lang.invalidDate || '';
	        }
	        format = pick(format, '%Y-%m-%d %H:%M:%S');

	        var date = new Date(timestamp - getTZOffset(timestamp)),
	            key, // used in for constuct below
	            // get the basic time values
	            hours = date[getHours](),
	            day = date[getDay](),
	            dayOfMonth = date[getDate](),
	            month = date[getMonth](),
	            fullYear = date[getFullYear](),
	            lang = defaultOptions.lang,
	            langWeekdays = lang.weekdays,

	            // List all format keys. Custom formats can be added from the outside.
	            replacements = extend({

	                // Day
	                'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
	                'A': langWeekdays[day], // Long weekday, like 'Monday'
	                'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31
	                'e': dayOfMonth, // Day of the month, 1 through 31
	                'w': day,

	                // Week (none implemented)
	                //'W': weekNumber(),

	                // Month
	                'b': lang.shortMonths[month], // Short month, like 'Jan'
	                'B': lang.months[month], // Long month, like 'January'
	                'm': pad(month + 1), // Two digit month number, 01 through 12

	                // Year
	                'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
	                'Y': fullYear, // Four digits year, like 2009

	                // Time
	                'H': pad(hours), // Two digits hours in 24h format, 00 through 23
	                'k': hours, // Hours in 24h format, 0 through 23
	                'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
	                'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
	                'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
	                'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
	                'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
	                'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59
	                'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)
	            }, Highcharts.dateFormats);


	        // do the replaces
	        for (key in replacements) {
	            while (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster
	                format = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);
	            }
	        }

	        // Optionally capitalize the string and return
	        return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
	    };

	    /**
	     * Format a single variable. Similar to sprintf, without the % prefix.
	     */
	    function formatSingle(format, val) {
	        var floatRegex = /f$/,
	            decRegex = /\.([0-9])/,
	            lang = defaultOptions.lang,
	            decimals;

	        if (floatRegex.test(format)) { // float
	            decimals = format.match(decRegex);
	            decimals = decimals ? decimals[1] : -1;
	            if (val !== null) {
	                val = Highcharts.numberFormat(
	                    val,
	                    decimals,
	                    lang.decimalPoint,
	                    format.indexOf(',') > -1 ? lang.thousandsSep : ''
	                );
	            }
	        } else {
	            val = dateFormat(format, val);
	        }
	        return val;
	    }

	    /**
	     * Format a string according to a subset of the rules of Python's String.format method.
	     */
	    function format(str, ctx) {
	        var splitter = '{',
	            isInside = false,
	            segment,
	            valueAndFormat,
	            path,
	            i,
	            len,
	            ret = [],
	            val,
	            index;

	        while ((index = str.indexOf(splitter)) !== -1) {

	            segment = str.slice(0, index);
	            if (isInside) { // we're on the closing bracket looking back

	                valueAndFormat = segment.split(':');
	                path = valueAndFormat.shift().split('.'); // get first and leave format
	                len = path.length;
	                val = ctx;

	                // Assign deeper paths
	                for (i = 0; i < len; i++) {
	                    val = val[path[i]];
	                }

	                // Format the replacement
	                if (valueAndFormat.length) {
	                    val = formatSingle(valueAndFormat.join(':'), val);
	                }

	                // Push the result and advance the cursor
	                ret.push(val);

	            } else {
	                ret.push(segment);

	            }
	            str = str.slice(index + 1); // the rest
	            isInside = !isInside; // toggle
	            splitter = isInside ? '}' : '{'; // now look for next matching bracket
	        }
	        ret.push(str);
	        return ret.join('');
	    }

	    /**
	     * Get the magnitude of a number
	     */
	    function getMagnitude(num) {
	        return math.pow(10, mathFloor(math.log(num) / math.LN10));
	    }

	    /**
	     * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
	     * @param {Number} interval
	     * @param {Array} multiples
	     * @param {Number} magnitude
	     * @param {Object} options
	     */
	    function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, preventExceed) {
	        var normalized,
	            i,
	            retInterval = interval;

	        // round to a tenfold of 1, 2, 2.5 or 5
	        magnitude = pick(magnitude, 1);
	        normalized = interval / magnitude;

	        // multiples for a linear scale
	        if (!multiples) {
	            multiples = [1, 2, 2.5, 5, 10];

	            // the allowDecimals option
	            if (allowDecimals === false) {
	                if (magnitude === 1) {
	                    multiples = [1, 2, 5, 10];
	                } else if (magnitude <= 0.1) {
	                    multiples = [1 / magnitude];
	                }
	            }
	        }

	        // normalize the interval to the nearest multiple
	        for (i = 0; i < multiples.length; i++) {
	            retInterval = multiples[i];
	            if ((preventExceed && retInterval * magnitude >= interval) || // only allow tick amounts smaller than natural
	                    (!preventExceed && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {
	                break;
	            }
	        }

	        // multiply back to the correct magnitude
	        retInterval *= magnitude;

	        return retInterval;
	    }


	    /**
	     * Utility method that sorts an object array and keeping the order of equal items.
	     * ECMA script standard does not specify the behaviour when items are equal.
	     */
	    function stableSort(arr, sortFunction) {
	        var length = arr.length,
	            sortValue,
	            i;

	        // Add index to each item
	        for (i = 0; i < length; i++) {
	            arr[i].safeI = i; // stable sort index
	        }

	        arr.sort(function (a, b) {
	            sortValue = sortFunction(a, b);
	            return sortValue === 0 ? a.safeI - b.safeI : sortValue;
	        });

	        // Remove index from items
	        for (i = 0; i < length; i++) {
	            delete arr[i].safeI; // stable sort index
	        }
	    }

	    /**
	     * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
	     * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
	     * method is slightly slower, but safe.
	     */
	    function arrayMin(data) {
	        var i = data.length,
	            min = data[0];

	        while (i--) {
	            if (data[i] < min) {
	                min = data[i];
	            }
	        }
	        return min;
	    }

	    /**
	     * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
	     * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
	     * method is slightly slower, but safe.
	     */
	    function arrayMax(data) {
	        var i = data.length,
	            max = data[0];

	        while (i--) {
	            if (data[i] > max) {
	                max = data[i];
	            }
	        }
	        return max;
	    }

	    /**
	     * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.
	     * It loops all properties and invokes destroy if there is a destroy method. The property is
	     * then delete'ed.
	     * @param {Object} The object to destroy properties on
	     * @param {Object} Exception, do not destroy this property, only delete it.
	     */
	    function destroyObjectProperties(obj, except) {
	        var n;
	        for (n in obj) {
	            // If the object is non-null and destroy is defined
	            if (obj[n] && obj[n] !== except && obj[n].destroy) {
	                // Invoke the destroy
	                obj[n].destroy();
	            }

	            // Delete the property from the object.
	            delete obj[n];
	        }
	    }


	    /**
	     * Discard an element by moving it to the bin and delete
	     * @param {Object} The HTML node to discard
	     */
	    function discardElement(element) {
	        // create a garbage bin element, not part of the DOM
	        if (!garbageBin) {
	            garbageBin = createElement(DIV);
	        }

	        // move the node and empty bin
	        if (element) {
	            garbageBin.appendChild(element);
	        }
	        garbageBin.innerHTML = '';
	    }

	    /**
	     * Fix JS round off float errors
	     * @param {Number} num
	     */
	    function correctFloat(num, prec) {
	        return parseFloat(
	            num.toPrecision(prec || 14)
	        );
	    }

	    /**
	     * Set the global animation to either a given value, or fall back to the
	     * given chart's animation option
	     * @param {Object} animation
	     * @param {Object} chart
	     */
	    function setAnimation(animation, chart) {
	        chart.renderer.globalAnimation = pick(animation, chart.animation);
	    }

	    /**
	     * The time unit lookup
	     */
	    timeUnits = {
	        millisecond: 1,
	        second: 1000,
	        minute: 60000,
	        hour: 3600000,
	        day: 24 * 3600000,
	        week: 7 * 24 * 3600000,
	        month: 28 * 24 * 3600000,
	        year: 364 * 24 * 3600000
	    };


	    /**
	     * Format a number and return a string based on input settings
	     * @param {Number} number The input number to format
	     * @param {Number} decimals The amount of decimals
	     * @param {String} decimalPoint The decimal point, defaults to the one given in the lang options
	     * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
	     */
	    Highcharts.numberFormat = function (number, decimals, decimalPoint, thousandsSep) {

	        number = +number || 0;

	        var lang = defaultOptions.lang,
	            origDec = (number.toString().split('.')[1] || '').length,
	            decimalComponent,
	            strinteger,
	            thousands,
	            absNumber = Math.abs(number),
	            ret;

	        if (decimals === -1) {
	            decimals = Math.min(origDec, 20); // Preserve decimals. Not huge numbers (#3793).
	        } else if (isNaN(decimals)) {
	            decimals = 2;
	        }

	        // A string containing the positive integer component of the number
	        strinteger = String(pInt(absNumber.toFixed(decimals)));

	        // Leftover after grouping into thousands. Can be 0, 1 or 3.
	        thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;

	        // Language
	        decimalPoint = pick(decimalPoint, lang.decimalPoint);
	        thousandsSep = pick(thousandsSep, lang.thousandsSep);

	        // Start building the return
	        ret = number < 0 ? '-' : '';

	        // Add the leftover after grouping into thousands. For example, in the number 42 000 000,
	        // this line adds 42.
	        ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';

	        // Add the remaining thousands groups, joined by the thousands separator
	        ret += strinteger.substr(thousands).replace(/(\d{3})(?=\d)/g, '$1' + thousandsSep);

	        // Add the decimal point and the decimal component
	        if (+decimals) {
	            // Get the decimal component, and add power to avoid rounding errors with float numbers (#4573)
	            decimalComponent = Math.abs(absNumber - strinteger + Math.pow(10, -Math.max(decimals, origDec) - 1));
	            ret += decimalPoint + decimalComponent.toFixed(decimals).slice(2);
	        }

	        return ret;
	    };

	    /**
	     * Easing definition
	     * @param   {Number} pos Current position, ranging from 0 to 1
	     */
	    Math.easeInOutSine = function (pos) {
	        return -0.5 * (Math.cos(Math.PI * pos) - 1);
	    };

	    /**
	     * Internal method to return CSS value for given element and property
	     */
	    getStyle = function (el, prop) {

	        var style;

	        // For width and height, return the actual inner pixel size (#4913)
	        if (prop === 'width') {
	            return Math.min(el.offsetWidth, el.scrollWidth) - getStyle(el, 'padding-left') - getStyle(el, 'padding-right');
	        } else if (prop === 'height') {
	            return Math.min(el.offsetHeight, el.scrollHeight) - getStyle(el, 'padding-top') - getStyle(el, 'padding-bottom');
	        }

	        // Otherwise, get the computed style
	        style = win.getComputedStyle(el, undefined);
	        return style && pInt(style.getPropertyValue(prop));
	    };

	    /**
	     * Return the index of an item in an array, or -1 if not found
	     */
	    inArray = function (item, arr) {
	        return arr.indexOf ? arr.indexOf(item) : [].indexOf.call(arr, item);
	    };

	    /**
	     * Filter an array
	     */
	    grep = function (elements, callback) {
	        return [].filter.call(elements, callback);
	    };

	    /**
	     * Map an array
	     */
	    map = function (arr, fn) {
	        var results = [], i = 0, len = arr.length;

	        for (; i < len; i++) {
	            results[i] = fn.call(arr[i], arr[i], i, arr);
	        }

	        return results;
	    };

	    /**
	     * Get the element's offset position, corrected by overflow:auto.
	     */
	    offset = function (el) {
	        var docElem = doc.documentElement,
	            box = el.getBoundingClientRect();

	        return {
	            top: box.top  + (win.pageYOffset || docElem.scrollTop)  - (docElem.clientTop  || 0),
	            left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
	        };
	    };

	    /**
	     * Stop running animation.
	     * A possible extension to this would be to stop a single property, when
	     * we want to continue animating others. Then assign the prop to the timer
	     * in the Fx.run method, and check for the prop here. This would be an improvement
	     * in all cases where we stop the animation from .attr. Instead of stopping
	     * everything, we can just stop the actual attributes we're setting.
	     */
	    stop = function (el) {

	        var i = timers.length;

	        // Remove timers related to this element (#4519)
	        while (i--) {
	            if (timers[i].elem === el) {
	                timers[i].stopped = true; // #4667
	            }
	        }
	    };

	    /**
	     * Utility for iterating over an array.
	     * @param {Array} arr
	     * @param {Function} fn
	     */
	    each = function (arr, fn) { // modern browsers
	        return Array.prototype.forEach.call(arr, fn);
	    };

	    /**
	     * Add an event listener
	     */
	    addEvent = function (el, type, fn) {
	    
	        var events = el.hcEvents = el.hcEvents || {};

	        function wrappedFn(e) {
	            e.target = e.srcElement || win; // #2820
	            fn.call(el, e);
	        }

	        // Handle DOM events in modern browsers
	        if (el.addEventListener) {
	            el.addEventListener(type, fn, false);

	        // Handle old IE implementation
	        } else if (el.attachEvent) {

	            if (!el.hcEventsIE) {
	                el.hcEventsIE = {};
	            }

	            // Link wrapped fn with original fn, so we can get this in removeEvent
	            el.hcEventsIE[fn.toString()] = wrappedFn;

	            el.attachEvent('on' + type, wrappedFn);
	        }

	        if (!events[type]) {
	            events[type] = [];
	        }

	        events[type].push(fn);
	    };

	    /**
	     * Remove event added with addEvent
	     */
	    removeEvent = function (el, type, fn) {
	    
	        var events,
	            hcEvents = el.hcEvents,
	            index;

	        function removeOneEvent(type, fn) {
	            if (el.removeEventListener) {
	                el.removeEventListener(type, fn, false);
	            } else if (el.attachEvent) {
	                fn = el.hcEventsIE[fn.toString()];
	                el.detachEvent('on' + type, fn);
	            }
	        }

	        function removeAllEvents() {
	            var types,
	                len,
	                n;

	            if (!el.nodeName) {
	                return; // break on non-DOM events
	            }

	            if (type) {
	                types = {};
	                types[type] = true;
	            } else {
	                types = hcEvents;
	            }

	            for (n in types) {
	                if (hcEvents[n]) {
	                    len = hcEvents[n].length;
	                    while (len--) {
	                        removeOneEvent(n, hcEvents[n][len]);
	                    }
	                }
	            }
	        }

	        if (hcEvents) {
	            if (type) {
	                events = hcEvents[type] || [];
	                if (fn) {
	                    index = inArray(fn, events);
	                    if (index > -1) {
	                        events.splice(index, 1);
	                        hcEvents[type] = events;
	                    }
	                    removeOneEvent(type, fn);

	                } else {
	                    removeAllEvents();
	                    hcEvents[type] = [];
	                }
	            } else {
	                removeAllEvents();
	                el.hcEvents = {};
	            }
	        }
	    };

	    /**
	     * Fire an event on a custom object
	     */
	    fireEvent = function (el, type, eventArguments, defaultFunction) {
	        var e,
	            hcEvents = el.hcEvents,
	            events,
	            len,
	            i,
	            preventDefault,
	            fn;

	        eventArguments = eventArguments || {};

	        if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {
	            e = doc.createEvent('Events');
	            e.initEvent(type, true, true);
	            e.target = el;

	            extend(e, eventArguments);

	            if (el.dispatchEvent) {
	                el.dispatchEvent(e);
	            } else {
	                el.fireEvent(type, e);
	            }

	        } else if (hcEvents) {
	        
	            events = hcEvents[type] || [];
	            len = events.length;

	            // Attach a simple preventDefault function to skip default handler if called
	            preventDefault = function () {
	                eventArguments.defaultPrevented = true;
	            };
	        
	            for (i = 0; i < len; i++) {
	                fn = events[i];

	                // eventArguments is never null here
	                if (eventArguments.stopped) {
	                    return;
	                }

	                eventArguments.preventDefault = preventDefault;
	                eventArguments.target = el;

	                // If the type is not set, we're running a custom event (#2297). If it is set,
	                // we're running a browser event, and setting it will cause en error in
	                // IE8 (#2465).
	                if (!eventArguments.type) {
	                    eventArguments.type = type;
	                }
	            
	                // If the event handler return false, prevent the default handler from executing
	                if (fn.call(el, eventArguments) === false) {
	                    eventArguments.preventDefault();
	                }
	            }
	        }

	        // Run the default if not prevented
	        if (defaultFunction && !eventArguments.defaultPrevented) {
	            defaultFunction(eventArguments);
	        }
	    };

	    /**
	     * The global animate method, which uses Fx to create individual animators.
	     */
	    animate = function (el, params, opt) {
	        var start,
	            unit = '',
	            end,
	            fx,
	            args,
	            prop;

	        if (!isObject(opt)) { // Number or undefined/null
	            args = arguments;
	            opt = {
	                duration: args[2],
	                easing: args[3],
	                complete: args[4]
	            };
	        }
	        if (!isNumber(opt.duration)) {
	            opt.duration = 400;
	        }
	        opt.easing = Math[opt.easing] || Math.easeInOutSine;
	        opt.curAnim = merge(params);

	        for (prop in params) {
	            fx = new Fx(el, opt, prop);
	            end = null;

	            if (prop === 'd') {
	                fx.paths = fx.initPath(
	                    el,
	                    el.d,
	                    params.d
	                );
	                fx.toD = params.d;
	                start = 0;
	                end = 1;
	            } else if (el.attr) {
	                start = el.attr(prop);
	            } else {
	                start = parseFloat(getStyle(el, prop)) || 0;
	                if (prop !== 'opacity') {
	                    unit = 'px';
	                }
	            }

	            if (!end) {
	                end = params[prop];
	            }
	            if (end.match && end.match('px')) {
	                end = end.replace(/px/g, ''); // #4351
	            }
	            fx.run(start, end, unit);
	        }
	    };

	    /**
	     * Register Highcharts as a plugin in jQuery
	     */
	    if (win.jQuery) {
	        win.jQuery.fn.highcharts = function () {
	            var args = [].slice.call(arguments);

	            if (this[0]) { // this[0] is the renderTo div

	                // Create the chart
	                if (args[0]) {
	                    new Highcharts[ // eslint-disable-line no-new
	                        isString(args[0]) ? args.shift() : 'Chart' // Constructor defaults to Chart
	                    ](this[0], args[0], args[1]);
	                    return this;
	                }

	                // When called without parameters or with the return argument, return an existing chart
	                return charts[attr(this[0], 'data-highcharts-chart')];
	            }
	        };
	    }


	    /**
	     * Compatibility section to add support for legacy IE. This can be removed if old IE 
	     * support is not needed.
	     */
	    if (doc && !doc.defaultView) {
	        getStyle = function (el, prop) {
	            var val,
	                alias = { width: 'clientWidth', height: 'clientHeight' }[prop];
	            
	            if (el.style[prop]) {
	                return pInt(el.style[prop]);
	            }
	            if (prop === 'opacity') {
	                prop = 'filter';
	            }

	            // Getting the rendered width and height
	            if (alias) {
	                el.style.zoom = 1;
	                return el[alias] - 2 * getStyle(el, 'padding');
	            }
	        
	            val = el.currentStyle[prop.replace(/\-(\w)/g, function (a, b) {
	                return b.toUpperCase();
	            })];
	            if (prop === 'filter') {
	                val = val.replace(
	                    /alpha\(opacity=([0-9]+)\)/, 
	                    function (a, b) { 
	                        return b / 100; 
	                    }
	                );
	            }
	        
	            return val === '' ? 1 : pInt(val);
	        };
	    }

	    if (!Array.prototype.forEach) {
	        each = function (arr, fn) { // legacy
	            var i = 0, 
	                len = arr.length;
	            for (; i < len; i++) {
	                if (fn.call(arr[i], arr[i], i, arr) === false) {
	                    return i;
	                }
	            }
	        };
	    }

	    if (!Array.prototype.indexOf) {
	        inArray = function (item, arr) {
	            var len, 
	                i = 0;

	            if (arr) {
	                len = arr.length;
	            
	                for (; i < len; i++) {
	                    if (arr[i] === item) {
	                        return i;
	                    }
	                }
	            }

	            return -1;
	        };
	    }

	    if (!Array.prototype.filter) {
	        grep = function (elements, fn) {
	            var ret = [],
	                i = 0,
	                length = elements.length;

	            for (; i < length; i++) {
	                if (fn(elements[i], i)) {
	                    ret.push(elements[i]);
	                }
	            }

	            return ret;
	        };
	    }

	    //--- End compatibility section ---

	    // Expose utilities
	    Highcharts.Fx = Fx;
	    Highcharts.inArray = inArray;
	    Highcharts.each = each;
	    Highcharts.grep = grep;
	    Highcharts.offset = offset;
	    Highcharts.map = map;
	    Highcharts.addEvent = addEvent;
	    Highcharts.removeEvent = removeEvent;
	    Highcharts.fireEvent = fireEvent;
	    Highcharts.animate = animate;
	    Highcharts.stop = stop;

	    /* ****************************************************************************
	     * Handle the options                                                         *
	     *****************************************************************************/
	    defaultOptions = {
	        colors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c',
	                '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],
	        symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
	        lang: {
	            loading: 'Loading...',
	            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
	                    'August', 'September', 'October', 'November', 'December'],
	            shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
	            weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
	            // invalidDate: '',
	            decimalPoint: '.',
	            numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels
	            resetZoom: 'Reset zoom',
	            resetZoomTitle: 'Reset zoom level 1:1',
	            thousandsSep: ' '
	        },
	        global: {
	            useUTC: true,
	            //timezoneOffset: 0,
	            canvasToolsURL: 'http://code.highcharts.com/modules/canvas-tools.js',
	            VMLRadialGradientURL: 'http://code.highcharts.com/stock/4.2.3/gfx/vml-radial-gradient.png'
	        },
	        chart: {
	            //animation: true,
	            //alignTicks: false,
	            //reflow: true,
	            //className: null,
	            //events: { load, selection },
	            //margin: [null],
	            //marginTop: null,
	            //marginRight: null,
	            //marginBottom: null,
	            //marginLeft: null,
	            borderColor: '#4572A7',
	            //borderWidth: 0,
	            borderRadius: 0,
	            defaultSeriesType: 'line',
	            ignoreHiddenSeries: true,
	            //inverted: false,
	            //shadow: false,
	            spacing: [10, 10, 15, 10],
	            //spacingTop: 10,
	            //spacingRight: 10,
	            //spacingBottom: 15,
	            //spacingLeft: 10,
	            //style: {
	            //    fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
	            //    fontSize: '12px'
	            //},
	            backgroundColor: '#FFFFFF',
	            //plotBackgroundColor: null,
	            plotBorderColor: '#C0C0C0',
	            //plotBorderWidth: 0,
	            //plotShadow: false,
	            //zoomType: ''
	            resetZoomButton: {
	                theme: {
	                    zIndex: 20
	                },
	                position: {
	                    align: 'right',
	                    x: -10,
	                    //verticalAlign: 'top',
	                    y: 10
	                }
	                // relativeTo: 'plot'
	            }
	        },
	        title: {
	            text: 'Chart title',
	            align: 'center',
	            // floating: false,
	            margin: 15,
	            // x: 0,
	            // verticalAlign: 'top',
	            // y: null,
	            style: {
	                color: '#333333',
	                fontSize: '18px'
	            }

	        },
	        subtitle: {
	            text: '',
	            align: 'center',
	            // floating: false
	            // x: 0,
	            // verticalAlign: 'top',
	            // y: null,
	            style: {
	                color: '#555555'
	            }
	        },

	        plotOptions: {
	            line: { // base series options
	                allowPointSelect: false,
	                showCheckbox: false,
	                animation: {
	                    duration: 1000
	                },
	                //connectNulls: false,
	                //cursor: 'default',
	                //clip: true,
	                //dashStyle: null,
	                //enableMouseTracking: true,
	                events: {},
	                //legendIndex: 0,
	                //linecap: 'round',
	                lineWidth: 2,
	                //shadow: false,
	                // stacking: null,
	                marker: {
	                    //enabled: true,
	                    //symbol: null,
	                    lineWidth: 0,
	                    radius: 4,
	                    lineColor: '#FFFFFF',
	                    //fillColor: null,
	                    states: { // states for a single point
	                        hover: {
	                            enabled: true,
	                            lineWidthPlus: 1,
	                            radiusPlus: 2
	                        },
	                        select: {
	                            fillColor: '#FFFFFF',
	                            lineColor: '#000000',
	                            lineWidth: 2
	                        }
	                    }
	                },
	                point: {
	                    events: {}
	                },
	                dataLabels: {
	                    align: 'center',
	                    // defer: true,
	                    // enabled: false,
	                    formatter: function () {
	                        return this.y === null ? '' : Highcharts.numberFormat(this.y, -1);
	                    },
	                    style: {
	                        color: 'contrast',
	                        fontSize: '11px',
	                        fontWeight: 'bold',
	                        textShadow: '0 0 6px contrast, 0 0 3px contrast'
	                    },
	                    verticalAlign: 'bottom', // above singular point
	                    x: 0,
	                    y: 0,
	                    // backgroundColor: undefined,
	                    // borderColor: undefined,
	                    // borderRadius: undefined,
	                    // borderWidth: undefined,
	                    padding: 5
	                    // shadow: false
	                },
	                cropThreshold: 300, // draw points outside the plot area when the number of points is less than this
	                pointRange: 0,
	                //pointStart: 0,
	                //pointInterval: 1,
	                //showInLegend: null, // auto: true for standalone series, false for linked series
	                softThreshold: true,
	                states: { // states for the entire series
	                    hover: {
	                        //enabled: false,
	                        lineWidthPlus: 1,
	                        marker: {
	                            // lineWidth: base + 1,
	                            // radius: base + 1
	                        },
	                        halo: {
	                            size: 10,
	                            opacity: 0.25
	                        }
	                    },
	                    select: {
	                        marker: {}
	                    }
	                },
	                stickyTracking: true,
	                //tooltip: {
	                    //pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b>'
	                    //valueDecimals: null,
	                    //xDateFormat: '%A, %b %e, %Y',
	                    //valuePrefix: '',
	                    //ySuffix: ''
	                //}
	                turboThreshold: 1000
	                // zIndex: null
	            }
	        },
	        labels: {
	            //items: [],
	            style: {
	                //font: defaultFont,
	                position: ABSOLUTE,
	                color: '#3E576F'
	            }
	        },
	        legend: {
	            enabled: true,
	            align: 'center',
	            //floating: false,
	            layout: 'horizontal',
	            labelFormatter: function () {
	                return this.name;
	            },
	            //borderWidth: 0,
	            borderColor: '#909090',
	            borderRadius: 0,
	            navigation: {
	                // animation: true,
	                activeColor: '#274b6d',
	                // arrowSize: 12
	                inactiveColor: '#CCC'
	                // style: {} // text styles
	            },
	            // margin: 20,
	            // reversed: false,
	            shadow: false,
	            // backgroundColor: null,
	            /*style: {
	                padding: '5px'
	            },*/
	            itemStyle: {
	                color: '#333333',
	                fontSize: '12px',
	                fontWeight: 'bold'
	            },
	            itemHoverStyle: {
	                //cursor: 'pointer', removed as of #601
	                color: '#000'
	            },
	            itemHiddenStyle: {
	                color: '#CCC'
	            },
	            itemCheckboxStyle: {
	                position: ABSOLUTE,
	                width: '13px', // for IE precision
	                height: '13px'
	            },
	            // itemWidth: undefined,
	            // symbolRadius: 0,
	            // symbolWidth: 16,
	            symbolPadding: 5,
	            verticalAlign: 'bottom',
	            // width: undefined,
	            x: 0,
	            y: 0,
	            title: {
	                //text: null,
	                style: {
	                    fontWeight: 'bold'
	                }
	            }
	        },

	        loading: {
	            // hideDuration: 100,
	            labelStyle: {
	                fontWeight: 'bold',
	                position: RELATIVE,
	                top: '45%'
	            },
	            // showDuration: 0,
	            style: {
	                position: ABSOLUTE,
	                backgroundColor: 'white',
	                opacity: 0.5,
	                textAlign: 'center'
	            }
	        },

	        tooltip: {
	            enabled: true,
	            animation: hasSVG,
	            //crosshairs: null,
	            backgroundColor: 'rgba(249, 249, 249, .85)',
	            borderWidth: 1,
	            borderRadius: 3,
	            dateTimeLabelFormats: {
	                millisecond: '%A, %b %e, %H:%M:%S.%L',
	                second: '%A, %b %e, %H:%M:%S',
	                minute: '%A, %b %e, %H:%M',
	                hour: '%A, %b %e, %H:%M',
	                day: '%A, %b %e, %Y',
	                week: 'Week from %A, %b %e, %Y',
	                month: '%B %Y',
	                year: '%Y'
	            },
	            footerFormat: '',
	            //formatter: defaultFormatter,
	            headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
	            pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
	            shadow: true,
	            //shape: 'callout',
	            //shared: false,
	            snap: isTouchDevice ? 25 : 10,
	            style: {
	                color: '#333333',
	                cursor: 'default',
	                fontSize: '12px',
	                padding: '8px',
	                pointerEvents: 'none', // #1686 http://caniuse.com/#feat=pointer-events
	                whiteSpace: 'nowrap'
	            }
	            //xDateFormat: '%A, %b %e, %Y',
	            //valueDecimals: null,
	            //valuePrefix: '',
	            //valueSuffix: ''
	        },

	        credits: {
	            enabled: true,
	            text: 'Highcharts.com',
	            href: 'http://www.highcharts.com',
	            position: {
	                align: 'right',
	                x: -10,
	                verticalAlign: 'bottom',
	                y: -5
	            },
	            style: {
	                cursor: 'pointer',
	                color: '#909090',
	                fontSize: '9px'
	            }
	        }
	    };



	    /**
	     * Set the time methods globally based on the useUTC option. Time method can be either
	     * local time or UTC (default).
	     */
	    function setTimeMethods() {
	        var globalOptions = defaultOptions.global,
	            useUTC = globalOptions.useUTC,
	            GET = useUTC ? 'getUTC' : 'get',
	            SET = useUTC ? 'setUTC' : 'set';


	        Date = globalOptions.Date || win.Date;
	        timezoneOffset = useUTC && globalOptions.timezoneOffset;
	        getTimezoneOffset = useUTC && globalOptions.getTimezoneOffset;
	        makeTime = function (year, month, date, hours, minutes, seconds) {
	            var d;
	            if (useUTC) {
	                d = Date.UTC.apply(0, arguments);
	                d += getTZOffset(d);
	            } else {
	                d = new Date(
	                    year,
	                    month,
	                    pick(date, 1),
	                    pick(hours, 0),
	                    pick(minutes, 0),
	                    pick(seconds, 0)
	                ).getTime();
	            }
	            return d;
	        };
	        getMinutes =      GET + 'Minutes';
	        getHours =        GET + 'Hours';
	        getDay =          GET + 'Day';
	        getDate =         GET + 'Date';
	        getMonth =        GET + 'Month';
	        getFullYear =     GET + 'FullYear';
	        setMilliseconds = SET + 'Milliseconds';
	        setSeconds =      SET + 'Seconds';
	        setMinutes =      SET + 'Minutes';
	        setHours =        SET + 'Hours';
	        setDate =         SET + 'Date';
	        setMonth =        SET + 'Month';
	        setFullYear =     SET + 'FullYear';

	    }

	    /**
	     * Merge the default options with custom options and return the new options structure
	     * @param {Object} options The new custom options
	     */
	    function setOptions(options) {

	        // Copy in the default options
	        defaultOptions = merge(true, defaultOptions, options);

	        // Apply UTC
	        setTimeMethods();

	        return defaultOptions;
	    }

	    /**
	     * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules
	     * wasn't enough because the setOptions method created a new object.
	     */
	    function getOptions() {
	        return defaultOptions;
	    }






	    // Series defaults
	    var defaultPlotOptions = defaultOptions.plotOptions,
	        defaultSeriesOptions = defaultPlotOptions.line;

	    // set the default time methods
	    setTimeMethods();


	    /**
	     * Handle color operations. The object methods are chainable.
	     * @param {String} input The input color in either rbga or hex format
	     */
	    function Color(input) {
	        // Backwards compatibility, allow instanciation without new
	        if (!(this instanceof Color)) {
	            return new Color(input);
	        }
	        // Initialize
	        this.init(input);
	    }
	    Color.prototype = {

	        // Collection of parsers. This can be extended from the outside by pushing parsers
	        // to Highcharts.Colors.prototype.parsers.
	        parsers: [{
	            // RGBA color
	            regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
	            parse: function (result) {
	                return [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
	            }
	        }, {
	            // HEX color
	            regex: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
	            parse: function (result) {
	                return [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
	            }
	        }, {
	            // RGB color
	            regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
	            parse: function (result) {
	                return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
	            }
	        }],

	        /**
	         * Parse the input color to rgba array
	         * @param {String} input
	         */
	        init: function (input) {
	            var result,
	                rgba,
	                i,
	                parser;

	            this.input = input;

	            // Gradients
	            if (input && input.stops) {
	                this.stops = map(input.stops, function (stop) {
	                    return new Color(stop[1]);
	                });

	            // Solid colors
	            } else {
	                i = this.parsers.length;
	                while (i-- && !rgba) {
	                    parser = this.parsers[i];
	                    result = parser.regex.exec(input);
	                    if (result) {
	                        rgba = parser.parse(result);
	                    }
	                }
	            }
	            this.rgba = rgba || [];
	        },

	        /**
	         * Return the color a specified format
	         * @param {String} format
	         */
	        get: function (format) {
	            var input = this.input,
	                rgba = this.rgba,
	                ret;

	            if (this.stops) {
	                ret = merge(input);
	                ret.stops = [].concat(ret.stops);
	                each(this.stops, function (stop, i) {
	                    ret.stops[i] = [ret.stops[i][0], stop.get(format)];
	                });

	            // it's NaN if gradient colors on a column chart
	            } else if (rgba && !isNaN(rgba[0])) {
	                if (format === 'rgb' || (!format && rgba[3] === 1)) {
	                    ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
	                } else if (format === 'a') {
	                    ret = rgba[3];
	                } else {
	                    ret = 'rgba(' + rgba.join(',') + ')';
	                }
	            } else {
	                ret = input;
	            }
	            return ret;
	        },

	        /**
	         * Brighten the color
	         * @param {Number} alpha
	         */
	        brighten: function (alpha) {
	            var i, 
	                rgba = this.rgba;

	            if (this.stops) {
	                each(this.stops, function (stop) {
	                    stop.brighten(alpha);
	                });

	            } else if (isNumber(alpha) && alpha !== 0) {
	                for (i = 0; i < 3; i++) {
	                    rgba[i] += pInt(alpha * 255);

	                    if (rgba[i] < 0) {
	                        rgba[i] = 0;
	                    }
	                    if (rgba[i] > 255) {
	                        rgba[i] = 255;
	                    }
	                }
	            }
	            return this;
	        },

	        /**
	         * Set the color's opacity to a given alpha value
	         * @param {Number} alpha
	         */
	        setOpacity: function (alpha) {
	            this.rgba[3] = alpha;
	            return this;
	        }
	    };


	    /**
	     * A wrapper object for SVG elements
	     */
	    function SVGElement() {}

	    SVGElement.prototype = {

	        // Default base for animation
	        opacity: 1,
	        // For labels, these CSS properties are applied to the <text> node directly
	        textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily', 'fontStyle', 'color',
	            'lineHeight', 'width', 'textDecoration', 'textOverflow', 'textShadow'],

	        /**
	         * Initialize the SVG renderer
	         * @param {Object} renderer
	         * @param {String} nodeName
	         */
	        init: function (renderer, nodeName) {
	            var wrapper = this;
	            wrapper.element = nodeName === 'span' ?
	                    createElement(nodeName) :
	                    doc.createElementNS(SVG_NS, nodeName);
	            wrapper.renderer = renderer;
	        },

	        /**
	         * Animate a given attribute
	         * @param {Object} params
	         * @param {Number} options Options include duration, easing, step and complete
	         * @param {Function} complete Function to perform at the end of animation
	         */
	        animate: function (params, options, complete) {
	            var animOptions = pick(options, this.renderer.globalAnimation, true);
	            stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)
	            if (animOptions) {
	                animOptions = merge(animOptions, {}); //#2625
	                if (complete) { // allows using a callback with the global animation without overwriting it
	                    animOptions.complete = complete;
	                }
	                animate(this, params, animOptions);
	            } else {
	                this.attr(params, null, complete);
	            }
	            return this;
	        },

	        /**
	         * Build an SVG gradient out of a common JavaScript configuration object
	         */
	        colorGradient: function (color, prop, elem) {
	            var renderer = this.renderer,
	                colorObject,
	                gradName,
	                gradAttr,
	                radAttr,
	                gradients,
	                gradientObject,
	                stops,
	                stopColor,
	                stopOpacity,
	                radialReference,
	                n,
	                id,
	                key = [],
	                value;

	            // Apply linear or radial gradients
	            if (color.linearGradient) {
	                gradName = 'linearGradient';
	            } else if (color.radialGradient) {
	                gradName = 'radialGradient';
	            }

	            if (gradName) {
	                gradAttr = color[gradName];
	                gradients = renderer.gradients;
	                stops = color.stops;
	                radialReference = elem.radialReference;

	                // Keep < 2.2 kompatibility
	                if (isArray(gradAttr)) {
	                    color[gradName] = gradAttr = {
	                        x1: gradAttr[0],
	                        y1: gradAttr[1],
	                        x2: gradAttr[2],
	                        y2: gradAttr[3],
	                        gradientUnits: 'userSpaceOnUse'
	                    };
	                }

	                // Correct the radial gradient for the radial reference system
	                if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {
	                    radAttr = gradAttr; // Save the radial attributes for updating
	                    gradAttr = merge(gradAttr,
	                        renderer.getRadialAttr(radialReference, radAttr),
	                        { gradientUnits: 'userSpaceOnUse' }
	                        );
	                }

	                // Build the unique key to detect whether we need to create a new element (#1282)
	                for (n in gradAttr) {
	                    if (n !== 'id') {
	                        key.push(n, gradAttr[n]);
	                    }
	                }
	                for (n in stops) {
	                    key.push(stops[n]);
	                }
	                key = key.join(',');

	                // Check if a gradient object with the same config object is created within this renderer
	                if (gradients[key]) {
	                    id = gradients[key].attr('id');

	                } else {

	                    // Set the id and create the element
	                    gradAttr.id = id = PREFIX + idCounter++;
	                    gradients[key] = gradientObject = renderer.createElement(gradName)
	                        .attr(gradAttr)
	                        .add(renderer.defs);

	                    gradientObject.radAttr = radAttr;

	                    // The gradient needs to keep a list of stops to be able to destroy them
	                    gradientObject.stops = [];
	                    each(stops, function (stop) {
	                        var stopObject;
	                        if (stop[1].indexOf('rgba') === 0) {
	                            colorObject = Color(stop[1]);
	                            stopColor = colorObject.get('rgb');
	                            stopOpacity = colorObject.get('a');
	                        } else {
	                            stopColor = stop[1];
	                            stopOpacity = 1;
	                        }
	                        stopObject = renderer.createElement('stop').attr({
	                            offset: stop[0],
	                            'stop-color': stopColor,
	                            'stop-opacity': stopOpacity
	                        }).add(gradientObject);

	                        // Add the stop element to the gradient
	                        gradientObject.stops.push(stopObject);
	                    });
	                }

	                // Set the reference to the gradient object
	                value = 'url(' + renderer.url + '#' + id + ')';
	                elem.setAttribute(prop, value);
	                elem.gradient = key;

	                // Allow the color to be concatenated into tooltips formatters etc. (#2995)
	                color.toString = function () {
	                    return value;
	                };
	            }
	        },

	        /**
	         * Apply a polyfill to the text-stroke CSS property, by copying the text element
	         * and apply strokes to the copy.
	         *
	         * Contrast checks at http://jsfiddle.net/highcharts/43soe9m1/2/
	         */
	        applyTextShadow: function (textShadow) {
	            var elem = this.element,
	                tspans,
	                hasContrast = textShadow.indexOf('contrast') !== -1,
	                styles = {},
	                forExport = this.renderer.forExport,
	                // IE10 and IE11 report textShadow in elem.style even though it doesn't work. Check
	                // this again with new IE release. In exports, the rendering is passed to PhantomJS.
	                supports = forExport || (elem.style.textShadow !== UNDEFINED && !isMS);

	            // When the text shadow is set to contrast, use dark stroke for light text and vice versa
	            if (hasContrast) {
	                styles.textShadow = textShadow = textShadow.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
	            }

	            // Safari with retina displays as well as PhantomJS bug (#3974). Firefox does not tolerate this,
	            // it removes the text shadows.
	            if (isWebKit || forExport) {
	                styles.textRendering = 'geometricPrecision';
	            }

	            /* Selective side-by-side testing in supported browser (http://jsfiddle.net/highcharts/73L1ptrh/)
	            if (elem.textContent.indexOf('2.') === 0) {
	                elem.style['text-shadow'] = 'none';
	                supports = false;
	            }
	            // */

	            // No reason to polyfill, we've got native support
	            if (supports) {
	                this.css(styles); // Apply altered textShadow or textRendering workaround
	            } else {

	                this.fakeTS = true; // Fake text shadow

	                // In order to get the right y position of the clones,
	                // copy over the y setter
	                this.ySetter = this.xSetter;

	                tspans = [].slice.call(elem.getElementsByTagName('tspan'));
	                each(textShadow.split(/\s?,\s?/g), function (textShadow) {
	                    var firstChild = elem.firstChild,
	                        color,
	                        strokeWidth;

	                    textShadow = textShadow.split(' ');
	                    color = textShadow[textShadow.length - 1];

	                    // Approximately tune the settings to the text-shadow behaviour
	                    strokeWidth = textShadow[textShadow.length - 2];

	                    if (strokeWidth) {
	                        each(tspans, function (tspan, y) {
	                            var clone;

	                            // Let the first line start at the correct X position
	                            if (y === 0) {
	                                tspan.setAttribute('x', elem.getAttribute('x'));
	                                y = elem.getAttribute('y');
	                                tspan.setAttribute('y', y || 0);
	                                if (y === null) {
	                                    elem.setAttribute('y', 0);
	                                }
	                            }

	                            // Create the clone and apply shadow properties
	                            clone = tspan.cloneNode(1);
	                            attr(clone, {
	                                'class': PREFIX + 'text-shadow',
	                                'fill': color,
	                                'stroke': color,
	                                'stroke-opacity': 1 / mathMax(pInt(strokeWidth), 3),
	                                'stroke-width': strokeWidth,
	                                'stroke-linejoin': 'round'
	                            });
	                            elem.insertBefore(clone, firstChild);
	                        });
	                    }
	                });
	            }
	        },

	        /**
	         * Set or get a given attribute
	         * @param {Object|String} hash
	         * @param {Mixed|Undefined} val
	         */
	        attr: function (hash, val, complete) {
	            var key,
	                value,
	                element = this.element,
	                hasSetSymbolSize,
	                ret = this,
	                skipAttr,
	                setter;

	            // single key-value pair
	            if (typeof hash === 'string' && val !== UNDEFINED) {
	                key = hash;
	                hash = {};
	                hash[key] = val;
	            }

	            // used as a getter: first argument is a string, second is undefined
	            if (typeof hash === 'string') {
	                ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);

	            // setter
	            } else {

	                for (key in hash) {
	                    value = hash[key];
	                    skipAttr = false;



	                    if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {
	                        if (!hasSetSymbolSize) {
	                            this.symbolAttr(hash);
	                            hasSetSymbolSize = true;
	                        }
	                        skipAttr = true;
	                    }

	                    if (this.rotation && (key === 'x' || key === 'y')) {
	                        this.doTransform = true;
	                    }

	                    if (!skipAttr) {
	                        setter = this[key + 'Setter'] || this._defaultSetter;
	                        setter.call(this, value, key, element);

	                        // Let the shadow follow the main element
	                        if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {
	                            this.updateShadows(key, value, setter);
	                        }
	                    }
	                }

	                // Update transform. Do this outside the loop to prevent redundant updating for batch setting
	                // of attributes.
	                if (this.doTransform) {
	                    this.updateTransform();
	                    this.doTransform = false;
	                }

	            }

	            // In accordance with animate, run a complete callback
	            if (complete) {
	                complete();
	            }

	            return ret;
	        },

	        /**
	         * Update the shadow elements with new attributes
	         * @param   {String}        key    The attribute name
	         * @param   {String|Number} value  The value of the attribute
	         * @param   {Function}      setter The setter function, inherited from the parent wrapper
	         * @returns {undefined}
	         */
	        updateShadows: function (key, value, setter) {
	            var shadows = this.shadows,
	                i = shadows.length;

	            while (i--) {
	                setter.call(
	                    null, 
	                    key === 'height' ?
	                        Math.max(value - (shadows[i].cutHeight || 0), 0) :
	                        key === 'd' ? this.d : value, 
	                    key, 
	                    shadows[i]
	                );
	            }
	        },

	        /**
	         * Add a class name to an element
	         */
	        addClass: function (className) {
	            var element = this.element,
	                currentClassName = attr(element, 'class') || '';

	            if (currentClassName.indexOf(className) === -1) {
	                attr(element, 'class', currentClassName + ' ' + className);
	            }
	            return this;
	        },
	        /* hasClass and removeClass are not (yet) needed
	        hasClass: function (className) {
	            return attr(this.element, 'class').indexOf(className) !== -1;
	        },
	        removeClass: function (className) {
	            attr(this.element, 'class', attr(this.element, 'class').replace(className, ''));
	            return this;
	        },
	        */

	        /**
	         * If one of the symbol size affecting parameters are changed,
	         * check all the others only once for each call to an element's
	         * .attr() method
	         * @param {Object} hash
	         */
	        symbolAttr: function (hash) {
	            var wrapper = this;

	            each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {
	                wrapper[key] = pick(hash[key], wrapper[key]);
	            });

	            wrapper.attr({
	                d: wrapper.renderer.symbols[wrapper.symbolName](
	                    wrapper.x,
	                    wrapper.y,
	                    wrapper.width,
	                    wrapper.height,
	                    wrapper
	                )
	            });
	        },

	        /**
	         * Apply a clipping path to this object
	         * @param {String} id
	         */
	        clip: function (clipRect) {
	            return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);
	        },

	        /**
	         * Calculate the coordinates needed for drawing a rectangle crisply and return the
	         * calculated attributes
	         * @param {Number} strokeWidth
	         * @param {Number} x
	         * @param {Number} y
	         * @param {Number} width
	         * @param {Number} height
	         */
	        crisp: function (rect) {

	            var wrapper = this,
	                key,
	                attribs = {},
	                normalizer,
	                strokeWidth = wrapper.strokeWidth || 0;

	            normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors

	            // normalize for crisp edges
	            rect.x = mathFloor(rect.x || wrapper.x || 0) + normalizer;
	            rect.y = mathFloor(rect.y || wrapper.y || 0) + normalizer;
	            rect.width = mathFloor((rect.width || wrapper.width || 0) - 2 * normalizer);
	            rect.height = mathFloor((rect.height || wrapper.height || 0) - 2 * normalizer);
	            rect.strokeWidth = strokeWidth;

	            for (key in rect) {
	                if (wrapper[key] !== rect[key]) { // only set attribute if changed
	                    wrapper[key] = attribs[key] = rect[key];
	                }
	            }

	            return attribs;
	        },

	        /**
	         * Set styles for the element
	         * @param {Object} styles
	         */
	        css: function (styles) {
	            var elemWrapper = this,
	                oldStyles = elemWrapper.styles,
	                newStyles = {},
	                elem = elemWrapper.element,
	                textWidth,
	                n,
	                serializedCss = '',
	                hyphenate,
	                hasNew = !oldStyles;

	            // convert legacy
	            if (styles && styles.color) {
	                styles.fill = styles.color;
	            }

	            // Filter out existing styles to increase performance (#2640)
	            if (oldStyles) {
	                for (n in styles) {
	                    if (styles[n] !== oldStyles[n]) {
	                        newStyles[n] = styles[n];
	                        hasNew = true;
	                    }
	                }
	            }
	            if (hasNew) {
	                textWidth = elemWrapper.textWidth =
	                    (styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) ||
	                    elemWrapper.textWidth; // #3501

	                // Merge the new styles with the old ones
	                if (oldStyles) {
	                    styles = extend(
	                        oldStyles,
	                        newStyles
	                    );
	                }

	                // store object
	                elemWrapper.styles = styles;

	                if (textWidth && (useCanVG || (!hasSVG && elemWrapper.renderer.forExport))) {
	                    delete styles.width;
	                }

	                // serialize and set style attribute
	                if (isMS && !hasSVG) {
	                    css(elemWrapper.element, styles);
	                } else {
	                    hyphenate = function (a, b) {
	                        return '-' + b.toLowerCase();
	                    };
	                    for (n in styles) {
	                        serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';
	                    }
	                    attr(elem, 'style', serializedCss); // #1881
	                }


	                // re-build text
	                if (textWidth && elemWrapper.added) {
	                    elemWrapper.renderer.buildText(elemWrapper);
	                }
	            }

	            return elemWrapper;
	        },

	        /**
	         * Add an event listener
	         * @param {String} eventType
	         * @param {Function} handler
	         */
	        on: function (eventType, handler) {
	            var svgElement = this,
	                element = svgElement.element;

	            // touch
	            if (hasTouch && eventType === 'click') {
	                element.ontouchstart = function (e) {
	                    svgElement.touchEventFired = Date.now();
	                    e.preventDefault();
	                    handler.call(element, e);
	                };
	                element.onclick = function (e) {
	                    if (userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269
	                        handler.call(element, e);
	                    }
	                };
	            } else {
	                // simplest possible event model for internal use
	                element['on' + eventType] = handler;
	            }
	            return this;
	        },

	        /**
	         * Set the coordinates needed to draw a consistent radial gradient across
	         * pie slices regardless of positioning inside the chart. The format is
	         * [centerX, centerY, diameter] in pixels.
	         */
	        setRadialReference: function (coordinates) {
	            var existingGradient = this.renderer.gradients[this.element.gradient];

	            this.element.radialReference = coordinates;

	            // On redrawing objects with an existing gradient, the gradient needs
	            // to be repositioned (#3801)
	            if (existingGradient && existingGradient.radAttr) {
	                existingGradient.animate(
	                    this.renderer.getRadialAttr(
	                        coordinates,
	                        existingGradient.radAttr
	                    )
	                );
	            }

	            return this;
	        },

	        /**
	         * Move an object and its children by x and y values
	         * @param {Number} x
	         * @param {Number} y
	         */
	        translate: function (x, y) {
	            return this.attr({
	                translateX: x,
	                translateY: y
	            });
	        },

	        /**
	         * Invert a group, rotate and flip
	         */
	        invert: function () {
	            var wrapper = this;
	            wrapper.inverted = true;
	            wrapper.updateTransform();
	            return wrapper;
	        },

	        /**
	         * Private method to update the transform attribute based on internal
	         * properties
	         */
	        updateTransform: function () {
	            var wrapper = this,
	                translateX = wrapper.translateX || 0,
	                translateY = wrapper.translateY || 0,
	                scaleX = wrapper.scaleX,
	                scaleY = wrapper.scaleY,
	                inverted = wrapper.inverted,
	                rotation = wrapper.rotation,
	                element = wrapper.element,
	                transform;

	            // flipping affects translate as adjustment for flipping around the group's axis
	            if (inverted) {
	                translateX += wrapper.attr('width');
	                translateY += wrapper.attr('height');
	            }

	            // Apply translate. Nearly all transformed elements have translation, so instead
	            // of checking for translate = 0, do it always (#1767, #1846).
	            transform = ['translate(' + translateX + ',' + translateY + ')'];

	            // apply rotation
	            if (inverted) {
	                transform.push('rotate(90) scale(-1,1)');
	            } else if (rotation) { // text rotation
	                transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');

	                // Delete bBox memo when the rotation changes
	                //delete wrapper.bBox;
	            }

	            // apply scale
	            if (defined(scaleX) || defined(scaleY)) {
	                transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');
	            }

	            if (transform.length) {
	                element.setAttribute('transform', transform.join(' '));
	            }
	        },
	        /**
	         * Bring the element to the front
	         */
	        toFront: function () {
	            var element = this.element;
	            element.parentNode.appendChild(element);
	            return this;
	        },


	        /**
	         * Break down alignment options like align, verticalAlign, x and y
	         * to x and y relative to the chart.
	         *
	         * @param {Object} alignOptions
	         * @param {Boolean} alignByTranslate
	         * @param {String[Object} box The box to align to, needs a width and height. When the
	         *        box is a string, it refers to an object in the Renderer. For example, when
	         *        box is 'spacingBox', it refers to Renderer.spacingBox which holds width, height
	         *        x and y properties.
	         *
	         */
	        align: function (alignOptions, alignByTranslate, box) {
	            var align,
	                vAlign,
	                x,
	                y,
	                attribs = {},
	                alignTo,
	                renderer = this.renderer,
	                alignedObjects = renderer.alignedObjects;

	            // First call on instanciate
	            if (alignOptions) {
	                this.alignOptions = alignOptions;
	                this.alignByTranslate = alignByTranslate;
	                if (!box || isString(box)) { // boxes other than renderer handle this internally
	                    this.alignTo = alignTo = box || 'renderer';
	                    erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize
	                    alignedObjects.push(this);
	                    box = null; // reassign it below
	                }

	            // When called on resize, no arguments are supplied
	            } else {
	                alignOptions = this.alignOptions;
	                alignByTranslate = this.alignByTranslate;
	                alignTo = this.alignTo;
	            }

	            box = pick(box, renderer[alignTo], renderer);

	            // Assign variables
	            align = alignOptions.align;
	            vAlign = alignOptions.verticalAlign;
	            x = (box.x || 0) + (alignOptions.x || 0); // default: left align
	            y = (box.y || 0) + (alignOptions.y || 0); // default: top align

	            // Align
	            if (align === 'right' || align === 'center') {
	                x += (box.width - (alignOptions.width || 0)) /
	                        { right: 1, center: 2 }[align];
	            }
	            attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);


	            // Vertical align
	            if (vAlign === 'bottom' || vAlign === 'middle') {
	                y += (box.height - (alignOptions.height || 0)) /
	                        ({ bottom: 1, middle: 2 }[vAlign] || 1);

	            }
	            attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);

	            // Animate only if already placed
	            this[this.placed ? 'animate' : 'attr'](attribs);
	            this.placed = true;
	            this.alignAttr = attribs;

	            return this;
	        },

	        /**
	         * Get the bounding box (width, height, x and y) for the element
	         */
	        getBBox: function (reload, rot) {
	            var wrapper = this,
	                bBox, // = wrapper.bBox,
	                renderer = wrapper.renderer,
	                width,
	                height,
	                rotation,
	                rad,
	                element = wrapper.element,
	                styles = wrapper.styles,
	                textStr = wrapper.textStr,
	                textShadow,
	                elemStyle = element.style,
	                toggleTextShadowShim,
	                cache = renderer.cache,
	                cacheKeys = renderer.cacheKeys,
	                cacheKey;

	            rotation = pick(rot, wrapper.rotation);
	            rad = rotation * deg2rad;

	            if (textStr !== UNDEFINED) {

	                // Properties that affect bounding box
	                cacheKey = ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');

	                // Since numbers are monospaced, and numerical labels appear a lot in a chart,
	                // we assume that a label of n characters has the same bounding box as others
	                // of the same length.
	                if (textStr === '' || numRegex.test(textStr)) {
	                    cacheKey = 'num:' + textStr.toString().length + cacheKey;

	                // Caching all strings reduces rendering time by 4-5%.
	                } else {
	                    cacheKey = textStr + cacheKey;
	                }
	            }

	            if (cacheKey && !reload) {
	                bBox = cache[cacheKey];
	            }

	            // No cache found
	            if (!bBox) {

	                // SVG elements
	                if (element.namespaceURI === SVG_NS || renderer.forExport) {
	                    try { // Fails in Firefox if the container has display: none.

	                        // When the text shadow shim is used, we need to hide the fake shadows
	                        // to get the correct bounding box (#3872)
	                        toggleTextShadowShim = this.fakeTS && function (display) {
	                            each(element.querySelectorAll('.' + PREFIX + 'text-shadow'), function (tspan) {
	                                tspan.style.display = display;
	                            });
	                        };

	                        // Workaround for #3842, Firefox reporting wrong bounding box for shadows
	                        if (isFirefox && elemStyle.textShadow) {
	                            textShadow = elemStyle.textShadow;
	                            elemStyle.textShadow = '';
	                        } else if (toggleTextShadowShim) {
	                            toggleTextShadowShim(NONE);
	                        }

	                        bBox = element.getBBox ?
	                            // SVG: use extend because IE9 is not allowed to change width and height in case
	                            // of rotation (below)
	                            extend({}, element.getBBox()) :
	                            // Canvas renderer and legacy IE in export mode
	                            {
	                                width: element.offsetWidth,
	                                height: element.offsetHeight
	                            };

	                        // #3842
	                        if (textShadow) {
	                            elemStyle.textShadow = textShadow;
	                        } else if (toggleTextShadowShim) {
	                            toggleTextShadowShim('');
	                        }
	                    } catch (e) {}

	                    // If the bBox is not set, the try-catch block above failed. The other condition
	                    // is for Opera that returns a width of -Infinity on hidden elements.
	                    if (!bBox || bBox.width < 0) {
	                        bBox = { width: 0, height: 0 };
	                    }


	                // VML Renderer or useHTML within SVG
	                } else {

	                    bBox = wrapper.htmlGetBBox();

	                }

	                // True SVG elements as well as HTML elements in modern browsers using the .useHTML option
	                // need to compensated for rotation
	                if (renderer.isSVG) {
	                    width = bBox.width;
	                    height = bBox.height;

	                    // Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)
	                    if (isMS && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {
	                        bBox.height = height = 14;
	                    }

	                    // Adjust for rotated text
	                    if (rotation) {
	                        bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
	                        bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
	                    }
	                }

	                // Cache it
	                if (cacheKey) {

	                    // Rotate (#4681)
	                    while (cacheKeys.length > 250) {
	                        delete cache[cacheKeys.shift()];
	                    }

	                    if (!cache[cacheKey]) {
	                        cacheKeys.push(cacheKey);
	                    }
	                    cache[cacheKey] = bBox;
	                }
	            }
	            return bBox;
	        },

	        /**
	         * Show the element
	         */
	        show: function (inherit) {
	            return this.attr({ visibility: inherit ? 'inherit' : VISIBLE });
	        },

	        /**
	         * Hide the element
	         */
	        hide: function () {
	            return this.attr({ visibility: HIDDEN });
	        },

	        fadeOut: function (duration) {
	            var elemWrapper = this;
	            elemWrapper.animate({
	                opacity: 0
	            }, {
	                duration: duration || 150,
	                complete: function () {
	                    elemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips
	                }
	            });
	        },

	        /**
	         * Add the element
	         * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
	         *    to append the element to the renderer.box.
	         */
	        add: function (parent) {

	            var renderer = this.renderer,
	                element = this.element,
	                inserted;

	            if (parent) {
	                this.parentGroup = parent;
	            }

	            // mark as inverted
	            this.parentInverted = parent && parent.inverted;

	            // build formatted text
	            if (this.textStr !== undefined) {
	                renderer.buildText(this);
	            }

	            // Mark as added
	            this.added = true;

	            // If we're adding to renderer root, or other elements in the group
	            // have a z index, we need to handle it
	            if (!parent || parent.handleZ || this.zIndex) {
	                inserted = this.zIndexSetter();
	            }

	            // If zIndex is not handled, append at the end
	            if (!inserted) {
	                (parent ? parent.element : renderer.box).appendChild(element);
	            }

	            // fire an event for internal hooks
	            if (this.onAdd) {
	                this.onAdd();
	            }

	            return this;
	        },

	        /**
	         * Removes a child either by removeChild or move to garbageBin.
	         * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
	         */
	        safeRemoveChild: function (element) {
	            var parentNode = element.parentNode;
	            if (parentNode) {
	                parentNode.removeChild(element);
	            }
	        },

	        /**
	         * Destroy the element and element wrapper
	         */
	        destroy: function () {
	            var wrapper = this,
	                element = wrapper.element || {},
	                shadows = wrapper.shadows,
	                parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,
	                grandParent,
	                key,
	                i;

	            // remove events
	            element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
	            stop(wrapper); // stop running animations

	            if (wrapper.clipPath) {
	                wrapper.clipPath = wrapper.clipPath.destroy();
	            }

	            // Destroy stops in case this is a gradient object
	            if (wrapper.stops) {
	                for (i = 0; i < wrapper.stops.length; i++) {
	                    wrapper.stops[i] = wrapper.stops[i].destroy();
	                }
	                wrapper.stops = null;
	            }

	            // remove element
	            wrapper.safeRemoveChild(element);

	            // destroy shadows
	            if (shadows) {
	                each(shadows, function (shadow) {
	                    wrapper.safeRemoveChild(shadow);
	                });
	            }

	            // In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).
	            while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
	                grandParent = parentToClean.parentGroup;
	                wrapper.safeRemoveChild(parentToClean.div);
	                delete parentToClean.div;
	                parentToClean = grandParent;
	            }

	            // remove from alignObjects
	            if (wrapper.alignTo) {
	                erase(wrapper.renderer.alignedObjects, wrapper);
	            }

	            for (key in wrapper) {
	                delete wrapper[key];
	            }

	            return null;
	        },

	        /**
	         * Add a shadow to the element. Must be done after the element is added to the DOM
	         * @param {Boolean|Object} shadowOptions
	         */
	        shadow: function (shadowOptions, group, cutOff) {
	            var shadows = [],
	                i,
	                shadow,
	                element = this.element,
	                strokeWidth,
	                shadowWidth,
	                shadowElementOpacity,

	                // compensate for inverted plot area
	                transform;


	            if (shadowOptions) {
	                shadowWidth = pick(shadowOptions.width, 3);
	                shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
	                transform = this.parentInverted ?
	                        '(-1,-1)' :
	                        '(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';
	                for (i = 1; i <= shadowWidth; i++) {
	                    shadow = element.cloneNode(0);
	                    strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
	                    attr(shadow, {
	                        'isShadow': 'true',
	                        'stroke': shadowOptions.color || 'black',
	                        'stroke-opacity': shadowElementOpacity * i,
	                        'stroke-width': strokeWidth,
	                        'transform': 'translate' + transform,
	                        'fill': NONE
	                    });
	                    if (cutOff) {
	                        attr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));
	                        shadow.cutHeight = strokeWidth;
	                    }

	                    if (group) {
	                        group.element.appendChild(shadow);
	                    } else {
	                        element.parentNode.insertBefore(shadow, element);
	                    }

	                    shadows.push(shadow);
	                }

	                this.shadows = shadows;
	            }
	            return this;

	        },

	        xGetter: function (key) {
	            if (this.element.nodeName === 'circle') {
	                key = { x: 'cx', y: 'cy' }[key] || key;
	            }
	            return this._defaultGetter(key);
	        },

	        /**
	         * Get the current value of an attribute or pseudo attribute, used mainly
	         * for animation.
	         */
	        _defaultGetter: function (key) {
	            var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);

	            if (/^[\-0-9\.]+$/.test(ret)) { // is numerical
	                ret = parseFloat(ret);
	            }
	            return ret;
	        },


	        dSetter: function (value, key, element) {
	            if (value && value.join) { // join path
	                value = value.join(' ');
	            }
	            if (/(NaN| {2}|^$)/.test(value)) {
	                value = 'M 0 0';
	            }
	            element.setAttribute(key, value);

	            this[key] = value;
	        },
	        dashstyleSetter: function (value) {
	            var i;
	            value = value && value.toLowerCase();
	            if (value) {
	                value = value
	                    .replace('shortdashdotdot', '3,1,1,1,1,1,')
	                    .replace('shortdashdot', '3,1,1,1')
	                    .replace('shortdot', '1,1,')
	                    .replace('shortdash', '3,1,')
	                    .replace('longdash', '8,3,')
	                    .replace(/dot/g, '1,3,')
	                    .replace('dash', '4,3,')
	                    .replace(/,$/, '')
	                    .split(','); // ending comma

	                i = value.length;
	                while (i--) {
	                    value[i] = pInt(value[i]) * this['stroke-width'];
	                }
	                value = value.join(',')
	                    .replace('NaN', 'none'); // #3226
	                this.element.setAttribute('stroke-dasharray', value);
	            }
	        },
	        alignSetter: function (value) {
	            this.element.setAttribute('text-anchor', { left: 'start', center: 'middle', right: 'end' }[value]);
	        },
	        opacitySetter: function (value, key, element) {
	            this[key] = value;
	            element.setAttribute(key, value);
	        },
	        titleSetter: function (value) {
	            var titleNode = this.element.getElementsByTagName('title')[0];
	            if (!titleNode) {
	                titleNode = doc.createElementNS(SVG_NS, 'title');
	                this.element.appendChild(titleNode);
	            }
	            titleNode.appendChild(
	                doc.createTextNode(
	                    (String(pick(value), '')).replace(/<[^>]*>/g, '') // #3276, #3895
	                )
	            );
	        },
	        textSetter: function (value) {
	            if (value !== this.textStr) {
	                // Delete bBox memo when the text changes
	                delete this.bBox;

	                this.textStr = value;
	                if (this.added) {
	                    this.renderer.buildText(this);
	                }
	            }
	        },
	        fillSetter: function (value, key, element) {
	            if (typeof value === 'string') {
	                element.setAttribute(key, value);
	            } else if (value) {
	                this.colorGradient(value, key, element);
	            }
	        },
	        visibilitySetter: function (value, key, element) {
	            // IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881, #3909)
	            if (value === 'inherit') {
	                element.removeAttribute(key);
	            } else {
	                element.setAttribute(key, value);
	            }
	        },
	        zIndexSetter: function (value, key) {
	            var renderer = this.renderer,
	                parentGroup = this.parentGroup,
	                parentWrapper = parentGroup || renderer,
	                parentNode = parentWrapper.element || renderer.box,
	                childNodes,
	                otherElement,
	                otherZIndex,
	                element = this.element,
	                inserted,
	                run = this.added,
	                i;

	            if (defined(value)) {
	                element.setAttribute(key, value); // So we can read it for other elements in the group
	                value = +value;
	                if (this[key] === value) { // Only update when needed (#3865)
	                    run = false;
	                }
	                this[key] = value;
	            }

	            // Insert according to this and other elements' zIndex. Before .add() is called,
	            // nothing is done. Then on add, or by later calls to zIndexSetter, the node
	            // is placed on the right place in the DOM.
	            if (run) {
	                value = this.zIndex;

	                if (value && parentGroup) {
	                    parentGroup.handleZ = true;
	                }

	                childNodes = parentNode.childNodes;
	                for (i = 0; i < childNodes.length && !inserted; i++) {
	                    otherElement = childNodes[i];
	                    otherZIndex = attr(otherElement, 'zIndex');
	                    if (otherElement !== element && (
	                            // Insert before the first element with a higher zIndex
	                            pInt(otherZIndex) > value ||
	                            // If no zIndex given, insert before the first element with a zIndex
	                            (!defined(value) && defined(otherZIndex))

	                        )) {
	                        parentNode.insertBefore(element, otherElement);
	                        inserted = true;
	                    }
	                }
	                if (!inserted) {
	                    parentNode.appendChild(element);
	                }
	            }
	            return inserted;
	        },
	        _defaultSetter: function (value, key, element) {
	            element.setAttribute(key, value);
	        }
	    };

	    // Some shared setters and getters
	    SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
	    SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter =
	            SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter =
	            SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {
	                this[key] = value;
	                this.doTransform = true;
	            };

	    // WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the
	    // stroke attribute altogether. #1270, #1369, #3065, #3072.
	    SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {
	        this[key] = value;
	        // Only apply the stroke attribute if the stroke width is defined and larger than 0
	        if (this.stroke && this['stroke-width']) {
	            this.strokeWidth = this['stroke-width'];
	            SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden
	            element.setAttribute('stroke-width', this['stroke-width']);
	            this.hasStroke = true;
	        } else if (key === 'stroke-width' && value === 0 && this.hasStroke) {
	            element.removeAttribute('stroke');
	            this.hasStroke = false;
	        }
	    };


	    /**
	     * The default SVG renderer
	     */
	    var SVGRenderer = function () {
	        this.init.apply(this, arguments);
	    };
	    SVGRenderer.prototype = {
	        Element: SVGElement,

	        /**
	         * Initialize the SVGRenderer
	         * @param {Object} container
	         * @param {Number} width
	         * @param {Number} height
	         * @param {Boolean} forExport
	         */
	        init: function (container, width, height, style, forExport, allowHTML) {
	            var renderer = this,
	                boxWrapper,
	                element,
	                desc;

	            boxWrapper = renderer.createElement('svg')
	                .attr({
	                    version: '1.1'
	                })
	                .css(this.getStyle(style));
	            element = boxWrapper.element;
	            container.appendChild(element);

	            // For browsers other than IE, add the namespace attribute (#1978)
	            if (container.innerHTML.indexOf('xmlns') === -1) {
	                attr(element, 'xmlns', SVG_NS);
	            }

	            // object properties
	            renderer.isSVG = true;
	            renderer.box = element;
	            renderer.boxWrapper = boxWrapper;
	            renderer.alignedObjects = [];

	            // Page url used for internal references. #24, #672, #1070
	            renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?
	                    win.location.href
	                        .replace(/#.*?$/, '') // remove the hash
	                        .replace(/([\('\)])/g, '\\$1') // escape parantheses and quotes
	                        .replace(/ /g, '%20') : // replace spaces (needed for Safari only)
	                    '';

	            // Add description
	            desc = this.createElement('desc').add();
	            desc.element.appendChild(doc.createTextNode('Created with ' + PRODUCT + ' ' + VERSION));


	            renderer.defs = this.createElement('defs').add();
	            renderer.allowHTML = allowHTML;
	            renderer.forExport = forExport;
	            renderer.gradients = {}; // Object where gradient SvgElements are stored
	            renderer.cache = {}; // Cache for numerical bounding boxes
	            renderer.cacheKeys = [];
	            renderer.imgCount = 0;

	            renderer.setSize(width, height, false);



	            // Issue 110 workaround:
	            // In Firefox, if a div is positioned by percentage, its pixel position may land
	            // between pixels. The container itself doesn't display this, but an SVG element
	            // inside this container will be drawn at subpixel precision. In order to draw
	            // sharp lines, this must be compensated for. This doesn't seem to work inside
	            // iframes though (like in jsFiddle).
	            var subPixelFix, rect;
	            if (isFirefox && container.getBoundingClientRect) {
	                renderer.subPixelFix = subPixelFix = function () {
	                    css(container, { left: 0, top: 0 });
	                    rect = container.getBoundingClientRect();
	                    css(container, {
	                        left: (mathCeil(rect.left) - rect.left) + PX,
	                        top: (mathCeil(rect.top) - rect.top) + PX
	                    });
	                };

	                // run the fix now
	                subPixelFix();

	                // run it on resize
	                addEvent(win, 'resize', subPixelFix);
	            }
	        },

	        getStyle: function (style) {
	            this.style = extend({
	                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', // default font
	                fontSize: '12px'
	            }, style);
	            return this.style;
	        },

	        /**
	         * Detect whether the renderer is hidden. This happens when one of the parent elements
	         * has display: none. #608.
	         */
	        isHidden: function () {
	            return !this.boxWrapper.getBBox().width;
	        },

	        /**
	         * Destroys the renderer and its allocated members.
	         */
	        destroy: function () {
	            var renderer = this,
	                rendererDefs = renderer.defs;
	            renderer.box = null;
	            renderer.boxWrapper = renderer.boxWrapper.destroy();

	            // Call destroy on all gradient elements
	            destroyObjectProperties(renderer.gradients || {});
	            renderer.gradients = null;

	            // Defs are null in VMLRenderer
	            // Otherwise, destroy them here.
	            if (rendererDefs) {
	                renderer.defs = rendererDefs.destroy();
	            }

	            // Remove sub pixel fix handler
	            // We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed
	            // See issue #982
	            if (renderer.subPixelFix) {
	                removeEvent(win, 'resize', renderer.subPixelFix);
	            }

	            renderer.alignedObjects = null;

	            return null;
	        },

	        /**
	         * Create a wrapper for an SVG element
	         * @param {Object} nodeName
	         */
	        createElement: function (nodeName) {
	            var wrapper = new this.Element();
	            wrapper.init(this, nodeName);
	            return wrapper;
	        },

	        /**
	         * Dummy function for use in canvas renderer
	         */
	        draw: function () {},

	        /**
	         * Get converted radial gradient attributes
	         */
	        getRadialAttr: function (radialReference, gradAttr) {
	            return {
	                cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],
	                cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],
	                r: gradAttr.r * radialReference[2]
	            };
	        },

	        /**
	         * Parse a simple HTML string into SVG tspans
	         *
	         * @param {Object} textNode The parent text SVG node
	         */
	        buildText: function (wrapper) {
	            var textNode = wrapper.element,
	                renderer = this,
	                forExport = renderer.forExport,
	                textStr = pick(wrapper.textStr, '').toString(),
	                hasMarkup = textStr.indexOf('<') !== -1,
	                lines,
	                childNodes = textNode.childNodes,
	                styleRegex,
	                hrefRegex,
	                parentX = attr(textNode, 'x'),
	                textStyles = wrapper.styles,
	                width = wrapper.textWidth,
	                textLineHeight = textStyles && textStyles.lineHeight,
	                textShadow = textStyles && textStyles.textShadow,
	                ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',
	                i = childNodes.length,
	                tempParent = width && !wrapper.added && this.box,
	                getLineHeight = function (tspan) {
	                    return textLineHeight ?
	                            pInt(textLineHeight) :
	                            renderer.fontMetrics(
	                                /(px|em)$/.test(tspan && tspan.style.fontSize) ?
	                                        tspan.style.fontSize :
	                                        ((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12),
	                                tspan
	                            ).h;
	                },
	                unescapeAngleBrackets = function (inputStr) {
	                    return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
	                };

	            /// remove old text
	            while (i--) {
	                textNode.removeChild(childNodes[i]);
	            }

	            // Skip tspans, add text directly to text node. The forceTSpan is a hook
	            // used in text outline hack.
	            if (!hasMarkup && !textShadow && !ellipsis && textStr.indexOf(' ') === -1) {
	                textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));

	            // Complex strings, add more logic
	            } else {

	                styleRegex = /<.*style="([^"]+)".*>/;
	                hrefRegex = /<.*href="(http[^"]+)".*>/;

	                if (tempParent) {
	                    tempParent.appendChild(textNode); // attach it to the DOM to read offset width
	                }

	                if (hasMarkup) {
	                    lines = textStr
	                        .replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
	                        .replace(/<(i|em)>/g, '<span style="font-style:italic">')
	                        .replace(/<a/g, '<span')
	                        .replace(/<\/(b|strong|i|em|a)>/g, '</span>')
	                        .split(/<br.*?>/g);

	                } else {
	                    lines = [textStr];
	                }


	                // remove empty line at end
	                if (lines[lines.length - 1] === '') {
	                    lines.pop();
	                }


	                // build the lines
	                each(lines, function (line, lineNo) {
	                    var spans, spanNo = 0;

	                    line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
	                    spans = line.split('|||');

	                    each(spans, function (span) {
	                        if (span !== '' || spans.length === 1) {
	                            var attributes = {},
	                                tspan = doc.createElementNS(SVG_NS, 'tspan'),
	                                spanStyle; // #390
	                            if (styleRegex.test(span)) {
	                                spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');
	                                attr(tspan, 'style', spanStyle);
	                            }
	                            if (hrefRegex.test(span) && !forExport) { // Not for export - #1529
	                                attr(tspan, 'onclick', 'location.href=\"' + span.match(hrefRegex)[1] + '\"');
	                                css(tspan, { cursor: 'pointer' });
	                            }

	                            span = unescapeAngleBrackets(span.replace(/<(.|\n)*?>/g, '') || ' ');

	                            // Nested tags aren't supported, and cause crash in Safari (#1596)
	                            if (span !== ' ') {

	                                // add the text node
	                                tspan.appendChild(doc.createTextNode(span));

	                                if (!spanNo) { // first span in a line, align it to the left
	                                    if (lineNo && parentX !== null) {
	                                        attributes.x = parentX;
	                                    }
	                                } else {
	                                    attributes.dx = 0; // #16
	                                }

	                                // add attributes
	                                attr(tspan, attributes);

	                                // Append it
	                                textNode.appendChild(tspan);

	                                // first span on subsequent line, add the line height
	                                if (!spanNo && lineNo) {

	                                    // allow getting the right offset height in exporting in IE
	                                    if (!hasSVG && forExport) {
	                                        css(tspan, { display: 'block' });
	                                    }

	                                    // Set the line height based on the font size of either
	                                    // the text element or the tspan element
	                                    attr(
	                                        tspan,
	                                        'dy',
	                                        getLineHeight(tspan)
	                                    );
	                                }

	                                /*if (width) {
	                                    renderer.breakText(wrapper, width);
	                                }*/

	                                // Check width and apply soft breaks or ellipsis
	                                if (width) {
	                                    var words = span.replace(/([^\^])-/g, '$1- ').split(' '), // #1273
	                                        hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && textStyles.whiteSpace !== 'nowrap'),
	                                        tooLong,
	                                        wasTooLong,
	                                        actualWidth,
	                                        rest = [],
	                                        dy = getLineHeight(tspan),
	                                        softLineNo = 1,
	                                        rotation = wrapper.rotation,
	                                        wordStr = span, // for ellipsis
	                                        cursor = wordStr.length, // binary search cursor
	                                        bBox;

	                                    while ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {
	                                        wrapper.rotation = 0; // discard rotation when computing box
	                                        bBox = wrapper.getBBox(true);
	                                        actualWidth = bBox.width;

	                                        // Old IE cannot measure the actualWidth for SVG elements (#2314)
	                                        if (!hasSVG && renderer.forExport) {
	                                            actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);
	                                        }

	                                        tooLong = actualWidth > width;

	                                        // For ellipsis, do a binary search for the correct string length
	                                        if (wasTooLong === undefined) {
	                                            wasTooLong = tooLong; // First time
	                                        }
	                                        if (ellipsis && wasTooLong) {
	                                            cursor /= 2;

	                                            if (wordStr === '' || (!tooLong && cursor < 0.5)) {
	                                                words = []; // All ok, break out
	                                            } else {
	                                                if (tooLong) {
	                                                    wasTooLong = true;
	                                                }
	                                                wordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * mathCeil(cursor));
	                                                words = [wordStr + (width > 3 ? '\u2026' : '')];
	                                                tspan.removeChild(tspan.firstChild);
	                                            }

	                                        // Looping down, this is the first word sequence that is not too long,
	                                        // so we can move on to build the next line.
	                                        } else if (!tooLong || words.length === 1) {
	                                            words = rest;
	                                            rest = [];

	                                            if (words.length) {
	                                                softLineNo++;

	                                                tspan = doc.createElementNS(SVG_NS, 'tspan');
	                                                attr(tspan, {
	                                                    dy: dy,
	                                                    x: parentX
	                                                });
	                                                if (spanStyle) { // #390
	                                                    attr(tspan, 'style', spanStyle);
	                                                }
	                                                textNode.appendChild(tspan);
	                                            }
	                                            if (actualWidth > width) { // a single word is pressing it out
	                                                width = actualWidth;
	                                            }
	                                        } else { // append to existing line tspan
	                                            tspan.removeChild(tspan.firstChild);
	                                            rest.unshift(words.pop());
	                                        }
	                                        if (words.length) {
	                                            tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
	                                        }
	                                    }
	                                    if (wasTooLong) {
	                                        wrapper.attr('title', wrapper.textStr);
	                                    }
	                                    wrapper.rotation = rotation;
	                                }

	                                spanNo++;
	                            }
	                        }
	                    });
	                });
	                if (tempParent) {
	                    tempParent.removeChild(textNode); // attach it to the DOM to read offset width
	                }

	                // Apply the text shadow
	                if (textShadow && wrapper.applyTextShadow) {
	                    wrapper.applyTextShadow(textShadow);
	                }
	            }
	        },



	        /*
	        breakText: function (wrapper, width) {
	            var bBox = wrapper.getBBox(),
	                node = wrapper.element,
	                textLength = node.textContent.length,
	                pos = mathRound(width * textLength / bBox.width), // try this position first, based on average character width
	                increment = 0,
	                finalPos;

	            if (bBox.width > width) {
	                while (finalPos === undefined) {
	                    textLength = node.getSubStringLength(0, pos);

	                    if (textLength <= width) {
	                        if (increment === -1) {
	                            finalPos = pos;
	                        } else {
	                            increment = 1;
	                        }
	                    } else {
	                        if (increment === 1) {
	                            finalPos = pos - 1;
	                        } else {
	                            increment = -1;
	                        }
	                    }
	                    pos += increment;
	                }
	            }
	            console.log(finalPos, node.getSubStringLength(0, finalPos))
	        },
	        */

	        /**
	         * Returns white for dark colors and black for bright colors
	         */
	        getContrast: function (color) {
	            color = Color(color).rgba;
	            return color[0] + color[1] + color[2] > 384 ? '#000000' : '#FFFFFF';
	        },

	        /**
	         * Create a button with preset states
	         * @param {String} text
	         * @param {Number} x
	         * @param {Number} y
	         * @param {Function} callback
	         * @param {Object} normalState
	         * @param {Object} hoverState
	         * @param {Object} pressedState
	         */
	        button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {
	            var label = this.label(text, x, y, shape, null, null, null, null, 'button'),
	                curState = 0,
	                stateOptions,
	                stateStyle,
	                normalStyle,
	                hoverStyle,
	                pressedStyle,
	                disabledStyle,
	                verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };

	            // Normal state - prepare the attributes
	            normalState = merge({
	                'stroke-width': 1,
	                stroke: '#CCCCCC',
	                fill: {
	                    linearGradient: verticalGradient,
	                    stops: [
	                        [0, '#FEFEFE'],
	                        [1, '#F6F6F6']
	                    ]
	                },
	                r: 2,
	                padding: 5,
	                style: {
	                    color: 'black'
	                }
	            }, normalState);
	            normalStyle = normalState.style;
	            delete normalState.style;

	            // Hover state
	            hoverState = merge(normalState, {
	                stroke: '#68A',
	                fill: {
	                    linearGradient: verticalGradient,
	                    stops: [
	                        [0, '#FFF'],
	                        [1, '#ACF']
	                    ]
	                }
	            }, hoverState);
	            hoverStyle = hoverState.style;
	            delete hoverState.style;

	            // Pressed state
	            pressedState = merge(normalState, {
	                stroke: '#68A',
	                fill: {
	                    linearGradient: verticalGradient,
	                    stops: [
	                        [0, '#9BD'],
	                        [1, '#CDF']
	                    ]
	                }
	            }, pressedState);
	            pressedStyle = pressedState.style;
	            delete pressedState.style;

	            // Disabled state
	            disabledState = merge(normalState, {
	                style: {
	                    color: '#CCC'
	                }
	            }, disabledState);
	            disabledStyle = disabledState.style;
	            delete disabledState.style;

	            // Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).
	            addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function () {
	                if (curState !== 3) {
	                    label.attr(hoverState)
	                        .css(hoverStyle);
	                }
	            });
	            addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function () {
	                if (curState !== 3) {
	                    stateOptions = [normalState, hoverState, pressedState][curState];
	                    stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];
	                    label.attr(stateOptions)
	                        .css(stateStyle);
	                }
	            });

	            label.setState = function (state) {
	                label.state = curState = state;
	                if (!state) {
	                    label.attr(normalState)
	                        .css(normalStyle);
	                } else if (state === 2) {
	                    label.attr(pressedState)
	                        .css(pressedStyle);
	                } else if (state === 3) {
	                    label.attr(disabledState)
	                        .css(disabledStyle);
	                }
	            };

	            return label
	                .on('click', function (e) {
	                    if (curState !== 3) {
	                        callback.call(label, e);
	                    }
	                })
	                .attr(normalState)
	                .css(extend({ cursor: 'default' }, normalStyle));
	        },

	        /**
	         * Make a straight line crisper by not spilling out to neighbour pixels
	         * @param {Array} points
	         * @param {Number} width
	         */
	        crispLine: function (points, width) {
	            // points format: [M, 0, 0, L, 100, 0]
	            // normalize to a crisp line
	            if (points[1] === points[4]) {
	                // Substract due to #1129. Now bottom and left axis gridlines behave the same.
	                points[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);
	            }
	            if (points[2] === points[5]) {
	                points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
	            }
	            return points;
	        },


	        /**
	         * Draw a path
	         * @param {Array} path An SVG path in array form
	         */
	        path: function (path) {
	            var attr = {
	                fill: NONE
	            };
	            if (isArray(path)) {
	                attr.d = path;
	            } else if (isObject(path)) { // attributes
	                extend(attr, path);
	            }
	            return this.createElement('path').attr(attr);
	        },

	        /**
	         * Draw and return an SVG circle
	         * @param {Number} x The x position
	         * @param {Number} y The y position
	         * @param {Number} r The radius
	         */
	        circle: function (x, y, r) {
	            var attr = isObject(x) ? x : { x: x, y: y, r: r },
	                wrapper = this.createElement('circle');

	            // Setting x or y translates to cx and cy
	            wrapper.xSetter = wrapper.ySetter = function (value, key, element) {
	                element.setAttribute('c' + key, value);
	            };

	            return wrapper.attr(attr);
	        },

	        /**
	         * Draw and return an arc
	         * @param {Number} x X position
	         * @param {Number} y Y position
	         * @param {Number} r Radius
	         * @param {Number} innerR Inner radius like used in donut charts
	         * @param {Number} start Starting angle
	         * @param {Number} end Ending angle
	         */
	        arc: function (x, y, r, innerR, start, end) {
	            var arc;

	            if (isObject(x)) {
	                y = x.y;
	                r = x.r;
	                innerR = x.innerR;
	                start = x.start;
	                end = x.end;
	                x = x.x;
	            }

	            // Arcs are defined as symbols for the ability to set
	            // attributes in attr and animate
	            arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {
	                innerR: innerR || 0,
	                start: start || 0,
	                end: end || 0
	            });
	            arc.r = r; // #959
	            return arc;
	        },

	        /**
	         * Draw and return a rectangle
	         * @param {Number} x Left position
	         * @param {Number} y Top position
	         * @param {Number} width
	         * @param {Number} height
	         * @param {Number} r Border corner radius
	         * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
	         */
	        rect: function (x, y, width, height, r, strokeWidth) {

	            r = isObject(x) ? x.r : r;

	            var wrapper = this.createElement('rect'),
	                attribs = isObject(x) ? x : x === UNDEFINED ? {} : {
	                    x: x,
	                    y: y,
	                    width: mathMax(width, 0),
	                    height: mathMax(height, 0)
	                };

	            if (strokeWidth !== UNDEFINED) {
	                wrapper.strokeWidth = strokeWidth;
	                attribs = wrapper.crisp(attribs);
	            }

	            if (r) {
	                attribs.r = r;
	            }

	            wrapper.rSetter = function (value, key, element) {
	                attr(element, {
	                    rx: value,
	                    ry: value
	                });
	            };

	            return wrapper.attr(attribs);
	        },

	        /**
	         * Resize the box and re-align all aligned elements
	         * @param {Object} width
	         * @param {Object} height
	         * @param {Boolean} animate
	         *
	         */
	        setSize: function (width, height, animate) {
	            var renderer = this,
	                alignedObjects = renderer.alignedObjects,
	                i = alignedObjects.length;

	            renderer.width = width;
	            renderer.height = height;

	            renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
	                width: width,
	                height: height
	            });

	            while (i--) {
	                alignedObjects[i].align();
	            }
	        },

	        /**
	         * Create a group
	         * @param {String} name The group will be given a class name of 'highcharts-{name}'.
	         *     This can be used for styling and scripting.
	         */
	        g: function (name) {
	            var elem = this.createElement('g');
	            return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;
	        },

	        /**
	         * Display an image
	         * @param {String} src
	         * @param {Number} x
	         * @param {Number} y
	         * @param {Number} width
	         * @param {Number} height
	         */
	        image: function (src, x, y, width, height) {
	            var attribs = {
	                    preserveAspectRatio: NONE
	                },
	                elemWrapper;

	            // optional properties
	            if (arguments.length > 1) {
	                extend(attribs, {
	                    x: x,
	                    y: y,
	                    width: width,
	                    height: height
	                });
	            }

	            elemWrapper = this.createElement('image').attr(attribs);

	            // set the href in the xlink namespace
	            if (elemWrapper.element.setAttributeNS) {
	                elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
	                    'href', src);
	            } else {
	                // could be exporting in IE
	                // using href throws "not supported" in ie7 and under, requries regex shim to fix later
	                elemWrapper.element.setAttribute('hc-svg-href', src);
	            }
	            return elemWrapper;
	        },

	        /**
	         * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
	         *
	         * @param {Object} symbol
	         * @param {Object} x
	         * @param {Object} y
	         * @param {Object} radius
	         * @param {Object} options
	         */
	        symbol: function (symbol, x, y, width, height, options) {

	            var ren = this,
	                obj,

	                // get the symbol definition function
	                symbolFn = this.symbols[symbol],

	                // check if there's a path defined for this symbol
	                path = symbolFn && symbolFn(
	                    mathRound(x),
	                    mathRound(y),
	                    width,
	                    height,
	                    options
	                ),

	                imageRegex = /^url\((.*?)\)$/,
	                imageSrc,
	                imageSize,
	                centerImage;

	            if (path) {

	                obj = this.path(path);
	                // expando properties for use in animate and attr
	                extend(obj, {
	                    symbolName: symbol,
	                    x: x,
	                    y: y,
	                    width: width,
	                    height: height
	                });
	                if (options) {
	                    extend(obj, options);
	                }


	            // image symbols
	            } else if (imageRegex.test(symbol)) {

	                // On image load, set the size and position
	                centerImage = function (img, size) {
	                    if (img.element) { // it may be destroyed in the meantime (#1390)
	                        img.attr({
	                            width: size[0],
	                            height: size[1]
	                        });

	                        if (!img.alignByTranslate) { // #185
	                            img.translate(
	                                mathRound((width - size[0]) / 2), // #1378
	                                mathRound((height - size[1]) / 2)
	                            );
	                        }
	                    }
	                };

	                imageSrc = symbol.match(imageRegex)[1];
	                imageSize = symbolSizes[imageSrc] || (options && options.width && options.height && [options.width, options.height]);

	                // Ireate the image synchronously, add attribs async
	                obj = this.image(imageSrc)
	                    .attr({
	                        x: x,
	                        y: y
	                    });
	                obj.isImg = true;

	                if (imageSize) {
	                    centerImage(obj, imageSize);
	                } else {
	                    // Initialize image to be 0 size so export will still function if there's no cached sizes.
	                    obj.attr({ width: 0, height: 0 });

	                    // Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,
	                    // the created element must be assigned to a variable in order to load (#292).
	                    createElement('img', {
	                        onload: function () {

	                            // Special case for SVGs on IE11, the width is not accessible until the image is
	                            // part of the DOM (#2854).
	                            if (this.width === 0) {
	                                css(this, {
	                                    position: ABSOLUTE,
	                                    top: '-999em'
	                                });
	                                doc.body.appendChild(this);
	                            }

	                            // Center the image
	                            centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);

	                            // Clean up after #2854 workaround.
	                            if (this.parentNode) {
	                                this.parentNode.removeChild(this);
	                            }

	                            // Fire the load event when all external images are loaded
	                            ren.imgCount--;
	                            if (!ren.imgCount) {
	                                charts[ren.chartIndex].onload();
	                            }
	                        },
	                        src: imageSrc
	                    });
	                }
	                this.imgCount++;
	            }

	            return obj;
	        },

	        /**
	         * An extendable collection of functions for defining symbol paths.
	         */
	        symbols: {
	            'circle': function (x, y, w, h) {
	                var cpw = 0.166 * w;
	                return [
	                    M, x + w / 2, y,
	                    'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,
	                    'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,
	                    'Z'
	                ];
	            },

	            'square': function (x, y, w, h) {
	                return [
	                    M, x, y,
	                    L, x + w, y,
	                    x + w, y + h,
	                    x, y + h,
	                    'Z'
	                ];
	            },

	            'triangle': function (x, y, w, h) {
	                return [
	                    M, x + w / 2, y,
	                    L, x + w, y + h,
	                    x, y + h,
	                    'Z'
	                ];
	            },

	            'triangle-down': function (x, y, w, h) {
	                return [
	                    M, x, y,
	                    L, x + w, y,
	                    x + w / 2, y + h,
	                    'Z'
	                ];
	            },
	            'diamond': function (x, y, w, h) {
	                return [
	                    M, x + w / 2, y,
	                    L, x + w, y + h / 2,
	                    x + w / 2, y + h,
	                    x, y + h / 2,
	                    'Z'
	                ];
	            },
	            'arc': function (x, y, w, h, options) {
	                var start = options.start,
	                    radius = options.r || w || h,
	                    end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)
	                    innerRadius = options.innerR,
	                    open = options.open,
	                    cosStart = mathCos(start),
	                    sinStart = mathSin(start),
	                    cosEnd = mathCos(end),
	                    sinEnd = mathSin(end),
	                    longArc = options.end - start < mathPI ? 0 : 1;

	                return [
	                    M,
	                    x + radius * cosStart,
	                    y + radius * sinStart,
	                    'A', // arcTo
	                    radius, // x radius
	                    radius, // y radius
	                    0, // slanting
	                    longArc, // long or short arc
	                    1, // clockwise
	                    x + radius * cosEnd,
	                    y + radius * sinEnd,
	                    open ? M : L,
	                    x + innerRadius * cosEnd,
	                    y + innerRadius * sinEnd,
	                    'A', // arcTo
	                    innerRadius, // x radius
	                    innerRadius, // y radius
	                    0, // slanting
	                    longArc, // long or short arc
	                    0, // clockwise
	                    x + innerRadius * cosStart,
	                    y + innerRadius * sinStart,

	                    open ? '' : 'Z' // close
	                ];
	            },

	            /**
	             * Callout shape used for default tooltips, also used for rounded rectangles in VML
	             */
	            callout: function (x, y, w, h, options) {
	                var arrowLength = 6,
	                    halfDistance = 6,
	                    r = mathMin((options && options.r) || 0, w, h),
	                    safeDistance = r + halfDistance,
	                    anchorX = options && options.anchorX,
	                    anchorY = options && options.anchorY,
	                    path;

	                path = [
	                    'M', x + r, y,
	                    'L', x + w - r, y, // top side
	                    'C', x + w, y, x + w, y, x + w, y + r, // top-right corner
	                    'L', x + w, y + h - r, // right side
	                    'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner
	                    'L', x + r, y + h, // bottom side
	                    'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner
	                    'L', x, y + r, // left side
	                    'C', x, y, x, y, x + r, y // top-right corner
	                ];

	                if (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side
	                    path.splice(13, 3,
	                        'L', x + w, anchorY - halfDistance,
	                        x + w + arrowLength, anchorY,
	                        x + w, anchorY + halfDistance,
	                        x + w, y + h - r
	                        );
	                } else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side
	                    path.splice(33, 3,
	                        'L', x, anchorY + halfDistance,
	                        x - arrowLength, anchorY,
	                        x, anchorY - halfDistance,
	                        x, y + r
	                        );
	                } else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom
	                    path.splice(23, 3,
	                        'L', anchorX + halfDistance, y + h,
	                        anchorX, y + h + arrowLength,
	                        anchorX - halfDistance, y + h,
	                        x + r, y + h
	                        );
	                } else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top
	                    path.splice(3, 3,
	                        'L', anchorX - halfDistance, y,
	                        anchorX, y - arrowLength,
	                        anchorX + halfDistance, y,
	                        w - r, y
	                        );
	                }
	                return path;
	            }
	        },

	        /**
	         * Define a clipping rectangle
	         * @param {String} id
	         * @param {Number} x
	         * @param {Number} y
	         * @param {Number} width
	         * @param {Number} height
	         */
	        clipRect: function (x, y, width, height) {
	            var wrapper,
	                id = PREFIX + idCounter++,

	                clipPath = this.createElement('clipPath').attr({
	                    id: id
	                }).add(this.defs);

	            wrapper = this.rect(x, y, width, height, 0).add(clipPath);
	            wrapper.id = id;
	            wrapper.clipPath = clipPath;
	            wrapper.count = 0;

	            return wrapper;
	        },





	        /**
	         * Add text to the SVG object
	         * @param {String} str
	         * @param {Number} x Left position
	         * @param {Number} y Top position
	         * @param {Boolean} useHTML Use HTML to render the text
	         */
	        text: function (str, x, y, useHTML) {

	            // declare variables
	            var renderer = this,
	                fakeSVG = useCanVG || (!hasSVG && renderer.forExport),
	                wrapper,
	                attr = {};

	            if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
	                return renderer.html(str, x, y);
	            }

	            attr.x = Math.round(x || 0); // X is always needed for line-wrap logic
	            if (y) {
	                attr.y = Math.round(y);
	            }
	            if (str || str === 0) {
	                attr.text = str;
	            }

	            wrapper = renderer.createElement('text')
	                .attr(attr);

	            // Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)
	            if (fakeSVG) {
	                wrapper.css({
	                    position: ABSOLUTE
	                });
	            }

	            if (!useHTML) {
	                wrapper.xSetter = function (value, key, element) {
	                    var tspans = element.getElementsByTagName('tspan'),
	                        tspan,
	                        parentVal = element.getAttribute(key),
	                        i;
	                    for (i = 0; i < tspans.length; i++) {
	                        tspan = tspans[i];
	                        // If the x values are equal, the tspan represents a linebreak
	                        if (tspan.getAttribute(key) === parentVal) {
	                            tspan.setAttribute(key, value);
	                        }
	                    }
	                    element.setAttribute(key, value);
	                };
	            }

	            return wrapper;
	        },

	        /**
	         * Utility to return the baseline offset and total line height from the font size
	         */
	        fontMetrics: function (fontSize, elem) {
	            var lineHeight,
	                baseline,
	                style;

	            fontSize = fontSize || this.style.fontSize;
	            if (!fontSize && elem && win.getComputedStyle) {
	                elem = elem.element || elem; // SVGElement
	                style = win.getComputedStyle(elem, '');
	                fontSize = style && style.fontSize; // #4309, the style doesn't exist inside a hidden iframe in Firefox
	            }
	            fontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;

	            // Empirical values found by comparing font size and bounding box height.
	            // Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/
	            lineHeight = fontSize < 24 ? fontSize + 3 : mathRound(fontSize * 1.2);
	            baseline = mathRound(lineHeight * 0.8);

	            return {
	                h: lineHeight,
	                b: baseline,
	                f: fontSize
	            };
	        },

	        /**
	         * Correct X and Y positioning of a label for rotation (#1764)
	         */
	        rotCorr: function (baseline, rotation, alterY) {
	            var y = baseline;
	            if (rotation && alterY) {
	                y = mathMax(y * mathCos(rotation * deg2rad), 4);
	            }
	            return {
	                x: (-baseline / 3) * mathSin(rotation * deg2rad),
	                y: y
	            };
	        },

	        /**
	         * Add a label, a text item that can hold a colored or gradient background
	         * as well as a border and shadow.
	         * @param {string} str
	         * @param {Number} x
	         * @param {Number} y
	         * @param {String} shape
	         * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the
	         *    coordinates it should be pinned to
	         * @param {Number} anchorY
	         * @param {Boolean} baseline Whether to position the label relative to the text baseline,
	         *    like renderer.text, or to the upper border of the rectangle.
	         * @param {String} className Class name for the group
	         */
	        label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {

	            var renderer = this,
	                wrapper = renderer.g(className),
	                text = renderer.text('', 0, 0, useHTML)
	                    .attr({
	                        zIndex: 1
	                    }),
	                    //.add(wrapper),
	                box,
	                bBox,
	                alignFactor = 0,
	                padding = 3,
	                paddingLeft = 0,
	                width,
	                height,
	                wrapperX,
	                wrapperY,
	                crispAdjust = 0,
	                deferredAttr = {},
	                baselineOffset,
	                needsBox,
	                updateBoxSize,
	                updateTextPadding,
	                boxAttr;

	            /**
	             * This function runs after the label is added to the DOM (when the bounding box is
	             * available), and after the text of the label is updated to detect the new bounding
	             * box and reflect it in the border box.
	             */
	            updateBoxSize = function () {
	                var boxX,
	                    boxY,
	                    style = text.element.style;

	                bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) &&
	                    text.getBBox(); //#3295 && 3514 box failure when string equals 0
	                wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
	                wrapper.height = (height || bBox.height || 0) + 2 * padding;

	                // update the label-scoped y offset
	                baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;


	                if (needsBox) {

	                    if (!box) {
	                        // create the border box if it is not already present
	                        boxX = crispAdjust;
	                        boxY = (baseline ? -baselineOffset : 0) + crispAdjust;

	                        wrapper.box = box = shape ?
	                                renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height, deferredAttr) :
	                                renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);

	                        if (!box.isImg) { // #4324, fill "none" causes it to be ignored by mouse events in IE
	                            box.attr('fill', NONE);
	                        }
	                        box.add(wrapper);
	                    }

	                    // apply the box attributes
	                    if (!box.isImg) { // #1630
	                        box.attr(extend({
	                            width: mathRound(wrapper.width),
	                            height: mathRound(wrapper.height)
	                        }, deferredAttr));
	                    }
	                    deferredAttr = null;
	                }
	            };

	            /**
	             * This function runs after setting text or padding, but only if padding is changed
	             */
	            updateTextPadding = function () {
	                var styles = wrapper.styles,
	                    textAlign = styles && styles.textAlign,
	                    x = paddingLeft + padding,
	                    y;

	                // determin y based on the baseline
	                y = baseline ? 0 : baselineOffset;

	                // compensate for alignment
	                if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {
	                    x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);
	                }

	                // update if anything changed
	                if (x !== text.x || y !== text.y) {
	                    text.attr('x', x);
	                    if (y !== UNDEFINED) {
	                        text.attr('y', y);
	                    }
	                }

	                // record current values
	                text.x = x;
	                text.y = y;
	            };

	            /**
	             * Set a box attribute, or defer it if the box is not yet created
	             * @param {Object} key
	             * @param {Object} value
	             */
	            boxAttr = function (key, value) {
	                if (box) {
	                    box.attr(key, value);
	                } else {
	                    deferredAttr[key] = value;
	                }
	            };

	            /**
	             * After the text element is added, get the desired size of the border box
	             * and add it before the text in the DOM.
	             */
	            wrapper.onAdd = function () {
	                text.add(wrapper);
	                wrapper.attr({
	                    text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value
	                    x: x,
	                    y: y
	                });

	                if (box && defined(anchorX)) {
	                    wrapper.attr({
	                        anchorX: anchorX,
	                        anchorY: anchorY
	                    });
	                }
	            };

	            /*
	             * Add specific attribute setters.
	             */

	            // only change local variables
	            wrapper.widthSetter = function (value) {
	                width = value;
	            };
	            wrapper.heightSetter = function (value) {
	                height = value;
	            };
	            wrapper.paddingSetter =  function (value) {
	                if (defined(value) && value !== padding) {
	                    padding = wrapper.padding = value;
	                    updateTextPadding();
	                }
	            };
	            wrapper.paddingLeftSetter =  function (value) {
	                if (defined(value) && value !== paddingLeft) {
	                    paddingLeft = value;
	                    updateTextPadding();
	                }
	            };


	            // change local variable and prevent setting attribute on the group
	            wrapper.alignSetter = function (value) {
	                value = { left: 0, center: 0.5, right: 1 }[value];
	                if (value !== alignFactor) {
	                    alignFactor = value;
	                    if (bBox) { // Bounding box exists, means we're dynamically changing
	                        wrapper.attr({ x: x });
	                    }
	                }
	            };

	            // apply these to the box and the text alike
	            wrapper.textSetter = function (value) {
	                if (value !== UNDEFINED) {
	                    text.textSetter(value);
	                }
	                updateBoxSize();
	                updateTextPadding();
	            };

	            // apply these to the box but not to the text
	            wrapper['stroke-widthSetter'] = function (value, key) {
	                if (value) {
	                    needsBox = true;
	                }
	                crispAdjust = value % 2 / 2;
	                boxAttr(key, value);
	            };
	            wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {
	                if (key === 'fill' && value) {
	                    needsBox = true;
	                }
	                boxAttr(key, value);
	            };
	            wrapper.anchorXSetter = function (value, key) {
	                anchorX = value;
	                boxAttr(key, mathRound(value) - crispAdjust - wrapperX);
	            };
	            wrapper.anchorYSetter = function (value, key) {
	                anchorY = value;
	                boxAttr(key, value - wrapperY);
	            };

	            // rename attributes
	            wrapper.xSetter = function (value) {
	                wrapper.x = value; // for animation getter
	                if (alignFactor) {
	                    value -= alignFactor * ((width || bBox.width) + 2 * padding);
	                }
	                wrapperX = mathRound(value);
	                wrapper.attr('translateX', wrapperX);
	            };
	            wrapper.ySetter = function (value) {
	                wrapperY = wrapper.y = mathRound(value);
	                wrapper.attr('translateY', wrapperY);
	            };

	            // Redirect certain methods to either the box or the text
	            var baseCss = wrapper.css;
	            return extend(wrapper, {
	                /**
	                 * Pick up some properties and apply them to the text instead of the wrapper
	                 */
	                css: function (styles) {
	                    if (styles) {
	                        var textStyles = {};
	                        styles = merge(styles); // create a copy to avoid altering the original object (#537)
	                        each(wrapper.textProps, function (prop) {
	                            if (styles[prop] !== UNDEFINED) {
	                                textStyles[prop] = styles[prop];
	                                delete styles[prop];
	                            }
	                        });
	                        text.css(textStyles);
	                    }
	                    return baseCss.call(wrapper, styles);
	                },
	                /**
	                 * Return the bounding box of the box, not the group
	                 */
	                getBBox: function () {
	                    return {
	                        width: bBox.width + 2 * padding,
	                        height: bBox.height + 2 * padding,
	                        x: bBox.x - padding,
	                        y: bBox.y - padding
	                    };
	                },
	                /**
	                 * Apply the shadow to the box
	                 */
	                shadow: function (b) {
	                    if (box) {
	                        box.shadow(b);
	                    }
	                    return wrapper;
	                },
	                /**
	                 * Destroy and release memory.
	                 */
	                destroy: function () {

	                    // Added by button implementation
	                    removeEvent(wrapper.element, 'mouseenter');
	                    removeEvent(wrapper.element, 'mouseleave');

	                    if (text) {
	                        text = text.destroy();
	                    }
	                    if (box) {
	                        box = box.destroy();
	                    }
	                    // Call base implementation to destroy the rest
	                    SVGElement.prototype.destroy.call(wrapper);

	                    // Release local pointers (#1298)
	                    wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;
	                }
	            });
	        }
	    }; // end SVGRenderer


	    // general renderer
	    Renderer = SVGRenderer;
	    // extend SvgElement for useHTML option
	    extend(SVGElement.prototype, {
	        /**
	         * Apply CSS to HTML elements. This is used in text within SVG rendering and
	         * by the VML renderer
	         */
	        htmlCss: function (styles) {
	            var wrapper = this,
	                element = wrapper.element,
	                textWidth = styles && element.tagName === 'SPAN' && styles.width;

	            if (textWidth) {
	                delete styles.width;
	                wrapper.textWidth = textWidth;
	                wrapper.updateTransform();
	            }
	            if (styles && styles.textOverflow === 'ellipsis') {
	                styles.whiteSpace = 'nowrap';
	                styles.overflow = 'hidden';
	            }
	            wrapper.styles = extend(wrapper.styles, styles);
	            css(wrapper.element, styles);

	            return wrapper;
	        },

	        /**
	         * VML and useHTML method for calculating the bounding box based on offsets
	         * @param {Boolean} refresh Whether to force a fresh value from the DOM or to
	         * use the cached value
	         *
	         * @return {Object} A hash containing values for x, y, width and height
	         */

	        htmlGetBBox: function () {
	            var wrapper = this,
	                element = wrapper.element;

	            // faking getBBox in exported SVG in legacy IE
	            // faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)
	            if (element.nodeName === 'text') {
	                element.style.position = ABSOLUTE;
	            }

	            return {
	                x: element.offsetLeft,
	                y: element.offsetTop,
	                width: element.offsetWidth,
	                height: element.offsetHeight
	            };
	        },

	        /**
	         * VML override private method to update elements based on internal
	         * properties based on SVG transform
	         */
	        htmlUpdateTransform: function () {
	            // aligning non added elements is expensive
	            if (!this.added) {
	                this.alignOnAdd = true;
	                return;
	            }

	            var wrapper = this,
	                renderer = wrapper.renderer,
	                elem = wrapper.element,
	                translateX = wrapper.translateX || 0,
	                translateY = wrapper.translateY || 0,
	                x = wrapper.x || 0,
	                y = wrapper.y || 0,
	                align = wrapper.textAlign || 'left',
	                alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
	                shadows = wrapper.shadows,
	                styles = wrapper.styles;

	            // apply translate
	            css(elem, {
	                marginLeft: translateX,
	                marginTop: translateY
	            });
	            if (shadows) { // used in labels/tooltip
	                each(shadows, function (shadow) {
	                    css(shadow, {
	                        marginLeft: translateX + 1,
	                        marginTop: translateY + 1
	                    });
	                });
	            }

	            // apply inversion
	            if (wrapper.inverted) { // wrapper is a group
	                each(elem.childNodes, function (child) {
	                    renderer.invertChild(child, elem);
	                });
	            }

	            if (elem.tagName === 'SPAN') {

	                var rotation = wrapper.rotation,
	                    baseline,
	                    textWidth = pInt(wrapper.textWidth),
	                    whiteSpace = styles && styles.whiteSpace,
	                    currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth, wrapper.textAlign].join(',');

	                if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed


	                    baseline = renderer.fontMetrics(elem.style.fontSize).b;

	                    // Renderer specific handling of span rotation
	                    if (defined(rotation)) {
	                        wrapper.setSpanRotation(rotation, alignCorrection, baseline);
	                    }

	                    // Update textWidth
	                    if (elem.offsetWidth > textWidth && /[ \-]/.test(elem.textContent || elem.innerText)) { // #983, #1254
	                        css(elem, {
	                            width: textWidth + PX,
	                            display: 'block',
	                            whiteSpace: whiteSpace || 'normal' // #3331
	                        });
	                        wrapper.hasTextWidth = true;
	                    } else if (wrapper.hasTextWidth) { // #4928
	                        css(elem, {
	                            width: '',
	                            display: '',
	                            whiteSpace: whiteSpace || 'nowrap'
	                        });
	                        wrapper.hasTextWidth = false;
	                    }

	                    wrapper.getSpanCorrection(wrapper.hasTextWidth ? textWidth : elem.offsetWidth, baseline, alignCorrection, rotation, align);
	                }

	                // apply position with correction
	                css(elem, {
	                    left: (x + (wrapper.xCorr || 0)) + PX,
	                    top: (y + (wrapper.yCorr || 0)) + PX
	                });

	                // force reflow in webkit to apply the left and top on useHTML element (#1249)
	                if (isWebKit) {
	                    baseline = elem.offsetHeight; // assigned to baseline for lint purpose
	                }

	                // record current text transform
	                wrapper.cTT = currentTextTransform;
	            }
	        },

	        /**
	         * Set the rotation of an individual HTML span
	         */
	        setSpanRotation: function (rotation, alignCorrection, baseline) {
	            var rotationStyle = {},
	                cssTransformKey = isMS ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';

	            rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';
	            rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';
	            css(this.element, rotationStyle);
	        },

	        /**
	         * Get the correction in X and Y positioning as the element is rotated.
	         */
	        getSpanCorrection: function (width, baseline, alignCorrection) {
	            this.xCorr = -width * alignCorrection;
	            this.yCorr = -baseline;
	        }
	    });

	    // Extend SvgRenderer for useHTML option.
	    extend(SVGRenderer.prototype, {
	        /**
	         * Create HTML text node. This is used by the VML renderer as well as the SVG
	         * renderer through the useHTML option.
	         *
	         * @param {String} str
	         * @param {Number} x
	         * @param {Number} y
	         */
	        html: function (str, x, y) {
	            var wrapper = this.createElement('span'),
	                element = wrapper.element,
	                renderer = wrapper.renderer,
	                addSetters = function (element, style) {
	                    // These properties are set as attributes on the SVG group, and as
	                    // identical CSS properties on the div. (#3542)
	                    each(['opacity', 'visibility'], function (prop) {
	                        wrap(element, prop + 'Setter', function (proceed, value, key, elem) {
	                            proceed.call(this, value, key, elem);
	                            style[key] = value;
	                        });
	                    });            
	                };

	            // Text setter
	            wrapper.textSetter = function (value) {
	                if (value !== element.innerHTML) {
	                    delete this.bBox;
	                }
	                element.innerHTML = this.textStr = value;
	                wrapper.htmlUpdateTransform();
	            };
	            addSetters(wrapper, wrapper.element.style);

	            // Various setters which rely on update transform
	            wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {
	                if (key === 'align') {
	                    key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.
	                }
	                wrapper[key] = value;
	                wrapper.htmlUpdateTransform();
	            };

	            // Set the default attributes
	            wrapper
	                .attr({
	                    text: str,
	                    x: mathRound(x),
	                    y: mathRound(y)
	                })
	                .css({
	                    position: ABSOLUTE,
	                    fontFamily: this.style.fontFamily,
	                    fontSize: this.style.fontSize
	                });

	            // Keep the whiteSpace style outside the wrapper.styles collection
	            element.style.whiteSpace = 'nowrap';

	            // Use the HTML specific .css method
	            wrapper.css = wrapper.htmlCss;

	            // This is specific for HTML within SVG
	            if (renderer.isSVG) {
	                wrapper.add = function (svgGroupWrapper) {

	                    var htmlGroup,
	                        container = renderer.box.parentNode,
	                        parentGroup,
	                        parents = [];

	                    this.parentGroup = svgGroupWrapper;

	                    // Create a mock group to hold the HTML elements
	                    if (svgGroupWrapper) {
	                        htmlGroup = svgGroupWrapper.div;
	                        if (!htmlGroup) {

	                            // Read the parent chain into an array and read from top down
	                            parentGroup = svgGroupWrapper;
	                            while (parentGroup) {

	                                parents.push(parentGroup);

	                                // Move up to the next parent group
	                                parentGroup = parentGroup.parentGroup;
	                            }

	                            // Ensure dynamically updating position when any parent is translated
	                            each(parents.reverse(), function (parentGroup) {
	                                var htmlGroupStyle,
	                                    cls = attr(parentGroup.element, 'class');

	                                if (cls) {
	                                    cls = { className: cls };
	                                } // else null

	                                // Create a HTML div and append it to the parent div to emulate
	                                // the SVG group structure
	                                htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, cls, {
	                                    position: ABSOLUTE,
	                                    left: (parentGroup.translateX || 0) + PX,
	                                    top: (parentGroup.translateY || 0) + PX
	                                }, htmlGroup || container); // the top group is appended to container

	                                // Shortcut
	                                htmlGroupStyle = htmlGroup.style;

	                                // Set listeners to update the HTML div's position whenever the SVG group
	                                // position is changed
	                                extend(parentGroup, {
	                                    translateXSetter: function (value, key) {
	                                        htmlGroupStyle.left = value + PX;
	                                        parentGroup[key] = value;
	                                        parentGroup.doTransform = true;
	                                    },
	                                    translateYSetter: function (value, key) {
	                                        htmlGroupStyle.top = value + PX;
	                                        parentGroup[key] = value;
	                                        parentGroup.doTransform = true;
	                                    }
	                                });
	                                addSetters(parentGroup, htmlGroupStyle);
	                            });

	                        }
	                    } else {
	                        htmlGroup = container;
	                    }

	                    htmlGroup.appendChild(element);

	                    // Shared with VML:
	                    wrapper.added = true;
	                    if (wrapper.alignOnAdd) {
	                        wrapper.htmlUpdateTransform();
	                    }

	                    return wrapper;
	                };
	            }
	            return wrapper;
	        }
	    });


	    /* ****************************************************************************
	     *                                                                            *
	     * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
	     *                                                                            *
	     * For applications and websites that don't need IE support, like platform    *
	     * targeted mobile apps and web apps, this code can be removed.               *
	     *                                                                            *
	     *****************************************************************************/

	    /**
	     * @constructor
	     */
	    var VMLRenderer, VMLElement;
	    if (!hasSVG && !useCanVG) {

	    /**
	     * The VML element wrapper.
	     */
	    VMLElement = {

	        /**
	         * Initialize a new VML element wrapper. It builds the markup as a string
	         * to minimize DOM traffic.
	         * @param {Object} renderer
	         * @param {Object} nodeName
	         */
	        init: function (renderer, nodeName) {
	            var wrapper = this,
	                markup =  ['<', nodeName, ' filled="f" stroked="f"'],
	                style = ['position: ', ABSOLUTE, ';'],
	                isDiv = nodeName === DIV;

	            // divs and shapes need size
	            if (nodeName === 'shape' || isDiv) {
	                style.push('left:0;top:0;width:1px;height:1px;');
	            }
	            style.push('visibility: ', isDiv ? HIDDEN : VISIBLE);

	            markup.push(' style="', style.join(''), '"/>');

	            // create element with default attributes and style
	            if (nodeName) {
	                markup = isDiv || nodeName === 'span' || nodeName === 'img' ?
	                    markup.join('')    :
	                    renderer.prepVML(markup);
	                wrapper.element = createElement(markup);
	            }

	            wrapper.renderer = renderer;
	        },

	        /**
	         * Add the node to the given parent
	         * @param {Object} parent
	         */
	        add: function (parent) {
	            var wrapper = this,
	                renderer = wrapper.renderer,
	                element = wrapper.element,
	                box = renderer.box,
	                inverted = parent && parent.inverted,

	                // get the parent node
	                parentNode = parent ?
	                    parent.element || parent :
	                    box;

	            if (parent) {
	                this.parentGroup = parent;
	            }

	            // if the parent group is inverted, apply inversion on all children
	            if (inverted) { // only on groups
	                renderer.invertChild(element, parentNode);
	            }

	            // append it
	            parentNode.appendChild(element);

	            // align text after adding to be able to read offset
	            wrapper.added = true;
	            if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
	                wrapper.updateTransform();
	            }

	            // fire an event for internal hooks
	            if (wrapper.onAdd) {
	                wrapper.onAdd();
	            }

	            return wrapper;
	        },

	        /**
	         * VML always uses htmlUpdateTransform
	         */
	        updateTransform: SVGElement.prototype.htmlUpdateTransform,

	        /**
	         * Set the rotation of a span with oldIE's filter
	         */
	        setSpanRotation: function () {
	            // Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented
	            // but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+
	            // has support for CSS3 transform. The getBBox method also needs to be updated
	            // to compensate for the rotation, like it currently does for SVG.
	            // Test case: http://jsfiddle.net/highcharts/Ybt44/

	            var rotation = this.rotation,
	                costheta = mathCos(rotation * deg2rad),
	                sintheta = mathSin(rotation * deg2rad);

	            css(this.element, {
	                filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
	                    ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
	                    ', sizingMethod=\'auto expand\')'].join('') : NONE
	            });
	        },

	        /**
	         * Get the positioning correction for the span after rotating.
	         */
	        getSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {

	            var costheta = rotation ? mathCos(rotation * deg2rad) : 1,
	                sintheta = rotation ? mathSin(rotation * deg2rad) : 0,
	                height = pick(this.elemHeight, this.element.offsetHeight),
	                quad,
	                nonLeft = align && align !== 'left';

	            // correct x and y
	            this.xCorr = costheta < 0 && -width;
	            this.yCorr = sintheta < 0 && -height;

	            // correct for baseline and corners spilling out after rotation
	            quad = costheta * sintheta < 0;
	            this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
	            this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
	            // correct for the length/height of the text
	            if (nonLeft) {
	                this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
	                if (rotation) {
	                    this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
	                }
	                css(this.element, {
	                    textAlign: align
	                });
	            }
	        },

	        /**
	         * Converts a subset of an SVG path definition to its VML counterpart. Takes an array
	         * as the parameter and returns a string.
	         */
	        pathToVML: function (value) {
	            // convert paths
	            var i = value.length,
	                path = [];

	            while (i--) {

	                // Multiply by 10 to allow subpixel precision.
	                // Substracting half a pixel seems to make the coordinates
	                // align with SVG, but this hasn't been tested thoroughly
	                if (isNumber(value[i])) {
	                    path[i] = mathRound(value[i] * 10) - 5;
	                } else if (value[i] === 'Z') { // close the path
	                    path[i] = 'x';
	                } else {
	                    path[i] = value[i];

	                    // When the start X and end X coordinates of an arc are too close,
	                    // they are rounded to the same value above. In this case, substract or
	                    // add 1 from the end X and Y positions. #186, #760, #1371, #1410.
	                    if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {
	                        // Start and end X
	                        if (path[i + 5] === path[i + 7]) {
	                            path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;
	                        }
	                        // Start and end Y
	                        if (path[i + 6] === path[i + 8]) {
	                            path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;
	                        }
	                    }
	                }
	            }


	            // Loop up again to handle path shortcuts (#2132)
	            /*while (i++ < path.length) {
	                if (path[i] === 'H') { // horizontal line to
	                    path[i] = 'L';
	                    path.splice(i + 2, 0, path[i - 1]);
	                } else if (path[i] === 'V') { // vertical line to
	                    path[i] = 'L';
	                    path.splice(i + 1, 0, path[i - 2]);
	                }
	            }*/
	            return path.join(' ') || 'x';
	        },

	        /**
	         * Set the element's clipping to a predefined rectangle
	         *
	         * @param {String} id The id of the clip rectangle
	         */
	        clip: function (clipRect) {
	            var wrapper = this,
	                clipMembers,
	                cssRet;

	            if (clipRect) {
	                clipMembers = clipRect.members;
	                erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)
	                clipMembers.push(wrapper);
	                wrapper.destroyClip = function () {
	                    erase(clipMembers, wrapper);
	                };
	                cssRet = clipRect.getCSS(wrapper);

	            } else {
	                if (wrapper.destroyClip) {
	                    wrapper.destroyClip();
	                }
	                cssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214
	            }

	            return wrapper.css(cssRet);

	        },

	        /**
	         * Set styles for the element
	         * @param {Object} styles
	         */
	        css: SVGElement.prototype.htmlCss,

	        /**
	         * Removes a child either by removeChild or move to garbageBin.
	         * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
	         */
	        safeRemoveChild: function (element) {
	            // discardElement will detach the node from its parent before attaching it
	            // to the garbage bin. Therefore it is important that the node is attached and have parent.
	            if (element.parentNode) {
	                discardElement(element);
	            }
	        },

	        /**
	         * Extend element.destroy by removing it from the clip members array
	         */
	        destroy: function () {
	            if (this.destroyClip) {
	                this.destroyClip();
	            }

	            return SVGElement.prototype.destroy.apply(this);
	        },

	        /**
	         * Add an event listener. VML override for normalizing event parameters.
	         * @param {String} eventType
	         * @param {Function} handler
	         */
	        on: function (eventType, handler) {
	            // simplest possible event model for internal use
	            this.element['on' + eventType] = function () {
	                var evt = win.event;
	                evt.target = evt.srcElement;
	                handler(evt);
	            };
	            return this;
	        },

	        /**
	         * In stacked columns, cut off the shadows so that they don't overlap
	         */
	        cutOffPath: function (path, length) {

	            var len;

	            path = path.split(/[ ,]/);
	            len = path.length;

	            if (len === 9 || len === 11) {
	                path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
	            }
	            return path.join(' ');
	        },

	        /**
	         * Apply a drop shadow by copying elements and giving them different strokes
	         * @param {Boolean|Object} shadowOptions
	         */
	        shadow: function (shadowOptions, group, cutOff) {
	            var shadows = [],
	                i,
	                element = this.element,
	                renderer = this.renderer,
	                shadow,
	                elemStyle = element.style,
	                markup,
	                path = element.path,
	                strokeWidth,
	                modifiedPath,
	                shadowWidth,
	                shadowElementOpacity;

	            // some times empty paths are not strings
	            if (path && typeof path.value !== 'string') {
	                path = 'x';
	            }
	            modifiedPath = path;

	            if (shadowOptions) {
	                shadowWidth = pick(shadowOptions.width, 3);
	                shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
	                for (i = 1; i <= 3; i++) {

	                    strokeWidth = (shadowWidth * 2) + 1 - (2 * i);

	                    // Cut off shadows for stacked column items
	                    if (cutOff) {
	                        modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);
	                    }

	                    markup = ['<shape isShadow="true" strokeweight="', strokeWidth,
	                        '" filled="false" path="', modifiedPath,
	                        '" coordsize="10 10" style="', element.style.cssText, '" />'];

	                    shadow = createElement(renderer.prepVML(markup),
	                        null, {
	                            left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
	                            top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
	                        }
	                    );
	                    if (cutOff) {
	                        shadow.cutOff = strokeWidth + 1;
	                    }

	                    // apply the opacity
	                    markup = ['<stroke color="', shadowOptions.color || 'black', '" opacity="', shadowElementOpacity * i, '"/>'];
	                    createElement(renderer.prepVML(markup), null, null, shadow);


	                    // insert it
	                    if (group) {
	                        group.element.appendChild(shadow);
	                    } else {
	                        element.parentNode.insertBefore(shadow, element);
	                    }

	                    // record it
	                    shadows.push(shadow);

	                }

	                this.shadows = shadows;
	            }
	            return this;
	        },
	        updateShadows: noop, // Used in SVG only

	        setAttr: function (key, value) {
	            if (docMode8) { // IE8 setAttribute bug
	                this.element[key] = value;
	            } else {
	                this.element.setAttribute(key, value);
	            }
	        },
	        classSetter: function (value) {
	            // IE8 Standards mode has problems retrieving the className unless set like this
	            this.element.className = value;
	        },
	        dashstyleSetter: function (value, key, element) {
	            var strokeElem = element.getElementsByTagName('stroke')[0] ||
	                createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);
	            strokeElem[key] = value || 'solid';
	            this[key] = value; /* because changing stroke-width will change the dash length
	                and cause an epileptic effect */
	        },
	        dSetter: function (value, key, element) {
	            var i,
	                shadows = this.shadows;
	            value = value || [];
	            this.d = value.join && value.join(' '); // used in getter for animation

	            element.path = value = this.pathToVML(value);

	            // update shadows
	            if (shadows) {
	                i = shadows.length;
	                while (i--) {
	                    shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
	                }
	            }
	            this.setAttr(key, value);
	        },
	        fillSetter: function (value, key, element) {
	            var nodeName = element.nodeName;
	            if (nodeName === 'SPAN') { // text color
	                element.style.color = value;
	            } else if (nodeName !== 'IMG') { // #1336
	                element.filled = value !== NONE;
	                this.setAttr('fillcolor', this.renderer.color(value, element, key, this));
	            }
	        },
	        'fill-opacitySetter': function (value, key, element) {
	            createElement(
	                this.renderer.prepVML(['<', key.split('-')[0], ' opacity="', value, '"/>']),
	                null,
	                null,
	                element
	            );
	        },
	        opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts
	        rotationSetter: function (value, key, element) {
	            var style = element.style;
	            this[key] = style[key] = value; // style is for #1873

	            // Correction for the 1x1 size of the shape container. Used in gauge needles.
	            style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;
	            style.top = mathRound(mathCos(value * deg2rad)) + PX;
	        },
	        strokeSetter: function (value, key, element) {
	            this.setAttr('strokecolor', this.renderer.color(value, element, key, this));
	        },
	        'stroke-widthSetter': function (value, key, element) {
	            element.stroked = !!value; // VML "stroked" attribute
	            this[key] = value; // used in getter, issue #113
	            if (isNumber(value)) {
	                value += PX;
	            }
	            this.setAttr('strokeweight', value);
	        },
	        titleSetter: function (value, key) {
	            this.setAttr(key, value);
	        },
	        visibilitySetter: function (value, key, element) {

	            // Handle inherited visibility
	            if (value === 'inherit') {
	                value = VISIBLE;
	            }

	            // Let the shadow follow the main element
	            if (this.shadows) {
	                each(this.shadows, function (shadow) {
	                    shadow.style[key] = value;
	                });
	            }

	            // Instead of toggling the visibility CSS property, move the div out of the viewport.
	            // This works around #61 and #586
	            if (element.nodeName === 'DIV') {
	                value = value === HIDDEN ? '-999em' : 0;

	                // In order to redraw, IE7 needs the div to be visible when tucked away
	                // outside the viewport. So the visibility is actually opposite of
	                // the expected value. This applies to the tooltip only.
	                if (!docMode8) {
	                    element.style[key] = value ? VISIBLE : HIDDEN;
	                }
	                key = 'top';
	            }
	            element.style[key] = value;
	        },
	        xSetter: function (value, key, element) {
	            this[key] = value; // used in getter

	            if (key === 'x') {
	                key = 'left';
	            } else if (key === 'y') {
	                key = 'top';
	            }/* else {
	                value = mathMax(0, value); // don't set width or height below zero (#311)
	            }*/

	            // clipping rectangle special
	            if (this.updateClipping) {
	                this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'
	                this.updateClipping();
	            } else {
	                // normal
	                element.style[key] = value;
	            }
	        },
	        zIndexSetter: function (value, key, element) {
	            element.style[key] = value;
	        }
	    };
	    VMLElement['stroke-opacitySetter'] = VMLElement['fill-opacitySetter'];

	    Highcharts.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);

	    // Some shared setters
	    VMLElement.prototype.ySetter =
	        VMLElement.prototype.widthSetter =
	        VMLElement.prototype.heightSetter =
	        VMLElement.prototype.xSetter;


	    /**
	     * The VML renderer
	     */
	    var VMLRendererExtension = { // inherit SVGRenderer

	        Element: VMLElement,
	        isIE8: userAgent.indexOf('MSIE 8.0') > -1,


	        /**
	         * Initialize the VMLRenderer
	         * @param {Object} container
	         * @param {Number} width
	         * @param {Number} height
	         */
	        init: function (container, width, height, style) {
	            var renderer = this,
	                boxWrapper,
	                box,
	                css;

	            renderer.alignedObjects = [];

	            boxWrapper = renderer.createElement(DIV)
	                .css(extend(this.getStyle(style), { position: 'relative' }));
	            box = boxWrapper.element;
	            container.appendChild(boxWrapper.element);


	            // generate the containing box
	            renderer.isVML = true;
	            renderer.box = box;
	            renderer.boxWrapper = boxWrapper;
	            renderer.gradients = {};
	            renderer.cache = {}; // Cache for numerical bounding boxes
	            renderer.cacheKeys = [];
	            renderer.imgCount = 0;


	            renderer.setSize(width, height, false);

	            // The only way to make IE6 and IE7 print is to use a global namespace. However,
	            // with IE8 the only way to make the dynamic shapes visible in screen and print mode
	            // seems to be to add the xmlns attribute and the behaviour style inline.
	            if (!doc.namespaces.hcv) {

	                doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');

	                // Setup default CSS (#2153, #2368, #2384)
	                css = 'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke' +
	                    '{ behavior:url(#default#VML); display: inline-block; } ';
	                try {
	                    doc.createStyleSheet().cssText = css;
	                } catch (e) {
	                    doc.styleSheets[0].cssText += css;
	                }

	            }
	        },


	        /**
	         * Detect whether the renderer is hidden. This happens when one of the parent elements
	         * has display: none
	         */
	        isHidden: function () {
	            return !this.box.offsetWidth;
	        },

	        /**
	         * Define a clipping rectangle. In VML it is accomplished by storing the values
	         * for setting the CSS style to all associated members.
	         *
	         * @param {Number} x
	         * @param {Number} y
	         * @param {Number} width
	         * @param {Number} height
	         */
	        clipRect: function (x, y, width, height) {

	            // create a dummy element
	            var clipRect = this.createElement(),
	                isObj = isObject(x);

	            // mimic a rectangle with its style object for automatic updating in attr
	            return extend(clipRect, {
	                members: [],
	                count: 0,
	                left: (isObj ? x.x : x) + 1,
	                top: (isObj ? x.y : y) + 1,
	                width: (isObj ? x.width : width) - 1,
	                height: (isObj ? x.height : height) - 1,
	                getCSS: function (wrapper) {
	                    var element = wrapper.element,
	                        nodeName = element.nodeName,
	                        isShape = nodeName === 'shape',
	                        inverted = wrapper.inverted,
	                        rect = this,
	                        top = rect.top - (isShape ? element.offsetTop : 0),
	                        left = rect.left,
	                        right = left + rect.width,
	                        bottom = top + rect.height,
	                        ret = {
	                            clip: 'rect(' +
	                                mathRound(inverted ? left : top) + 'px,' +
	                                mathRound(inverted ? bottom : right) + 'px,' +
	                                mathRound(inverted ? right : bottom) + 'px,' +
	                                mathRound(inverted ? top : left) + 'px)'
	                        };

	                    // issue 74 workaround
	                    if (!inverted && docMode8 && nodeName === 'DIV') {
	                        extend(ret, {
	                            width: right + PX,
	                            height: bottom + PX
	                        });
	                    }
	                    return ret;
	                },

	                // used in attr and animation to update the clipping of all members
	                updateClipping: function () {
	                    each(clipRect.members, function (member) {
	                        if (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.
	                            member.css(clipRect.getCSS(member));
	                        }
	                    });
	                }
	            });

	        },


	        /**
	         * Take a color and return it if it's a string, make it a gradient if it's a
	         * gradient configuration object, and apply opacity.
	         *
	         * @param {Object} color The color or config object
	         */
	        color: function (color, elem, prop, wrapper) {
	            var renderer = this,
	                colorObject,
	                regexRgba = /^rgba/,
	                markup,
	                fillType,
	                ret = NONE;

	            // Check for linear or radial gradient
	            if (color && color.linearGradient) {
	                fillType = 'gradient';
	            } else if (color && color.radialGradient) {
	                fillType = 'pattern';
	            }


	            if (fillType) {

	                var stopColor,
	                    stopOpacity,
	                    gradient = color.linearGradient || color.radialGradient,
	                    x1,
	                    y1,
	                    x2,
	                    y2,
	                    opacity1,
	                    opacity2,
	                    color1,
	                    color2,
	                    fillAttr = '',
	                    stops = color.stops,
	                    firstStop,
	                    lastStop,
	                    colors = [],
	                    addFillNode = function () {
	                        // Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2
	                        // are reversed.
	                        markup = ['<fill colors="' + colors.join(',') + '" opacity="', opacity2, '" o:opacity2="', opacity1,
	                            '" type="', fillType, '" ', fillAttr, 'focus="100%" method="any" />'];
	                        createElement(renderer.prepVML(markup), null, null, elem);
	                    };

	                // Extend from 0 to 1
	                firstStop = stops[0];
	                lastStop = stops[stops.length - 1];
	                if (firstStop[0] > 0) {
	                    stops.unshift([
	                        0,
	                        firstStop[1]
	                    ]);
	                }
	                if (lastStop[0] < 1) {
	                    stops.push([
	                        1,
	                        lastStop[1]
	                    ]);
	                }

	                // Compute the stops
	                each(stops, function (stop, i) {
	                    if (regexRgba.test(stop[1])) {
	                        colorObject = Color(stop[1]);
	                        stopColor = colorObject.get('rgb');
	                        stopOpacity = colorObject.get('a');
	                    } else {
	                        stopColor = stop[1];
	                        stopOpacity = 1;
	                    }

	                    // Build the color attribute
	                    colors.push((stop[0] * 100) + '% ' + stopColor);

	                    // Only start and end opacities are allowed, so we use the first and the last
	                    if (!i) {
	                        opacity1 = stopOpacity;
	                        color2 = stopColor;
	                    } else {
	                        opacity2 = stopOpacity;
	                        color1 = stopColor;
	                    }
	                });

	                // Apply the gradient to fills only.
	                if (prop === 'fill') {

	                    // Handle linear gradient angle
	                    if (fillType === 'gradient') {
	                        x1 = gradient.x1 || gradient[0] || 0;
	                        y1 = gradient.y1 || gradient[1] || 0;
	                        x2 = gradient.x2 || gradient[2] || 0;
	                        y2 = gradient.y2 || gradient[3] || 0;
	                        fillAttr = 'angle="' + (90  - math.atan(
	                            (y2 - y1) / // y vector
	                            (x2 - x1) // x vector
	                            ) * 180 / mathPI) + '"';

	                        addFillNode();

	                    // Radial (circular) gradient
	                    } else {

	                        var r = gradient.r,
	                            sizex = r * 2,
	                            sizey = r * 2,
	                            cx = gradient.cx,
	                            cy = gradient.cy,
	                            radialReference = elem.radialReference,
	                            bBox,
	                            applyRadialGradient = function () {
	                                if (radialReference) {
	                                    bBox = wrapper.getBBox();
	                                    cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;
	                                    cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;
	                                    sizex *= radialReference[2] / bBox.width;
	                                    sizey *= radialReference[2] / bBox.height;
	                                }
	                                fillAttr = 'src="' + defaultOptions.global.VMLRadialGradientURL + '" ' +
	                                    'size="' + sizex + ',' + sizey + '" ' +
	                                    'origin="0.5,0.5" ' +
	                                    'position="' + cx + ',' + cy + '" ' +
	                                    'color2="' + color2 + '" ';

	                                addFillNode();
	                            };

	                        // Apply radial gradient
	                        if (wrapper.added) {
	                            applyRadialGradient();
	                        } else {
	                            // We need to know the bounding box to get the size and position right
	                            wrapper.onAdd = applyRadialGradient;
	                        }

	                        // The fill element's color attribute is broken in IE8 standards mode, so we
	                        // need to set the parent shape's fillcolor attribute instead.
	                        ret = color1;
	                    }

	                // Gradients are not supported for VML stroke, return the first color. #722.
	                } else {
	                    ret = stopColor;
	                }

	            // If the color is an rgba color, split it and add a fill node
	            // to hold the opacity component
	            } else if (regexRgba.test(color) && elem.tagName !== 'IMG') {

	                colorObject = Color(color);

	                wrapper[prop + '-opacitySetter'](colorObject.get('a'), prop, elem);

	                ret = colorObject.get('rgb');


	            } else {
	                var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node
	                if (propNodes.length) {
	                    propNodes[0].opacity = 1;
	                    propNodes[0].type = 'solid';
	                }
	                ret = color;
	            }

	            return ret;
	        },

	        /**
	         * Take a VML string and prepare it for either IE8 or IE6/IE7.
	         * @param {Array} markup A string array of the VML markup to prepare
	         */
	        prepVML: function (markup) {
	            var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
	                isIE8 = this.isIE8;

	            markup = markup.join('');

	            if (isIE8) { // add xmlns and style inline
	                markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
	                if (markup.indexOf('style="') === -1) {
	                    markup = markup.replace('/>', ' style="' + vmlStyle + '" />');
	                } else {
	                    markup = markup.replace('style="', 'style="' + vmlStyle);
	                }

	            } else { // add namespace
	                markup = markup.replace('<', '<hcv:');
	            }

	            return markup;
	        },

	        /**
	         * Create rotated and aligned text
	         * @param {String} str
	         * @param {Number} x
	         * @param {Number} y
	         */
	        text: SVGRenderer.prototype.html,

	        /**
	         * Create and return a path element
	         * @param {Array} path
	         */
	        path: function (path) {
	            var attr = {
	                // subpixel precision down to 0.1 (width and height = 1px)
	                coordsize: '10 10'
	            };
	            if (isArray(path)) {
	                attr.d = path;
	            } else if (isObject(path)) { // attributes
	                extend(attr, path);
	            }
	            // create the shape
	            return this.createElement('shape').attr(attr);
	        },

	        /**
	         * Create and return a circle element. In VML circles are implemented as
	         * shapes, which is faster than v:oval
	         * @param {Number} x
	         * @param {Number} y
	         * @param {Number} r
	         */
	        circle: function (x, y, r) {
	            var circle = this.symbol('circle');
	            if (isObject(x)) {
	                r = x.r;
	                y = x.y;
	                x = x.x;
	            }
	            circle.isCircle = true; // Causes x and y to mean center (#1682)
	            circle.r = r;
	            return circle.attr({ x: x, y: y });
	        },

	        /**
	         * Create a group using an outer div and an inner v:group to allow rotating
	         * and flipping. A simple v:group would have problems with positioning
	         * child HTML elements and CSS clip.
	         *
	         * @param {String} name The name of the group
	         */
	        g: function (name) {
	            var wrapper,
	                attribs;

	            // set the class name
	            if (name) {
	                attribs = { 'className': PREFIX + name, 'class': PREFIX + name };
	            }

	            // the div to hold HTML and clipping
	            wrapper = this.createElement(DIV).attr(attribs);

	            return wrapper;
	        },

	        /**
	         * VML override to create a regular HTML image
	         * @param {String} src
	         * @param {Number} x
	         * @param {Number} y
	         * @param {Number} width
	         * @param {Number} height
	         */
	        image: function (src, x, y, width, height) {
	            var obj = this.createElement('img')
	                .attr({ src: src });

	            if (arguments.length > 1) {
	                obj.attr({
	                    x: x,
	                    y: y,
	                    width: width,
	                    height: height
	                });
	            }
	            return obj;
	        },

	        /**
	         * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems
	         */
	        createElement: function (nodeName) {
	            return nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);
	        },

	        /**
	         * In the VML renderer, each child of an inverted div (group) is inverted
	         * @param {Object} element
	         * @param {Object} parentNode
	         */
	        invertChild: function (element, parentNode) {
	            var ren = this,
	                parentStyle = parentNode.style,
	                imgStyle = element.tagName === 'IMG' && element.style; // #1111

	            css(element, {
	                flip: 'x',
	                left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),
	                top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),
	                rotation: -90
	            });

	            // Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.
	            each(element.childNodes, function (child) {
	                ren.invertChild(child, element);
	            });
	        },

	        /**
	         * Symbol definitions that override the parent SVG renderer's symbols
	         *
	         */
	        symbols: {
	            // VML specific arc function
	            arc: function (x, y, w, h, options) {
	                var start = options.start,
	                    end = options.end,
	                    radius = options.r || w || h,
	                    innerRadius = options.innerR,
	                    cosStart = mathCos(start),
	                    sinStart = mathSin(start),
	                    cosEnd = mathCos(end),
	                    sinEnd = mathSin(end),
	                    ret;

	                if (end - start === 0) { // no angle, don't show it.
	                    return ['x'];
	                }

	                ret = [
	                    'wa', // clockwise arc to
	                    x - radius, // left
	                    y - radius, // top
	                    x + radius, // right
	                    y + radius, // bottom
	                    x + radius * cosStart, // start x
	                    y + radius * sinStart, // start y
	                    x + radius * cosEnd, // end x
	                    y + radius * sinEnd  // end y
	                ];

	                if (options.open && !innerRadius) {
	                    ret.push(
	                        'e',
	                        M,
	                        x, // - innerRadius,
	                        y// - innerRadius
	                    );
	                }

	                ret.push(
	                    'at', // anti clockwise arc to
	                    x - innerRadius, // left
	                    y - innerRadius, // top
	                    x + innerRadius, // right
	                    y + innerRadius, // bottom
	                    x + innerRadius * cosEnd, // start x
	                    y + innerRadius * sinEnd, // start y
	                    x + innerRadius * cosStart, // end x
	                    y + innerRadius * sinStart, // end y
	                    'x', // finish path
	                    'e' // close
	                );

	                ret.isArc = true;
	                return ret;

	            },
	            // Add circle symbol path. This performs significantly faster than v:oval.
	            circle: function (x, y, w, h, wrapper) {

	                if (wrapper) {
	                    w = h = 2 * wrapper.r;
	                }

	                // Center correction, #1682
	                if (wrapper && wrapper.isCircle) {
	                    x -= w / 2;
	                    y -= h / 2;
	                }

	                // Return the path
	                return [
	                    'wa', // clockwisearcto
	                    x, // left
	                    y, // top
	                    x + w, // right
	                    y + h, // bottom
	                    x + w, // start x
	                    y + h / 2,     // start y
	                    x + w, // end x
	                    y + h / 2,     // end y
	                    //'x', // finish path
	                    'e' // close
	                ];
	            },
	            /**
	             * Add rectangle symbol path which eases rotation and omits arcsize problems
	             * compared to the built-in VML roundrect shape. When borders are not rounded,
	             * use the simpler square path, else use the callout path without the arrow.
	             */
	            rect: function (x, y, w, h, options) {
	                return SVGRenderer.prototype.symbols[
	                    !defined(options) || !options.r ? 'square' : 'callout'
	                ].call(0, x, y, w, h, options);
	            }
	        }
	    };
	    Highcharts.VMLRenderer = VMLRenderer = function () {
	        this.init.apply(this, arguments);
	    };
	    VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);

	        // general renderer
	        Renderer = VMLRenderer;
	    }

	    // This method is used with exporting in old IE, when emulating SVG (see #2314)
	    SVGRenderer.prototype.measureSpanWidth = function (text, styles) {
	        var measuringSpan = doc.createElement('span'),
	            offsetWidth,
	            textNode = doc.createTextNode(text);

	        measuringSpan.appendChild(textNode);
	        css(measuringSpan, styles);
	        this.box.appendChild(measuringSpan);
	        offsetWidth = measuringSpan.offsetWidth;
	        discardElement(measuringSpan); // #2463
	        return offsetWidth;
	    };


	    /* ****************************************************************************
	     *                                                                            *
	     * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
	     *                                                                            *
	     *****************************************************************************/
	    /* ****************************************************************************
	     *                                                                            *
	     * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *
	     * TARGETING THAT SYSTEM.                                                     *
	     *                                                                            *
	     *****************************************************************************/
	    var CanVGRenderer,
	        CanVGController;

	    /**
	     * Downloads a script and executes a callback when done.
	     * @param {String} scriptLocation
	     * @param {Function} callback
	     */
	    function getScript(scriptLocation, callback) {
	        var head = doc.getElementsByTagName('head')[0],
	            script = doc.createElement('script');

	        script.type = 'text/javascript';
	        script.src = scriptLocation;
	        script.onload = callback;

	        head.appendChild(script);
	    }

	    if (useCanVG) {
	        /**
	         * The CanVGRenderer is empty from start to keep the source footprint small.
	         * When requested, the CanVGController downloads the rest of the source packaged
	         * together with the canvg library.
	         */
	        Highcharts.CanVGRenderer = CanVGRenderer = function () {
	            // Override the global SVG namespace to fake SVG/HTML that accepts CSS
	            SVG_NS = 'http://www.w3.org/1999/xhtml';
	        };

	        /**
	         * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but
	         * the implementation from SvgRenderer will not be merged in until first render.
	         */
	        CanVGRenderer.prototype.symbols = {};

	        /**
	         * Handles on demand download of canvg rendering support.
	         */
	        CanVGController = (function () {
	            // List of renderering calls
	            var deferredRenderCalls = [];

	            /**
	             * When downloaded, we are ready to draw deferred charts.
	             */
	            function drawDeferred() {
	                var callLength = deferredRenderCalls.length,
	                    callIndex;

	                // Draw all pending render calls
	                for (callIndex = 0; callIndex < callLength; callIndex++) {
	                    deferredRenderCalls[callIndex]();
	                }
	                // Clear the list
	                deferredRenderCalls = [];
	            }

	            return {
	                push: function (func, scriptLocation) {
	                    // Only get the script once
	                    if (deferredRenderCalls.length === 0) {
	                        getScript(scriptLocation, drawDeferred);
	                    }
	                    // Register render call
	                    deferredRenderCalls.push(func);
	                }
	            };
	        }());

	        Renderer = CanVGRenderer;
	    } // end CanVGRenderer

	    /* ****************************************************************************
	     *                                                                            *
	     * END OF ANDROID < 3 SPECIFIC CODE                                           *
	     *                                                                            *
	     *****************************************************************************/

	    /**
	     * The Tick class
	     */
	    function Tick(axis, pos, type, noLabel) {
	        this.axis = axis;
	        this.pos = pos;
	        this.type = type || '';
	        this.isNew = true;

	        if (!type && !noLabel) {
	            this.addLabel();
	        }
	    }

	    Tick.prototype = {
	        /**
	         * Write the tick label
	         */
	        addLabel: function () {
	            var tick = this,
	                axis = tick.axis,
	                options = axis.options,
	                chart = axis.chart,
	                categories = axis.categories,
	                names = axis.names,
	                pos = tick.pos,
	                labelOptions = options.labels,
	                str,
	                tickPositions = axis.tickPositions,
	                isFirst = pos === tickPositions[0],
	                isLast = pos === tickPositions[tickPositions.length - 1],
	                value = categories ?
	                    pick(categories[pos], names[pos], pos) :
	                    pos,
	                label = tick.label,
	                tickPositionInfo = tickPositions.info,
	                dateTimeLabelFormat;

	            // Set the datetime label format. If a higher rank is set for this position, use that. If not,
	            // use the general format.
	            if (axis.isDatetimeAxis && tickPositionInfo) {
	                dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
	            }
	            // set properties for access in render method
	            tick.isFirst = isFirst;
	            tick.isLast = isLast;

	            // get the string
	            str = axis.labelFormatter.call({
	                axis: axis,
	                chart: chart,
	                isFirst: isFirst,
	                isLast: isLast,
	                dateTimeLabelFormat: dateTimeLabelFormat,
	                value: axis.isLog ? correctFloat(lin2log(value)) : value
	            });

	            // prepare CSS
	            //css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };

	            // first call
	            if (!defined(label)) {

	                tick.label = label =
	                    defined(str) && labelOptions.enabled ?
	                        chart.renderer.text(
	                                str,
	                                0,
	                                0,
	                                labelOptions.useHTML
	                            )
	                            //.attr(attr)
	                            // without position absolute, IE export sometimes is wrong
	                            .css(merge(labelOptions.style))
	                            .add(axis.labelGroup) :
	                        null;
	                tick.labelLength = label && label.getBBox().width; // Un-rotated length
	                tick.rotation = 0; // Base value to detect change for new calls to getBBox

	            // update
	            } else if (label) {
	                label.attr({ text: str });
	            }
	        },

	        /**
	         * Get the offset height or width of the label
	         */
	        getLabelSize: function () {
	            return this.label ?
	                this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
	                0;
	        },

	        /**
	         * Handle the label overflow by adjusting the labels to the left and right edge, or
	         * hide them if they collide into the neighbour label.
	         */
	        handleOverflow: function (xy) {
	            var axis = this.axis,
	                pxPos = xy.x,
	                chartWidth = axis.chart.chartWidth,
	                spacing = axis.chart.spacing,
	                leftBound = pick(axis.labelLeft, mathMin(axis.pos, spacing[3])),
	                rightBound = pick(axis.labelRight, mathMax(axis.pos + axis.len, chartWidth - spacing[1])),
	                label = this.label,
	                rotation = this.rotation,
	                factor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],
	                labelWidth = label.getBBox().width,
	                slotWidth = axis.slotWidth,
	                xCorrection = factor,
	                goRight = 1,
	                leftPos,
	                rightPos,
	                textWidth,
	                css = {};

	            // Check if the label overshoots the chart spacing box. If it does, move it.
	            // If it now overshoots the slotWidth, add ellipsis.
	            if (!rotation) {
	                leftPos = pxPos - factor * labelWidth;
	                rightPos = pxPos + (1 - factor) * labelWidth;

	                if (leftPos < leftBound) {
	                    slotWidth = xy.x + slotWidth * (1 - factor) - leftBound;
	                } else if (rightPos > rightBound) {
	                    slotWidth = rightBound - xy.x + slotWidth * factor;
	                    goRight = -1;
	                }

	                slotWidth = mathMin(axis.slotWidth, slotWidth); // #4177
	                if (slotWidth < axis.slotWidth && axis.labelAlign === 'center') {
	                    xy.x += goRight * (axis.slotWidth - slotWidth - xCorrection * (axis.slotWidth - mathMin(labelWidth, slotWidth)));
	                }
	                // If the label width exceeds the available space, set a text width to be
	                // picked up below. Also, if a width has been set before, we need to set a new
	                // one because the reported labelWidth will be limited by the box (#3938).
	                if (labelWidth > slotWidth || (axis.autoRotation && label.styles.width)) {
	                    textWidth = slotWidth;
	                }

	            // Add ellipsis to prevent rotated labels to be clipped against the edge of the chart
	            } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
	                textWidth = mathRound(pxPos / mathCos(rotation * deg2rad) - leftBound);
	            } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
	                textWidth = mathRound((chartWidth - pxPos) / mathCos(rotation * deg2rad));
	            }

	            if (textWidth) {
	                css.width = textWidth;
	                if (!axis.options.labels.style.textOverflow) {
	                    css.textOverflow = 'ellipsis';
	                }
	                label.css(css);
	            }
	        },

	        /**
	         * Get the x and y position for ticks and labels
	         */
	        getPosition: function (horiz, pos, tickmarkOffset, old) {
	            var axis = this.axis,
	                chart = axis.chart,
	                cHeight = (old && chart.oldChartHeight) || chart.chartHeight;

	            return {
	                x: horiz ?
	                    axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :
	                    axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),

	                y: horiz ?
	                    cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :
	                    cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
	            };

	        },

	        /**
	         * Get the x, y position of the tick label
	         */
	        getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
	            var axis = this.axis,
	                transA = axis.transA,
	                reversed = axis.reversed,
	                staggerLines = axis.staggerLines,
	                rotCorr = axis.tickRotCorr || { x: 0, y: 0 },
	                yOffset = labelOptions.y,
	                line;

	            if (!defined(yOffset)) {
	                yOffset = axis.side === 2 ? 
	                    rotCorr.y + 8 :
	                    // #3140, #3140
	                    yOffset = mathCos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(false, 0).height / 2);
	            }

	            x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?
	                tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
	            y = y + yOffset - (tickmarkOffset && !horiz ?
	                tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

	            // Correct for staggered labels
	            if (staggerLines) {
	                line = (index / (step || 1) % staggerLines);
	                if (axis.opposite) {
	                    line = staggerLines - line - 1;
	                }
	                y += line * (axis.labelOffset / staggerLines);
	            }

	            return {
	                x: x,
	                y: mathRound(y)
	            };
	        },

	        /**
	         * Extendible method to return the path of the marker
	         */
	        getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {
	            return renderer.crispLine([
	                M,
	                x,
	                y,
	                L,
	                x + (horiz ? 0 : -tickLength),
	                y + (horiz ? tickLength : 0)
	            ], tickWidth);
	        },

	        /**
	         * Put everything in place
	         *
	         * @param index {Number}
	         * @param old {Boolean} Use old coordinates to prepare an animation into new position
	         */
	        render: function (index, old, opacity) {
	            var tick = this,
	                axis = tick.axis,
	                options = axis.options,
	                chart = axis.chart,
	                renderer = chart.renderer,
	                horiz = axis.horiz,
	                type = tick.type,
	                label = tick.label,
	                pos = tick.pos,
	                labelOptions = options.labels,
	                gridLine = tick.gridLine,
	                gridPrefix = type ? type + 'Grid' : 'grid',
	                tickPrefix = type ? type + 'Tick' : 'tick',
	                gridLineWidth = options[gridPrefix + 'LineWidth'],
	                gridLineColor = options[gridPrefix + 'LineColor'],
	                dashStyle = options[gridPrefix + 'LineDashStyle'],
	                tickLength = options[tickPrefix + 'Length'],
	                tickWidth = pick(options[tickPrefix + 'Width'], !type && axis.isXAxis ? 1 : 0), // X axis defaults to 1
	                tickColor = options[tickPrefix + 'Color'],
	                tickPosition = options[tickPrefix + 'Position'],
	                gridLinePath,
	                mark = tick.mark,
	                markPath,
	                step = /*axis.labelStep || */labelOptions.step,
	                attribs,
	                show = true,
	                tickmarkOffset = axis.tickmarkOffset,
	                xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
	                x = xy.x,
	                y = xy.y,
	                reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687

	            opacity = pick(opacity, 1);
	            this.isActive = true;

	            // create the grid line
	            if (gridLineWidth) {
	                gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);

	                if (gridLine === UNDEFINED) {
	                    attribs = {
	                        stroke: gridLineColor,
	                        'stroke-width': gridLineWidth
	                    };
	                    if (dashStyle) {
	                        attribs.dashstyle = dashStyle;
	                    }
	                    if (!type) {
	                        attribs.zIndex = 1;
	                    }
	                    if (old) {
	                        attribs.opacity = 0;
	                    }
	                    tick.gridLine = gridLine =
	                        gridLineWidth ?
	                            renderer.path(gridLinePath)
	                                .attr(attribs).add(axis.gridGroup) :
	                            null;
	                }

	                // If the parameter 'old' is set, the current call will be followed
	                // by another call, therefore do not do any animations this time
	                if (!old && gridLine && gridLinePath) {
	                    gridLine[tick.isNew ? 'attr' : 'animate']({
	                        d: gridLinePath,
	                        opacity: opacity
	                    });
	                }
	            }

	            // create the tick mark
	            if (tickWidth && tickLength) {

	                // negate the length
	                if (tickPosition === 'inside') {
	                    tickLength = -tickLength;
	                }
	                if (axis.opposite) {
	                    tickLength = -tickLength;
	                }

	                markPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);
	                if (mark) { // updating
	                    mark.animate({
	                        d: markPath,
	                        opacity: opacity
	                    });
	                } else { // first time
	                    tick.mark = renderer.path(
	                        markPath
	                    ).attr({
	                        stroke: tickColor,
	                        'stroke-width': tickWidth,
	                        opacity: opacity
	                    }).add(axis.axisGroup);
	                }
	            }

	            // the label is created on init - now move it into place
	            if (label && !isNaN(x)) {
	                label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);

	                // Apply show first and show last. If the tick is both first and last, it is
	                // a single centered tick, in which case we show the label anyway (#2100).
	                if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||
	                        (tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {
	                    show = false;

	                // Handle label overflow and show or hide accordingly
	                } else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
	                    tick.handleOverflow(xy);
	                }

	                // apply step
	                if (step && index % step) {
	                    // show those indices dividable by step
	                    show = false;
	                }

	                // Set the new position, and show or hide
	                if (show && !isNaN(xy.y)) {
	                    xy.opacity = opacity;
	                    label[tick.isNew ? 'attr' : 'animate'](xy);
	                    tick.isNew = false;
	                } else {
	                    label.attr('y', -9999); // #1338
	                }
	            }
	        },

	        /**
	         * Destructor for the tick prototype
	         */
	        destroy: function () {
	            destroyObjectProperties(this, this.axis);
	        }
	    };

	    /**
	     * The object wrapper for plot lines and plot bands
	     * @param {Object} options
	     */
	    Highcharts.PlotLineOrBand = function (axis, options) {
	        this.axis = axis;

	        if (options) {
	            this.options = options;
	            this.id = options.id;
	        }
	    };

	    Highcharts.PlotLineOrBand.prototype = {

	        /**
	         * Render the plot line or plot band. If it is already existing,
	         * move it.
	         */
	        render: function () {
	            var plotLine = this,
	                axis = plotLine.axis,
	                horiz = axis.horiz,
	                options = plotLine.options,
	                optionsLabel = options.label,
	                label = plotLine.label,
	                width = options.width,
	                to = options.to,
	                from = options.from,
	                isBand = defined(from) && defined(to),
	                value = options.value,
	                dashStyle = options.dashStyle,
	                svgElem = plotLine.svgElem,
	                path = [],
	                addEvent,
	                eventType,
	                color = options.color,
	                zIndex = pick(options.zIndex, 0),
	                events = options.events,
	                attribs = {},
	                renderer = axis.chart.renderer;

	            // logarithmic conversion
	            if (axis.isLog) {
	                from = log2lin(from);
	                to = log2lin(to);
	                value = log2lin(value);
	            }

	            // plot line
	            if (width) {
	                path = axis.getPlotLinePath(value, width);
	                attribs = {
	                    stroke: color,
	                    'stroke-width': width
	                };
	                if (dashStyle) {
	                    attribs.dashstyle = dashStyle;
	                }
	            } else if (isBand) { // plot band

	                path = axis.getPlotBandPath(from, to, options);
	                if (color) {
	                    attribs.fill = color;
	                }
	                if (options.borderWidth) {
	                    attribs.stroke = options.borderColor;
	                    attribs['stroke-width'] = options.borderWidth;
	                }
	            } else {
	                return;
	            }
	            // zIndex
	            attribs.zIndex = zIndex;

	            // common for lines and bands
	            if (svgElem) {
	                if (path) {
	                    svgElem.show();
	                    svgElem.animate({ d: path });
	                } else {
	                    svgElem.hide();
	                    if (label) {
	                        plotLine.label = label = label.destroy();
	                    }
	                }
	            } else if (path && path.length) {
	                plotLine.svgElem = svgElem = renderer.path(path)
	                    .attr(attribs).add();

	                // events
	                if (events) {
	                    addEvent = function (eventType) {
	                        svgElem.on(eventType, function (e) {
	                            events[eventType].apply(plotLine, [e]);
	                        });
	                    };
	                    for (eventType in events) {
	                        addEvent(eventType);
	                    }
	                }
	            }

	            // the plot band/line label
	            if (optionsLabel && defined(optionsLabel.text) && path && path.length && 
	                    axis.width > 0 && axis.height > 0 && !path.flat) {
	                // apply defaults
	                optionsLabel = merge({
	                    align: horiz && isBand && 'center',
	                    x: horiz ? !isBand && 4 : 10,
	                    verticalAlign: !horiz && isBand && 'middle',
	                    y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
	                    rotation: horiz && !isBand && 90
	                }, optionsLabel);

	                this.renderLabel(optionsLabel, path, isBand, zIndex);

	            } else if (label) { // move out of sight
	                label.hide();
	            }

	            // chainable
	            return plotLine;
	        },

	        /**
	         * Render and align label for plot line or band.
	         */
	        renderLabel: function (optionsLabel, path, isBand, zIndex) {
	            var plotLine = this,
	                label = plotLine.label,
	                renderer = plotLine.axis.chart.renderer,
	                attribs,
	                xs,
	                ys,
	                x,
	                y;

	            // add the SVG element
	            if (!label) {
	                attribs = {
	                    align: optionsLabel.textAlign || optionsLabel.align,
	                    rotation: optionsLabel.rotation
	                };
	            
	                attribs.zIndex = zIndex;
	            
	                plotLine.label = label = renderer.text(
	                        optionsLabel.text,
	                        0,
	                        0,
	                        optionsLabel.useHTML
	                    )
	                    .attr(attribs)
	                    .css(optionsLabel.style)
	                    .add();
	            }

	            // get the bounding box and align the label
	            // #3000 changed to better handle choice between plotband or plotline
	            xs = [path[1], path[4], (isBand ? path[6] : path[1])];
	            ys = [path[2], path[5], (isBand ? path[7] : path[2])];
	            x = arrayMin(xs);
	            y = arrayMin(ys);

	            label.align(optionsLabel, false, {
	                x: x,
	                y: y,
	                width: arrayMax(xs) - x,
	                height: arrayMax(ys) - y
	            });
	            label.show();
	        },

	        /**
	         * Remove the plot line or band
	         */
	        destroy: function () {
	            // remove it from the lookup
	            erase(this.axis.plotLinesAndBands, this);

	            delete this.axis;
	            destroyObjectProperties(this);
	        }
	    };

	    /**
	     * Object with members for extending the Axis prototype
	     */

	    AxisPlotLineOrBandExtension = {

	        /**
	         * Create the path for a plot band
	         */
	        getPlotBandPath: function (from, to) {
	            var toPath = this.getPlotLinePath(to, null, null, true),
	                path = this.getPlotLinePath(from, null, null, true);

	            if (path && toPath) {

	                // Flat paths don't need labels (#3836)
	                path.flat = path.toString() === toPath.toString();

	                path.push(
	                    toPath[4],
	                    toPath[5],
	                    toPath[1],
	                    toPath[2]
	                );
	            } else { // outside the axis area
	                path = null;
	            }

	            return path;
	        },

	        addPlotBand: function (options) {
	            return this.addPlotBandOrLine(options, 'plotBands');
	        },

	        addPlotLine: function (options) {
	            return this.addPlotBandOrLine(options, 'plotLines');
	        },

	        /**
	         * Add a plot band or plot line after render time
	         *
	         * @param options {Object} The plotBand or plotLine configuration object
	         */
	        addPlotBandOrLine: function (options, coll) {
	            var obj = new Highcharts.PlotLineOrBand(this, options).render(),
	                userOptions = this.userOptions;

	            if (obj) { // #2189
	                // Add it to the user options for exporting and Axis.update
	                if (coll) {
	                    userOptions[coll] = userOptions[coll] || [];
	                    userOptions[coll].push(options);
	                }
	                this.plotLinesAndBands.push(obj);
	            }

	            return obj;
	        },

	        /**
	         * Remove a plot band or plot line from the chart by id
	         * @param {Object} id
	         */
	        removePlotBandOrLine: function (id) {
	            var plotLinesAndBands = this.plotLinesAndBands,
	                options = this.options,
	                userOptions = this.userOptions,
	                i = plotLinesAndBands.length;
	            while (i--) {
	                if (plotLinesAndBands[i].id === id) {
	                    plotLinesAndBands[i].destroy();
	                }
	            }
	            each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {
	                i = arr.length;
	                while (i--) {
	                    if (arr[i].id === id) {
	                        erase(arr, arr[i]);
	                    }
	                }
	            });
	        }
	    };

	    /**
	     * Create a new axis object
	     * @param {Object} chart
	     * @param {Object} options
	     */
	    var Axis = Highcharts.Axis = function () {
	        this.init.apply(this, arguments);
	    };

	    Axis.prototype = {

	        /**
	         * Default options for the X axis - the Y axis has extended defaults
	         */
	        defaultOptions: {
	            // allowDecimals: null,
	            // alternateGridColor: null,
	            // categories: [],
	            dateTimeLabelFormats: {
	                millisecond: '%H:%M:%S.%L',
	                second: '%H:%M:%S',
	                minute: '%H:%M',
	                hour: '%H:%M',
	                day: '%e. %b',
	                week: '%e. %b',
	                month: '%b \'%y',
	                year: '%Y'
	            },
	            endOnTick: false,
	            gridLineColor: '#D8D8D8',
	            // gridLineDashStyle: 'solid',
	            // gridLineWidth: 0,
	            // reversed: false,

	            labels: {
	                enabled: true,
	                // rotation: 0,
	                // align: 'center',
	                // step: null,
	                style: {
	                    color: '#606060',
	                    cursor: 'default',
	                    fontSize: '11px'
	                },
	                x: 0,
	                y: 15
	                /*formatter: function () {
	                    return this.value;
	                },*/
	            },
	            lineColor: '#C0D0E0',
	            lineWidth: 1,
	            //linkedTo: null,
	            //max: undefined,
	            //min: undefined,
	            minPadding: 0.01,
	            maxPadding: 0.01,
	            //minRange: null,
	            minorGridLineColor: '#E0E0E0',
	            // minorGridLineDashStyle: null,
	            minorGridLineWidth: 1,
	            minorTickColor: '#A0A0A0',
	            //minorTickInterval: null,
	            minorTickLength: 2,
	            minorTickPosition: 'outside', // inside or outside
	            //minorTickWidth: 0,
	            //opposite: false,
	            //offset: 0,
	            //plotBands: [{
	            //    events: {},
	            //    zIndex: 1,
	            //    labels: { align, x, verticalAlign, y, style, rotation, textAlign }
	            //}],
	            //plotLines: [{
	            //    events: {}
	            //  dashStyle: {}
	            //    zIndex:
	            //    labels: { align, x, verticalAlign, y, style, rotation, textAlign }
	            //}],
	            //reversed: false,
	            // showFirstLabel: true,
	            // showLastLabel: true,
	            startOfWeek: 1,
	            startOnTick: false,
	            tickColor: '#C0D0E0',
	            //tickInterval: null,
	            tickLength: 10,
	            tickmarkPlacement: 'between', // on or between
	            tickPixelInterval: 100,
	            tickPosition: 'outside',
	            //tickWidth: 1,
	            title: {
	                //text: null,
	                align: 'middle', // low, middle or high
	                //margin: 0 for horizontal, 10 for vertical axes,
	                //rotation: 0,
	                //side: 'outside',
	                style: {
	                    color: '#707070'
	                }
	                //x: 0,
	                //y: 0
	            },
	            type: 'linear' // linear, logarithmic or datetime
	            //visible: true
	        },

	        /**
	         * This options set extends the defaultOptions for Y axes
	         */
	        defaultYAxisOptions: {
	            endOnTick: true,
	            gridLineWidth: 1,
	            tickPixelInterval: 72,
	            showLastLabel: true,
	            labels: {
	                x: -8,
	                y: 3
	            },
	            lineWidth: 0,
	            maxPadding: 0.05,
	            minPadding: 0.05,
	            startOnTick: true,
	            //tickWidth: 0,
	            title: {
	                rotation: 270,
	                text: 'Values'
	            },
	            stackLabels: {
	                enabled: false,
	                //align: dynamic,
	                //y: dynamic,
	                //x: dynamic,
	                //verticalAlign: dynamic,
	                //textAlign: dynamic,
	                //rotation: 0,
	                formatter: function () {
	                    return Highcharts.numberFormat(this.total, -1);
	                },
	                style: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })
	            }
	        },

	        /**
	         * These options extend the defaultOptions for left axes
	         */
	        defaultLeftAxisOptions: {
	            labels: {
	                x: -15,
	                y: null
	            },
	            title: {
	                rotation: 270
	            }
	        },

	        /**
	         * These options extend the defaultOptions for right axes
	         */
	        defaultRightAxisOptions: {
	            labels: {
	                x: 15,
	                y: null
	            },
	            title: {
	                rotation: 90
	            }
	        },

	        /**
	         * These options extend the defaultOptions for bottom axes
	         */
	        defaultBottomAxisOptions: {
	            labels: {
	                autoRotation: [-45],
	                x: 0,
	                y: null // based on font size
	                // overflow: undefined,
	                // staggerLines: null
	            },
	            title: {
	                rotation: 0
	            }
	        },
	        /**
	         * These options extend the defaultOptions for top axes
	         */
	        defaultTopAxisOptions: {
	            labels: {
	                autoRotation: [-45],
	                x: 0,
	                y: -15
	                // overflow: undefined
	                // staggerLines: null
	            },
	            title: {
	                rotation: 0
	            }
	        },

	        /**
	         * Initialize the axis
	         */
	        init: function (chart, userOptions) {


	            var isXAxis = userOptions.isX,
	                axis = this;

	            axis.chart = chart;

	            // Flag, is the axis horizontal
	            axis.horiz = chart.inverted ? !isXAxis : isXAxis;

	            // Flag, isXAxis
	            axis.isXAxis = isXAxis;
	            axis.coll = isXAxis ? 'xAxis' : 'yAxis';

	            axis.opposite = userOptions.opposite; // needed in setOptions
	            axis.side = userOptions.side || (axis.horiz ?
	                    (axis.opposite ? 0 : 2) : // top : bottom
	                    (axis.opposite ? 1 : 3));  // right : left

	            axis.setOptions(userOptions);


	            var options = this.options,
	                type = options.type,
	                isDatetimeAxis = type === 'datetime';

	            axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format


	            // Flag, stagger lines or not
	            axis.userOptions = userOptions;

	            //axis.axisTitleMargin = UNDEFINED,// = options.title.margin,
	            axis.minPixelPadding = 0;

	            axis.reversed = options.reversed;
	            axis.visible = options.visible !== false;
	            axis.zoomEnabled = options.zoomEnabled !== false;

	            // Initial categories
	            axis.categories = options.categories || type === 'category';
	            axis.names = axis.names || []; // Preserve on update (#3830)

	            // Elements
	            //axis.axisGroup = UNDEFINED;
	            //axis.gridGroup = UNDEFINED;
	            //axis.axisTitle = UNDEFINED;
	            //axis.axisLine = UNDEFINED;

	            // Shorthand types
	            axis.isLog = type === 'logarithmic';
	            axis.isDatetimeAxis = isDatetimeAxis;

	            // Flag, if axis is linked to another axis
	            axis.isLinked = defined(options.linkedTo);
	            // Linked axis.
	            //axis.linkedParent = UNDEFINED;

	            // Tick positions
	            //axis.tickPositions = UNDEFINED; // array containing predefined positions
	            // Tick intervals
	            //axis.tickInterval = UNDEFINED;
	            //axis.minorTickInterval = UNDEFINED;


	            // Major ticks
	            axis.ticks = {};
	            axis.labelEdge = [];
	            // Minor ticks
	            axis.minorTicks = {};

	            // List of plotLines/Bands
	            axis.plotLinesAndBands = [];

	            // Alternate bands
	            axis.alternateBands = {};

	            // Axis metrics
	            //axis.left = UNDEFINED;
	            //axis.top = UNDEFINED;
	            //axis.width = UNDEFINED;
	            //axis.height = UNDEFINED;
	            //axis.bottom = UNDEFINED;
	            //axis.right = UNDEFINED;
	            //axis.transA = UNDEFINED;
	            //axis.transB = UNDEFINED;
	            //axis.oldTransA = UNDEFINED;
	            axis.len = 0;
	            //axis.oldMin = UNDEFINED;
	            //axis.oldMax = UNDEFINED;
	            //axis.oldUserMin = UNDEFINED;
	            //axis.oldUserMax = UNDEFINED;
	            //axis.oldAxisLength = UNDEFINED;
	            axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
	            axis.range = options.range;
	            axis.offset = options.offset || 0;


	            // Dictionary for stacks
	            axis.stacks = {};
	            axis.oldStacks = {};
	            axis.stacksTouched = 0;

	            // Min and max in the data
	            //axis.dataMin = UNDEFINED,
	            //axis.dataMax = UNDEFINED,

	            // The axis range
	            axis.max = null;
	            axis.min = null;

	            // User set min and max
	            //axis.userMin = UNDEFINED,
	            //axis.userMax = UNDEFINED,

	            // Crosshair options
	            axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);
	            // Run Axis

	            var eventType,
	                events = axis.options.events;

	            // Register
	            if (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()
	                if (isXAxis && !this.isColorAxis) { // #2713
	                    chart.axes.splice(chart.xAxis.length, 0, axis);
	                } else {
	                    chart.axes.push(axis);
	                }

	                chart[axis.coll].push(axis);
	            }

	            axis.series = axis.series || []; // populated by Series

	            // inverted charts have reversed xAxes as default
	            if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {
	                axis.reversed = true;
	            }

	            axis.removePlotBand = axis.removePlotBandOrLine;
	            axis.removePlotLine = axis.removePlotBandOrLine;


	            // register event listeners
	            for (eventType in events) {
	                addEvent(axis, eventType, events[eventType]);
	            }

	            // extend logarithmic axis
	            if (axis.isLog) {
	                axis.val2lin = log2lin;
	                axis.lin2val = lin2log;
	            }
	        },

	        /**
	         * Merge and set options
	         */
	        setOptions: function (userOptions) {
	            this.options = merge(
	                this.defaultOptions,
	                this.isXAxis ? {} : this.defaultYAxisOptions,
	                [this.defaultTopAxisOptions, this.defaultRightAxisOptions,
	                    this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],
	                merge(
	                    defaultOptions[this.coll], // if set in setOptions (#1053)
	                    userOptions
	                )
	            );
	        },

	        /**
	         * The default label formatter. The context is a special config object for the label.
	         */
	        defaultLabelFormatter: function () {
	            var axis = this.axis,
	                value = this.value,
	                categories = axis.categories,
	                dateTimeLabelFormat = this.dateTimeLabelFormat,
	                numericSymbols = defaultOptions.lang.numericSymbols,
	                i = numericSymbols && numericSymbols.length,
	                multi,
	                ret,
	                formatOption = axis.options.labels.format,

	                // make sure the same symbol is added for all labels on a linear axis
	                numericSymbolDetector = axis.isLog ? value : axis.tickInterval;

	            if (formatOption) {
	                ret = format(formatOption, this);

	            } else if (categories) {
	                ret = value;

	            } else if (dateTimeLabelFormat) { // datetime axis
	                ret = dateFormat(dateTimeLabelFormat, value);

	            } else if (i && numericSymbolDetector >= 1000) {
	                // Decide whether we should add a numeric symbol like k (thousands) or M (millions).
	                // If we are to enable this in tooltip or other places as well, we can move this
	                // logic to the numberFormatter and enable it by a parameter.
	                while (i-- && ret === UNDEFINED) {
	                    multi = Math.pow(1000, i + 1);
	                    if (numericSymbolDetector >= multi && (value * 10) % multi === 0 && numericSymbols[i] !== null) {
	                        ret = Highcharts.numberFormat(value / multi, -1) + numericSymbols[i];
	                    }
	                }
	            }

	            if (ret === UNDEFINED) {
	                if (mathAbs(value) >= 10000) { // add thousands separators
	                    ret = Highcharts.numberFormat(value, -1);

	                } else { // small numbers
	                    ret = Highcharts.numberFormat(value, -1, UNDEFINED, ''); // #2466
	                }
	            }

	            return ret;
	        },

	        /**
	         * Get the minimum and maximum for the series of each axis
	         */
	        getSeriesExtremes: function () {
	            var axis = this,
	                chart = axis.chart;

	            axis.hasVisibleSeries = false;

	            // Reset properties in case we're redrawing (#3353)
	            axis.dataMin = axis.dataMax = axis.threshold = null;
	            axis.softThreshold = !axis.isXAxis;

	            if (axis.buildStacks) {
	                axis.buildStacks();
	            }

	            // loop through this axis' series
	            each(axis.series, function (series) {

	                if (series.visible || !chart.options.chart.ignoreHiddenSeries) {

	                    var seriesOptions = series.options,
	                        xData,
	                        threshold = seriesOptions.threshold,
	                        seriesDataMin,
	                        seriesDataMax;

	                    axis.hasVisibleSeries = true;

	                    // Validate threshold in logarithmic axes
	                    if (axis.isLog && threshold <= 0) {
	                        threshold = null;
	                    }

	                    // Get dataMin and dataMax for X axes
	                    if (axis.isXAxis) {
	                        xData = series.xData;
	                        if (xData.length) {
	                            axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));
	                            axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));
	                        }

	                    // Get dataMin and dataMax for Y axes, as well as handle stacking and processed data
	                    } else {

	                        // Get this particular series extremes
	                        series.getExtremes();
	                        seriesDataMax = series.dataMax;
	                        seriesDataMin = series.dataMin;

	                        // Get the dataMin and dataMax so far. If percentage is used, the min and max are
	                        // always 0 and 100. If seriesDataMin and seriesDataMax is null, then series
	                        // doesn't have active y data, we continue with nulls
	                        if (defined(seriesDataMin) && defined(seriesDataMax)) {
	                            axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);
	                            axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);
	                        }

	                        // Adjust to threshold
	                        if (defined(threshold)) {
	                            axis.threshold = threshold;
	                        }
	                        // If any series has a hard threshold, it takes precedence
	                        if (!seriesOptions.softThreshold || axis.isLog) {
	                            axis.softThreshold = false;
	                        }
	                    }
	                }
	            });
	        },

	        /**
	         * Translate from axis value to pixel position on the chart, or back
	         *
	         */
	        translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {
	            var axis = this.linkedParent || this, // #1417
	                sign = 1,
	                cvsOffset = 0,
	                localA = old ? axis.oldTransA : axis.transA,
	                localMin = old ? axis.oldMin : axis.min,
	                returnValue,
	                minPixelPadding = axis.minPixelPadding,
	                doPostTranslate = (axis.isOrdinal || axis.isBroken || (axis.isLog && handleLog)) && axis.lin2val;

	            if (!localA) {
	                localA = axis.transA;
	            }

	            // In vertical axes, the canvas coordinates start from 0 at the top like in
	            // SVG.
	            if (cvsCoord) {
	                sign *= -1; // canvas coordinates inverts the value
	                cvsOffset = axis.len;
	            }

	            // Handle reversed axis
	            if (axis.reversed) {
	                sign *= -1;
	                cvsOffset -= sign * (axis.sector || axis.len);
	            }

	            // From pixels to value
	            if (backwards) { // reverse translation

	                val = val * sign + cvsOffset;
	                val -= minPixelPadding;
	                returnValue = val / localA + localMin; // from chart pixel to value
	                if (doPostTranslate) { // log and ordinal axes
	                    returnValue = axis.lin2val(returnValue);
	                }

	            // From value to pixels
	            } else {
	                if (doPostTranslate) { // log and ordinal axes
	                    val = axis.val2lin(val);
	                }
	                if (pointPlacement === 'between') {
	                    pointPlacement = 0.5;
	                }
	                returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +
	                    (isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);
	            }

	            return returnValue;
	        },

	        /**
	         * Utility method to translate an axis value to pixel position.
	         * @param {Number} value A value in terms of axis units
	         * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart
	         *        or just the axis/pane itself.
	         */
	        toPixels: function (value, paneCoordinates) {
	            return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
	        },

	        /*
	         * Utility method to translate a pixel position in to an axis value
	         * @param {Number} pixel The pixel value coordinate
	         * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the
	         *        axis/pane itself.
	         */
	        toValue: function (pixel, paneCoordinates) {
	            return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
	        },

	        /**
	         * Create the path for a plot line that goes from the given value on
	         * this axis, across the plot to the opposite side
	         * @param {Number} value
	         * @param {Number} lineWidth Used for calculation crisp line
	         * @param {Number] old Use old coordinates (for resizing and rescaling)
	         */
	        getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {
	            var axis = this,
	                chart = axis.chart,
	                axisLeft = axis.left,
	                axisTop = axis.top,
	                x1,
	                y1,
	                x2,
	                y2,
	                cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
	                cWidth = (old && chart.oldChartWidth) || chart.chartWidth,
	                skip,
	                transB = axis.transB,
	                /**
	                 * Check if x is between a and b. If not, either move to a/b or skip,
	                 * depending on the force parameter.
	                 */
	                between = function (x, a, b) {
	                    if (x < a || x > b) {
	                        if (force) {
	                            x = mathMin(mathMax(a, x), b);
	                        } else {
	                            skip = true;
	                        }
	                    }
	                    return x;
	                };

	            translatedValue = pick(translatedValue, axis.translate(value, null, null, old));
	            x1 = x2 = mathRound(translatedValue + transB);
	            y1 = y2 = mathRound(cHeight - translatedValue - transB);

	            if (isNaN(translatedValue)) { // no min or max
	                skip = true;

	            } else if (axis.horiz) {
	                y1 = axisTop;
	                y2 = cHeight - axis.bottom;
	                x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
	            } else {
	                x1 = axisLeft;
	                x2 = cWidth - axis.right;
	                y1 = y2 = between(y1, axisTop, axisTop + axis.height);
	            }
	            return skip && !force ?
	                null :
	                chart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 1);
	        },

	        /**
	         * Set the tick positions of a linear axis to round values like whole tens or every five.
	         */
	        getLinearTickPositions: function (tickInterval, min, max) {
	            var pos,
	                lastPos,
	                roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
	                roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),
	                tickPositions = [];

	            // For single points, add a tick regardless of the relative position (#2662)
	            if (min === max && isNumber(min)) {
	                return [min];
	            }

	            // Populate the intermediate values
	            pos = roundedMin;
	            while (pos <= roundedMax) {

	                // Place the tick on the rounded value
	                tickPositions.push(pos);

	                // Always add the raw tickInterval, not the corrected one.
	                pos = correctFloat(pos + tickInterval);

	                // If the interval is not big enough in the current min - max range to actually increase
	                // the loop variable, we need to break out to prevent endless loop. Issue #619
	                if (pos === lastPos) {
	                    break;
	                }

	                // Record the last value
	                lastPos = pos;
	            }
	            return tickPositions;
	        },

	        /**
	         * Return the minor tick positions. For logarithmic axes, reuse the same logic
	         * as for major ticks.
	         */
	        getMinorTickPositions: function () {
	            var axis = this,
	                options = axis.options,
	                tickPositions = axis.tickPositions,
	                minorTickInterval = axis.minorTickInterval,
	                minorTickPositions = [],
	                pos,
	                i,
	                pointRangePadding = axis.pointRangePadding || 0,
	                min = axis.min - pointRangePadding, // #1498
	                max = axis.max + pointRangePadding, // #1498
	                range = max - min,
	                len;

	            // If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.
	            if (range && range / minorTickInterval < axis.len / 3) { // #3875

	                if (axis.isLog) {
	                    len = tickPositions.length;
	                    for (i = 1; i < len; i++) {
	                        minorTickPositions = minorTickPositions.concat(
	                            axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)
	                        );
	                    }
	                } else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314
	                    minorTickPositions = minorTickPositions.concat(
	                        axis.getTimeTicks(
	                            axis.normalizeTimeTickInterval(minorTickInterval),
	                            min,
	                            max,
	                            options.startOfWeek
	                        )
	                    );
	                } else {
	                    for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
	                        minorTickPositions.push(pos);
	                    }
	                }
	            }

	            if (minorTickPositions.length !== 0) { // don't change the extremes, when there is no minor ticks
	                axis.trimTicks(minorTickPositions, options.startOnTick, options.endOnTick); // #3652 #3743 #1498
	            }
	            return minorTickPositions;
	        },

	        /**
	         * Adjust the min and max for the minimum range. Keep in mind that the series data is
	         * not yet processed, so we don't have information on data cropping and grouping, or
	         * updated axis.pointRange or series.pointRange. The data can't be processed until
	         * we have finally established min and max.
	         */
	        adjustForMinRange: function () {
	            var axis = this,
	                options = axis.options,
	                min = axis.min,
	                max = axis.max,
	                zoomOffset,
	                spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,
	                closestDataRange,
	                i,
	                distance,
	                xData,
	                loopLength,
	                minArgs,
	                maxArgs,
	                minRange;

	            // Set the automatic minimum range based on the closest point distance
	            if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {

	                if (defined(options.min) || defined(options.max)) {
	                    axis.minRange = null; // don't do this again

	                } else {

	                    // Find the closest distance between raw data points, as opposed to
	                    // closestPointRange that applies to processed points (cropped and grouped)
	                    each(axis.series, function (series) {
	                        xData = series.xData;
	                        loopLength = series.xIncrement ? 1 : xData.length - 1;
	                        for (i = loopLength; i > 0; i--) {
	                            distance = xData[i] - xData[i - 1];
	                            if (closestDataRange === UNDEFINED || distance < closestDataRange) {
	                                closestDataRange = distance;
	                            }
	                        }
	                    });
	                    axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);
	                }
	            }

	            // if minRange is exceeded, adjust
	            if (max - min < axis.minRange) {
	                minRange = axis.minRange;
	                zoomOffset = (minRange - max + min) / 2;

	                // if min and max options have been set, don't go beyond it
	                minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
	                if (spaceAvailable) { // if space is available, stay within the data range
	                    minArgs[2] = axis.dataMin;
	                }
	                min = arrayMax(minArgs);

	                maxArgs = [min + minRange, pick(options.max, min + minRange)];
	                if (spaceAvailable) { // if space is availabe, stay within the data range
	                    maxArgs[2] = axis.dataMax;
	                }

	                max = arrayMin(maxArgs);

	                // now if the max is adjusted, adjust the min back
	                if (max - min < minRange) {
	                    minArgs[0] = max - minRange;
	                    minArgs[1] = pick(options.min, max - minRange);
	                    min = arrayMax(minArgs);
	                }
	            }

	            // Record modified extremes
	            axis.min = min;
	            axis.max = max;
	        },

	        /**
	         * Update translation information
	         */
	        setAxisTranslation: function (saveOld) {
	            var axis = this,
	                range = axis.max - axis.min,
	                pointRange = axis.axisPointRange || 0,
	                closestPointRange,
	                minPointOffset = 0,
	                pointRangePadding = 0,
	                linkedParent = axis.linkedParent,
	                ordinalCorrection,
	                hasCategories = !!axis.categories,
	                transA = axis.transA,
	                isXAxis = axis.isXAxis;

	            // Adjust translation for padding. Y axis with categories need to go through the same (#1784).
	            if (isXAxis || hasCategories || pointRange) {
	                if (linkedParent) {
	                    minPointOffset = linkedParent.minPointOffset;
	                    pointRangePadding = linkedParent.pointRangePadding;

	                } else {
	                    // Find the closestPointRange across all series
	                    each(axis.series, function (series) {
	                        var seriesClosest = series.closestPointRange;
	                        if (!series.noSharedTooltip && defined(seriesClosest)) {
	                            closestPointRange = defined(closestPointRange) ?
	                                mathMin(closestPointRange, seriesClosest) :
	                                seriesClosest;
	                        }
	                    });

	                    each(axis.series, function (series) {
	                        var seriesPointRange = hasCategories ? 
	                            1 : 
	                            (isXAxis ? 
	                                pick(series.options.pointRange, closestPointRange, 0) : 
	                                (axis.axisPointRange || 0)), // #2806
	                            pointPlacement = series.options.pointPlacement;

	                        pointRange = mathMax(pointRange, seriesPointRange);

	                        if (!axis.single) {
	                            // minPointOffset is the value padding to the left of the axis in order to make
	                            // room for points with a pointRange, typically columns. When the pointPlacement option
	                            // is 'between' or 'on', this padding does not apply.
	                            minPointOffset = mathMax(
	                                minPointOffset,
	                                isString(pointPlacement) ? 0 : seriesPointRange / 2
	                            );

	                            // Determine the total padding needed to the length of the axis to make room for the
	                            // pointRange. If the series' pointPlacement is 'on', no padding is added.
	                            pointRangePadding = mathMax(
	                                pointRangePadding,
	                                pointPlacement === 'on' ? 0 : seriesPointRange
	                            );
	                        }
	                    });
	                }

	                // Record minPointOffset and pointRangePadding
	                ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853
	                axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
	                axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;

	                // pointRange means the width reserved for each point, like in a column chart
	                axis.pointRange = mathMin(pointRange, range);

	                // closestPointRange means the closest distance between points. In columns
	                // it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange
	                // is some other value
	                if (isXAxis) {
	                    axis.closestPointRange = closestPointRange;
	                }
	            }

	            // Secondary values
	            if (saveOld) {
	                axis.oldTransA = transA;
	            }
	            axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);
	            axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend
	            axis.minPixelPadding = transA * minPointOffset;
	        },

	        minFromRange: function () {
	            return this.max - this.range;
	        },

	        /**
	         * Set the tick positions to round values and optionally extend the extremes
	         * to the nearest tick
	         */
	        setTickInterval: function (secondPass) {
	            var axis = this,
	                chart = axis.chart,
	                options = axis.options,
	                isLog = axis.isLog,
	                isDatetimeAxis = axis.isDatetimeAxis,
	                isXAxis = axis.isXAxis,
	                isLinked = axis.isLinked,
	                maxPadding = options.maxPadding,
	                minPadding = options.minPadding,
	                length,
	                linkedParentExtremes,
	                tickIntervalOption = options.tickInterval,
	                minTickInterval,
	                tickPixelIntervalOption = options.tickPixelInterval,
	                categories = axis.categories,
	                threshold = axis.threshold,
	                softThreshold = axis.softThreshold,
	                thresholdMin,
	                thresholdMax,
	                hardMin,
	                hardMax;

	            if (!isDatetimeAxis && !categories && !isLinked) {
	                this.getTickAmount();
	            }

	            // Min or max set either by zooming/setExtremes or initial options
	            hardMin = pick(axis.userMin, options.min);
	            hardMax = pick(axis.userMax, options.max);

	            // Linked axis gets the extremes from the parent axis
	            if (isLinked) {
	                axis.linkedParent = chart[axis.coll][options.linkedTo];
	                linkedParentExtremes = axis.linkedParent.getExtremes();
	                axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
	                axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
	                if (options.type !== axis.linkedParent.options.type) {
	                    error(11, 1); // Can't link axes of different type
	                }

	            // Initial min and max from the extreme data values
	            } else {

	                // Adjust to hard threshold
	                if (!softThreshold && defined(threshold)) {
	                    if (axis.dataMin >= threshold) {
	                        thresholdMin = threshold;
	                        minPadding = 0;
	                    } else if (axis.dataMax <= threshold) {
	                        thresholdMax = threshold;
	                        maxPadding = 0;
	                    }
	                }

	                axis.min = pick(hardMin, thresholdMin, axis.dataMin);
	                axis.max = pick(hardMax, thresholdMax, axis.dataMax);

	            }

	            if (isLog) {
	                if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978
	                    error(10, 1); // Can't plot negative values on log axis
	                }
	                // The correctFloat cures #934, float errors on full tens. But it
	                // was too aggressive for #4360 because of conversion back to lin,
	                // therefore use precision 15.
	                axis.min = correctFloat(log2lin(axis.min), 15);
	                axis.max = correctFloat(log2lin(axis.max), 15);
	            }

	            // handle zoomed range
	            if (axis.range && defined(axis.max)) {
	                axis.userMin = axis.min = hardMin = mathMax(axis.min, axis.minFromRange()); // #618
	                axis.userMax = hardMax = axis.max;

	                axis.range = null;  // don't use it when running setExtremes
	            }

	            // Hook for adjusting this.min and this.max. Used by bubble series.
	            if (axis.beforePadding) {
	                axis.beforePadding();
	            }

	            // adjust min and max for the minimum range
	            axis.adjustForMinRange();

	            // Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding
	            // into account, we do this after computing tick interval (#1337).
	            if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {
	                length = axis.max - axis.min;
	                if (length) {
	                    if (!defined(hardMin) && minPadding) {
	                        axis.min -= length * minPadding;
	                    }
	                    if (!defined(hardMax)  && maxPadding) {
	                        axis.max += length * maxPadding;
	                    }
	                }
	            }

	            // Stay within floor and ceiling
	            if (isNumber(options.floor)) {
	                axis.min = mathMax(axis.min, options.floor);
	            }
	            if (isNumber(options.ceiling)) {
	                axis.max = mathMin(axis.max, options.ceiling);
	            }

	            // When the threshold is soft, adjust the extreme value only if
	            // the data extreme and the padded extreme land on either side of the threshold. For example,
	            // a series of [0, 1, 2, 3] would make the yAxis add a tick for -1 because of the
	            // default minPadding and startOnTick options. This is prevented by the softThreshold
	            // option.
	            if (softThreshold && defined(axis.dataMin)) {
	                threshold = threshold || 0;
	                if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {
	                    axis.min = threshold;
	                } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {
	                    axis.max = threshold;
	                }
	            }


	            // get tickInterval
	            if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
	                axis.tickInterval = 1;
	            } else if (isLinked && !tickIntervalOption &&
	                    tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
	                axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;
	            } else {
	                axis.tickInterval = pick(
	                    tickIntervalOption,
	                    this.tickAmount ? ((axis.max - axis.min) / mathMax(this.tickAmount - 1, 1)) : undefined,
	                    categories ? // for categoried axis, 1 is default, for linear axis use tickPix
	                        1 :
	                        // don't let it be more than the data range
	                        (axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)
	                );
	            }

	            // Now we're finished detecting min and max, crop and group series data. This
	            // is in turn needed in order to find tick positions in ordinal axes.
	            if (isXAxis && !secondPass) {
	                each(axis.series, function (series) {
	                    series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
	                });
	            }

	            // set the translation factor used in translate function
	            axis.setAxisTranslation(true);

	            // hook for ordinal axes and radial axes
	            if (axis.beforeSetTickPositions) {
	                axis.beforeSetTickPositions();
	            }

	            // hook for extensions, used in Highstock ordinal axes
	            if (axis.postProcessTickInterval) {
	                axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
	            }

	            // In column-like charts, don't cramp in more ticks than there are points (#1943, #4184)
	            if (axis.pointRange && !tickIntervalOption) {
	                axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);
	            }

	            // Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.
	            minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);
	            if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
	                axis.tickInterval = minTickInterval;
	            }

	            // for linear axes, get magnitude and normalize the interval
	            if (!isDatetimeAxis && !isLog && !tickIntervalOption) {
	                axis.tickInterval = normalizeTickInterval(
	                    axis.tickInterval,
	                    null,
	                    getMagnitude(axis.tickInterval),
	                    // If the tick interval is between 0.5 and 5 and the axis max is in the order of
	                    // thousands, chances are we are dealing with years. Don't allow decimals. #3363.
	                    pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),
	                    !!this.tickAmount
	                );
	            }

	            // Prevent ticks from getting so close that we can't draw the labels
	            if (!this.tickAmount && this.len) { // Color axis with disabled legend has no length
	                axis.tickInterval = axis.unsquish();
	            }

	            this.setTickPositions();
	        },

	        /**
	         * Now we have computed the normalized tickInterval, get the tick positions
	         */
	        setTickPositions: function () {

	            var options = this.options,
	                tickPositions,
	                tickPositionsOption = options.tickPositions,
	                tickPositioner = options.tickPositioner,
	                startOnTick = options.startOnTick,
	                endOnTick = options.endOnTick,
	                single;

	            // Set the tickmarkOffset
	            this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' &&
	                this.tickInterval === 1) ? 0.5 : 0; // #3202


	            // get minorTickInterval
	            this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?
	                this.tickInterval / 5 : options.minorTickInterval;

	            // Find the tick positions
	            this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice(); // Work on a copy (#1565)
	            if (!tickPositions) {

	                if (this.isDatetimeAxis) {
	                    tickPositions = this.getTimeTicks(
	                        this.normalizeTimeTickInterval(this.tickInterval, options.units),
	                        this.min,
	                        this.max,
	                        options.startOfWeek,
	                        this.ordinalPositions,
	                        this.closestPointRange,
	                        true
	                    );
	                } else if (this.isLog) {
	                    tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);
	                } else {
	                    tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
	                }

	                // Too dense ticks, keep only the first and last (#4477)
	                if (tickPositions.length > this.len) {
	                    tickPositions = [tickPositions[0], tickPositions.pop()];
	                }

	                this.tickPositions = tickPositions;

	                // Run the tick positioner callback, that allows modifying auto tick positions.
	                if (tickPositioner) {
	                    tickPositioner = tickPositioner.apply(this, [this.min, this.max]);
	                    if (tickPositioner) {
	                        this.tickPositions = tickPositions = tickPositioner;
	                    }
	                }

	            }

	            if (!this.isLinked) {

	                // reset min/max or remove extremes based on start/end on tick
	                this.trimTicks(tickPositions, startOnTick, endOnTick);

	                // When there is only one point, or all points have the same value on this axis, then min
	                // and max are equal and tickPositions.length is 0 or 1. In this case, add some padding
	                // in order to center the point, but leave it with one tick. #1337.
	                if (this.min === this.max && defined(this.min) && !this.tickAmount) {
	                    // Substract half a unit (#2619, #2846, #2515, #3390)
	                    single = true;
	                    this.min -= 0.5;
	                    this.max += 0.5;
	                }
	                this.single = single;

	                if (!tickPositionsOption && !tickPositioner) {
	                    this.adjustTickAmount();
	                }
	            }
	        },

	        /**
	         * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max
	         */
	        trimTicks: function (tickPositions, startOnTick, endOnTick) {
	            var roundedMin = tickPositions[0],
	                roundedMax = tickPositions[tickPositions.length - 1],
	                minPointOffset = this.minPointOffset || 0;

	            if (startOnTick) {
	                this.min = roundedMin;
	            } else {
	                while (this.min - minPointOffset > tickPositions[0]) {
	                    tickPositions.shift();
	                }
	            }

	            if (endOnTick) {
	                this.max = roundedMax;
	            } else {
	                while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {
	                    tickPositions.pop();
	                }
	            }

	            // If no tick are left, set one tick in the middle (#3195)
	            if (tickPositions.length === 0 && defined(roundedMin)) {
	                tickPositions.push((roundedMax + roundedMin) / 2);
	            }
	        },

	        /**
	         * Check if there are multiple axes in the same pane
	         * @returns {Boolean} There are other axes
	         */
	        alignToOthers: function () {
	            var others = {}, // Whether there is another axis to pair with this one
	                hasOther,
	                options = this.options;

	            if (this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {
	                each(this.chart[this.coll], function (axis) {
	                    var otherOptions = axis.options,
	                        horiz = axis.horiz,
	                        key = [
	                            horiz ? otherOptions.left : otherOptions.top, 
	                            otherOptions.width,
	                            otherOptions.height, 
	                            otherOptions.pane
	                        ].join(',');


	                    if (axis.series.length) { // #4442
	                        if (others[key]) {
	                            hasOther = true; // #4201
	                        } else {
	                            others[key] = 1;
	                        }
	                    }
	                });
	            }
	            return hasOther;
	        },

	        /**
	         * Set the max ticks of either the x and y axis collection
	         */
	        getTickAmount: function () {
	            var options = this.options,
	                tickAmount = options.tickAmount,
	                tickPixelInterval = options.tickPixelInterval;

	            if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&
	                    !this.isLog && options.startOnTick && options.endOnTick) {
	                tickAmount = 2;
	            }

	            if (!tickAmount && this.alignToOthers()) {
	                // Add 1 because 4 tick intervals require 5 ticks (including first and last)
	                tickAmount = mathCeil(this.len / tickPixelInterval) + 1;
	            }

	            // For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This
	            // prevents the axis from adding ticks that are too far away from the data extremes.
	            if (tickAmount < 4) {
	                this.finalTickAmt = tickAmount;
	                tickAmount = 5;
	            }

	            this.tickAmount = tickAmount;
	        },

	        /**
	         * When using multiple axes, adjust the number of ticks to match the highest
	         * number of ticks in that group
	         */
	        adjustTickAmount: function () {
	            var tickInterval = this.tickInterval,
	                tickPositions = this.tickPositions,
	                tickAmount = this.tickAmount,
	                finalTickAmt = this.finalTickAmt,
	                currentTickAmount = tickPositions && tickPositions.length,
	                i,
	                len;

	            if (currentTickAmount < tickAmount) {
	                while (tickPositions.length < tickAmount) {
	                    tickPositions.push(correctFloat(
	                        tickPositions[tickPositions.length - 1] + tickInterval
	                    ));
	                }
	                this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
	                this.max = tickPositions[tickPositions.length - 1];

	            // We have too many ticks, run second pass to try to reduce ticks
	            } else if (currentTickAmount > tickAmount) {
	                this.tickInterval *= 2;
	                this.setTickPositions();
	            }

	            // The finalTickAmt property is set in getTickAmount
	            if (defined(finalTickAmt)) {
	                i = len = tickPositions.length;
	                while (i--) {
	                    if (
	                        (finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick
	                        (finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last
	                    ) {
	                        tickPositions.splice(i, 1);
	                    }
	                }
	                this.finalTickAmt = UNDEFINED;
	            }
	        },

	        /**
	         * Set the scale based on data min and max, user set min and max or options
	         *
	         */
	        setScale: function () {
	            var axis = this,
	                isDirtyData,
	                isDirtyAxisLength;

	            axis.oldMin = axis.min;
	            axis.oldMax = axis.max;
	            axis.oldAxisLength = axis.len;

	            // set the new axisLength
	            axis.setAxisSize();
	            //axisLength = horiz ? axisWidth : axisHeight;
	            isDirtyAxisLength = axis.len !== axis.oldAxisLength;

	            // is there new data?
	            each(axis.series, function (series) {
	                if (series.isDirtyData || series.isDirty ||
	                        series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well
	                    isDirtyData = true;
	                }
	            });

	            // do we really need to go through all this?
	            if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||
	                axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax || axis.alignToOthers()) {

	                if (axis.resetStacks) {
	                    axis.resetStacks();
	                }

	                axis.forceRedraw = false;

	                // get data extremes if needed
	                axis.getSeriesExtremes();

	                // get fixed positions based on tickInterval
	                axis.setTickInterval();

	                // record old values to decide whether a rescale is necessary later on (#540)
	                axis.oldUserMin = axis.userMin;
	                axis.oldUserMax = axis.userMax;

	                // Mark as dirty if it is not already set to dirty and extremes have changed. #595.
	                if (!axis.isDirty) {
	                    axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
	                }
	            } else if (axis.cleanStacks) {
	                axis.cleanStacks();
	            }
	        },

	        /**
	         * Set the extremes and optionally redraw
	         * @param {Number} newMin
	         * @param {Number} newMax
	         * @param {Boolean} redraw
	         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	         *    configuration
	         * @param {Object} eventArguments
	         *
	         */
	        setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {
	            var axis = this,
	                chart = axis.chart;

	            redraw = pick(redraw, true); // defaults to true

	            each(axis.series, function (serie) {
	                delete serie.kdTree;
	            });

	            // Extend the arguments with min and max
	            eventArguments = extend(eventArguments, {
	                min: newMin,
	                max: newMax
	            });

	            // Fire the event
	            fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler

	                axis.userMin = newMin;
	                axis.userMax = newMax;
	                axis.eventArgs = eventArguments;

	                if (redraw) {
	                    chart.redraw(animation);
	                }
	            });
	        },

	        /**
	         * Overridable method for zooming chart. Pulled out in a separate method to allow overriding
	         * in stock charts.
	         */
	        zoom: function (newMin, newMax) {
	            var dataMin = this.dataMin,
	                dataMax = this.dataMax,
	                options = this.options,
	                min = mathMin(dataMin, pick(options.min, dataMin)),
	                max = mathMax(dataMax, pick(options.max, dataMax));

	            // Prevent pinch zooming out of range. Check for defined is for #1946. #1734.
	            if (!this.allowZoomOutside) {
	                if (defined(dataMin) && newMin <= min) {
	                    newMin = min;
	                }
	                if (defined(dataMax) && newMax >= max) {
	                    newMax = max;
	                }
	            }

	            // In full view, displaying the reset zoom button is not required
	            this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;

	            // Do it
	            this.setExtremes(
	                newMin,
	                newMax,
	                false,
	                UNDEFINED,
	                { trigger: 'zoom' }
	            );
	            return true;
	        },

	        /**
	         * Update the axis metrics
	         */
	        setAxisSize: function () {
	            var chart = this.chart,
	                options = this.options,
	                offsetLeft = options.offsetLeft || 0,
	                offsetRight = options.offsetRight || 0,
	                horiz = this.horiz,
	                width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),
	                height = pick(options.height, chart.plotHeight),
	                top = pick(options.top, chart.plotTop),
	                left = pick(options.left, chart.plotLeft + offsetLeft),
	                percentRegex = /%$/;

	            // Check for percentage based input values. Rounding fixes problems with
	            // column overflow and plot line filtering (#4898, #4899)
	            if (percentRegex.test(height)) {
	                height = Math.round(parseFloat(height) / 100 * chart.plotHeight);
	            }
	            if (percentRegex.test(top)) {
	                top = Math.round(parseFloat(top) / 100 * chart.plotHeight + chart.plotTop);
	            }

	            // Expose basic values to use in Series object and navigator
	            this.left = left;
	            this.top = top;
	            this.width = width;
	            this.height = height;
	            this.bottom = chart.chartHeight - height - top;
	            this.right = chart.chartWidth - width - left;

	            // Direction agnostic properties
	            this.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905
	            this.pos = horiz ? left : top; // distance from SVG origin
	        },

	        /**
	         * Get the actual axis extremes
	         */
	        getExtremes: function () {
	            var axis = this,
	                isLog = axis.isLog;

	            return {
	                min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
	                max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
	                dataMin: axis.dataMin,
	                dataMax: axis.dataMax,
	                userMin: axis.userMin,
	                userMax: axis.userMax
	            };
	        },

	        /**
	         * Get the zero plane either based on zero or on the min or max value.
	         * Used in bar and area plots
	         */
	        getThreshold: function (threshold) {
	            var axis = this,
	                isLog = axis.isLog,
	                realMin = isLog ? lin2log(axis.min) : axis.min,
	                realMax = isLog ? lin2log(axis.max) : axis.max;

	            // With a threshold of null, make the columns/areas rise from the top or bottom
	            // depending on the value, assuming an actual threshold of 0 (#4233).
	            if (threshold === null) {
	                threshold = realMax < 0 ? realMax : realMin;
	            } else if (realMin > threshold) {
	                threshold = realMin;
	            } else if (realMax < threshold) {
	                threshold = realMax;
	            }

	            return axis.translate(threshold, 0, 1, 0, 1);
	        },

	        /**
	         * Compute auto alignment for the axis label based on which side the axis is on
	         * and the given rotation for the label
	         */
	        autoLabelAlign: function (rotation) {
	            var ret,
	                angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;

	            if (angle > 15 && angle < 165) {
	                ret = 'right';
	            } else if (angle > 195 && angle < 345) {
	                ret = 'left';
	            } else {
	                ret = 'center';
	            }
	            return ret;
	        },

	        /**
	         * Prevent the ticks from getting so close we can't draw the labels. On a horizontal
	         * axis, this is handled by rotating the labels, removing ticks and adding ellipsis.
	         * On a vertical axis remove ticks and add ellipsis.
	         */
	        unsquish: function () {
	            var chart = this.chart,
	                ticks = this.ticks,
	                labelOptions = this.options.labels,
	                horiz = this.horiz,
	                tickInterval = this.tickInterval,
	                newTickInterval = tickInterval,
	                slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),
	                rotation,
	                rotationOption = labelOptions.rotation,
	                labelMetrics = chart.renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
	                step,
	                bestScore = Number.MAX_VALUE,
	                autoRotation,
	                // Return the multiple of tickInterval that is needed to avoid collision
	                getStep = function (spaceNeeded) {
	                    var step = spaceNeeded / (slotSize || 1);
	                    step = step > 1 ? mathCeil(step) : 1;
	                    return step * tickInterval;
	                };

	            if (horiz) {
	                autoRotation = !labelOptions.staggerLines && !labelOptions.step && ( // #3971
	                    defined(rotationOption) ?
	                        [rotationOption] :
	                        slotSize < pick(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation
	                );

	                if (autoRotation) {

	                    // Loop over the given autoRotation options, and determine which gives the best score. The
	                    // best score is that with the lowest number of steps and a rotation closest to horizontal.
	                    each(autoRotation, function (rot) {
	                        var score;

	                        if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891

	                            step = getStep(mathAbs(labelMetrics.h / mathSin(deg2rad * rot)));

	                            score = step + mathAbs(rot / 360);

	                            if (score < bestScore) {
	                                bestScore = score;
	                                rotation = rot;
	                                newTickInterval = step;
	                            }
	                        }
	                    });
	                }

	            } else if (!labelOptions.step) { // #4411
	                newTickInterval = getStep(labelMetrics.h);
	            }

	            this.autoRotation = autoRotation;
	            this.labelRotation = pick(rotation, rotationOption);

	            return newTickInterval;
	        },

	        renderUnsquish: function () {
	            var chart = this.chart,
	                renderer = chart.renderer,
	                tickPositions = this.tickPositions,
	                ticks = this.ticks,
	                labelOptions = this.options.labels,
	                horiz = this.horiz,
	                margin = chart.margin,
	                slotCount = this.categories ? tickPositions.length : tickPositions.length - 1,
	                slotWidth = this.slotWidth = (horiz && (labelOptions.step || 0) < 2 && !labelOptions.rotation && // #4415
	                    ((this.staggerLines || 1) * chart.plotWidth) / slotCount) ||
	                    (!horiz && ((margin[3] && (margin[3] - chart.spacing[3])) || chart.chartWidth * 0.33)), // #1580, #1931,
	                innerWidth = mathMax(1, mathRound(slotWidth - 2 * (labelOptions.padding || 5))),
	                attr = {},
	                labelMetrics = renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
	                textOverflowOption = labelOptions.style.textOverflow,
	                css,
	                labelLength = 0,
	                label,
	                i,
	                pos;

	            // Set rotation option unless it is "auto", like in gauges
	            if (!isString(labelOptions.rotation)) {
	                attr.rotation = labelOptions.rotation || 0; // #4443
	            }

	            // Handle auto rotation on horizontal axis
	            if (this.autoRotation) {

	                // Get the longest label length
	                each(tickPositions, function (tick) {
	                    tick = ticks[tick];
	                    if (tick && tick.labelLength > labelLength) {
	                        labelLength = tick.labelLength;
	                    }
	                });

	                // Apply rotation only if the label is too wide for the slot, and
	                // the label is wider than its height.
	                if (labelLength > innerWidth && labelLength > labelMetrics.h) {
	                    attr.rotation = this.labelRotation;
	                } else {
	                    this.labelRotation = 0;
	                }

	            // Handle word-wrap or ellipsis on vertical axis
	            } else if (slotWidth) {
	                // For word-wrap or ellipsis
	                css = { width: innerWidth + PX };

	                if (!textOverflowOption) {
	                    css.textOverflow = 'clip';

	                    // On vertical axis, only allow word wrap if there is room for more lines.
	                    i = tickPositions.length;
	                    while (!horiz && i--) {
	                        pos = tickPositions[i];
	                        label = ticks[pos].label;
	                        if (label) {
	                            // Reset ellipsis in order to get the correct bounding box (#4070)
	                            if (label.styles.textOverflow === 'ellipsis') {
	                                label.css({ textOverflow: 'clip' });
	                            }
	                            if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f) ||
	                                    ticks[pos].labelLength > slotWidth) { // #4678
	                                label.specCss = { textOverflow: 'ellipsis' };
	                            }
	                        }
	                    }
	                }
	            }


	            // Add ellipsis if the label length is significantly longer than ideal
	            if (attr.rotation) {
	                css = {
	                    width: (labelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + PX
	                };
	                if (!textOverflowOption) {
	                    css.textOverflow = 'ellipsis';
	                }
	            }

	            // Set the explicit or automatic label alignment
	            this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);
	            if (this.labelAlign) {
	                attr.align = this.labelAlign;
	            }

	            // Apply general and specific CSS
	            each(tickPositions, function (pos) {
	                var tick = ticks[pos],
	                    label = tick && tick.label;
	                if (label) {
	                    label.attr(attr); // This needs to go before the CSS in old IE (#4502)
	                    if (css) {
	                        label.css(merge(css, label.specCss));
	                    }
	                    delete label.specCss;
	                    tick.rotation = attr.rotation;
	                }
	            });

	            // Note: Why is this not part of getLabelPosition?
	            this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);
	        },

	        /**
	         * Return true if the axis has associated data
	         */
	        hasData: function () {
	            return this.hasVisibleSeries || (defined(this.min) && defined(this.max) && !!this.tickPositions);
	        },

	        /**
	         * Render the tick labels to a preliminary position to get their sizes
	         */
	        getOffset: function () {
	            var axis = this,
	                chart = axis.chart,
	                renderer = chart.renderer,
	                options = axis.options,
	                tickPositions = axis.tickPositions,
	                ticks = axis.ticks,
	                horiz = axis.horiz,
	                side = axis.side,
	                invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,
	                hasData,
	                showAxis,
	                titleOffset = 0,
	                titleOffsetOption,
	                titleMargin = 0,
	                axisTitleOptions = options.title,
	                labelOptions = options.labels,
	                labelOffset = 0, // reset
	                labelOffsetPadded,
	                opposite = axis.opposite,
	                axisOffset = chart.axisOffset,
	                clipOffset = chart.clipOffset,
	                clip,
	                directionFactor = [-1, 1, 1, -1][side],
	                n,
	                axisParent = axis.axisParent, // Used in color axis
	                lineHeightCorrection;

	            // For reuse in Axis.render
	            hasData = axis.hasData();
	            axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);

	            // Set/reset staggerLines
	            axis.staggerLines = axis.horiz && labelOptions.staggerLines;

	            // Create the axisGroup and gridGroup elements on first iteration
	            if (!axis.axisGroup) {
	                axis.gridGroup = renderer.g('grid')
	                    .attr({ zIndex: options.gridZIndex || 1 })
	                    .add(axisParent);
	                axis.axisGroup = renderer.g('axis')
	                    .attr({ zIndex: options.zIndex || 2 })
	                    .add(axisParent);
	                axis.labelGroup = renderer.g('axis-labels')
	                    .attr({ zIndex: labelOptions.zIndex || 7 })
	                    .addClass(PREFIX + axis.coll.toLowerCase() + '-labels')
	                    .add(axisParent);
	            }

	            if (hasData || axis.isLinked) {

	                // Generate ticks
	                each(tickPositions, function (pos) {
	                    if (!ticks[pos]) {
	                        ticks[pos] = new Tick(axis, pos);
	                    } else {
	                        ticks[pos].addLabel(); // update labels depending on tick interval
	                    }
	                });

	                axis.renderUnsquish();


	                // Left side must be align: right and right side must have align: left for labels
	                if (labelOptions.reserveSpace !== false && (side === 0 || side === 2 ||
	                        { 1: 'left', 3: 'right' }[side] === axis.labelAlign || axis.labelAlign === 'center')) {
	                    each(tickPositions, function (pos) {

	                        // get the highest offset
	                        labelOffset = mathMax(
	                            ticks[pos].getLabelSize(),
	                            labelOffset
	                        );
	                    });
	                }

	                if (axis.staggerLines) {
	                    labelOffset *= axis.staggerLines;
	                    axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);
	                }


	            } else { // doesn't have data
	                for (n in ticks) {
	                    ticks[n].destroy();
	                    delete ticks[n];
	                }
	            }

	            if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
	                if (!axis.axisTitle) {
	                    axis.axisTitle = renderer.text(
	                        axisTitleOptions.text,
	                        0,
	                        0,
	                        axisTitleOptions.useHTML
	                    )
	                    .attr({
	                        zIndex: 7,
	                        rotation: axisTitleOptions.rotation || 0,
	                        align: 
	                            axisTitleOptions.textAlign ||
	                            { 
	                                low: opposite ? 'right' : 'left',
	                                middle: 'center',
	                                high: opposite ? 'left' : 'right'
	                            }[axisTitleOptions.align]
	                    })
	                    .addClass(PREFIX + this.coll.toLowerCase() + '-title')
	                    .css(axisTitleOptions.style)
	                    .add(axis.axisGroup);
	                    axis.axisTitle.isNew = true;
	                }

	                if (showAxis) {
	                    titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
	                    titleOffsetOption = axisTitleOptions.offset;
	                    titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);
	                }

	                // hide or show the title depending on whether showEmpty is set
	                axis.axisTitle[showAxis ? 'show' : 'hide'](true);
	            }

	            // handle automatic or user set offset
	            axis.offset = directionFactor * pick(options.offset, axisOffset[side]);

	            axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar
	            lineHeightCorrection = side === 2 ? axis.tickRotCorr.y : 0;
	            labelOffsetPadded = Math.abs(labelOffset) + titleMargin +
	                (labelOffset && (directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + 8) : labelOptions.x) - lineHeightCorrection));
	            axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);

	            axisOffset[side] = mathMax(
	                axisOffset[side],
	                axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
	                labelOffsetPadded // #3027
	            );

	            // Decide the clipping needed to keep the graph inside the plot area and axis lines
	            clip = options.offset ? 0 : mathFloor(options.lineWidth / 2) * 2; // #4308, #4371
	            clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], clip);
	        },

	        /**
	         * Get the path for the axis line
	         */
	        getLinePath: function (lineWidth) {
	            var chart = this.chart,
	                opposite = this.opposite,
	                offset = this.offset,
	                horiz = this.horiz,
	                lineLeft = this.left + (opposite ? this.width : 0) + offset,
	                lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;

	            if (opposite) {
	                lineWidth *= -1; // crispify the other way - #1480, #1687
	            }

	            return chart.renderer
	                .crispLine([
	                    M,
	                    horiz ?
	                        this.left :
	                        lineLeft,
	                    horiz ?
	                        lineTop :
	                        this.top,
	                    L,
	                    horiz ?
	                        chart.chartWidth - this.right :
	                        lineLeft,
	                    horiz ?
	                        lineTop :
	                        chart.chartHeight - this.bottom
	                ], lineWidth);
	        },

	        /**
	         * Position the title
	         */
	        getTitlePosition: function () {
	            // compute anchor points for each of the title align options
	            var horiz = this.horiz,
	                axisLeft = this.left,
	                axisTop = this.top,
	                axisLength = this.len,
	                axisTitleOptions = this.options.title,
	                margin = horiz ? axisLeft : axisTop,
	                opposite = this.opposite,
	                offset = this.offset,
	                xOption = axisTitleOptions.x || 0,
	                yOption = axisTitleOptions.y || 0,
	                fontSize = pInt(axisTitleOptions.style.fontSize || 12),

	                // the position in the length direction of the axis
	                alongAxis = {
	                    low: margin + (horiz ? 0 : axisLength),
	                    middle: margin + axisLength / 2,
	                    high: margin + (horiz ? axisLength : 0)
	                }[axisTitleOptions.align],

	                // the position in the perpendicular direction of the axis
	                offAxis = (horiz ? axisTop + this.height : axisLeft) +
	                    (horiz ? 1 : -1) * // horizontal axis reverses the margin
	                    (opposite ? -1 : 1) * // so does opposite axes
	                    this.axisTitleMargin +
	                    (this.side === 2 ? fontSize : 0);

	            return {
	                x: horiz ?
	                    alongAxis + xOption :
	                    offAxis + (opposite ? this.width : 0) + offset + xOption,
	                y: horiz ?
	                    offAxis + yOption - (opposite ? this.height : 0) + offset :
	                    alongAxis + yOption
	            };
	        },

	        /**
	         * Render the axis
	         */
	        render: function () {
	            var axis = this,
	                chart = axis.chart,
	                renderer = chart.renderer,
	                options = axis.options,
	                isLog = axis.isLog,
	                isLinked = axis.isLinked,
	                tickPositions = axis.tickPositions,
	                axisTitle = axis.axisTitle,
	                ticks = axis.ticks,
	                minorTicks = axis.minorTicks,
	                alternateBands = axis.alternateBands,
	                stackLabelOptions = options.stackLabels,
	                alternateGridColor = options.alternateGridColor,
	                tickmarkOffset = axis.tickmarkOffset,
	                lineWidth = options.lineWidth,
	                linePath,
	                hasRendered = chart.hasRendered,
	                slideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin),
	                showAxis = axis.showAxis,
	                globalAnimation = renderer.globalAnimation,
	                from,
	                to;

	            // Reset
	            axis.labelEdge.length = 0;
	            //axis.justifyToPlot = overflow === 'justify';
	            axis.overlap = false;

	            // Mark all elements inActive before we go over and mark the active ones
	            each([ticks, minorTicks, alternateBands], function (coll) {
	                var pos;
	                for (pos in coll) {
	                    coll[pos].isActive = false;
	                }
	            });

	            // If the series has data draw the ticks. Else only the line and title
	            if (axis.hasData() || isLinked) {

	                // minor ticks
	                if (axis.minorTickInterval && !axis.categories) {
	                    each(axis.getMinorTickPositions(), function (pos) {
	                        if (!minorTicks[pos]) {
	                            minorTicks[pos] = new Tick(axis, pos, 'minor');
	                        }

	                        // render new ticks in old position
	                        if (slideInTicks && minorTicks[pos].isNew) {
	                            minorTicks[pos].render(null, true);
	                        }

	                        minorTicks[pos].render(null, false, 1);
	                    });
	                }

	                // Major ticks. Pull out the first item and render it last so that
	                // we can get the position of the neighbour label. #808.
	                if (tickPositions.length) { // #1300
	                    each(tickPositions, function (pos, i) {

	                        // linked axes need an extra check to find out if
	                        if (!isLinked || (pos >= axis.min && pos <= axis.max)) {

	                            if (!ticks[pos]) {
	                                ticks[pos] = new Tick(axis, pos);
	                            }

	                            // render new ticks in old position
	                            if (slideInTicks && ticks[pos].isNew) {
	                                ticks[pos].render(i, true, 0.1);
	                            }

	                            ticks[pos].render(i);
	                        }

	                    });
	                    // In a categorized axis, the tick marks are displayed between labels. So
	                    // we need to add a tick mark and grid line at the left edge of the X axis.
	                    if (tickmarkOffset && (axis.min === 0 || axis.single)) {
	                        if (!ticks[-1]) {
	                            ticks[-1] = new Tick(axis, -1, null, true);
	                        }
	                        ticks[-1].render(-1);
	                    }

	                }

	                // alternate grid color
	                if (alternateGridColor) {
	                    each(tickPositions, function (pos, i) {
	                        to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset; 
	                        if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) { // #2248, #4660
	                            if (!alternateBands[pos]) {
	                                alternateBands[pos] = new Highcharts.PlotLineOrBand(axis);
	                            }
	                            from = pos + tickmarkOffset; // #949
	                            alternateBands[pos].options = {
	                                from: isLog ? lin2log(from) : from,
	                                to: isLog ? lin2log(to) : to,
	                                color: alternateGridColor
	                            };
	                            alternateBands[pos].render();
	                            alternateBands[pos].isActive = true;
	                        }
	                    });
	                }

	                // custom plot lines and bands
	                if (!axis._addedPlotLB) { // only first time
	                    each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {
	                        axis.addPlotBandOrLine(plotLineOptions);
	                    });
	                    axis._addedPlotLB = true;
	                }

	            } // end if hasData

	            // Remove inactive ticks
	            each([ticks, minorTicks, alternateBands], function (coll) {
	                var pos,
	                    i,
	                    forDestruction = [],
	                    delay = globalAnimation ? globalAnimation.duration || 500 : 0,
	                    destroyInactiveItems = function () {
	                        i = forDestruction.length;
	                        while (i--) {
	                            // When resizing rapidly, the same items may be destroyed in different timeouts,
	                            // or the may be reactivated
	                            if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
	                                coll[forDestruction[i]].destroy();
	                                delete coll[forDestruction[i]];
	                            }
	                        }

	                    };

	                for (pos in coll) {

	                    if (!coll[pos].isActive) {
	                        // Render to zero opacity
	                        coll[pos].render(pos, false, 0);
	                        coll[pos].isActive = false;
	                        forDestruction.push(pos);
	                    }
	                }

	                // When the objects are finished fading out, destroy them
	                syncTimeout(
	                    destroyInactiveItems, 
	                    coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay
	                );
	            });

	            // Static items. As the axis group is cleared on subsequent calls
	            // to render, these items are added outside the group.
	            // axis line
	            if (lineWidth) {
	                linePath = axis.getLinePath(lineWidth);
	                if (!axis.axisLine) {
	                    axis.axisLine = renderer.path(linePath)
	                        .attr({
	                            stroke: options.lineColor,
	                            'stroke-width': lineWidth,
	                            zIndex: 7
	                        })
	                        .add(axis.axisGroup);
	                } else {
	                    axis.axisLine.animate({ d: linePath });
	                }

	                // show or hide the line depending on options.showEmpty
	                axis.axisLine[showAxis ? 'show' : 'hide'](true);
	            }

	            if (axisTitle && showAxis) {

	                axisTitle[axisTitle.isNew ? 'attr' : 'animate'](
	                    axis.getTitlePosition()
	                );
	                axisTitle.isNew = false;
	            }

	            // Stacked totals:
	            if (stackLabelOptions && stackLabelOptions.enabled) {
	                axis.renderStackTotals();
	            }
	            // End stacked totals

	            axis.isDirty = false;
	        },

	        /**
	         * Redraw the axis to reflect changes in the data or axis extremes
	         */
	        redraw: function () {

	            if (this.visible) {
	                // render the axis
	                this.render();

	                // move plot lines and bands
	                each(this.plotLinesAndBands, function (plotLine) {
	                    plotLine.render();
	                });
	            }

	            // mark associated series as dirty and ready for redraw
	            each(this.series, function (series) {
	                series.isDirty = true;
	            });

	        },

	        /**
	         * Destroys an Axis instance.
	         */
	        destroy: function (keepEvents) {
	            var axis = this,
	                stacks = axis.stacks,
	                stackKey,
	                plotLinesAndBands = axis.plotLinesAndBands,
	                i;

	            // Remove the events
	            if (!keepEvents) {
	                removeEvent(axis);
	            }

	            // Destroy each stack total
	            for (stackKey in stacks) {
	                destroyObjectProperties(stacks[stackKey]);

	                stacks[stackKey] = null;
	            }

	            // Destroy collections
	            each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {
	                destroyObjectProperties(coll);
	            });
	            i = plotLinesAndBands.length;
	            while (i--) { // #1975
	                plotLinesAndBands[i].destroy();
	            }

	            // Destroy local variables
	            each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'cross', 'gridGroup', 'labelGroup'], function (prop) {
	                if (axis[prop]) {
	                    axis[prop] = axis[prop].destroy();
	                }
	            });

	            // Destroy crosshair
	            if (this.cross) {
	                this.cross.destroy();
	            }
	        },

	        /**
	         * Draw the crosshair
	         * 
	         * @param  {Object} e The event arguments from the modified pointer event
	         * @param  {Object} point The Point object
	         */
	        drawCrosshair: function (e, point) {

	            var path,
	                options = this.crosshair,
	                pos,
	                attribs,
	                categorized,
	                strokeWidth;

	            if (
	                // Disabled in options
	                !this.crosshair ||
	                // Snap
	                ((defined(point) || !pick(options.snap, true)) === false)
	            ) {
	                this.hideCrosshair();

	            } else {

	                // Get the path
	                if (!pick(options.snap, true)) {
	                    pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
	                } else if (defined(point)) {
	                    pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834
	                }

	                if (this.isRadial) {
	                    path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189
	                } else {
	                    path = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189
	                }

	                if (path === null) {
	                    this.hideCrosshair();
	                    return;
	                }

	                categorized = this.categories && !this.isRadial;
	                strokeWidth = pick(options.width, (categorized ? this.transA : 1));

	                // Draw the cross
	                if (this.cross) {
	                    this.cross
	                        .attr({
	                            d: path,
	                            visibility: 'visible',
	                            'stroke-width': strokeWidth // #4737
	                        });
	                } else {
	                    attribs = {
	                        'stroke-width': strokeWidth,
	                        stroke: options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),
	                        zIndex: pick(options.zIndex, 2)
	                    };
	                    if (options.dashStyle) {
	                        attribs.dashstyle = options.dashStyle;
	                    }
	                    this.cross = this.chart.renderer.path(path).attr(attribs).add();
	                }

	            }

	        },

	        /**
	         *    Hide the crosshair.
	         */
	        hideCrosshair: function () {
	            if (this.cross) {
	                this.cross.hide();
	            }
	        }
	    }; // end Axis

	    extend(Axis.prototype, AxisPlotLineOrBandExtension);

	    /**
	     * Set the tick positions to a time unit that makes sense, for example
	     * on the first of each month or on every Monday. Return an array
	     * with the time positions. Used in datetime axes as well as for grouping
	     * data on a datetime axis.
	     *
	     * @param {Object} normalizedInterval The interval in axis values (ms) and the count
	     * @param {Number} min The minimum in axis values
	     * @param {Number} max The maximum in axis values
	     * @param {Number} startOfWeek
	     */
	    Axis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {
	        var tickPositions = [],
	            i,
	            higherRanks = {},
	            useUTC = defaultOptions.global.useUTC,
	            minYear, // used in months and years as a basis for Date.UTC()
	            minDate = new Date(min - getTZOffset(min)),
	            interval = normalizedInterval.unitRange,
	            count = normalizedInterval.count;

	        if (defined(min)) { // #1300
	            minDate[setMilliseconds](interval >= timeUnits.second ? 0 : // #3935
	                count * mathFloor(minDate.getMilliseconds() / count)); // #3652, #3654

	            if (interval >= timeUnits.second) { // second
	                minDate[setSeconds](interval >= timeUnits.minute ? 0 : // #3935
	                    count * mathFloor(minDate.getSeconds() / count));
	            }

	            if (interval >= timeUnits.minute) { // minute
	                minDate[setMinutes](interval >= timeUnits.hour ? 0 :
	                    count * mathFloor(minDate[getMinutes]() / count));
	            }

	            if (interval >= timeUnits.hour) { // hour
	                minDate[setHours](interval >= timeUnits.day ? 0 :
	                    count * mathFloor(minDate[getHours]() / count));
	            }

	            if (interval >= timeUnits.day) { // day
	                minDate[setDate](interval >= timeUnits.month ? 1 :
	                    count * mathFloor(minDate[getDate]() / count));
	            }

	            if (interval >= timeUnits.month) { // month
	                minDate[setMonth](interval >= timeUnits.year ? 0 :
	                    count * mathFloor(minDate[getMonth]() / count));
	                minYear = minDate[getFullYear]();
	            }

	            if (interval >= timeUnits.year) { // year
	                minYear -= minYear % count;
	                minDate[setFullYear](minYear);
	            }

	            // week is a special case that runs outside the hierarchy
	            if (interval === timeUnits.week) {
	                // get start of current week, independent of count
	                minDate[setDate](minDate[getDate]() - minDate[getDay]() +
	                    pick(startOfWeek, 1));
	            }


	            // get tick positions
	            i = 1;
	            if (timezoneOffset || getTimezoneOffset) {
	                minDate = minDate.getTime();
	                minDate = new Date(minDate + getTZOffset(minDate));
	            }
	            minYear = minDate[getFullYear]();
	            var time = minDate.getTime(),
	                minMonth = minDate[getMonth](),
	                minDateDate = minDate[getDate](),
	                variableDayLength = !useUTC || !!getTimezoneOffset, // #4951
	                localTimezoneOffset = (timeUnits.day +
	                        (useUTC ? getTZOffset(minDate) : minDate.getTimezoneOffset() * 60 * 1000)
	                    ) % timeUnits.day; // #950, #3359

	            // iterate and add tick positions at appropriate values
	            while (time < max) {
	                tickPositions.push(time);

	                // if the interval is years, use Date.UTC to increase years
	                if (interval === timeUnits.year) {
	                    time = makeTime(minYear + i * count, 0);

	                // if the interval is months, use Date.UTC to increase months
	                } else if (interval === timeUnits.month) {
	                    time = makeTime(minYear, minMonth + i * count);

	                // if we're using global time, the interval is not fixed as it jumps
	                // one hour at the DST crossover
	                } else if (variableDayLength && (interval === timeUnits.day || interval === timeUnits.week)) {
	                    time = makeTime(minYear, minMonth, minDateDate +
	                        i * count * (interval === timeUnits.day ? 1 : 7));

	                // else, the interval is fixed and we use simple addition
	                } else {
	                    time += interval * count;
	                }

	                i++;
	            }

	            // push the last time
	            tickPositions.push(time);


	            // mark new days if the time is dividible by day (#1649, #1760)
	            each(grep(tickPositions, function (time) {
	                return interval <= timeUnits.hour && time % timeUnits.day === localTimezoneOffset;
	            }), function (time) {
	                higherRanks[time] = 'day';
	            });
	        }


	        // record information on the chosen unit - for dynamic label formatter
	        tickPositions.info = extend(normalizedInterval, {
	            higherRanks: higherRanks,
	            totalRange: interval * count
	        });

	        return tickPositions;
	    };

	    /**
	     * Get a normalized tick interval for dates. Returns a configuration object with
	     * unit range (interval), count and name. Used to prepare data for getTimeTicks.
	     * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
	     * of segments in stock charts, the normalizing logic was extracted in order to
	     * prevent it for running over again for each segment having the same interval.
	     * #662, #697.
	     */
	    Axis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {
	        var units = unitsOption || [[
	                'millisecond', // unit name
	                [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
	            ], [
	                'second',
	                [1, 2, 5, 10, 15, 30]
	            ], [
	                'minute',
	                [1, 2, 5, 10, 15, 30]
	            ], [
	                'hour',
	                [1, 2, 3, 4, 6, 8, 12]
	            ], [
	                'day',
	                [1, 2]
	            ], [
	                'week',
	                [1, 2]
	            ], [
	                'month',
	                [1, 2, 3, 4, 6]
	            ], [
	                'year',
	                null
	            ]],
	            unit = units[units.length - 1], // default unit is years
	            interval = timeUnits[unit[0]],
	            multiples = unit[1],
	            count,
	            i;

	        // loop through the units to find the one that best fits the tickInterval
	        for (i = 0; i < units.length; i++) {
	            unit = units[i];
	            interval = timeUnits[unit[0]];
	            multiples = unit[1];


	            if (units[i + 1]) {
	                // lessThan is in the middle between the highest multiple and the next unit.
	                var lessThan = (interval * multiples[multiples.length - 1] +
	                            timeUnits[units[i + 1][0]]) / 2;

	                // break and keep the current unit
	                if (tickInterval <= lessThan) {
	                    break;
	                }
	            }
	        }

	        // prevent 2.5 years intervals, though 25, 250 etc. are allowed
	        if (interval === timeUnits.year && tickInterval < 5 * interval) {
	            multiples = [1, 2, 5];
	        }

	        // get the count
	        count = normalizeTickInterval(
	            tickInterval / interval,
	            multiples,
	            unit[0] === 'year' ? mathMax(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360
	        );

	        return {
	            unitRange: interval,
	            count: count,
	            unitName: unit[0]
	        };
	    };
	    /**
	     * Methods defined on the Axis prototype
	     */

	    /**
	     * Set the tick positions of a logarithmic axis
	     */
	    Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {
	        var axis = this,
	            options = axis.options,
	            axisLength = axis.len,
	            // Since we use this method for both major and minor ticks,
	            // use a local variable and return the result
	            positions = [];

	        // Reset
	        if (!minor) {
	            axis._minorAutoInterval = null;
	        }

	        // First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
	        if (interval >= 0.5) {
	            interval = mathRound(interval);
	            positions = axis.getLinearTickPositions(interval, min, max);

	        // Second case: We need intermediary ticks. For example
	        // 1, 2, 4, 6, 8, 10, 20, 40 etc.
	        } else if (interval >= 0.08) {
	            var roundedMin = mathFloor(min),
	                intermediate,
	                i,
	                j,
	                len,
	                pos,
	                lastPos,
	                break2;

	            if (interval > 0.3) {
	                intermediate = [1, 2, 4];
	            } else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
	                intermediate = [1, 2, 4, 6, 8];
	            } else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
	                intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
	            }

	            for (i = roundedMin; i < max + 1 && !break2; i++) {
	                len = intermediate.length;
	                for (j = 0; j < len && !break2; j++) {
	                    pos = log2lin(lin2log(i) * intermediate[j]);
	                    if (pos > min && (!minor || lastPos <= max) && lastPos !== UNDEFINED) { // #1670, lastPos is #3113
	                        positions.push(lastPos);
	                    }

	                    if (lastPos > max) {
	                        break2 = true;
	                    }
	                    lastPos = pos;
	                }
	            }

	        // Third case: We are so deep in between whole logarithmic values that
	        // we might as well handle the tick positions like a linear axis. For
	        // example 1.01, 1.02, 1.03, 1.04.
	        } else {
	            var realMin = lin2log(min),
	                realMax = lin2log(max),
	                tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],
	                filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
	                tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
	                totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;

	            interval = pick(
	                filteredTickIntervalOption,
	                axis._minorAutoInterval,
	                (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
	            );

	            interval = normalizeTickInterval(
	                interval,
	                null,
	                getMagnitude(interval)
	            );

	            positions = map(axis.getLinearTickPositions(
	                interval,
	                realMin,
	                realMax
	            ), log2lin);

	            if (!minor) {
	                axis._minorAutoInterval = interval / 5;
	            }
	        }

	        // Set the axis-level tickInterval variable
	        if (!minor) {
	            axis.tickInterval = interval;
	        }
	        return positions;
	    };/**
	     * The tooltip object
	     * @param {Object} chart The chart instance
	     * @param {Object} options Tooltip options
	     */
	    var Tooltip = Highcharts.Tooltip = function () {
	        this.init.apply(this, arguments);
	    };

	    Tooltip.prototype = {

	        init: function (chart, options) {

	            var borderWidth = options.borderWidth,
	                style = options.style,
	                padding = pInt(style.padding);

	            // Save the chart and options
	            this.chart = chart;
	            this.options = options;

	            // Keep track of the current series
	            //this.currentSeries = UNDEFINED;

	            // List of crosshairs
	            this.crosshairs = [];

	            // Current values of x and y when animating
	            this.now = { x: 0, y: 0 };

	            // The tooltip is initially hidden
	            this.isHidden = true;


	            // create the label
	            this.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')
	                .attr({
	                    padding: padding,
	                    fill: options.backgroundColor,
	                    'stroke-width': borderWidth,
	                    r: options.borderRadius,
	                    zIndex: 8
	                })
	                .css(style)
	                .css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)
	                .add()
	                .attr({ y: -9999 }); // #2301, #2657

	            // When using canVG the shadow shows up as a gray circle
	            // even if the tooltip is hidden.
	            if (!useCanVG) {
	                this.label.shadow(options.shadow);
	            }

	            // Public property for getting the shared state.
	            this.shared = options.shared;
	        },

	        /**
	         * Destroy the tooltip and its elements.
	         */
	        destroy: function () {
	            // Destroy and clear local variables
	            if (this.label) {
	                this.label = this.label.destroy();
	            }
	            clearTimeout(this.hideTimer);
	            clearTimeout(this.tooltipTimeout);
	        },

	        /**
	         * Provide a soft movement for the tooltip
	         *
	         * @param {Number} x
	         * @param {Number} y
	         * @private
	         */
	        move: function (x, y, anchorX, anchorY) {
	            var tooltip = this,
	                now = tooltip.now,
	                animate = tooltip.options.animation !== false && !tooltip.isHidden &&
	                    // When we get close to the target position, abort animation and land on the right place (#3056)
	                    (mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1),
	                skipAnchor = tooltip.followPointer || tooltip.len > 1;

	            // Get intermediate values for animation
	            extend(now, {
	                x: animate ? (2 * now.x + x) / 3 : x,
	                y: animate ? (now.y + y) / 2 : y,
	                anchorX: skipAnchor ? UNDEFINED : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
	                anchorY: skipAnchor ? UNDEFINED : animate ? (now.anchorY + anchorY) / 2 : anchorY
	            });

	            // Move to the intermediate value
	            tooltip.label.attr(now);


	            // Run on next tick of the mouse tracker
	            if (animate) {

	                // Never allow two timeouts
	                clearTimeout(this.tooltipTimeout);

	                // Set the fixed interval ticking for the smooth tooltip
	                this.tooltipTimeout = setTimeout(function () {
	                    // The interval function may still be running during destroy, so check that the chart is really there before calling.
	                    if (tooltip) {
	                        tooltip.move(x, y, anchorX, anchorY);
	                    }
	                }, 32);

	            }
	        },

	        /**
	         * Hide the tooltip
	         */
	        hide: function (delay) {
	            var tooltip = this;
	            clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)
	            delay = pick(delay, this.options.hideDelay, 500);
	            if (!this.isHidden) {
	                this.hideTimer = syncTimeout(function () {
	                    tooltip.label[delay ? 'fadeOut' : 'hide']();
	                    tooltip.isHidden = true;
	                }, delay);
	            }
	        },

	        /**
	         * Extendable method to get the anchor position of the tooltip
	         * from a point or set of points
	         */
	        getAnchor: function (points, mouseEvent) {
	            var ret,
	                chart = this.chart,
	                inverted = chart.inverted,
	                plotTop = chart.plotTop,
	                plotLeft = chart.plotLeft,
	                plotX = 0,
	                plotY = 0,
	                yAxis,
	                xAxis;

	            points = splat(points);

	            // Pie uses a special tooltipPos
	            ret = points[0].tooltipPos;

	            // When tooltip follows mouse, relate the position to the mouse
	            if (this.followPointer && mouseEvent) {
	                if (mouseEvent.chartX === UNDEFINED) {
	                    mouseEvent = chart.pointer.normalize(mouseEvent);
	                }
	                ret = [
	                    mouseEvent.chartX - chart.plotLeft,
	                    mouseEvent.chartY - plotTop
	                ];
	            }
	            // When shared, use the average position
	            if (!ret) {
	                each(points, function (point) {
	                    yAxis = point.series.yAxis;
	                    xAxis = point.series.xAxis;
	                    plotX += point.plotX  + (!inverted && xAxis ? xAxis.left - plotLeft : 0);
	                    plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +
	                        (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151
	                });

	                plotX /= points.length;
	                plotY /= points.length;

	                ret = [
	                    inverted ? chart.plotWidth - plotY : plotX,
	                    this.shared && !inverted && points.length > 1 && mouseEvent ?
	                        mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)
	                        inverted ? chart.plotHeight - plotX : plotY
	                ];
	            }

	            return map(ret, mathRound);
	        },

	        /**
	         * Place the tooltip in a chart without spilling over
	         * and not covering the point it self.
	         */
	        getPosition: function (boxWidth, boxHeight, point) {

	            var chart = this.chart,
	                distance = this.distance,
	                ret = {},
	                h = point.h || 0, // #4117
	                swapped,
	                first = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop, chart.plotTop, chart.plotTop + chart.plotHeight],
	                second = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft, chart.plotLeft, chart.plotLeft + chart.plotWidth],
	                // The far side is right or bottom
	                preferFarSide = pick(point.ttBelow, (chart.inverted && !point.negative) || (!chart.inverted && point.negative)),
	                /**
	                 * Handle the preferred dimension. When the preferred dimension is tooltip
	                 * on top or bottom of the point, it will look for space there.
	                 */
	                firstDimension = function (dim, outerSize, innerSize, point, min, max) {
	                    var roomLeft = innerSize < point - distance,
	                        roomRight = point + distance + innerSize < outerSize,
	                        alignedLeft = point - distance - innerSize,
	                        alignedRight = point + distance;

	                    if (preferFarSide && roomRight) {
	                        ret[dim] = alignedRight;
	                    } else if (!preferFarSide && roomLeft) {
	                        ret[dim] = alignedLeft;
	                    } else if (roomLeft) {
	                        ret[dim] = mathMin(max - innerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);
	                    } else if (roomRight) {
	                        ret[dim] = mathMax(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);
	                    } else {
	                        return false;
	                    }
	                },
	                /**
	                 * Handle the secondary dimension. If the preferred dimension is tooltip
	                 * on top or bottom of the point, the second dimension is to align the tooltip
	                 * above the point, trying to align center but allowing left or right
	                 * align within the chart box.
	                 */
	                secondDimension = function (dim, outerSize, innerSize, point) {
	                    var retVal;

	                    // Too close to the edge, return false and swap dimensions
	                    if (point < distance || point > outerSize - distance) {
	                        retVal = false;
	                    // Align left/top
	                    } else if (point < innerSize / 2) {
	                        ret[dim] = 1;
	                    // Align right/bottom
	                    } else if (point > outerSize - innerSize / 2) {
	                        ret[dim] = outerSize - innerSize - 2;
	                    // Align center
	                    } else {
	                        ret[dim] = point - innerSize / 2;
	                    }
	                    return retVal;
	                },
	                /**
	                 * Swap the dimensions
	                 */
	                swap = function (count) {
	                    var temp = first;
	                    first = second;
	                    second = temp;
	                    swapped = count;
	                },
	                run = function () {
	                    if (firstDimension.apply(0, first) !== false) {
	                        if (secondDimension.apply(0, second) === false && !swapped) {
	                            swap(true);
	                            run();
	                        }
	                    } else if (!swapped) {
	                        swap(true);
	                        run();
	                    } else {
	                        ret.x = ret.y = 0;
	                    }
	                };

	            // Under these conditions, prefer the tooltip on the side of the point
	            if (chart.inverted || this.len > 1) {
	                swap();
	            }
	            run();

	            return ret;

	        },

	        /**
	         * In case no user defined formatter is given, this will be used. Note that the context
	         * here is an object holding point, series, x, y etc.
	         */
	        defaultFormatter: function (tooltip) {
	            var items = this.points || splat(this),
	                s;

	            // build the header
	            s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header

	            // build the values
	            s = s.concat(tooltip.bodyFormatter(items));

	            // footer
	            s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header

	            return s.join('');
	        },

	        /**
	         * Refresh the tooltip's text and position.
	         * @param {Object} point
	         */
	        refresh: function (point, mouseEvent) {
	            var tooltip = this,
	                chart = tooltip.chart,
	                label = tooltip.label,
	                options = tooltip.options,
	                x,
	                y,
	                anchor,
	                textConfig = {},
	                text,
	                pointConfig = [],
	                formatter = options.formatter || tooltip.defaultFormatter,
	                hoverPoints = chart.hoverPoints,
	                borderColor,
	                shared = tooltip.shared,
	                currentSeries;

	            clearTimeout(this.hideTimer);

	            // get the reference point coordinates (pie charts use tooltipPos)
	            tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
	            anchor = tooltip.getAnchor(point, mouseEvent);
	            x = anchor[0];
	            y = anchor[1];

	            // shared tooltip, array is sent over
	            if (shared && !(point.series && point.series.noSharedTooltip)) {

	                // hide previous hoverPoints and set new

	                chart.hoverPoints = point;
	                if (hoverPoints) {
	                    each(hoverPoints, function (point) {
	                        point.setState();
	                    });
	                }

	                each(point, function (item) {
	                    item.setState(HOVER_STATE);

	                    pointConfig.push(item.getLabelConfig());
	                });

	                textConfig = {
	                    x: point[0].category,
	                    y: point[0].y
	                };
	                textConfig.points = pointConfig;
	                this.len = pointConfig.length;
	                point = point[0];

	            // single point tooltip
	            } else {
	                textConfig = point.getLabelConfig();
	            }
	            text = formatter.call(textConfig, tooltip);

	            // register the current series
	            currentSeries = point.series;
	            this.distance = pick(currentSeries.tooltipOptions.distance, 16);

	            // update the inner HTML
	            if (text === false) {
	                this.hide();
	            } else {

	                // show it
	                if (tooltip.isHidden) {
	                    stop(label);
	                    label.attr('opacity', 1).show();
	                }

	                // update text
	                label.attr({
	                    text: text
	                });

	                // set the stroke color of the box
	                borderColor = options.borderColor || point.color || currentSeries.color || '#606060';
	                label.attr({
	                    stroke: borderColor
	                });
	                tooltip.updatePosition({
	                    plotX: x,
	                    plotY: y,
	                    negative: point.negative,
	                    ttBelow: point.ttBelow,
	                    h: anchor[2] || 0
	                });

	                this.isHidden = false;
	            }
	            fireEvent(chart, 'tooltipRefresh', {
	                text: text,
	                x: x + chart.plotLeft,
	                y: y + chart.plotTop,
	                borderColor: borderColor
	            });
	        },

	        /**
	         * Find the new position and perform the move
	         */
	        updatePosition: function (point) {
	            var chart = this.chart,
	                label = this.label,
	                pos = (this.options.positioner || this.getPosition).call(
	                    this,
	                    label.width,
	                    label.height,
	                    point
	                );

	            // do the move
	            this.move(
	                mathRound(pos.x),
	                mathRound(pos.y || 0), // can be undefined (#3977)
	                point.plotX + chart.plotLeft,
	                point.plotY + chart.plotTop
	            );
	        },

	        /**
	         * Get the best X date format based on the closest point range on the axis.
	         */
	        getXDateFormat: function (point, options, xAxis) {
	            var xDateFormat,
	                dateTimeLabelFormats = options.dateTimeLabelFormats,
	                closestPointRange = xAxis && xAxis.closestPointRange,
	                n,
	                blank = '01-01 00:00:00.000',
	                strpos = {
	                    millisecond: 15,
	                    second: 12,
	                    minute: 9,
	                    hour: 6,
	                    day: 3
	                },
	                date,
	                lastN = 'millisecond'; // for sub-millisecond data, #4223

	            if (closestPointRange) {
	                date = dateFormat('%m-%d %H:%M:%S.%L', point.x);
	                for (n in timeUnits) {

	                    // If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format
	                    if (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek &&
	                            date.substr(6) === blank.substr(6)) {
	                        n = 'week';
	                        break;
	                    }

	                    // The first format that is too great for the range
	                    if (timeUnits[n] > closestPointRange) {
	                        n = lastN;
	                        break;
	                    }

	                    // If the point is placed every day at 23:59, we need to show
	                    // the minutes as well. #2637.
	                    if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {
	                        break;
	                    }

	                    // Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition
	                    if (n !== 'week') {
	                        lastN = n;
	                    }
	                }

	                if (n) {
	                    xDateFormat = dateTimeLabelFormats[n];
	                }
	            } else {
	                xDateFormat = dateTimeLabelFormats.day;
	            }

	            return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581
	        },

	        /**
	         * Format the footer/header of the tooltip
	         * #3397: abstraction to enable formatting of footer and header
	         */
	        tooltipFooterHeaderFormatter: function (point, isFooter) {
	            var footOrHead = isFooter ? 'footer' : 'header',
	                series = point.series,
	                tooltipOptions = series.tooltipOptions,
	                xDateFormat = tooltipOptions.xDateFormat,
	                xAxis = series.xAxis,
	                isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(point.key),
	                formatString = tooltipOptions[footOrHead + 'Format'];

	            // Guess the best date format based on the closest point distance (#568, #3418)
	            if (isDateTime && !xDateFormat) {
	                xDateFormat = this.getXDateFormat(point, tooltipOptions, xAxis);
	            }

	            // Insert the footer date format if any
	            if (isDateTime && xDateFormat) {
	                formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');
	            }

	            return format(formatString, {
	                point: point,
	                series: series
	            });
	        },

	        /**
	         * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,
	         * abstracting this functionality allows to easily overwrite and extend it.
	         */
	        bodyFormatter: function (items) {
	            return map(items, function (item) {
	                var tooltipOptions = item.series.tooltipOptions;
	                return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);
	            });
	        }

	    };

	    var hoverChartIndex;

	    // Global flag for touch support
	    hasTouch = doc && doc.documentElement.ontouchstart !== UNDEFINED;

	    /**
	     * The mouse tracker object. All methods starting with "on" are primary DOM event handlers.
	     * Subsequent methods should be named differently from what they are doing.
	     * @param {Object} chart The Chart instance
	     * @param {Object} options The root options object
	     */
	    var Pointer = Highcharts.Pointer = function (chart, options) {
	        this.init(chart, options);
	    };

	    Pointer.prototype = {
	        /**
	         * Initialize Pointer
	         */
	        init: function (chart, options) {

	            var chartOptions = options.chart,
	                chartEvents = chartOptions.events,
	                zoomType = useCanVG ? '' : chartOptions.zoomType,
	                inverted = chart.inverted,
	                zoomX,
	                zoomY;

	            // Store references
	            this.options = options;
	            this.chart = chart;

	            // Zoom status
	            this.zoomX = zoomX = /x/.test(zoomType);
	            this.zoomY = zoomY = /y/.test(zoomType);
	            this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
	            this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);
	            this.hasZoom = zoomX || zoomY;

	            // Do we need to handle click on a touch device?
	            this.runChartClick = chartEvents && !!chartEvents.click;

	            this.pinchDown = [];
	            this.lastValidTouch = {};

	            if (Highcharts.Tooltip && options.tooltip.enabled) {
	                chart.tooltip = new Tooltip(chart, options.tooltip);
	                this.followTouchMove = pick(options.tooltip.followTouchMove, true);
	            }

	            this.setDOMEvents();
	        },

	        /**
	         * Add crossbrowser support for chartX and chartY
	         * @param {Object} e The event object in standard browsers
	         */
	        normalize: function (e, chartPosition) {
	            var chartX,
	                chartY,
	                ePos;

	            // IE normalizing
	            e = e || win.event;
	            if (!e.target) {
	                e.target = e.srcElement;
	            }

	            // iOS (#2757)
	            ePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;

	            // Get mouse position
	            if (!chartPosition) {
	                this.chartPosition = chartPosition = offset(this.chart.container);
	            }

	            // chartX and chartY
	            if (ePos.pageX === UNDEFINED) { // IE < 9. #886.
	                chartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is
	                    // for IE10 quirks mode within framesets
	                chartY = e.y;
	            } else {
	                chartX = ePos.pageX - chartPosition.left;
	                chartY = ePos.pageY - chartPosition.top;
	            }

	            return extend(e, {
	                chartX: mathRound(chartX),
	                chartY: mathRound(chartY)
	            });
	        },

	        /**
	         * Get the click position in terms of axis values.
	         *
	         * @param {Object} e A pointer event
	         */
	        getCoordinates: function (e) {
	            var coordinates = {
	                xAxis: [],
	                yAxis: []
	            };

	            each(this.chart.axes, function (axis) {
	                coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
	                    axis: axis,
	                    value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
	                });
	            });
	            return coordinates;
	        },

	        /**
	         * With line type charts with a single tracker, get the point closest to the mouse.
	         * Run Point.onMouseOver and display tooltip for the point or points.
	         */
	        runPointActions: function (e) {

	            var pointer = this,
	                chart = pointer.chart,
	                series = chart.series,
	                tooltip = chart.tooltip,
	                shared = tooltip ? tooltip.shared : false,
	                followPointer,
	                hoverPoint = chart.hoverPoint,
	                hoverSeries = chart.hoverSeries,
	                i,
	                distance = [Number.MAX_VALUE, Number.MAX_VALUE], // #4511
	                anchor,
	                noSharedTooltip,
	                stickToHoverSeries,
	                directTouch,
	                kdpoints = [],
	                kdpoint = [],
	                kdpointT;

	            // For hovering over the empty parts of the plot area (hoverSeries is undefined).
	            // If there is one series with point tracking (combo chart), don't go to nearest neighbour.
	            if (!shared && !hoverSeries) {
	                for (i = 0; i < series.length; i++) {
	                    if (series[i].directTouch || !series[i].options.stickyTracking) {
	                        series = [];
	                    }
	                }
	            }

	            // If it has a hoverPoint and that series requires direct touch (like columns, #3899), or we're on
	            // a noSharedTooltip series among shared tooltip series (#4546), use the hoverPoint . Otherwise,
	            // search the k-d tree.
	            stickToHoverSeries = hoverSeries && (shared ? hoverSeries.noSharedTooltip : hoverSeries.directTouch);
	            if (stickToHoverSeries && hoverPoint) {
	                kdpoint = [hoverPoint];

	            // Handle shared tooltip or cases where a series is not yet hovered
	            } else {
	                // Find nearest points on all series
	                each(series, function (s) {
	                    // Skip hidden series
	                    noSharedTooltip = s.noSharedTooltip && shared;
	                    directTouch = !shared && s.directTouch;
	                    if (s.visible && !noSharedTooltip && !directTouch && pick(s.options.enableMouseTracking, true)) { // #3821
	                        kdpointT = s.searchPoint(e, !noSharedTooltip && s.kdDimensions === 1); // #3828
	                        if (kdpointT) {
	                            kdpoints.push(kdpointT);
	                        }
	                    }
	                });
	                // Find absolute nearest point
	                each(kdpoints, function (p) {
	                    if (p) {
	                        // Store both closest points, using point.dist and point.distX comparisons (#4645):
	                        each(['dist', 'distX'], function (dist, k) {
	                            if (typeof p[dist] === 'number' && p[dist] < distance[k]) {
	                                distance[k] = p[dist];
	                                kdpoint[k] = p;
	                            }
	                        });
	                    }
	                });
	            }

	            // Remove points with different x-positions, required for shared tooltip and crosshairs (#4645):
	            if (shared) {
	                i = kdpoints.length;
	                while (i--) {
	                    if (kdpoints[i].clientX !== kdpoint[1].clientX || kdpoints[i].series.noSharedTooltip) {
	                        kdpoints.splice(i, 1);
	                    }
	                }
	            }

	            // Refresh tooltip for kdpoint if new hover point or tooltip was hidden // #3926, #4200
	            if (kdpoint[0] && (kdpoint[0] !== this.prevKDPoint || (tooltip && tooltip.isHidden))) {
	                // Draw tooltip if necessary
	                if (shared && !kdpoint[0].series.noSharedTooltip) {
	                    if (kdpoints.length && tooltip) {
	                        tooltip.refresh(kdpoints, e);
	                    }

	                    // Do mouseover on all points (#3919, #3985, #4410)
	                    each(kdpoints, function (point) {
	                        point.onMouseOver(e, point !== ((hoverSeries && hoverSeries.directTouch && hoverPoint) || kdpoint[0]));
	                    });
	                    this.prevKDPoint = kdpoint[1];
	                } else {
	                    if (tooltip) {
	                        tooltip.refresh(kdpoint[0], e);
	                    }
	                    if (!hoverSeries || !hoverSeries.directTouch) { // #4448
	                        kdpoint[0].onMouseOver(e);
	                    }
	                    this.prevKDPoint = kdpoint[0];
	                }

	            // Update positions (regardless of kdpoint or hoverPoint)
	            } else {
	                followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;
	                if (tooltip && followPointer && !tooltip.isHidden) {
	                    anchor = tooltip.getAnchor([{}], e);
	                    tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });
	                }
	            }

	            // Start the event listener to pick up the tooltip and crosshairs
	            if (!pointer._onDocumentMouseMove) {
	                pointer._onDocumentMouseMove = function (e) {
	                    if (charts[hoverChartIndex]) {
	                        charts[hoverChartIndex].pointer.onDocumentMouseMove(e);
	                    }
	                };
	                addEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
	            }

	            // Crosshair
	            each(shared ? kdpoints : [pick(kdpoint[1], hoverPoint)], function (point) {
	                var series = point && point.series;
	                if (series) {
	                    each(['xAxis', 'yAxis', 'colorAxis'], function (coll) {
	                        if (series[coll]) {
	                            series[coll].drawCrosshair(e, point);
	                        }
	                    });
	                }
	            });

	        },



	        /**
	         * Reset the tracking by hiding the tooltip, the hover series state and the hover point
	         *
	         * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible
	         */
	        reset: function (allowMove, delay) {
	            var pointer = this,
	                chart = pointer.chart,
	                hoverSeries = chart.hoverSeries,
	                hoverPoint = chart.hoverPoint,
	                hoverPoints = chart.hoverPoints,
	                tooltip = chart.tooltip,
	                tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;

	            // Narrow in allowMove
	            allowMove = allowMove && tooltip && tooltipPoints;

	            // Check if the points have moved outside the plot area (#1003, #4736)
	            if (allowMove) {
	                each(splat(tooltipPoints), function (point) {
	                    if (point.plotX === undefined) {
	                        allowMove = false;
	                    }
	                });
	            }
	        
	            // Just move the tooltip, #349
	            if (allowMove) {
	                tooltip.refresh(tooltipPoints);
	                if (hoverPoint) { // #2500
	                    hoverPoint.setState(hoverPoint.state, true);
	                    each(chart.axes, function (axis) {
	                        if (pick(axis.options.crosshair && axis.options.crosshair.snap, true)) {
	                            axis.drawCrosshair(null, hoverPoint);
	                        }  else {
	                            axis.hideCrosshair();
	                        }
	                    });

	                }

	            // Full reset
	            } else {

	                if (hoverPoint) {
	                    hoverPoint.onMouseOut();
	                }

	                if (hoverPoints) {
	                    each(hoverPoints, function (point) {
	                        point.setState();
	                    });
	                }

	                if (hoverSeries) {
	                    hoverSeries.onMouseOut();
	                }

	                if (tooltip) {
	                    tooltip.hide(delay);
	                }

	                if (pointer._onDocumentMouseMove) {
	                    removeEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
	                    pointer._onDocumentMouseMove = null;
	                }

	                // Remove crosshairs
	                each(chart.axes, function (axis) {
	                    axis.hideCrosshair();
	                });

	                pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;

	            }
	        },

	        /**
	         * Scale series groups to a certain scale and translation
	         */
	        scaleGroups: function (attribs, clip) {

	            var chart = this.chart,
	                seriesAttribs;

	            // Scale each series
	            each(chart.series, function (series) {
	                seriesAttribs = attribs || series.getPlotBox(); // #1701
	                if (series.xAxis && series.xAxis.zoomEnabled) {
	                    series.group.attr(seriesAttribs);
	                    if (series.markerGroup) {
	                        series.markerGroup.attr(seriesAttribs);
	                        series.markerGroup.clip(clip ? chart.clipRect : null);
	                    }
	                    if (series.dataLabelsGroup) {
	                        series.dataLabelsGroup.attr(seriesAttribs);
	                    }
	                }
	            });

	            // Clip
	            chart.clipRect.attr(clip || chart.clipBox);
	        },

	        /**
	         * Start a drag operation
	         */
	        dragStart: function (e) {
	            var chart = this.chart;

	            // Record the start position
	            chart.mouseIsDown = e.type;
	            chart.cancelClick = false;
	            chart.mouseDownX = this.mouseDownX = e.chartX;
	            chart.mouseDownY = this.mouseDownY = e.chartY;
	        },

	        /**
	         * Perform a drag operation in response to a mousemove event while the mouse is down
	         */
	        drag: function (e) {

	            var chart = this.chart,
	                chartOptions = chart.options.chart,
	                chartX = e.chartX,
	                chartY = e.chartY,
	                zoomHor = this.zoomHor,
	                zoomVert = this.zoomVert,
	                plotLeft = chart.plotLeft,
	                plotTop = chart.plotTop,
	                plotWidth = chart.plotWidth,
	                plotHeight = chart.plotHeight,
	                clickedInside,
	                size,
	                selectionMarker = this.selectionMarker,
	                mouseDownX = this.mouseDownX,
	                mouseDownY = this.mouseDownY,
	                panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];

	            // If the device supports both touch and mouse (like IE11), and we are touch-dragging
	            // inside the plot area, don't handle the mouse event. #4339.
	            if (selectionMarker && selectionMarker.touch) {
	                return;
	            }

	            // If the mouse is outside the plot area, adjust to cooordinates
	            // inside to prevent the selection marker from going outside
	            if (chartX < plotLeft) {
	                chartX = plotLeft;
	            } else if (chartX > plotLeft + plotWidth) {
	                chartX = plotLeft + plotWidth;
	            }

	            if (chartY < plotTop) {
	                chartY = plotTop;
	            } else if (chartY > plotTop + plotHeight) {
	                chartY = plotTop + plotHeight;
	            }

	            // determine if the mouse has moved more than 10px
	            this.hasDragged = Math.sqrt(
	                Math.pow(mouseDownX - chartX, 2) +
	                Math.pow(mouseDownY - chartY, 2)
	            );

	            if (this.hasDragged > 10) {
	                clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);

	                // make a selection
	                if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
	                    if (!selectionMarker) {
	                        this.selectionMarker = selectionMarker = chart.renderer.rect(
	                            plotLeft,
	                            plotTop,
	                            zoomHor ? 1 : plotWidth,
	                            zoomVert ? 1 : plotHeight,
	                            0
	                        )
	                        .attr({
	                            fill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',
	                            zIndex: 7
	                        })
	                        .add();
	                    }
	                }

	                // adjust the width of the selection marker
	                if (selectionMarker && zoomHor) {
	                    size = chartX - mouseDownX;
	                    selectionMarker.attr({
	                        width: mathAbs(size),
	                        x: (size > 0 ? 0 : size) + mouseDownX
	                    });
	                }
	                // adjust the height of the selection marker
	                if (selectionMarker && zoomVert) {
	                    size = chartY - mouseDownY;
	                    selectionMarker.attr({
	                        height: mathAbs(size),
	                        y: (size > 0 ? 0 : size) + mouseDownY
	                    });
	                }

	                // panning
	                if (clickedInside && !selectionMarker && chartOptions.panning) {
	                    chart.pan(e, chartOptions.panning);
	                }
	            }
	        },

	        /**
	         * On mouse up or touch end across the entire document, drop the selection.
	         */
	        drop: function (e) {
	            var pointer = this,
	                chart = this.chart,
	                hasPinched = this.hasPinched;

	            if (this.selectionMarker) {
	                var selectionData = {
	                        originalEvent: e, // #4890
	                        xAxis: [],
	                        yAxis: []
	                    },
	                    selectionBox = this.selectionMarker,
	                    selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,
	                    selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,
	                    selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,
	                    selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,
	                    runZoom;

	                // a selection has been made
	                if (this.hasDragged || hasPinched) {

	                    // record each axis' min and max
	                    each(chart.axes, function (axis) {
	                        if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569
	                            var horiz = axis.horiz,
	                                minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0, // #1207, #3075
	                                selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
	                                selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);

	                            selectionData[axis.coll].push({
	                                axis: axis,
	                                min: mathMin(selectionMin, selectionMax), // for reversed axes
	                                max: mathMax(selectionMin, selectionMax)
	                            });
	                            runZoom = true;
	                        }
	                    });
	                    if (runZoom) {
	                        fireEvent(chart, 'selection', selectionData, function (args) {
	                            chart.zoom(extend(args, hasPinched ? { animation: false } : null));
	                        });
	                    }

	                }
	                this.selectionMarker = this.selectionMarker.destroy();

	                // Reset scaling preview
	                if (hasPinched) {
	                    this.scaleGroups();
	                }
	            }

	            // Reset all
	            if (chart) { // it may be destroyed on mouse up - #877
	                css(chart.container, { cursor: chart._cursor });
	                chart.cancelClick = this.hasDragged > 10; // #370
	                chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
	                this.pinchDown = [];
	            }
	        },

	        onContainerMouseDown: function (e) {

	            e = this.normalize(e);

	            // issue #295, dragging not always working in Firefox
	            if (e.preventDefault) {
	                e.preventDefault();
	            }

	            this.dragStart(e);
	        },



	        onDocumentMouseUp: function (e) {
	            if (charts[hoverChartIndex]) {
	                charts[hoverChartIndex].pointer.drop(e);
	            }
	        },

	        /**
	         * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.
	         * Issue #149 workaround. The mouseleave event does not always fire.
	         */
	        onDocumentMouseMove: function (e) {
	            var chart = this.chart,
	                chartPosition = this.chartPosition;

	            e = this.normalize(e, chartPosition);

	            // If we're outside, hide the tooltip
	            if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&
	                    !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
	                this.reset();
	            }
	        },

	        /**
	         * When mouse leaves the container, hide the tooltip.
	         */
	        onContainerMouseLeave: function (e) {
	            var chart = charts[hoverChartIndex];
	            if (chart && (e.relatedTarget || e.toElement)) { // #4886, MS Touch end fires mouseleave but with no related target
	                chart.pointer.reset();
	                chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix
	            }
	        },

	        // The mousemove, touchmove and touchstart event handler
	        onContainerMouseMove: function (e) {

	            var chart = this.chart;

	            if (!defined(hoverChartIndex) || !charts[hoverChartIndex] || !charts[hoverChartIndex].mouseIsDown) {
	                hoverChartIndex = chart.index;
	            }

	            e = this.normalize(e);
	            e.returnValue = false; // #2251, #3224

	            if (chart.mouseIsDown === 'mousedown') {
	                this.drag(e);
	            }

	            // Show the tooltip and run mouse over events (#977)
	            if ((this.inClass(e.target, 'highcharts-tracker') ||
	                    chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
	                this.runPointActions(e);
	            }
	        },

	        /**
	         * Utility to detect whether an element has, or has a parent with, a specific
	         * class name. Used on detection of tracker objects and on deciding whether
	         * hovering the tooltip should cause the active series to mouse out.
	         */
	        inClass: function (element, className) {
	            var elemClassName;
	            while (element) {
	                elemClassName = attr(element, 'class');
	                if (elemClassName) {
	                    if (elemClassName.indexOf(className) !== -1) {
	                        return true;
	                    }
	                    if (elemClassName.indexOf(PREFIX + 'container') !== -1) {
	                        return false;
	                    }
	                }
	                element = element.parentNode;
	            }
	        },

	        onTrackerMouseOut: function (e) {
	            var series = this.chart.hoverSeries,
	                relatedTarget = e.relatedTarget || e.toElement;

	            if (series && relatedTarget && !series.options.stickyTracking && // #4886
	                    !this.inClass(relatedTarget, PREFIX + 'tooltip') &&
	                    !this.inClass(relatedTarget, PREFIX + 'series-' + series.index)) { // #2499, #4465
	                series.onMouseOut();
	            }
	        },

	        onContainerClick: function (e) {
	            var chart = this.chart,
	                hoverPoint = chart.hoverPoint,
	                plotLeft = chart.plotLeft,
	                plotTop = chart.plotTop;

	            e = this.normalize(e);

	            if (!chart.cancelClick) {

	                // On tracker click, fire the series and point events. #783, #1583
	                if (hoverPoint && this.inClass(e.target, PREFIX + 'tracker')) {

	                    // the series click event
	                    fireEvent(hoverPoint.series, 'click', extend(e, {
	                        point: hoverPoint
	                    }));

	                    // the point click event
	                    if (chart.hoverPoint) { // it may be destroyed (#1844)
	                        hoverPoint.firePointEvent('click', e);
	                    }

	                // When clicking outside a tracker, fire a chart event
	                } else {
	                    extend(e, this.getCoordinates(e));

	                    // fire a click event in the chart
	                    if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
	                        fireEvent(chart, 'click', e);
	                    }
	                }


	            }
	        },

	        /**
	         * Set the JS DOM events on the container and document. This method should contain
	         * a one-to-one assignment between methods and their handlers. Any advanced logic should
	         * be moved to the handler reflecting the event's name.
	         */
	        setDOMEvents: function () {

	            var pointer = this,
	                container = pointer.chart.container;

	            container.onmousedown = function (e) {
	                pointer.onContainerMouseDown(e);
	            };
	            container.onmousemove = function (e) {
	                pointer.onContainerMouseMove(e);
	            };
	            container.onclick = function (e) {
	                pointer.onContainerClick(e);
	            };
	            addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);
	            if (chartCount === 1) {
	                addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);
	            }
	            if (hasTouch) {
	                container.ontouchstart = function (e) {
	                    pointer.onContainerTouchStart(e);
	                };
	                container.ontouchmove = function (e) {
	                    pointer.onContainerTouchMove(e);
	                };
	                if (chartCount === 1) {
	                    addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);
	                }
	            }

	        },

	        /**
	         * Destroys the Pointer object and disconnects DOM events.
	         */
	        destroy: function () {
	            var prop;

	            removeEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);
	            if (!chartCount) {
	                removeEvent(doc, 'mouseup', this.onDocumentMouseUp);
	                removeEvent(doc, 'touchend', this.onDocumentTouchEnd);
	            }

	            // memory and CPU leak
	            clearInterval(this.tooltipTimeout);

	            for (prop in this) {
	                this[prop] = null;
	            }
	        }
	    };


	    /* Support for touch devices */
	    extend(Highcharts.Pointer.prototype, {

	        /**
	         * Run translation operations
	         */
	        pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
	            if (this.zoomHor || this.pinchHor) {
	                this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
	            }
	            if (this.zoomVert || this.pinchVert) {
	                this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
	            }
	        },

	        /**
	         * Run translation operations for each direction (horizontal and vertical) independently
	         */
	        pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
	            var chart = this.chart,
	                xy = horiz ? 'x' : 'y',
	                XY = horiz ? 'X' : 'Y',
	                sChartXY = 'chart' + XY,
	                wh = horiz ? 'width' : 'height',
	                plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
	                selectionWH,
	                selectionXY,
	                clipXY,
	                scale = forcedScale || 1,
	                inverted = chart.inverted,
	                bounds = chart.bounds[horiz ? 'h' : 'v'],
	                singleTouch = pinchDown.length === 1,
	                touch0Start = pinchDown[0][sChartXY],
	                touch0Now = touches[0][sChartXY],
	                touch1Start = !singleTouch && pinchDown[1][sChartXY],
	                touch1Now = !singleTouch && touches[1][sChartXY],
	                outOfBounds,
	                transformScale,
	                scaleKey,
	                setScale = function () {
	                    if (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis
	                        scale = forcedScale || mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start);
	                    }

	                    clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
	                    selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;
	                };

	            // Set the scale, first pass
	            setScale();

	            selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not

	            // Out of bounds
	            if (selectionXY < bounds.min) {
	                selectionXY = bounds.min;
	                outOfBounds = true;
	            } else if (selectionXY + selectionWH > bounds.max) {
	                selectionXY = bounds.max - selectionWH;
	                outOfBounds = true;
	            }

	            // Is the chart dragged off its bounds, determined by dataMin and dataMax?
	            if (outOfBounds) {

	                // Modify the touchNow position in order to create an elastic drag movement. This indicates
	                // to the user that the chart is responsive but can't be dragged further.
	                touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
	                if (!singleTouch) {
	                    touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
	                }

	                // Set the scale, second pass to adapt to the modified touchNow positions
	                setScale();

	            } else {
	                lastValidTouch[xy] = [touch0Now, touch1Now];
	            }

	            // Set geometry for clipping, selection and transformation
	            if (!inverted) {
	                clip[xy] = clipXY - plotLeftTop;
	                clip[wh] = selectionWH;
	            }
	            scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
	            transformScale = inverted ? 1 / scale : scale;

	            selectionMarker[wh] = selectionWH;
	            selectionMarker[xy] = selectionXY;
	            transform[scaleKey] = scale;
	            transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));
	        },

	        /**
	         * Handle touch events with two touches
	         */
	        pinch: function (e) {

	            var self = this,
	                chart = self.chart,
	                pinchDown = self.pinchDown,
	                touches = e.touches,
	                touchesLength = touches.length,
	                lastValidTouch = self.lastValidTouch,
	                hasZoom = self.hasZoom,
	                selectionMarker = self.selectionMarker,
	                transform = {},
	                fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, PREFIX + 'tracker') &&
	                    chart.runTrackerClick) || self.runChartClick),
	                clip = {};

	            // Don't initiate panning until the user has pinched. This prevents us from
	            // blocking page scrolling as users scroll down a long page (#4210).
	            if (touchesLength > 1) {
	                self.initiated = true;
	            }

	            // On touch devices, only proceed to trigger click if a handler is defined
	            if (hasZoom && self.initiated && !fireClickEvent) {
	                e.preventDefault();
	            }

	            // Normalize each touch
	            map(touches, function (e) {
	                return self.normalize(e);
	            });

	            // Register the touch start position
	            if (e.type === 'touchstart') {
	                each(touches, function (e, i) {
	                    pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };
	                });
	                lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
	                lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];

	                // Identify the data bounds in pixels
	                each(chart.axes, function (axis) {
	                    if (axis.zoomEnabled) {
	                        var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
	                            minPixelPadding = axis.minPixelPadding,
	                            min = axis.toPixels(pick(axis.options.min, axis.dataMin)),
	                            max = axis.toPixels(pick(axis.options.max, axis.dataMax)),
	                            absMin = mathMin(min, max),
	                            absMax = mathMax(min, max);

	                        // Store the bounds for use in the touchmove handler
	                        bounds.min = mathMin(axis.pos, absMin - minPixelPadding);
	                        bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);
	                    }
	                });
	                self.res = true; // reset on next move

	            // Event type is touchmove, handle panning and pinching
	            } else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first


	                // Set the marker
	                if (!selectionMarker) {
	                    self.selectionMarker = selectionMarker = extend({
	                        destroy: noop,
	                        touch: true
	                    }, chart.plotBox);
	                }

	                self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);

	                self.hasPinched = hasZoom;

	                // Scale and translate the groups to provide visual feedback during pinching
	                self.scaleGroups(transform, clip);

	                // Optionally move the tooltip on touchmove
	                if (!hasZoom && self.followTouchMove && touchesLength === 1) {
	                    this.runPointActions(self.normalize(e));
	                } else if (self.res) {
	                    self.res = false;
	                    this.reset(false, 0);
	                }
	            }
	        },

	        /**
	         * General touch handler shared by touchstart and touchmove.
	         */
	        touch: function (e, start) {
	            var chart = this.chart;

	            hoverChartIndex = chart.index;

	            if (e.touches.length === 1) {

	                e = this.normalize(e);

	                if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {

	                    // Run mouse events and display tooltip etc
	                    if (start) {
	                        this.runPointActions(e);
	                    }

	                    this.pinch(e);

	                } else if (start) {
	                    // Hide the tooltip on touching outside the plot area (#1203)
	                    this.reset();
	                }

	            } else if (e.touches.length === 2) {
	                this.pinch(e);
	            }
	        },

	        onContainerTouchStart: function (e) {
	            this.touch(e, true);
	        },

	        onContainerTouchMove: function (e) {
	            this.touch(e);
	        },

	        onDocumentTouchEnd: function (e) {
	            if (charts[hoverChartIndex]) {
	                charts[hoverChartIndex].pointer.drop(e);
	            }
	        }

	    });
	    if (win.PointerEvent || win.MSPointerEvent) {

	        // The touches object keeps track of the points being touched at all times
	        var touches = {},
	            hasPointerEvent = !!win.PointerEvent,
	            getWebkitTouches = function () {
	                var key, fake = [];
	                fake.item = function (i) {
	                    return this[i];
	                };
	                for (key in touches) {
	                    if (touches.hasOwnProperty(key)) {
	                        fake.push({
	                            pageX: touches[key].pageX,
	                            pageY: touches[key].pageY,
	                            target: touches[key].target
	                        });
	                    }
	                }
	                return fake;
	            },
	            translateMSPointer = function (e, method, wktype, func) {
	                var p;
	                if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[hoverChartIndex]) {
	                    func(e);
	                    p = charts[hoverChartIndex].pointer;
	                    p[method]({
	                        type: wktype,
	                        target: e.currentTarget,
	                        preventDefault: noop,
	                        touches: getWebkitTouches()
	                    });
	                }
	            };

	        /**
	         * Extend the Pointer prototype with methods for each event handler and more
	         */
	        extend(Pointer.prototype, {
	            onContainerPointerDown: function (e) {
	                translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {
	                    touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };
	                });
	            },
	            onContainerPointerMove: function (e) {
	                translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {
	                    touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };
	                    if (!touches[e.pointerId].target) {
	                        touches[e.pointerId].target = e.currentTarget;
	                    }
	                });
	            },
	            onDocumentPointerUp: function (e) {
	                translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function (e) {
	                    delete touches[e.pointerId];
	                });
	            },

	            /**
	             * Add or remove the MS Pointer specific events
	             */
	            batchMSEvents: function (fn) {
	                fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);
	                fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);
	                fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);
	            }
	        });

	        // Disable default IE actions for pinch and such on chart element
	        wrap(Pointer.prototype, 'init', function (proceed, chart, options) {
	            proceed.call(this, chart, options);
	            if (this.hasZoom) { // #4014
	                css(chart.container, {
	                    '-ms-touch-action': NONE,
	                    'touch-action': NONE
	                });
	            }
	        });

	        // Add IE specific touch events to chart
	        wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {
	            proceed.apply(this);
	            if (this.hasZoom || this.followTouchMove) {
	                this.batchMSEvents(addEvent);
	            }
	        });
	        // Destroy MS events also
	        wrap(Pointer.prototype, 'destroy', function (proceed) {
	            this.batchMSEvents(removeEvent);
	            proceed.call(this);
	        });
	    }
	    /**
	     * The overview of the chart's series
	     */
	    var Legend = Highcharts.Legend = function (chart, options) {
	        this.init(chart, options);
	    };

	    Legend.prototype = {

	        /**
	         * Initialize the legend
	         */
	        init: function (chart, options) {

	            var legend = this,
	                itemStyle = options.itemStyle,
	                padding,
	                itemMarginTop = options.itemMarginTop || 0;

	            this.options = options;

	            if (!options.enabled) {
	                return;
	            }

	            legend.itemStyle = itemStyle;
	            legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);
	            legend.itemMarginTop = itemMarginTop;
	            legend.padding = padding = pick(options.padding, 8);
	            legend.initialItemX = padding;
	            legend.initialItemY = padding - 5; // 5 is the number of pixels above the text
	            legend.maxItemWidth = 0;
	            legend.chart = chart;
	            legend.itemHeight = 0;
	            legend.symbolWidth = pick(options.symbolWidth, 16);
	            legend.pages = [];


	            // Render it
	            legend.render();

	            // move checkboxes
	            addEvent(legend.chart, 'endResize', function () {
	                legend.positionCheckboxes();
	            });

	        },

	        /**
	         * Set the colors for the legend item
	         * @param {Object} item A Series or Point instance
	         * @param {Object} visible Dimmed or colored
	         */
	        colorizeItem: function (item, visible) {
	            var legend = this,
	                options = legend.options,
	                legendItem = item.legendItem,
	                legendLine = item.legendLine,
	                legendSymbol = item.legendSymbol,
	                hiddenColor = legend.itemHiddenStyle.color,
	                textColor = visible ? options.itemStyle.color : hiddenColor,
	                symbolColor = visible ? (item.legendColor || item.color || '#CCC') : hiddenColor,
	                markerOptions = item.options && item.options.marker,
	                symbolAttr = { fill: symbolColor },
	                key,
	                val;

	            if (legendItem) {
	                legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE
	            }
	            if (legendLine) {
	                legendLine.attr({ stroke: symbolColor });
	            }

	            if (legendSymbol) {

	                // Apply marker options
	                if (markerOptions && legendSymbol.isMarker) { // #585
	                    symbolAttr.stroke = symbolColor;
	                    markerOptions = item.convertAttribs(markerOptions);
	                    for (key in markerOptions) {
	                        val = markerOptions[key];
	                        if (val !== UNDEFINED) {
	                            symbolAttr[key] = val;
	                        }
	                    }
	                }

	                legendSymbol.attr(symbolAttr);
	            }
	        },

	        /**
	         * Position the legend item
	         * @param {Object} item A Series or Point instance
	         */
	        positionItem: function (item) {
	            var legend = this,
	                options = legend.options,
	                symbolPadding = options.symbolPadding,
	                ltr = !options.rtl,
	                legendItemPos = item._legendItemPos,
	                itemX = legendItemPos[0],
	                itemY = legendItemPos[1],
	                checkbox = item.checkbox,
	                legendGroup = item.legendGroup;

	            if (legendGroup && legendGroup.element) {
	                legendGroup.translate(
	                    ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
	                    itemY
	                );
	            }

	            if (checkbox) {
	                checkbox.x = itemX;
	                checkbox.y = itemY;
	            }
	        },

	        /**
	         * Destroy a single legend item
	         * @param {Object} item The series or point
	         */
	        destroyItem: function (item) {
	            var checkbox = item.checkbox;

	            // destroy SVG elements
	            each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {
	                if (item[key]) {
	                    item[key] = item[key].destroy();
	                }
	            });

	            if (checkbox) {
	                discardElement(item.checkbox);
	            }
	        },

	        /**
	         * Destroys the legend.
	         */
	        destroy: function () {
	            var legend = this,
	                legendGroup = legend.group,
	                box = legend.box;

	            if (box) {
	                legend.box = box.destroy();
	            }

	            if (legendGroup) {
	                legend.group = legendGroup.destroy();
	            }
	        },

	        /**
	         * Position the checkboxes after the width is determined
	         */
	        positionCheckboxes: function (scrollOffset) {
	            var alignAttr = this.group.alignAttr,
	                translateY,
	                clipHeight = this.clipHeight || this.legendHeight,
	                titleHeight = this.titleHeight;

	            if (alignAttr) {
	                translateY = alignAttr.translateY;
	                each(this.allItems, function (item) {
	                    var checkbox = item.checkbox,
	                        top;

	                    if (checkbox) {
	                        top = translateY + titleHeight + checkbox.y + (scrollOffset || 0) + 3;
	                        css(checkbox, {
	                            left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + PX,
	                            top: top + PX,
	                            display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE
	                        });
	                    }
	                });
	            }
	        },

	        /**
	         * Render the legend title on top of the legend
	         */
	        renderTitle: function () {
	            var options = this.options,
	                padding = this.padding,
	                titleOptions = options.title,
	                titleHeight = 0,
	                bBox;

	            if (titleOptions.text) {
	                if (!this.title) {
	                    this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')
	                        .attr({ zIndex: 1 })
	                        .css(titleOptions.style)
	                        .add(this.group);
	                }
	                bBox = this.title.getBBox();
	                titleHeight = bBox.height;
	                this.offsetWidth = bBox.width; // #1717
	                this.contentGroup.attr({ translateY: titleHeight });
	            }
	            this.titleHeight = titleHeight;
	        },

	        /**
	         * Set the legend item text
	         */
	        setText: function (item) {
	            var options = this.options;
	            item.legendItem.attr({
	                text: options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item)
	            });
	        },

	        /**
	         * Render a single specific legend item
	         * @param {Object} item A series or point
	         */
	        renderItem: function (item) {
	            var legend = this,
	                chart = legend.chart,
	                renderer = chart.renderer,
	                options = legend.options,
	                horizontal = options.layout === 'horizontal',
	                symbolWidth = legend.symbolWidth,
	                symbolPadding = options.symbolPadding,
	                itemStyle = legend.itemStyle,
	                itemHiddenStyle = legend.itemHiddenStyle,
	                padding = legend.padding,
	                itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
	                ltr = !options.rtl,
	                itemHeight,
	                widthOption = options.width,
	                itemMarginBottom = options.itemMarginBottom || 0,
	                itemMarginTop = legend.itemMarginTop,
	                initialItemX = legend.initialItemX,
	                bBox,
	                itemWidth,
	                li = item.legendItem,
	                series = item.series && item.series.drawLegendSymbol ? item.series : item,
	                seriesOptions = series.options,
	                showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,
	                useHTML = options.useHTML;

	            if (!li) { // generate it once, later move it

	                // Generate the group box
	                // A group to hold the symbol and text. Text is to be appended in Legend class.
	                item.legendGroup = renderer.g('legend-item')
	                    .attr({ zIndex: 1 })
	                    .add(legend.scrollGroup);

	                // Generate the list item text and add it to the group
	                item.legendItem = li = renderer.text(
	                        '',
	                        ltr ? symbolWidth + symbolPadding : -symbolPadding,
	                        legend.baseline || 0,
	                        useHTML
	                    )
	                    .css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)
	                    .attr({
	                        align: ltr ? 'left' : 'right',
	                        zIndex: 2
	                    })
	                    .add(item.legendGroup);

	                // Get the baseline for the first item - the font size is equal for all
	                if (!legend.baseline) {
	                    legend.fontMetrics = renderer.fontMetrics(itemStyle.fontSize, li);
	                    legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;
	                    li.attr('y', legend.baseline);
	                }

	                // Draw the legend symbol inside the group box
	                series.drawLegendSymbol(legend, item);

	                if (legend.setItemEvents) {
	                    legend.setItemEvents(item, li, useHTML, itemStyle, itemHiddenStyle);
	                }

	                // add the HTML checkbox on top
	                if (showCheckbox) {
	                    legend.createCheckboxForItem(item);
	                }
	            }

	            // Colorize the items
	            legend.colorizeItem(item, item.visible);

	            // Always update the text
	            legend.setText(item);

	            // calculate the positions for the next line
	            bBox = li.getBBox();

	            itemWidth = item.checkboxOffset =
	                options.itemWidth ||
	                item.legendItemWidth ||
	                symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);
	            legend.itemHeight = itemHeight = mathRound(item.legendItemHeight || bBox.height);

	            // if the item exceeds the width, start a new line
	            if (horizontal && legend.itemX - initialItemX + itemWidth >
	                    (widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {
	                legend.itemX = initialItemX;
	                legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;
	                legend.lastLineHeight = 0; // reset for next line (#915, #3976)
	            }

	            // If the item exceeds the height, start a new column
	            /*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {
	                legend.itemY = legend.initialItemY;
	                legend.itemX += legend.maxItemWidth;
	                legend.maxItemWidth = 0;
	            }*/

	            // Set the edge positions
	            legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);
	            legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
	            legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915

	            // cache the position of the newly generated or reordered items
	            item._legendItemPos = [legend.itemX, legend.itemY];

	            // advance
	            if (horizontal) {
	                legend.itemX += itemWidth;

	            } else {
	                legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
	                legend.lastLineHeight = itemHeight;
	            }

	            // the width of the widest item
	            legend.offsetWidth = widthOption || mathMax(
	                (horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,
	                legend.offsetWidth
	            );
	        },

	        /**
	         * Get all items, which is one item per series for normal series and one item per point
	         * for pie series.
	         */
	        getAllItems: function () {
	            var allItems = [];
	            each(this.chart.series, function (series) {
	                var seriesOptions = series.options;

	                // Handle showInLegend. If the series is linked to another series, defaults to false.
	                if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {
	                    return;
	                }

	                // use points or series for the legend item depending on legendType
	                allItems = allItems.concat(
	                        series.legendItems ||
	                        (seriesOptions.legendType === 'point' ?
	                                series.data :
	                                series)
	                );
	            });
	            return allItems;
	        },

	        /**
	         * Adjust the chart margins by reserving space for the legend on only one side
	         * of the chart. If the position is set to a corner, top or bottom is reserved
	         * for horizontal legends and left or right for vertical ones.
	         */
	        adjustMargins: function (margin, spacing) {
	            var chart = this.chart,
	                options = this.options,
	                // Use the first letter of each alignment option in order to detect the side
	                alignment = options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0); // #4189 - use charAt(x) notation instead of [x] for IE7

	            if (this.display && !options.floating) {

	                each([
	                    /(lth|ct|rth)/,
	                    /(rtv|rm|rbv)/,
	                    /(rbh|cb|lbh)/,
	                    /(lbv|lm|ltv)/
	                ], function (alignments, side) {
	                    if (alignments.test(alignment) && !defined(margin[side])) {
	                        // Now we have detected on which side of the chart we should reserve space for the legend
	                        chart[marginNames[side]] = mathMax(
	                            chart[marginNames[side]],
	                            chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] +
	                                [1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] +
	                                pick(options.margin, 12) +
	                                spacing[side]
	                        );
	                    }
	                });
	            }
	        },

	        /**
	         * Render the legend. This method can be called both before and after
	         * chart.render. If called after, it will only rearrange items instead
	         * of creating new ones.
	         */
	        render: function () {
	            var legend = this,
	                chart = legend.chart,
	                renderer = chart.renderer,
	                legendGroup = legend.group,
	                allItems,
	                display,
	                legendWidth,
	                legendHeight,
	                box = legend.box,
	                options = legend.options,
	                padding = legend.padding,
	                legendBorderWidth = options.borderWidth,
	                legendBackgroundColor = options.backgroundColor;

	            legend.itemX = legend.initialItemX;
	            legend.itemY = legend.initialItemY;
	            legend.offsetWidth = 0;
	            legend.lastItemY = 0;

	            if (!legendGroup) {
	                legend.group = legendGroup = renderer.g('legend')
	                    .attr({ zIndex: 7 })
	                    .add();
	                legend.contentGroup = renderer.g()
	                    .attr({ zIndex: 1 }) // above background
	                    .add(legendGroup);
	                legend.scrollGroup = renderer.g()
	                    .add(legend.contentGroup);
	            }

	            legend.renderTitle();

	            // add each series or point
	            allItems = legend.getAllItems();

	            // sort by legendIndex
	            stableSort(allItems, function (a, b) {
	                return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);
	            });

	            // reversed legend
	            if (options.reversed) {
	                allItems.reverse();
	            }

	            legend.allItems = allItems;
	            legend.display = display = !!allItems.length;

	            // render the items
	            legend.lastLineHeight = 0;
	            each(allItems, function (item) {
	                legend.renderItem(item);
	            });

	            // Get the box
	            legendWidth = (options.width || legend.offsetWidth) + padding;
	            legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
	            legendHeight = legend.handleOverflow(legendHeight);
	            legendHeight += padding;

	            // Draw the border and/or background
	            if (legendBorderWidth || legendBackgroundColor) {

	                if (!box) {
	                    legend.box = box = renderer.rect(
	                        0,
	                        0,
	                        legendWidth,
	                        legendHeight,
	                        options.borderRadius,
	                        legendBorderWidth || 0
	                    ).attr({
	                        stroke: options.borderColor,
	                        'stroke-width': legendBorderWidth || 0,
	                        fill: legendBackgroundColor || NONE
	                    })
	                    .add(legendGroup)
	                    .shadow(options.shadow);
	                    box.isNew = true;

	                } else if (legendWidth > 0 && legendHeight > 0) {
	                    box[box.isNew ? 'attr' : 'animate'](
	                        box.crisp({ width: legendWidth, height: legendHeight })
	                    );
	                    box.isNew = false;
	                }

	                // hide the border if no items
	                box[display ? 'show' : 'hide']();
	            }

	            legend.legendWidth = legendWidth;
	            legend.legendHeight = legendHeight;

	            // Now that the legend width and height are established, put the items in the
	            // final position
	            each(allItems, function (item) {
	                legend.positionItem(item);
	            });

	            // 1.x compatibility: positioning based on style
	            /*var props = ['left', 'right', 'top', 'bottom'],
	                prop,
	                i = 4;
	            while (i--) {
	                prop = props[i];
	                if (options.style[prop] && options.style[prop] !== 'auto') {
	                    options[i < 2 ? 'align' : 'verticalAlign'] = prop;
	                    options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);
	                }
	            }*/

	            if (display) {
	                legendGroup.align(extend({
	                    width: legendWidth,
	                    height: legendHeight
	                }, options), true, 'spacingBox');
	            }

	            if (!chart.isResizing) {
	                this.positionCheckboxes();
	            }
	        },

	        /**
	         * Set up the overflow handling by adding navigation with up and down arrows below the
	         * legend.
	         */
	        handleOverflow: function (legendHeight) {
	            var legend = this,
	                chart = this.chart,
	                renderer = chart.renderer,
	                options = this.options,
	                optionsY = options.y,
	                alignTop = options.verticalAlign === 'top',
	                spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,
	                maxHeight = options.maxHeight,
	                clipHeight,
	                clipRect = this.clipRect,
	                navOptions = options.navigation,
	                animation = pick(navOptions.animation, true),
	                arrowSize = navOptions.arrowSize || 12,
	                nav = this.nav,
	                pages = this.pages,
	                padding = this.padding,
	                lastY,
	                allItems = this.allItems,
	                clipToHeight = function (height) {
	                    clipRect.attr({
	                        height: height
	                    });

	                    // useHTML
	                    if (legend.contentGroup.div) {
	                        legend.contentGroup.div.style.clip = 'rect(' + padding + 'px,9999px,' + (padding + height) + 'px,0)';
	                    }
	                };


	            // Adjust the height
	            if (options.layout === 'horizontal') {
	                spaceHeight /= 2;
	            }
	            if (maxHeight) {
	                spaceHeight = mathMin(spaceHeight, maxHeight);
	            }

	            // Reset the legend height and adjust the clipping rectangle
	            pages.length = 0;
	            if (legendHeight > spaceHeight) {

	                this.clipHeight = clipHeight = mathMax(spaceHeight - 20 - this.titleHeight - padding, 0);
	                this.currentPage = pick(this.currentPage, 1);
	                this.fullHeight = legendHeight;

	                // Fill pages with Y positions so that the top of each a legend item defines
	                // the scroll top for each page (#2098)
	                each(allItems, function (item, i) {
	                    var y = item._legendItemPos[1],
	                        h = mathRound(item.legendItem.getBBox().height),
	                        len = pages.length;

	                    if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {
	                        pages.push(lastY || y);
	                        len++;
	                    }

	                    if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {
	                        pages.push(y);
	                    }
	                    if (y !== lastY) {
	                        lastY = y;
	                    }
	                });

	                // Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)
	                if (!clipRect) {
	                    clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);
	                    legend.contentGroup.clip(clipRect);
	                }

	                clipToHeight(clipHeight);

	                // Add navigation elements
	                if (!nav) {
	                    this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
	                    this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)
	                        .on('click', function () {
	                            legend.scroll(-1, animation);
	                        })
	                        .add(nav);
	                    this.pager = renderer.text('', 15, 10)
	                        .css(navOptions.style)
	                        .add(nav);
	                    this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)
	                        .on('click', function () {
	                            legend.scroll(1, animation);
	                        })
	                        .add(nav);
	                }

	                // Set initial position
	                legend.scroll(0);

	                legendHeight = spaceHeight;

	            } else if (nav) {
	                clipToHeight(chart.chartHeight);
	                nav.hide();
	                this.scrollGroup.attr({
	                    translateY: 1
	                });
	                this.clipHeight = 0; // #1379
	            }

	            return legendHeight;
	        },

	        /**
	         * Scroll the legend by a number of pages
	         * @param {Object} scrollBy
	         * @param {Object} animation
	         */
	        scroll: function (scrollBy, animation) {
	            var pages = this.pages,
	                pageCount = pages.length,
	                currentPage = this.currentPage + scrollBy,
	                clipHeight = this.clipHeight,
	                navOptions = this.options.navigation,
	                activeColor = navOptions.activeColor,
	                inactiveColor = navOptions.inactiveColor,
	                pager = this.pager,
	                padding = this.padding,
	                scrollOffset;

	            // When resizing while looking at the last page
	            if (currentPage > pageCount) {
	                currentPage = pageCount;
	            }

	            if (currentPage > 0) {

	                if (animation !== UNDEFINED) {
	                    setAnimation(animation, this.chart);
	                }

	                this.nav.attr({
	                    translateX: padding,
	                    translateY: clipHeight + this.padding + 7 + this.titleHeight,
	                    visibility: VISIBLE
	                });
	                this.up.attr({
	                        fill: currentPage === 1 ? inactiveColor : activeColor
	                    })
	                    .css({
	                        cursor: currentPage === 1 ? 'default' : 'pointer'
	                    });
	                pager.attr({
	                    text: currentPage + '/' + pageCount
	                });
	                this.down.attr({
	                        x: 18 + this.pager.getBBox().width, // adjust to text width
	                        fill: currentPage === pageCount ? inactiveColor : activeColor
	                    })
	                    .css({
	                        cursor: currentPage === pageCount ? 'default' : 'pointer'
	                    });

	                scrollOffset = -pages[currentPage - 1] + this.initialItemY;

	                this.scrollGroup.animate({
	                    translateY: scrollOffset
	                });

	                this.currentPage = currentPage;
	                this.positionCheckboxes(scrollOffset);
	            }

	        }

	    };

	    /*
	     * LegendSymbolMixin
	     */

	    var LegendSymbolMixin = Highcharts.LegendSymbolMixin = {

	        /**
	         * Get the series' symbol in the legend
	         *
	         * @param {Object} legend The legend object
	         * @param {Object} item The series (this) or point
	         */
	        drawRectangle: function (legend, item) {
	            var symbolHeight = legend.options.symbolHeight || legend.fontMetrics.f;

	            item.legendSymbol = this.chart.renderer.rect(
	                0,
	                legend.baseline - symbolHeight + 1, // #3988
	                legend.symbolWidth,
	                symbolHeight,
	                legend.options.symbolRadius || 0
	            ).attr({
	                zIndex: 3
	            }).add(item.legendGroup);

	        },

	        /**
	         * Get the series' symbol in the legend. This method should be overridable to create custom
	         * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.
	         *
	         * @param {Object} legend The legend object
	         */
	        drawLineMarker: function (legend) {

	            var options = this.options,
	                markerOptions = options.marker,
	                radius,
	                legendSymbol,
	                symbolWidth = legend.symbolWidth,
	                renderer = this.chart.renderer,
	                legendItemGroup = this.legendGroup,
	                verticalCenter = legend.baseline - mathRound(legend.fontMetrics.b * 0.3),
	                attr;

	            // Draw the line
	            if (options.lineWidth) {
	                attr = {
	                    'stroke-width': options.lineWidth
	                };
	                if (options.dashStyle) {
	                    attr.dashstyle = options.dashStyle;
	                }
	                this.legendLine = renderer.path([
	                    M,
	                    0,
	                    verticalCenter,
	                    L,
	                    symbolWidth,
	                    verticalCenter
	                ])
	                .attr(attr)
	                .add(legendItemGroup);
	            }

	            // Draw the marker
	            if (markerOptions && markerOptions.enabled !== false) {
	                radius = markerOptions.radius;
	                this.legendSymbol = legendSymbol = renderer.symbol(
	                    this.symbol,
	                    (symbolWidth / 2) - radius,
	                    verticalCenter - radius,
	                    2 * radius,
	                    2 * radius,
	                    markerOptions
	                )
	                .add(legendItemGroup);
	                legendSymbol.isMarker = true;
	            }
	        }
	    };

	    // Workaround for #2030, horizontal legend items not displaying in IE11 Preview,
	    // and for #2580, a similar drawing flaw in Firefox 26.
	    // Explore if there's a general cause for this. The problem may be related
	    // to nested group elements, as the legend item texts are within 4 group elements.
	    if (/Trident\/7\.0/.test(userAgent) || isFirefox) {
	        wrap(Legend.prototype, 'positionItem', function (proceed, item) {
	            var legend = this,
	                runPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)
	                    if (item._legendItemPos) {
	                        proceed.call(legend, item);
	                    }
	                };

	            // Do it now, for export and to get checkbox placement
	            runPositionItem();

	            // Do it after to work around the core issue
	            setTimeout(runPositionItem);
	        });
	    }
	    /**
	     * The Chart class
	     * @param {String|Object} renderTo The DOM element to render to, or its id
	     * @param {Object} options
	     * @param {Function} callback Function to run when the chart has loaded
	     */
	    var Chart = Highcharts.Chart = function () {
	        this.getArgs.apply(this, arguments);
	    };

	    Highcharts.chart = function (a, b, c) {
	        return new Chart(a, b, c);
	    };

	    Chart.prototype = {

	        /**
	         * Hook for modules
	         */
	        callbacks: [],

	        /**
	         * Handle the arguments passed to the constructor
	         * @returns {Array} Arguments without renderTo
	         */
	        getArgs: function () {
	            var args = [].slice.call(arguments);
	        
	            // Remove the optional first argument, renderTo, and
	            // set it on this.
	            if (isString(args[0]) || args[0].nodeName) {
	                this.renderTo = args.shift();
	            }
	            this.init(args[0], args[1]);
	        },

	        /**
	         * Initialize the chart
	         */
	        init: function (userOptions, callback) {

	            // Handle regular options
	            var options,
	                seriesOptions = userOptions.series; // skip merging data points to increase performance

	            userOptions.series = null;
	            options = merge(defaultOptions, userOptions); // do the merge
	            options.series = userOptions.series = seriesOptions; // set back the series data
	            this.userOptions = userOptions;

	            var optionsChart = options.chart;

	            // Create margin & spacing array
	            this.margin = this.splashArray('margin', optionsChart);
	            this.spacing = this.splashArray('spacing', optionsChart);

	            var chartEvents = optionsChart.events;

	            //this.runChartClick = chartEvents && !!chartEvents.click;
	            this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom

	            this.callback = callback;
	            this.isResizing = 0;
	            this.options = options;
	            //chartTitleOptions = UNDEFINED;
	            //chartSubtitleOptions = UNDEFINED;

	            this.axes = [];
	            this.series = [];
	            this.hasCartesianSeries = optionsChart.showAxes;
	            //this.axisOffset = UNDEFINED;
	            //this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes
	            //this.inverted = UNDEFINED;
	            //this.loadingShown = UNDEFINED;
	            //this.container = UNDEFINED;
	            //this.chartWidth = UNDEFINED;
	            //this.chartHeight = UNDEFINED;
	            //this.marginRight = UNDEFINED;
	            //this.marginBottom = UNDEFINED;
	            //this.containerWidth = UNDEFINED;
	            //this.containerHeight = UNDEFINED;
	            //this.oldChartWidth = UNDEFINED;
	            //this.oldChartHeight = UNDEFINED;

	            //this.renderTo = UNDEFINED;
	            //this.renderToClone = UNDEFINED;

	            //this.spacingBox = UNDEFINED

	            //this.legend = UNDEFINED;

	            // Elements
	            //this.chartBackground = UNDEFINED;
	            //this.plotBackground = UNDEFINED;
	            //this.plotBGImage = UNDEFINED;
	            //this.plotBorder = UNDEFINED;
	            //this.loadingDiv = UNDEFINED;
	            //this.loadingSpan = UNDEFINED;

	            var chart = this,
	                eventType;

	            // Add the chart to the global lookup
	            chart.index = charts.length;
	            charts.push(chart);
	            chartCount++;

	            // Set up auto resize
	            if (optionsChart.reflow !== false) {
	                addEvent(chart, 'load', function () {
	                    chart.initReflow();
	                });
	            }

	            // Chart event handlers
	            if (chartEvents) {
	                for (eventType in chartEvents) {
	                    addEvent(chart, eventType, chartEvents[eventType]);
	                }
	            }

	            chart.xAxis = [];
	            chart.yAxis = [];

	            // Expose methods and variables
	            chart.animation = useCanVG ? false : pick(optionsChart.animation, true);
	            chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;

	            chart.firstRender();
	        },

	        /**
	         * Initialize an individual series, called internally before render time
	         */
	        initSeries: function (options) {
	            var chart = this,
	                optionsChart = chart.options.chart,
	                type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
	                series,
	                constr = seriesTypes[type];

	            // No such series type
	            if (!constr) {
	                error(17, true);
	            }

	            series = new constr();
	            series.init(this, options);
	            return series;
	        },

	        /**
	         * Check whether a given point is within the plot area
	         *
	         * @param {Number} plotX Pixel x relative to the plot area
	         * @param {Number} plotY Pixel y relative to the plot area
	         * @param {Boolean} inverted Whether the chart is inverted
	         */
	        isInsidePlot: function (plotX, plotY, inverted) {
	            var x = inverted ? plotY : plotX,
	                y = inverted ? plotX : plotY;

	            return x >= 0 &&
	                x <= this.plotWidth &&
	                y >= 0 &&
	                y <= this.plotHeight;
	        },

	        /**
	         * Redraw legend, axes or series based on updated data
	         *
	         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	         *    configuration
	         */
	        redraw: function (animation) {
	            var chart = this,
	                axes = chart.axes,
	                series = chart.series,
	                pointer = chart.pointer,
	                legend = chart.legend,
	                redrawLegend = chart.isDirtyLegend,
	                hasStackedSeries,
	                hasDirtyStacks,
	                hasCartesianSeries = chart.hasCartesianSeries,
	                isDirtyBox = chart.isDirtyBox,
	                seriesLength = series.length,
	                i = seriesLength,
	                serie,
	                renderer = chart.renderer,
	                isHiddenChart = renderer.isHidden(),
	                afterRedraw = [];

	            setAnimation(animation, chart);

	            if (isHiddenChart) {
	                chart.cloneRenderTo();
	            }

	            // Adjust title layout (reflow multiline text)
	            chart.layOutTitles();

	            // link stacked series
	            while (i--) {
	                serie = series[i];

	                if (serie.options.stacking) {
	                    hasStackedSeries = true;

	                    if (serie.isDirty) {
	                        hasDirtyStacks = true;
	                        break;
	                    }
	                }
	            }
	            if (hasDirtyStacks) { // mark others as dirty
	                i = seriesLength;
	                while (i--) {
	                    serie = series[i];
	                    if (serie.options.stacking) {
	                        serie.isDirty = true;
	                    }
	                }
	            }

	            // Handle updated data in the series
	            each(series, function (serie) {
	                if (serie.isDirty) {
	                    if (serie.options.legendType === 'point') {
	                        if (serie.updateTotals) {
	                            serie.updateTotals();
	                        }
	                        redrawLegend = true;
	                    }
	                }
	            });

	            // handle added or removed series
	            if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed
	                // draw legend graphics
	                legend.render();

	                chart.isDirtyLegend = false;
	            }

	            // reset stacks
	            if (hasStackedSeries) {
	                chart.getStacks();
	            }


	            if (hasCartesianSeries) {
	                if (!chart.isResizing) {

	                    // reset maxTicks
	                    chart.maxTicks = null;

	                    // set axes scales
	                    each(axes, function (axis) {
	                        axis.setScale();
	                    });
	                }
	            }

	            chart.getMargins(); // #3098

	            if (hasCartesianSeries) {
	                // If one axis is dirty, all axes must be redrawn (#792, #2169)
	                each(axes, function (axis) {
	                    if (axis.isDirty) {
	                        isDirtyBox = true;
	                    }
	                });

	                // redraw axes
	                each(axes, function (axis) {

	                    // Fire 'afterSetExtremes' only if extremes are set
	                    var key = axis.min + ',' + axis.max;
	                    if (axis.extKey !== key) { // #821, #4452
	                        axis.extKey = key;
	                        afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)
	                            fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751
	                            delete axis.eventArgs;
	                        });
	                    }
	                    if (isDirtyBox || hasStackedSeries) {
	                        axis.redraw();
	                    }
	                });
	            }

	            // the plot areas size has changed
	            if (isDirtyBox) {
	                chart.drawChartBox();
	            }


	            // redraw affected series
	            each(series, function (serie) {
	                if (serie.isDirty && serie.visible &&
	                        (!serie.isCartesian || serie.xAxis)) { // issue #153
	                    serie.redraw();
	                }
	            });

	            // move tooltip or reset
	            if (pointer) {
	                pointer.reset(true);
	            }

	            // redraw if canvas
	            renderer.draw();

	            // fire the event
	            fireEvent(chart, 'redraw');

	            if (isHiddenChart) {
	                chart.cloneRenderTo(true);
	            }

	            // Fire callbacks that are put on hold until after the redraw
	            each(afterRedraw, function (callback) {
	                callback.call();
	            });
	        },

	        /**
	         * Get an axis, series or point object by id.
	         * @param id {String} The id as given in the configuration options
	         */
	        get: function (id) {
	            var chart = this,
	                axes = chart.axes,
	                series = chart.series;

	            var i,
	                j,
	                points;

	            // search axes
	            for (i = 0; i < axes.length; i++) {
	                if (axes[i].options.id === id) {
	                    return axes[i];
	                }
	            }

	            // search series
	            for (i = 0; i < series.length; i++) {
	                if (series[i].options.id === id) {
	                    return series[i];
	                }
	            }

	            // search points
	            for (i = 0; i < series.length; i++) {
	                points = series[i].points || [];
	                for (j = 0; j < points.length; j++) {
	                    if (points[j].id === id) {
	                        return points[j];
	                    }
	                }
	            }
	            return null;
	        },

	        /**
	         * Create the Axis instances based on the config options
	         */
	        getAxes: function () {
	            var chart = this,
	                options = this.options,
	                xAxisOptions = options.xAxis = splat(options.xAxis || {}),
	                yAxisOptions = options.yAxis = splat(options.yAxis || {}),
	                optionsArray;

	            // make sure the options are arrays and add some members
	            each(xAxisOptions, function (axis, i) {
	                axis.index = i;
	                axis.isX = true;
	            });

	            each(yAxisOptions, function (axis, i) {
	                axis.index = i;
	            });

	            // concatenate all axis options into one array
	            optionsArray = xAxisOptions.concat(yAxisOptions);

	            each(optionsArray, function (axisOptions) {
	                new Axis(chart, axisOptions); // eslint-disable-line no-new
	            });
	        },


	        /**
	         * Get the currently selected points from all series
	         */
	        getSelectedPoints: function () {
	            var points = [];
	            each(this.series, function (serie) {
	                points = points.concat(grep(serie.points || [], function (point) {
	                    return point.selected;
	                }));
	            });
	            return points;
	        },

	        /**
	         * Get the currently selected series
	         */
	        getSelectedSeries: function () {
	            return grep(this.series, function (serie) {
	                return serie.selected;
	            });
	        },

	        /**
	         * Show the title and subtitle of the chart
	         *
	         * @param titleOptions {Object} New title options
	         * @param subtitleOptions {Object} New subtitle options
	         *
	         */
	        setTitle: function (titleOptions, subtitleOptions, redraw) {
	            var chart = this,
	                options = chart.options,
	                chartTitleOptions,
	                chartSubtitleOptions;

	            chartTitleOptions = options.title = merge(options.title, titleOptions);
	            chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);

	            // add title and subtitle
	            each([
	                ['title', titleOptions, chartTitleOptions],
	                ['subtitle', subtitleOptions, chartSubtitleOptions]
	            ], function (arr) {
	                var name = arr[0],
	                    title = chart[name],
	                    titleOptions = arr[1],
	                    chartTitleOptions = arr[2];

	                if (title && titleOptions) {
	                    chart[name] = title = title.destroy(); // remove old
	                }

	                if (chartTitleOptions && chartTitleOptions.text && !title) {
	                    chart[name] = chart.renderer.text(
	                        chartTitleOptions.text,
	                        0,
	                        0,
	                        chartTitleOptions.useHTML
	                    )
	                    .attr({
	                        align: chartTitleOptions.align,
	                        'class': PREFIX + name,
	                        zIndex: chartTitleOptions.zIndex || 4
	                    })
	                    .css(chartTitleOptions.style)
	                    .add();
	                }
	            });
	            chart.layOutTitles(redraw);
	        },

	        /**
	         * Lay out the chart titles and cache the full offset height for use in getMargins
	         */
	        layOutTitles: function (redraw) {
	            var titleOffset = 0,
	                title = this.title,
	                subtitle = this.subtitle,
	                options = this.options,
	                titleOptions = options.title,
	                subtitleOptions = options.subtitle,
	                requiresDirtyBox,
	                renderer = this.renderer,
	                autoWidth = this.spacingBox.width - 44; // 44 makes room for default context button

	            if (title) {
	                title
	                    .css({ width: (titleOptions.width || autoWidth) + PX })
	                    .align(extend({
	                        y: renderer.fontMetrics(titleOptions.style.fontSize, title).b - 3
	                    }, titleOptions), false, 'spacingBox');

	                if (!titleOptions.floating && !titleOptions.verticalAlign) {
	                    titleOffset = title.getBBox().height;
	                }
	            }
	            if (subtitle) {
	                subtitle
	                    .css({ width: (subtitleOptions.width || autoWidth) + PX })
	                    .align(extend({
	                        y: titleOffset + (titleOptions.margin - 13) + renderer.fontMetrics(subtitleOptions.style.fontSize, title).b
	                    }, subtitleOptions), false, 'spacingBox');

	                if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {
	                    titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);
	                }
	            }

	            requiresDirtyBox = this.titleOffset !== titleOffset;
	            this.titleOffset = titleOffset; // used in getMargins

	            if (!this.isDirtyBox && requiresDirtyBox) {
	                this.isDirtyBox = requiresDirtyBox;
	                // Redraw if necessary (#2719, #2744)
	                if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
	                    this.redraw();
	                }
	            }
	        },

	        /**
	         * Get chart width and height according to options and container size
	         */
	        getChartSize: function () {
	            var chart = this,
	                optionsChart = chart.options.chart,
	                widthOption = optionsChart.width,
	                heightOption = optionsChart.height,
	                renderTo = chart.renderToClone || chart.renderTo;

	            // Get inner width and height
	            if (!defined(widthOption)) {
	                chart.containerWidth = getStyle(renderTo, 'width');
	            }
	            if (!defined(heightOption)) {
	                chart.containerHeight = getStyle(renderTo, 'height');
	            }

	            chart.chartWidth = mathMax(0, widthOption || chart.containerWidth || 600); // #1393, 1460
	            chart.chartHeight = mathMax(0, pick(heightOption,
	                // the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
	                chart.containerHeight > 19 ? chart.containerHeight : 400));
	        },

	        /**
	         * Create a clone of the chart's renderTo div and place it outside the viewport to allow
	         * size computation on chart.render and chart.redraw
	         */
	        cloneRenderTo: function (revert) {
	            var clone = this.renderToClone,
	                container = this.container;

	            // Destroy the clone and bring the container back to the real renderTo div
	            if (revert) {
	                if (clone) {
	                    this.renderTo.appendChild(container);
	                    discardElement(clone);
	                    delete this.renderToClone;
	                }

	            // Set up the clone
	            } else {
	                if (container && container.parentNode === this.renderTo) {
	                    this.renderTo.removeChild(container); // do not clone this
	                }
	                this.renderToClone = clone = this.renderTo.cloneNode(0);
	                css(clone, {
	                    position: ABSOLUTE,
	                    top: '-9999px',
	                    display: 'block' // #833
	                });
	                if (clone.style.setProperty) { // #2631
	                    clone.style.setProperty('display', 'block', 'important');
	                }
	                doc.body.appendChild(clone);
	                if (container) {
	                    clone.appendChild(container);
	                }
	            }
	        },

	        /**
	         * Get the containing element, determine the size and create the inner container
	         * div to hold the chart
	         */
	        getContainer: function () {
	            var chart = this,
	                container,
	                options = chart.options,
	                optionsChart = options.chart,
	                chartWidth,
	                chartHeight,
	                renderTo = chart.renderTo,
	                indexAttrName = 'data-highcharts-chart',
	                oldChartIndex,
	                Ren,
	                containerId = 'highcharts-' + idCounter++;

	            if (!renderTo) {
	                chart.renderTo = renderTo = optionsChart.renderTo;
	            }
	        
	            if (isString(renderTo)) {
	                chart.renderTo = renderTo = doc.getElementById(renderTo);
	            }

	            // Display an error if the renderTo is wrong
	            if (!renderTo) {
	                error(13, true);
	            }

	            // If the container already holds a chart, destroy it. The check for hasRendered is there
	            // because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart
	            // attribute and the SVG contents, but not an interactive chart. So in this case,
	            // charts[oldChartIndex] will point to the wrong chart if any (#2609).
	            oldChartIndex = pInt(attr(renderTo, indexAttrName));
	            if (!isNaN(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {
	                charts[oldChartIndex].destroy();
	            }

	            // Make a reference to the chart from the div
	            attr(renderTo, indexAttrName, chart.index);

	            // remove previous chart
	            renderTo.innerHTML = '';

	            // If the container doesn't have an offsetWidth, it has or is a child of a node
	            // that has display:none. We need to temporarily move it out to a visible
	            // state to determine the size, else the legend and tooltips won't render
	            // properly. The allowClone option is used in sparklines as a micro optimization,
	            // saving about 1-2 ms each chart.
	            if (!optionsChart.skipClone && !renderTo.offsetWidth) {
	                chart.cloneRenderTo();
	            }

	            // get the width and height
	            chart.getChartSize();
	            chartWidth = chart.chartWidth;
	            chartHeight = chart.chartHeight;

	            // create the inner container
	            chart.container = container = createElement(DIV, {
	                    className: PREFIX + 'container' +
	                        (optionsChart.className ? ' ' + optionsChart.className : ''),
	                    id: containerId
	                }, extend({
	                    position: RELATIVE,
	                    overflow: HIDDEN, // needed for context menu (avoid scrollbars) and
	                        // content overflow in IE
	                    width: chartWidth + PX,
	                    height: chartHeight + PX,
	                    textAlign: 'left',
	                    lineHeight: 'normal', // #427
	                    zIndex: 0, // #1072
	                    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
	                }, optionsChart.style),
	                chart.renderToClone || renderTo
	            );

	            // cache the cursor (#1650)
	            chart._cursor = container.style.cursor;

	            // Initialize the renderer
	            Ren = Highcharts[optionsChart.renderer] || Renderer;
	            chart.renderer = new Ren(
	                container,
	                chartWidth,
	                chartHeight,
	                optionsChart.style,
	                optionsChart.forExport,
	                options.exporting && options.exporting.allowHTML
	            );

	            if (useCanVG) {
	                // If we need canvg library, extend and configure the renderer
	                // to get the tracker for translating mouse events
	                chart.renderer.create(chart, container, chartWidth, chartHeight);
	            }
	            // Add a reference to the charts index
	            chart.renderer.chartIndex = chart.index;
	        },

	        /**
	         * Calculate margins by rendering axis labels in a preliminary position. Title,
	         * subtitle and legend have already been rendered at this stage, but will be
	         * moved into their final positions
	         */
	        getMargins: function (skipAxes) {
	            var chart = this,
	                spacing = chart.spacing,
	                margin = chart.margin,
	                titleOffset = chart.titleOffset;

	            chart.resetMargins();

	            // Adjust for title and subtitle
	            if (titleOffset && !defined(margin[0])) {
	                chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);
	            }

	            // Adjust for legend
	            chart.legend.adjustMargins(margin, spacing);

	            // adjust for scroller
	            if (chart.extraBottomMargin) {
	                chart.marginBottom += chart.extraBottomMargin;
	            }
	            if (chart.extraTopMargin) {
	                chart.plotTop += chart.extraTopMargin;
	            }
	            if (!skipAxes) {
	                this.getAxisMargins();
	            }
	        },

	        getAxisMargins: function () {

	            var chart = this,
	                axisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left
	                margin = chart.margin;

	            // pre-render axes to get labels offset width
	            if (chart.hasCartesianSeries) {
	                each(chart.axes, function (axis) {
	                    if (axis.visible) {
	                        axis.getOffset();
	                    }
	                });
	            }

	            // Add the axis offsets
	            each(marginNames, function (m, side) {
	                if (!defined(margin[side])) {
	                    chart[m] += axisOffset[side];
	                }
	            });

	            chart.setChartSize();

	        },

	        /**
	         * Resize the chart to its container if size is not explicitly set
	         */
	        reflow: function (e) {
	            var chart = this,
	                optionsChart = chart.options.chart,
	                renderTo = chart.renderTo,
	                width = optionsChart.width || getStyle(renderTo, 'width'),
	                height = optionsChart.height || getStyle(renderTo, 'height'),
	                target = e ? e.target : win;

	            // Width and height checks for display:none. Target is doc in IE8 and Opera,
	            // win in Firefox, Chrome and IE9.
	            if (!chart.hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) { // #1093
	                if (width !== chart.containerWidth || height !== chart.containerHeight) {
	                    clearTimeout(chart.reflowTimeout);
	                    // When called from window.resize, e is set, else it's called directly (#2224)
	                    chart.reflowTimeout = syncTimeout(function () {
	                        if (chart.container) { // It may have been destroyed in the meantime (#1257)
	                            chart.setSize(width, height, false);
	                            chart.hasUserSize = null;
	                        }
	                    }, e ? 100 : 0);
	                }
	                chart.containerWidth = width;
	                chart.containerHeight = height;
	            }
	        },

	        /**
	         * Add the event handlers necessary for auto resizing
	         */
	        initReflow: function () {
	            var chart = this,
	                reflow = function (e) {
	                    chart.reflow(e);
	                };


	            addEvent(win, 'resize', reflow);
	            addEvent(chart, 'destroy', function () {
	                removeEvent(win, 'resize', reflow);
	            });
	        },

	        /**
	         * Resize the chart to a given width and height
	         * @param {Number} width
	         * @param {Number} height
	         * @param {Object|Boolean} animation
	         */
	        setSize: function (width, height, animation) {
	            var chart = this,
	                chartWidth,
	                chartHeight,
	                renderer = chart.renderer,
	                globalAnimation;

	            // Handle the isResizing counter
	            chart.isResizing += 1;
	        
	            // set the animation for the current process
	            setAnimation(animation, chart);

	            chart.oldChartHeight = chart.chartHeight;
	            chart.oldChartWidth = chart.chartWidth;
	            if (defined(width)) {
	                chart.chartWidth = chartWidth = mathMax(0, mathRound(width));
	                chart.hasUserSize = !!chartWidth;
	            }
	            if (defined(height)) {
	                chart.chartHeight = chartHeight = mathMax(0, mathRound(height));
	            }

	            // Resize the container with the global animation applied if enabled (#2503)
	            globalAnimation = renderer.globalAnimation;
	            (globalAnimation ? animate : css)(chart.container, {
	                width: chartWidth + PX,
	                height: chartHeight + PX
	            }, globalAnimation);

	            chart.setChartSize(true);
	            renderer.setSize(chartWidth, chartHeight, animation);

	            // handle axes
	            chart.maxTicks = null;
	            each(chart.axes, function (axis) {
	                axis.isDirty = true;
	                axis.setScale();
	            });

	            // make sure non-cartesian series are also handled
	            each(chart.series, function (serie) {
	                serie.isDirty = true;
	            });

	            chart.isDirtyLegend = true; // force legend redraw
	            chart.isDirtyBox = true; // force redraw of plot and chart border

	            chart.layOutTitles(); // #2857
	            chart.getMargins();

	            chart.redraw(animation);


	            chart.oldChartHeight = null;
	            fireEvent(chart, 'resize');

	            // Fire endResize and set isResizing back. If animation is disabled, fire without delay
	            globalAnimation = renderer.globalAnimation; // Reassign it before using it, it may have changed since the top of this function.
	            syncTimeout(function () {
	                if (chart) {
	                    fireEvent(chart, 'endResize', null, function () {
	                        chart.isResizing -= 1;
	                    });
	                }
	            }, globalAnimation === false ? 0 : ((globalAnimation && globalAnimation.duration) || 500));
	        },

	        /**
	         * Set the public chart properties. This is done before and after the pre-render
	         * to determine margin sizes
	         */
	        setChartSize: function (skipAxes) {
	            var chart = this,
	                inverted = chart.inverted,
	                renderer = chart.renderer,
	                chartWidth = chart.chartWidth,
	                chartHeight = chart.chartHeight,
	                optionsChart = chart.options.chart,
	                spacing = chart.spacing,
	                clipOffset = chart.clipOffset,
	                clipX,
	                clipY,
	                plotLeft,
	                plotTop,
	                plotWidth,
	                plotHeight,
	                plotBorderWidth;

	            chart.plotLeft = plotLeft = mathRound(chart.plotLeft);
	            chart.plotTop = plotTop = mathRound(chart.plotTop);
	            chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));
	            chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));

	            chart.plotSizeX = inverted ? plotHeight : plotWidth;
	            chart.plotSizeY = inverted ? plotWidth : plotHeight;

	            chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;

	            // Set boxes used for alignment
	            chart.spacingBox = renderer.spacingBox = {
	                x: spacing[3],
	                y: spacing[0],
	                width: chartWidth - spacing[3] - spacing[1],
	                height: chartHeight - spacing[0] - spacing[2]
	            };
	            chart.plotBox = renderer.plotBox = {
	                x: plotLeft,
	                y: plotTop,
	                width: plotWidth,
	                height: plotHeight
	            };

	            plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);
	            clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);
	            clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);
	            chart.clipBox = {
	                x: clipX,
	                y: clipY,
	                width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX),
	                height: mathMax(0, mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY))
	            };

	            if (!skipAxes) {
	                each(chart.axes, function (axis) {
	                    axis.setAxisSize();
	                    axis.setAxisTranslation();
	                });
	            }
	        },

	        /**
	         * Initial margins before auto size margins are applied
	         */
	        resetMargins: function () {
	            var chart = this;

	            each(marginNames, function (m, side) {
	                chart[m] = pick(chart.margin[side], chart.spacing[side]);
	            });
	            chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
	            chart.clipOffset = [0, 0, 0, 0];
	        },

	        /**
	         * Draw the borders and backgrounds for chart and plot area
	         */
	        drawChartBox: function () {
	            var chart = this,
	                optionsChart = chart.options.chart,
	                renderer = chart.renderer,
	                chartWidth = chart.chartWidth,
	                chartHeight = chart.chartHeight,
	                chartBackground = chart.chartBackground,
	                plotBackground = chart.plotBackground,
	                plotBorder = chart.plotBorder,
	                plotBGImage = chart.plotBGImage,
	                chartBorderWidth = optionsChart.borderWidth || 0,
	                chartBackgroundColor = optionsChart.backgroundColor,
	                plotBackgroundColor = optionsChart.plotBackgroundColor,
	                plotBackgroundImage = optionsChart.plotBackgroundImage,
	                plotBorderWidth = optionsChart.plotBorderWidth || 0,
	                mgn,
	                bgAttr,
	                plotLeft = chart.plotLeft,
	                plotTop = chart.plotTop,
	                plotWidth = chart.plotWidth,
	                plotHeight = chart.plotHeight,
	                plotBox = chart.plotBox,
	                clipRect = chart.clipRect,
	                clipBox = chart.clipBox;

	            // Chart area
	            mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

	            if (chartBorderWidth || chartBackgroundColor) {
	                if (!chartBackground) {

	                    bgAttr = {
	                        fill: chartBackgroundColor || NONE
	                    };
	                    if (chartBorderWidth) { // #980
	                        bgAttr.stroke = optionsChart.borderColor;
	                        bgAttr['stroke-width'] = chartBorderWidth;
	                    }
	                    chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,
	                            optionsChart.borderRadius, chartBorderWidth)
	                        .attr(bgAttr)
	                        .addClass(PREFIX + 'background')
	                        .add()
	                        .shadow(optionsChart.shadow);

	                } else { // resize
	                    chartBackground.animate(
	                        chartBackground.crisp({ width: chartWidth - mgn, height: chartHeight - mgn })
	                    );
	                }
	            }


	            // Plot background
	            if (plotBackgroundColor) {
	                if (!plotBackground) {
	                    chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
	                        .attr({
	                            fill: plotBackgroundColor
	                        })
	                        .add()
	                        .shadow(optionsChart.plotShadow);
	                } else {
	                    plotBackground.animate(plotBox);
	                }
	            }
	            if (plotBackgroundImage) {
	                if (!plotBGImage) {
	                    chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
	                        .add();
	                } else {
	                    plotBGImage.animate(plotBox);
	                }
	            }

	            // Plot clip
	            if (!clipRect) {
	                chart.clipRect = renderer.clipRect(clipBox);
	            } else {
	                clipRect.animate({
	                    width: clipBox.width,
	                    height: clipBox.height
	                });
	            }

	            // Plot area border
	            if (plotBorderWidth) {
	                if (!plotBorder) {
	                    chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)
	                        .attr({
	                            stroke: optionsChart.plotBorderColor,
	                            'stroke-width': plotBorderWidth,
	                            fill: NONE,
	                            zIndex: 1
	                        })
	                        .add();
	                } else {
	                    plotBorder.strokeWidth = -plotBorderWidth;
	                    plotBorder.animate(
	                        plotBorder.crisp({ x: plotLeft, y: plotTop, width: plotWidth, height: plotHeight }) //#3282 plotBorder should be negative
	                    );
	                }
	            }

	            // reset
	            chart.isDirtyBox = false;
	        },

	        /**
	         * Detect whether a certain chart property is needed based on inspecting its options
	         * and series. This mainly applies to the chart.invert property, and in extensions to
	         * the chart.angular and chart.polar properties.
	         */
	        propFromSeries: function () {
	            var chart = this,
	                optionsChart = chart.options.chart,
	                klass,
	                seriesOptions = chart.options.series,
	                i,
	                value;


	            each(['inverted', 'angular', 'polar'], function (key) {

	                // The default series type's class
	                klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];

	                // Get the value from available chart-wide properties
	                value = (
	                    chart[key] || // 1. it is set before
	                    optionsChart[key] || // 2. it is set in the options
	                    (klass && klass.prototype[key]) // 3. it's default series class requires it
	                );

	                // 4. Check if any the chart's series require it
	                i = seriesOptions && seriesOptions.length;
	                while (!value && i--) {
	                    klass = seriesTypes[seriesOptions[i].type];
	                    if (klass && klass.prototype[key]) {
	                        value = true;
	                    }
	                }

	                // Set the chart property
	                chart[key] = value;
	            });

	        },

	        /**
	         * Link two or more series together. This is done initially from Chart.render,
	         * and after Chart.addSeries and Series.remove.
	         */
	        linkSeries: function () {
	            var chart = this,
	                chartSeries = chart.series;

	            // Reset links
	            each(chartSeries, function (series) {
	                series.linkedSeries.length = 0;
	            });

	            // Apply new links
	            each(chartSeries, function (series) {
	                var linkedTo = series.options.linkedTo;
	                if (isString(linkedTo)) {
	                    if (linkedTo === ':previous') {
	                        linkedTo = chart.series[series.index - 1];
	                    } else {
	                        linkedTo = chart.get(linkedTo);
	                    }
	                    if (linkedTo) {
	                        linkedTo.linkedSeries.push(series);
	                        series.linkedParent = linkedTo;
	                        series.visible = pick(series.options.visible, linkedTo.options.visible, series.visible); // #3879
	                    }
	                }
	            });
	        },

	        /**
	         * Render series for the chart
	         */
	        renderSeries: function () {
	            each(this.series, function (serie) {
	                serie.translate();
	                serie.render();
	            });
	        },

	        /**
	         * Render labels for the chart
	         */
	        renderLabels: function () {
	            var chart = this,
	                labels = chart.options.labels;
	            if (labels.items) {
	                each(labels.items, function (label) {
	                    var style = extend(labels.style, label.style),
	                        x = pInt(style.left) + chart.plotLeft,
	                        y = pInt(style.top) + chart.plotTop + 12;

	                    // delete to prevent rewriting in IE
	                    delete style.left;
	                    delete style.top;

	                    chart.renderer.text(
	                        label.html,
	                        x,
	                        y
	                    )
	                    .attr({ zIndex: 2 })
	                    .css(style)
	                    .add();

	                });
	            }
	        },

	        /**
	         * Render all graphics for the chart
	         */
	        render: function () {
	            var chart = this,
	                axes = chart.axes,
	                renderer = chart.renderer,
	                options = chart.options,
	                tempWidth,
	                tempHeight,
	                redoHorizontal,
	                redoVertical;

	            // Title
	            chart.setTitle();


	            // Legend
	            chart.legend = new Legend(chart, options.legend);

	            // Get stacks
	            if (chart.getStacks) {
	                chart.getStacks();
	            }

	            // Get chart margins
	            chart.getMargins(true);
	            chart.setChartSize();

	            // Record preliminary dimensions for later comparison
	            tempWidth = chart.plotWidth;
	            tempHeight = chart.plotHeight = chart.plotHeight - 21; // 21 is the most common correction for X axis labels

	            // Get margins by pre-rendering axes
	            each(axes, function (axis) {
	                axis.setScale();
	            });
	            chart.getAxisMargins();

	            // If the plot area size has changed significantly, calculate tick positions again
	            redoHorizontal = tempWidth / chart.plotWidth > 1.1;
	            redoVertical = tempHeight / chart.plotHeight > 1.05; // Height is more sensitive

	            if (redoHorizontal || redoVertical) {

	                chart.maxTicks = null; // reset for second pass
	                each(axes, function (axis) {
	                    if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {
	                        axis.setTickInterval(true); // update to reflect the new margins
	                    }
	                });
	                chart.getMargins(); // second pass to check for new labels
	            }

	            // Draw the borders and backgrounds
	            chart.drawChartBox();


	            // Axes
	            if (chart.hasCartesianSeries) {
	                each(axes, function (axis) {
	                    if (axis.visible) {
	                        axis.render();
	                    }
	                });
	            }

	            // The series
	            if (!chart.seriesGroup) {
	                chart.seriesGroup = renderer.g('series-group')
	                    .attr({ zIndex: 3 })
	                    .add();
	            }
	            chart.renderSeries();

	            // Labels
	            chart.renderLabels();

	            // Credits
	            chart.showCredits(options.credits);

	            // Set flag
	            chart.hasRendered = true;

	        },

	        /**
	         * Show chart credits based on config options
	         */
	        showCredits: function (credits) {
	            if (credits.enabled && !this.credits) {
	                this.credits = this.renderer.text(
	                    credits.text,
	                    0,
	                    0
	                )
	                .on('click', function () {
	                    if (credits.href) {
	                        win.location.href = credits.href;
	                    }
	                })
	                .attr({
	                    align: credits.position.align,
	                    zIndex: 8
	                })
	                .css(credits.style)
	                .add()
	                .align(credits.position);
	            }
	        },

	        /**
	         * Clean up memory usage
	         */
	        destroy: function () {
	            var chart = this,
	                axes = chart.axes,
	                series = chart.series,
	                container = chart.container,
	                i,
	                parentNode = container && container.parentNode;

	            // fire the chart.destoy event
	            fireEvent(chart, 'destroy');

	            // Delete the chart from charts lookup array
	            charts[chart.index] = UNDEFINED;
	            chartCount--;
	            chart.renderTo.removeAttribute('data-highcharts-chart');

	            // remove events
	            removeEvent(chart);

	            // ==== Destroy collections:
	            // Destroy axes
	            i = axes.length;
	            while (i--) {
	                axes[i] = axes[i].destroy();
	            }

	            // Destroy each series
	            i = series.length;
	            while (i--) {
	                series[i] = series[i].destroy();
	            }

	            // ==== Destroy chart properties:
	            each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage',
	                    'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller',
	                    'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {
	                var prop = chart[name];

	                if (prop && prop.destroy) {
	                    chart[name] = prop.destroy();
	                }
	            });

	            // remove container and all SVG
	            if (container) { // can break in IE when destroyed before finished loading
	                container.innerHTML = '';
	                removeEvent(container);
	                if (parentNode) {
	                    discardElement(container);
	                }

	            }

	            // clean it all up
	            for (i in chart) {
	                delete chart[i];
	            }

	        },


	        /**
	         * VML namespaces can't be added until after complete. Listening
	         * for Perini's doScroll hack is not enough.
	         */
	        isReadyToRender: function () {
	            var chart = this;

	            // Note: win == win.top is required
	            if ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) { // eslint-disable-line eqeqeq
	                if (useCanVG) {
	                    // Delay rendering until canvg library is downloaded and ready
	                    CanVGController.push(function () {
	                        chart.firstRender();
	                    }, chart.options.global.canvasToolsURL);
	                } else {
	                    doc.attachEvent('onreadystatechange', function () {
	                        doc.detachEvent('onreadystatechange', chart.firstRender);
	                        if (doc.readyState === 'complete') {
	                            chart.firstRender();
	                        }
	                    });
	                }
	                return false;
	            }
	            return true;
	        },

	        /**
	         * Prepare for first rendering after all data are loaded
	         */
	        firstRender: function () {
	            var chart = this,
	                options = chart.options;

	            // Check whether the chart is ready to render
	            if (!chart.isReadyToRender()) {
	                return;
	            }

	            // Create the container
	            chart.getContainer();

	            // Run an early event after the container and renderer are established
	            fireEvent(chart, 'init');


	            chart.resetMargins();
	            chart.setChartSize();

	            // Set the common chart properties (mainly invert) from the given series
	            chart.propFromSeries();

	            // get axes
	            chart.getAxes();

	            // Initialize the series
	            each(options.series || [], function (serieOptions) {
	                chart.initSeries(serieOptions);
	            });

	            chart.linkSeries();

	            // Run an event after axes and series are initialized, but before render. At this stage,
	            // the series data is indexed and cached in the xData and yData arrays, so we can access
	            // those before rendering. Used in Highstock.
	            fireEvent(chart, 'beforeRender');

	            // depends on inverted and on margins being set
	            if (Highcharts.Pointer) {
	                chart.pointer = new Pointer(chart, options);
	            }

	            chart.render();

	            // add canvas
	            chart.renderer.draw();
	        
	            // Fire the load event if there are no external images
	            if (!chart.renderer.imgCount) {
	                chart.onload();
	            }

	            // If the chart was rendered outside the top container, put it back in (#3679)
	            chart.cloneRenderTo(true);

	        },

	        /** 
	         * On chart load
	         */
	        onload: function () {
	            var chart = this;

	            // Run callbacks
	            each([this.callback].concat(this.callbacks), function (fn) {
	                if (fn && chart.index !== undefined) { // Chart destroyed in its own callback (#3600)
	                    fn.apply(chart, [chart]);
	                }
	            });

	            // Fire the load event if there are no external images
	            if (!chart.renderer.imgCount) {
	                fireEvent(chart, 'load');
	            }
	        },

	        /**
	        * Creates arrays for spacing and margin from given options.
	        */
	        splashArray: function (target, options) {
	            var oVar = options[target],
	                tArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];

	            return [pick(options[target + 'Top'], tArray[0]),
	                    pick(options[target + 'Right'], tArray[1]),
	                    pick(options[target + 'Bottom'], tArray[2]),
	                    pick(options[target + 'Left'], tArray[3])];
	        }
	    }; // end Chart

	    var CenteredSeriesMixin = Highcharts.CenteredSeriesMixin = {
	        /**
	         * Get the center of the pie based on the size and center options relative to the
	         * plot area. Borrowed by the polar and gauge series types.
	         */
	        getCenter: function () {

	            var options = this.options,
	                chart = this.chart,
	                slicingRoom = 2 * (options.slicedOffset || 0),
	                handleSlicingRoom,
	                plotWidth = chart.plotWidth - 2 * slicingRoom,
	                plotHeight = chart.plotHeight - 2 * slicingRoom,
	                centerOption = options.center,
	                positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],
	                smallestSize = mathMin(plotWidth, plotHeight),
	                i,
	                value;

	            for (i = 0; i < 4; ++i) {
	                value = positions[i];
	                handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));

	                // i == 0: centerX, relative to width
	                // i == 1: centerY, relative to height
	                // i == 2: size, relative to smallestSize
	                // i == 3: innerSize, relative to size
	                positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) +
	                    (handleSlicingRoom ? slicingRoom : 0);

	            }
	            // innerSize cannot be larger than size (#3632)
	            if (positions[3] > positions[2]) {
	                positions[3] = positions[2];
	            }
	            return positions;
	        }
	    };

	    /**
	     * The Point object and prototype. Inheritable and used as base for PiePoint
	     */
	    var Point = function () {};
	    Point.prototype = {

	        /**
	         * Initialize the point
	         * @param {Object} series The series object containing this point
	         * @param {Object} options The data in either number, array or object format
	         */
	        init: function (series, options, x) {

	            var point = this,
	                colors;
	            point.series = series;
	            point.color = series.color; // #3445
	            point.applyOptions(options, x);
	            point.pointAttr = {};

	            if (series.options.colorByPoint) {
	                colors = series.options.colors || series.chart.options.colors;
	                point.color = point.color || colors[series.colorCounter++];
	                // loop back to zero
	                if (series.colorCounter === colors.length) {
	                    series.colorCounter = 0;
	                }
	            }

	            series.chart.pointCount++;
	            return point;
	        },
	        /**
	         * Apply the options containing the x and y data and possible some extra properties.
	         * This is called on point init or from point.update.
	         *
	         * @param {Object} options
	         */
	        applyOptions: function (options, x) {
	            var point = this,
	                series = point.series,
	                pointValKey = series.options.pointValKey || series.pointValKey;

	            options = Point.prototype.optionsToObject.call(this, options);

	            // copy options directly to point
	            extend(point, options);
	            point.options = point.options ? extend(point.options, options) : options;

	            // For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.
	            if (pointValKey) {
	                point.y = point[pointValKey];
	            }
	            point.isNull = point.y === null;

	            // If no x is set by now, get auto incremented value. All points must have an
	            // x value, however the y value can be null to create a gap in the series
	            if (typeof point.x !== 'number' && series) {
	                point.x = x === undefined ? series.autoIncrement() : x;
	            }

	            return point;
	        },

	        /**
	         * Transform number or array configs into objects
	         */
	        optionsToObject: function (options) {
	            var ret = {},
	                series = this.series,
	                keys = series.options.keys,
	                pointArrayMap = keys || series.pointArrayMap || ['y'],
	                valueCount = pointArrayMap.length,
	                firstItemType,
	                i = 0,
	                j = 0;

	            if (typeof options === 'number' || options === null) {
	                ret[pointArrayMap[0]] = options;

	            } else if (isArray(options)) {
	                // with leading x value
	                if (!keys && options.length > valueCount) {
	                    firstItemType = typeof options[0];
	                    if (firstItemType === 'string') {
	                        ret.name = options[0];
	                    } else if (firstItemType === 'number') {
	                        ret.x = options[0];
	                    }
	                    i++;
	                }
	                while (j < valueCount) {
	                    if (!keys || options[i] !== undefined) { // Skip undefined positions for keys
	                        ret[pointArrayMap[j]] = options[i];
	                    }
	                    i++;
	                    j++;
	                }
	            } else if (typeof options === 'object') {
	                ret = options;

	                // This is the fastest way to detect if there are individual point dataLabels that need
	                // to be considered in drawDataLabels. These can only occur in object configs.
	                if (options.dataLabels) {
	                    series._hasPointLabels = true;
	                }

	                // Same approach as above for markers
	                if (options.marker) {
	                    series._hasPointMarkers = true;
	                }
	            }
	            return ret;
	        },

	        /**
	         * Destroy a point to clear memory. Its reference still stays in series.data.
	         */
	        destroy: function () {
	            var point = this,
	                series = point.series,
	                chart = series.chart,
	                hoverPoints = chart.hoverPoints,
	                prop;

	            chart.pointCount--;

	            if (hoverPoints) {
	                point.setState();
	                erase(hoverPoints, point);
	                if (!hoverPoints.length) {
	                    chart.hoverPoints = null;
	                }

	            }
	            if (point === chart.hoverPoint) {
	                point.onMouseOut();
	            }

	            // remove all events
	            if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
	                removeEvent(point);
	                point.destroyElements();
	            }

	            if (point.legendItem) { // pies have legend items
	                chart.legend.destroyItem(point);
	            }

	            for (prop in point) {
	                point[prop] = null;
	            }


	        },

	        /**
	         * Destroy SVG elements associated with the point
	         */
	        destroyElements: function () {
	            var point = this,
	                props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],
	                prop,
	                i = 6;
	            while (i--) {
	                prop = props[i];
	                if (point[prop]) {
	                    point[prop] = point[prop].destroy();
	                }
	            }
	        },

	        /**
	         * Return the configuration hash needed for the data label and tooltip formatters
	         */
	        getLabelConfig: function () {
	            return {
	                x: this.category,
	                y: this.y,
	                color: this.color,
	                key: this.name || this.category,
	                series: this.series,
	                point: this,
	                percentage: this.percentage,
	                total: this.total || this.stackTotal
	            };
	        },

	        /**
	         * Extendable method for formatting each point's tooltip line
	         *
	         * @return {String} A string to be concatenated in to the common tooltip text
	         */
	        tooltipFormatter: function (pointFormat) {

	            // Insert options for valueDecimals, valuePrefix, and valueSuffix
	            var series = this.series,
	                seriesTooltipOptions = series.tooltipOptions,
	                valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),
	                valuePrefix = seriesTooltipOptions.valuePrefix || '',
	                valueSuffix = seriesTooltipOptions.valueSuffix || '';

	            // Loop over the point array map and replace unformatted values with sprintf formatting markup
	            each(series.pointArrayMap || ['y'], function (key) {
	                key = '{point.' + key; // without the closing bracket
	                if (valuePrefix || valueSuffix) {
	                    pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);
	                }
	                pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');
	            });

	            return format(pointFormat, {
	                point: this,
	                series: this.series
	            });
	        },

	        /**
	         * Fire an event on the Point object.
	         * @param {String} eventType
	         * @param {Object} eventArgs Additional event arguments
	         * @param {Function} defaultFunction Default event handler
	         */
	        firePointEvent: function (eventType, eventArgs, defaultFunction) {
	            var point = this,
	                series = this.series,
	                seriesOptions = series.options;

	            // load event handlers on demand to save time on mouseover/out
	            if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
	                this.importEvents();
	            }

	            // add default handler if in selection mode
	            if (eventType === 'click' && seriesOptions.allowPointSelect) {
	                defaultFunction = function (event) {
	                    // Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
	                    if (point.select) { // Could be destroyed by prior event handlers (#2911)
	                        point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
	                    }
	                };
	            }

	            fireEvent(this, eventType, eventArgs, defaultFunction);
	        },
	        visible: true
	    };/**
	     * @classDescription The base function which all other series types inherit from. The data in the series is stored
	     * in various arrays.
	     *
	     * - First, series.options.data contains all the original config options for
	     * each point whether added by options or methods like series.addPoint.
	     * - Next, series.data contains those values converted to points, but in case the series data length
	     * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It
	     * only contains the points that have been created on demand.
	     * - Then there's series.points that contains all currently visible point objects. In case of cropping,
	     * the cropped-away points are not part of this array. The series.points array starts at series.cropStart
	     * compared to series.data and series.options.data. If however the series data is grouped, these can't
	     * be correlated one to one.
	     * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.
	     * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.
	     *
	     * @param {Object} chart
	     * @param {Object} options
	     */
	    var Series = Highcharts.Series = function () {};

	    Series.prototype = {

	        isCartesian: true,
	        type: 'line',
	        pointClass: Point,
	        sorted: true, // requires the data to be sorted
	        requireSorting: true,
	        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
	            stroke: 'lineColor',
	            'stroke-width': 'lineWidth',
	            fill: 'fillColor',
	            r: 'radius'
	        },
	        directTouch: false,
	        axisTypes: ['xAxis', 'yAxis'],
	        colorCounter: 0,
	        parallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData
	        init: function (chart, options) {
	            var series = this,
	                eventType,
	                events,
	                chartSeries = chart.series,
	                sortByIndex = function (a, b) {
	                    return pick(a.options.index, a._i) - pick(b.options.index, b._i);
	                };

	            series.chart = chart;
	            series.options = options = series.setOptions(options); // merge with plotOptions
	            series.linkedSeries = [];

	            // bind the axes
	            series.bindAxes();

	            // set some variables
	            extend(series, {
	                name: options.name,
	                state: NORMAL_STATE,
	                pointAttr: {},
	                visible: options.visible !== false, // true by default
	                selected: options.selected === true // false by default
	            });

	            // special
	            if (useCanVG) {
	                options.animation = false;
	            }

	            // register event listeners
	            events = options.events;
	            for (eventType in events) {
	                addEvent(series, eventType, events[eventType]);
	            }
	            if (
	                (events && events.click) ||
	                (options.point && options.point.events && options.point.events.click) ||
	                options.allowPointSelect
	            ) {
	                chart.runTrackerClick = true;
	            }

	            series.getColor();
	            series.getSymbol();

	            // Set the data
	            each(series.parallelArrays, function (key) {
	                series[key + 'Data'] = [];
	            });
	            series.setData(options.data, false);

	            // Mark cartesian
	            if (series.isCartesian) {
	                chart.hasCartesianSeries = true;
	            }

	            // Register it in the chart
	            chartSeries.push(series);
	            series._i = chartSeries.length - 1;

	            // Sort series according to index option (#248, #1123, #2456)
	            stableSort(chartSeries, sortByIndex);
	            if (this.yAxis) {
	                stableSort(this.yAxis.series, sortByIndex);
	            }

	            each(chartSeries, function (series, i) {
	                series.index = i;
	                series.name = series.name || 'Series ' + (i + 1);
	            });

	        },

	        /**
	         * Set the xAxis and yAxis properties of cartesian series, and register the series
	         * in the axis.series array
	         */
	        bindAxes: function () {
	            var series = this,
	                seriesOptions = series.options,
	                chart = series.chart,
	                axisOptions;

	            each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis

	                each(chart[AXIS], function (axis) { // loop through the chart's axis objects
	                    axisOptions = axis.options;

	                    // apply if the series xAxis or yAxis option mathches the number of the
	                    // axis, or if undefined, use the first axis
	                    if ((seriesOptions[AXIS] === axisOptions.index) ||
	                            (seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||
	                            (seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {

	                        // register this series in the axis.series lookup
	                        axis.series.push(series);

	                        // set this series.xAxis or series.yAxis reference
	                        series[AXIS] = axis;

	                        // mark dirty for redraw
	                        axis.isDirty = true;
	                    }
	                });

	                // The series needs an X and an Y axis
	                if (!series[AXIS] && series.optionalAxis !== AXIS) {
	                    error(18, true);
	                }

	            });
	        },

	        /**
	         * For simple series types like line and column, the data values are held in arrays like
	         * xData and yData for quick lookup to find extremes and more. For multidimensional series
	         * like bubble and map, this can be extended with arrays like zData and valueData by
	         * adding to the series.parallelArrays array.
	         */
	        updateParallelArrays: function (point, i) {
	            var series = point.series,
	                args = arguments,
	                fn = typeof i === 'number' ?
	                    // Insert the value in the given position
	                    function (key) {
	                        var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];
	                        series[key + 'Data'][i] = val;
	                    } :
	                    // Apply the method specified in i with the following arguments as arguments
	                    function (key) {
	                        Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));
	                    };

	            each(series.parallelArrays, fn);
	        },

	        /**
	         * Return an auto incremented x value based on the pointStart and pointInterval options.
	         * This is only used if an x value is not given for the point that calls autoIncrement.
	         */
	        autoIncrement: function () {

	            var options = this.options,
	                xIncrement = this.xIncrement,
	                date,
	                pointInterval,
	                pointIntervalUnit = options.pointIntervalUnit;

	            xIncrement = pick(xIncrement, options.pointStart, 0);

	            this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);

	            // Added code for pointInterval strings
	            if (pointIntervalUnit === 'month' || pointIntervalUnit === 'year') {
	                date = new Date(xIncrement);
	                date = (pointIntervalUnit === 'month') ?
	                    +date[setMonth](date[getMonth]() + pointInterval) :
	                    +date[setFullYear](date[getFullYear]() + pointInterval);
	                pointInterval = date - xIncrement;
	            }

	            this.xIncrement = xIncrement + pointInterval;
	            return xIncrement;
	        },
	    
	        /**
	         * Set the series options by merging from the options tree
	         * @param {Object} itemOptions
	         */
	        setOptions: function (itemOptions) {
	            var chart = this.chart,
	                chartOptions = chart.options,
	                plotOptions = chartOptions.plotOptions,
	                userOptions = chart.userOptions || {},
	                userPlotOptions = userOptions.plotOptions || {},
	                typeOptions = plotOptions[this.type],
	                options,
	                zones;

	            this.userOptions = itemOptions;

	            // General series options take precedence over type options because otherwise, default
	            // type options like column.animation would be overwritten by the general option.
	            // But issues have been raised here (#3881), and the solution may be to distinguish
	            // between default option and userOptions like in the tooltip below.
	            options = merge(
	                typeOptions,
	                plotOptions.series,
	                itemOptions
	            );

	            // The tooltip options are merged between global and series specific options
	            this.tooltipOptions = merge(
	                defaultOptions.tooltip,
	                defaultOptions.plotOptions[this.type].tooltip,
	                userOptions.tooltip,
	                userPlotOptions.series && userPlotOptions.series.tooltip,
	                userPlotOptions[this.type] && userPlotOptions[this.type].tooltip,
	                itemOptions.tooltip
	            );

	            // Delete marker object if not allowed (#1125)
	            if (typeOptions.marker === null) {
	                delete options.marker;
	            }

	            // Handle color zones
	            this.zoneAxis = options.zoneAxis;
	            zones = this.zones = (options.zones || []).slice();
	            if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
	                zones.push({
	                    value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,
	                    color: options.negativeColor,
	                    fillColor: options.negativeFillColor
	                });
	            }
	            if (zones.length) { // Push one extra zone for the rest
	                if (defined(zones[zones.length - 1].value)) {
	                    zones.push({
	                        color: this.color,
	                        fillColor: this.fillColor
	                    });
	                }
	            }
	            return options;
	        },

	        getCyclic: function (prop, value, defaults) {
	            var i,
	                userOptions = this.userOptions,
	                indexName = '_' + prop + 'Index',
	                counterName = prop + 'Counter';

	            if (!value) {
	                if (defined(userOptions[indexName])) { // after Series.update()
	                    i = userOptions[indexName];
	                } else {
	                    userOptions[indexName] = i = this.chart[counterName] % defaults.length;
	                    this.chart[counterName] += 1;
	                }
	                value = defaults[i];
	            }
	            this[prop] = value;
	        },

	        /**
	         * Get the series' color
	         */
	        getColor: function () {
	            if (this.options.colorByPoint) {
	                this.options.color = null; // #4359, selected slice got series.color even when colorByPoint was set.
	            } else {
	                this.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);
	            }
	        },
	        /**
	         * Get the series' symbol
	         */
	        getSymbol: function () {
	            var seriesMarkerOption = this.options.marker;

	            this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);

	            // don't substract radius in image symbols (#604)
	            if (/^url/.test(this.symbol)) {
	                seriesMarkerOption.radius = 0;
	            }
	        },

	        drawLegendSymbol: LegendSymbolMixin.drawLineMarker,

	        /**
	         * Replace the series data with a new set of data
	         * @param {Object} data
	         * @param {Object} redraw
	         */
	        setData: function (data, redraw, animation, updatePoints) {
	            var series = this,
	                oldData = series.points,
	                oldDataLength = (oldData && oldData.length) || 0,
	                dataLength,
	                options = series.options,
	                chart = series.chart,
	                firstPoint = null,
	                xAxis = series.xAxis,
	                hasCategories = xAxis && !!xAxis.categories,
	                i,
	                turboThreshold = options.turboThreshold,
	                pt,
	                xData = this.xData,
	                yData = this.yData,
	                pointArrayMap = series.pointArrayMap,
	                valueCount = pointArrayMap && pointArrayMap.length;

	            data = data || [];
	            dataLength = data.length;
	            redraw = pick(redraw, true);

	            // If the point count is the same as is was, just run Point.update which is
	            // cheaper, allows animation, and keeps references to points.
	            if (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {
	                each(data, function (point, i) {
	                    // .update doesn't exist on a linked, hidden series (#3709)
	                    if (oldData[i].update && point !== options.data[i]) {
	                        oldData[i].update(point, false, null, false);
	                    }
	                });

	            } else {

	                // Reset properties
	                series.xIncrement = null;

	                series.colorCounter = 0; // for series with colorByPoint (#1547)

	                // Update parallel arrays
	                each(this.parallelArrays, function (key) {
	                    series[key + 'Data'].length = 0;
	                });

	                // In turbo mode, only one- or twodimensional arrays of numbers are allowed. The
	                // first value is tested, and we assume that all the rest are defined the same
	                // way. Although the 'for' loops are similar, they are repeated inside each
	                // if-else conditional for max performance.
	                if (turboThreshold && dataLength > turboThreshold) {

	                    // find the first non-null point
	                    i = 0;
	                    while (firstPoint === null && i < dataLength) {
	                        firstPoint = data[i];
	                        i++;
	                    }


	                    if (isNumber(firstPoint)) { // assume all points are numbers
	                        var x = pick(options.pointStart, 0),
	                            pointInterval = pick(options.pointInterval, 1);

	                        for (i = 0; i < dataLength; i++) {
	                            xData[i] = x;
	                            yData[i] = data[i];
	                            x += pointInterval;
	                        }
	                        series.xIncrement = x;
	                    } else if (isArray(firstPoint)) { // assume all points are arrays
	                        if (valueCount) { // [x, low, high] or [x, o, h, l, c]
	                            for (i = 0; i < dataLength; i++) {
	                                pt = data[i];
	                                xData[i] = pt[0];
	                                yData[i] = pt.slice(1, valueCount + 1);
	                            }
	                        } else { // [x, y]
	                            for (i = 0; i < dataLength; i++) {
	                                pt = data[i];
	                                xData[i] = pt[0];
	                                yData[i] = pt[1];
	                            }
	                        }
	                    } else {
	                        error(12); // Highcharts expects configs to be numbers or arrays in turbo mode
	                    }
	                } else {
	                    for (i = 0; i < dataLength; i++) {
	                        if (data[i] !== UNDEFINED) { // stray commas in oldIE
	                            pt = { series: series };
	                            series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
	                            series.updateParallelArrays(pt, i);
	                            if (hasCategories && defined(pt.name)) { // #4401
	                                xAxis.names[pt.x] = pt.name; // #2046
	                            }
	                        }
	                    }
	                }

	                // Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON
	                if (isString(yData[0])) {
	                    error(14, true);
	                }

	                series.data = [];
	                series.options.data = series.userOptions.data = data;

	                // destroy old points
	                i = oldDataLength;
	                while (i--) {
	                    if (oldData[i] && oldData[i].destroy) {
	                        oldData[i].destroy();
	                    }
	                }

	                // reset minRange (#878)
	                if (xAxis) {
	                    xAxis.minRange = xAxis.userMinRange;
	                }

	                // redraw
	                series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
	                animation = false;
	            }

	            // Typically for pie series, points need to be processed and generated
	            // prior to rendering the legend
	            if (options.legendType === 'point') {
	                this.processData();
	                this.generatePoints();
	            }

	            if (redraw) {
	                chart.redraw(animation);
	            }
	        },

	        /**
	         * Process the data by cropping away unused data points if the series is longer
	         * than the crop threshold. This saves computing time for lage series.
	         */
	        processData: function (force) {
	            var series = this,
	                processedXData = series.xData, // copied during slice operation below
	                processedYData = series.yData,
	                dataLength = processedXData.length,
	                croppedData,
	                cropStart = 0,
	                cropped,
	                distance,
	                closestPointRange,
	                xAxis = series.xAxis,
	                i, // loop variable
	                options = series.options,
	                cropThreshold = options.cropThreshold,
	                getExtremesFromAll = series.getExtremesFromAll || options.getExtremesFromAll, // #4599
	                isCartesian = series.isCartesian,
	                xExtremes,
	                val2lin = xAxis && xAxis.val2lin,
	                isLog = xAxis && xAxis.isLog,
	                min,
	                max;

	            // If the series data or axes haven't changed, don't go through this. Return false to pass
	            // the message on to override methods like in data grouping.
	            if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
	                return false;
	            }

	            if (xAxis) {
	                xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)
	                min = xExtremes.min;
	                max = xExtremes.max;
	            }

	            // optionally filter out points outside the plot area
	            if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {

	                // it's outside current extremes
	                if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
	                    processedXData = [];
	                    processedYData = [];

	                // only crop if it's actually spilling out
	                } else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {
	                    croppedData = this.cropData(series.xData, series.yData, min, max);
	                    processedXData = croppedData.xData;
	                    processedYData = croppedData.yData;
	                    cropStart = croppedData.start;
	                    cropped = true;
	                }
	            }


	            // Find the closest distance between processed points
	            i = processedXData.length || 1;
	            while (--i) {
	                distance = isLog ?
	                    val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) :
	                    processedXData[i] - processedXData[i - 1];

	                if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {
	                    closestPointRange = distance;

	                // Unsorted data is not supported by the line tooltip, as well as data grouping and
	                // navigation in Stock charts (#725) and width calculation of columns (#1900)
	                } else if (distance < 0 && series.requireSorting) {
	                    error(15);
	                }
	            }

	            // Record the properties
	            series.cropped = cropped; // undefined or true
	            series.cropStart = cropStart;
	            series.processedXData = processedXData;
	            series.processedYData = processedYData;

	            series.closestPointRange = closestPointRange;

	        },

	        /**
	         * Iterate over xData and crop values between min and max. Returns object containing crop start/end
	         * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range
	         */
	        cropData: function (xData, yData, min, max) {
	            var dataLength = xData.length,
	                cropStart = 0,
	                cropEnd = dataLength,
	                cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside
	                i,
	                j;

	            // iterate up to find slice start
	            for (i = 0; i < dataLength; i++) {
	                if (xData[i] >= min) {
	                    cropStart = mathMax(0, i - cropShoulder);
	                    break;
	                }
	            }

	            // proceed to find slice end
	            for (j = i; j < dataLength; j++) {
	                if (xData[j] > max) {
	                    cropEnd = j + cropShoulder;
	                    break;
	                }
	            }

	            return {
	                xData: xData.slice(cropStart, cropEnd),
	                yData: yData.slice(cropStart, cropEnd),
	                start: cropStart,
	                end: cropEnd
	            };
	        },


	        /**
	         * Generate the data point after the data has been processed by cropping away
	         * unused points and optionally grouped in Highcharts Stock.
	         */
	        generatePoints: function () {
	            var series = this,
	                options = series.options,
	                dataOptions = options.data,
	                data = series.data,
	                dataLength,
	                processedXData = series.processedXData,
	                processedYData = series.processedYData,
	                pointClass = series.pointClass,
	                processedDataLength = processedXData.length,
	                cropStart = series.cropStart || 0,
	                cursor,
	                hasGroupedData = series.hasGroupedData,
	                point,
	                points = [],
	                i;

	            if (!data && !hasGroupedData) {
	                var arr = [];
	                arr.length = dataOptions.length;
	                data = series.data = arr;
	            }

	            for (i = 0; i < processedDataLength; i++) {
	                cursor = cropStart + i;
	                if (!hasGroupedData) {
	                    if (data[cursor]) {
	                        point = data[cursor];
	                    } else if (dataOptions[cursor] !== UNDEFINED) { // #970
	                        data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);
	                    }
	                    points[i] = point;
	                } else {
	                    // splat the y data in case of ohlc data array
	                    points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
	                }
	                points[i].index = cursor; // For faster access in Point.update
	            }

	            // Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when
	            // swithching view from non-grouped data to grouped data (#637)
	            if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
	                for (i = 0; i < dataLength; i++) {
	                    if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points
	                        i += processedDataLength;
	                    }
	                    if (data[i]) {
	                        data[i].destroyElements();
	                        data[i].plotX = UNDEFINED; // #1003
	                    }
	                }
	            }

	            series.data = data;
	            series.points = points;
	        },

	        /**
	         * Calculate Y extremes for visible data
	         */
	        getExtremes: function (yData) {
	            var xAxis = this.xAxis,
	                yAxis = this.yAxis,
	                xData = this.processedXData,
	                yDataLength,
	                activeYData = [],
	                activeCounter = 0,
	                xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis
	                xMin = xExtremes.min,
	                xMax = xExtremes.max,
	                validValue,
	                withinRange,
	                x,
	                y,
	                i,
	                j;

	            yData = yData || this.stackedYData || this.processedYData;
	            yDataLength = yData.length;

	            for (i = 0; i < yDataLength; i++) {

	                x = xData[i];
	                y = yData[i];

	                // For points within the visible range, including the first point outside the
	                // visible range, consider y extremes
	                validValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || (y.length || y > 0));
	                withinRange = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped ||
	                    ((xData[i + 1] || x) >= xMin &&    (xData[i - 1] || x) <= xMax);

	                if (validValue && withinRange) {

	                    j = y.length;
	                    if (j) { // array, like ohlc or range data
	                        while (j--) {
	                            if (y[j] !== null) {
	                                activeYData[activeCounter++] = y[j];
	                            }
	                        }
	                    } else {
	                        activeYData[activeCounter++] = y;
	                    }
	                }
	            }
	            this.dataMin = arrayMin(activeYData);
	            this.dataMax = arrayMax(activeYData);
	        },

	        /**
	         * Translate data points from raw data values to chart specific positioning data
	         * needed later in drawPoints, drawGraph and drawTracker.
	         */
	        translate: function () {
	            if (!this.processedXData) { // hidden series
	                this.processData();
	            }
	            this.generatePoints();
	            var series = this,
	                options = series.options,
	                stacking = options.stacking,
	                xAxis = series.xAxis,
	                categories = xAxis.categories,
	                yAxis = series.yAxis,
	                points = series.points,
	                dataLength = points.length,
	                hasModifyValue = !!series.modifyValue,
	                i,
	                pointPlacement = options.pointPlacement,
	                dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),
	                threshold = options.threshold,
	                stackThreshold = options.startFromThreshold ? threshold : 0,
	                plotX,
	                plotY,
	                lastPlotX,
	                stackIndicator,
	                closestPointRangePx = Number.MAX_VALUE;

	            // Translate each point
	            for (i = 0; i < dataLength; i++) {
	                var point = points[i],
	                    xValue = point.x,
	                    yValue = point.y,
	                    yBottom = point.low,
	                    stack = stacking && yAxis.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey],
	                    pointStack,
	                    stackValues;

	                // Discard disallowed y values for log axes (#3434)
	                if (yAxis.isLog && yValue !== null && yValue <= 0) {
	                    point.y = yValue = null;
	                    error(10);
	                }

	                // Get the plotX translation
	                point.plotX = plotX = mathMin(mathMax(-1e5, xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags')), 1e5); // #3923


	                // Calculate the bottom y value for stacked series
	                if (stacking && series.visible && !point.isNull && stack && stack[xValue]) {
	                    stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);
	                    pointStack = stack[xValue];
	                    stackValues = pointStack.points[stackIndicator.key];
	                    yBottom = stackValues[0];
	                    yValue = stackValues[1];

	                    if (yBottom === stackThreshold) {
	                        yBottom = pick(threshold, yAxis.min);
	                    }
	                    if (yAxis.isLog && yBottom <= 0) { // #1200, #1232
	                        yBottom = null;
	                    }

	                    point.total = point.stackTotal = pointStack.total;
	                    point.percentage = pointStack.total && (point.y / pointStack.total * 100);
	                    point.stackY = yValue;

	                    // Place the stack label
	                    pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);

	                }

	                // Set translated yBottom or remove it
	                point.yBottom = defined(yBottom) ?
	                    yAxis.translate(yBottom, 0, 1, 0, 1) :
	                    null;

	                // general hook, used for Highstock compare mode
	                if (hasModifyValue) {
	                    yValue = series.modifyValue(yValue, point);
	                }

	                // Set the the plotY value, reset it for redraws
	                point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?
	                    mathMin(mathMax(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201
	                    UNDEFINED;
	                point.isInside = plotY !== UNDEFINED && plotY >= 0 && plotY <= yAxis.len && // #3519
	                    plotX >= 0 && plotX <= xAxis.len;


	                // Set client related positions for mouse tracking
	                point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : plotX; // #1514

	                point.negative = point.y < (threshold || 0);

	                // some API data
	                point.category = categories && categories[point.x] !== UNDEFINED ?
	                    categories[point.x] : point.x;

	                // Determine auto enabling of markers (#3635)
	                if (i) {
	                    closestPointRangePx = mathMin(closestPointRangePx, mathAbs(plotX - lastPlotX));
	                }
	                lastPlotX = plotX;

	            }
	            series.closestPointRangePx = closestPointRangePx;
	        },

	        /**
	         * Return the series points with null points filtered out
	         */
	        getValidPoints: function (points) {
	            return grep(points || this.points, function (point) {
	                return !point.isNull;
	            });
	        },

	        /**
	         * Set the clipping for the series. For animated series it is called twice, first to initiate
	         * animating the clip then the second time without the animation to set the final clip.
	         */
	        setClip: function (animation) {
	            var chart = this.chart,
	                options = this.options,
	                renderer = chart.renderer,
	                inverted = chart.inverted,
	                seriesClipBox = this.clipBox,
	                clipBox = seriesClipBox || chart.clipBox,
	                sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height, options.xAxis, options.yAxis].join(','), // #4526
	                clipRect = chart[sharedClipKey],
	                markerClipRect = chart[sharedClipKey + 'm'];

	            // If a clipping rectangle with the same properties is currently present in the chart, use that.
	            if (!clipRect) {

	                // When animation is set, prepare the initial positions
	                if (animation) {
	                    clipBox.width = 0;

	                    chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(
	                        -99, // include the width of the first marker
	                        inverted ? -chart.plotLeft : -chart.plotTop,
	                        99,
	                        inverted ? chart.chartWidth : chart.chartHeight
	                    );
	                }
	                chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);

	            }
	            if (animation) {
	                clipRect.count += 1;
	            }

	            if (options.clip !== false) {
	                this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
	                this.markerGroup.clip(markerClipRect);
	                this.sharedClipKey = sharedClipKey;
	            }

	            // Remove the shared clipping rectangle when all series are shown
	            if (!animation) {
	                clipRect.count -= 1;
	                if (clipRect.count <= 0 && sharedClipKey && chart[sharedClipKey]) {
	                    if (!seriesClipBox) {
	                        chart[sharedClipKey] = chart[sharedClipKey].destroy();
	                    }
	                    if (chart[sharedClipKey + 'm']) {
	                        chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();
	                    }
	                }
	            }
	        },

	        /**
	         * Animate in the series
	         */
	        animate: function (init) {
	            var series = this,
	                chart = series.chart,
	                clipRect,
	                animation = series.options.animation,
	                sharedClipKey;

	            // Animation option is set to true
	            if (animation && !isObject(animation)) {
	                animation = defaultPlotOptions[series.type].animation;
	            }

	            // Initialize the animation. Set up the clipping rectangle.
	            if (init) {

	                series.setClip(animation);

	            // Run the animation
	            } else {
	                sharedClipKey = this.sharedClipKey;
	                clipRect = chart[sharedClipKey];
	                if (clipRect) {
	                    clipRect.animate({
	                        width: chart.plotSizeX
	                    }, animation);
	                }
	                if (chart[sharedClipKey + 'm']) {
	                    chart[sharedClipKey + 'm'].animate({
	                        width: chart.plotSizeX + 99
	                    }, animation);
	                }

	                // Delete this function to allow it only once
	                series.animate = null;

	            }
	        },

	        /**
	         * This runs after animation to land on the final plot clipping
	         */
	        afterAnimate: function () {
	            this.setClip();
	            fireEvent(this, 'afterAnimate');
	        },

	        /**
	         * Draw the markers
	         */
	        drawPoints: function () {
	            var series = this,
	                pointAttr,
	                points = series.points,
	                chart = series.chart,
	                plotX,
	                plotY,
	                i,
	                point,
	                radius,
	                symbol,
	                isImage,
	                graphic,
	                options = series.options,
	                seriesMarkerOptions = options.marker,
	                seriesPointAttr = series.pointAttr[''],
	                pointMarkerOptions,
	                hasPointMarker,
	                enabled,
	                isInside,
	                markerGroup = series.markerGroup,
	                xAxis = series.xAxis,
	                globallyEnabled = pick(
	                    seriesMarkerOptions.enabled,
	                    xAxis.isRadial,
	                    series.closestPointRangePx > 2 * seriesMarkerOptions.radius
	                );

	            if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {

	                i = points.length;
	                while (i--) {
	                    point = points[i];
	                    plotX = mathFloor(point.plotX); // #1843
	                    plotY = point.plotY;
	                    graphic = point.graphic;
	                    pointMarkerOptions = point.marker || {};
	                    hasPointMarker = !!point.marker;
	                    enabled = (globallyEnabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;
	                    isInside = point.isInside;

	                    // only draw the point if y is defined
	                    if (enabled && plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {

	                        // shortcuts
	                        pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || seriesPointAttr;
	                        radius = pointAttr.r;
	                        symbol = pick(pointMarkerOptions.symbol, series.symbol);
	                        isImage = symbol.indexOf('url') === 0;

	                        if (graphic) { // update
	                            graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled
	                                .attr(pointAttr) // #4759
	                                .animate(extend({
	                                    x: plotX - radius,
	                                    y: plotY - radius
	                                }, graphic.symbolName ? { // don't apply to image symbols #507
	                                    width: 2 * radius,
	                                    height: 2 * radius
	                                } : {}));
	                        } else if (isInside && (radius > 0 || isImage)) {
	                            point.graphic = graphic = chart.renderer.symbol(
	                                symbol,
	                                plotX - radius,
	                                plotY - radius,
	                                2 * radius,
	                                2 * radius,
	                                hasPointMarker ? pointMarkerOptions : seriesMarkerOptions
	                            )
	                            .attr(pointAttr)
	                            .add(markerGroup);
	                        }

	                    } else if (graphic) {
	                        point.graphic = graphic.destroy(); // #1269
	                    }
	                }
	            }

	        },

	        /**
	         * Convert state properties from API naming conventions to SVG attributes
	         *
	         * @param {Object} options API options object
	         * @param {Object} base1 SVG attribute object to inherit from
	         * @param {Object} base2 Second level SVG attribute object to inherit from
	         */
	        convertAttribs: function (options, base1, base2, base3) {
	            var conversion = this.pointAttrToOptions,
	                attr,
	                option,
	                obj = {};

	            options = options || {};
	            base1 = base1 || {};
	            base2 = base2 || {};
	            base3 = base3 || {};

	            for (attr in conversion) {
	                option = conversion[attr];
	                obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
	            }
	            return obj;
	        },

	        /**
	         * Get the state attributes. Each series type has its own set of attributes
	         * that are allowed to change on a point's state change. Series wide attributes are stored for
	         * all series, and additionally point specific attributes are stored for all
	         * points with individual marker options. If such options are not defined for the point,
	         * a reference to the series wide attributes is stored in point.pointAttr.
	         */
	        getAttribs: function () {
	            var series = this,
	                seriesOptions = series.options,
	                normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,
	                stateOptions = normalOptions.states,
	                stateOptionsHover = stateOptions[HOVER_STATE],
	                pointStateOptionsHover,
	                seriesColor = series.color,
	                seriesNegativeColor = series.options.negativeColor,
	                normalDefaults = {
	                    stroke: seriesColor,
	                    fill: seriesColor
	                },
	                points = series.points || [], // #927
	                i,
	                j,
	                threshold,
	                point,
	                seriesPointAttr = [],
	                pointAttr,
	                pointAttrToOptions = series.pointAttrToOptions,
	                hasPointSpecificOptions = series.hasPointSpecificOptions,
	                defaultLineColor = normalOptions.lineColor,
	                defaultFillColor = normalOptions.fillColor,
	                turboThreshold = seriesOptions.turboThreshold,
	                zones = series.zones,
	                zoneAxis = series.zoneAxis || 'y',
	                attr,
	                key;

	            // series type specific modifications
	            if (seriesOptions.marker) { // line, spline, area, areaspline, scatter

	                // if no hover radius is given, default to normal radius + 2
	                stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + stateOptionsHover.radiusPlus;
	                stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + stateOptionsHover.lineWidthPlus;

	            } else { // column, bar, pie

	                // if no hover color is given, brighten the normal color
	                stateOptionsHover.color = stateOptionsHover.color ||
	                    Color(stateOptionsHover.color || seriesColor)
	                        .brighten(stateOptionsHover.brightness).get();

	                // if no hover negativeColor is given, brighten the normal negativeColor
	                stateOptionsHover.negativeColor = stateOptionsHover.negativeColor ||
	                    Color(stateOptionsHover.negativeColor || seriesNegativeColor)
	                        .brighten(stateOptionsHover.brightness).get();
	            }

	            // general point attributes for the series normal state
	            seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);

	            // HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
	            each([HOVER_STATE, SELECT_STATE], function (state) {
	                seriesPointAttr[state] =
	                        series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
	            });

	            // set it
	            series.pointAttr = seriesPointAttr;


	            // Generate the point-specific attribute collections if specific point
	            // options are given. If not, create a referance to the series wide point
	            // attributes
	            i = points.length;
	            if (!turboThreshold || i < turboThreshold || hasPointSpecificOptions) {
	                while (i--) {
	                    point = points[i];
	                    normalOptions = (point.options && point.options.marker) || point.options;
	                    if (normalOptions && normalOptions.enabled === false) {
	                        normalOptions.radius = 0;
	                    }

	                    if (zones.length) {
	                        j = 0;
	                        threshold = zones[j];
	                        while (point[zoneAxis] >= threshold.value) {
	                            threshold = zones[++j];
	                        }

	                        point.color = point.fillColor = pick(threshold.color, series.color); // #3636, #4267, #4430 - inherit color from series, when color is undefined

	                    }

	                    hasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868

	                    // check if the point has specific visual options
	                    if (point.options) {
	                        for (key in pointAttrToOptions) {
	                            if (defined(normalOptions[pointAttrToOptions[key]])) {
	                                hasPointSpecificOptions = true;
	                            }
	                        }
	                    }

	                    // a specific marker config object is defined for the individual point:
	                    // create it's own attribute collection
	                    if (hasPointSpecificOptions) {
	                        normalOptions = normalOptions || {};
	                        pointAttr = [];
	                        stateOptions = normalOptions.states || {}; // reassign for individual point
	                        pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};

	                        // Handle colors for column and pies
	                        if (!seriesOptions.marker || (point.negative && !pointStateOptionsHover.fillColor && !stateOptionsHover.fillColor)) { // column, bar, point or negative threshold for series with markers (#3636)
	                            // If no hover color is given, brighten the normal color. #1619, #2579
	                            pointStateOptionsHover[series.pointAttrToOptions.fill] = pointStateOptionsHover.color || (!point.options.color && stateOptionsHover[(point.negative && seriesNegativeColor ? 'negativeColor' : 'color')]) ||
	                                Color(point.color)
	                                    .brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness)
	                                    .get();
	                        }

	                        // normal point state inherits series wide normal state
	                        attr = { color: point.color }; // #868
	                        if (!defaultFillColor) { // Individual point color or negative color markers (#2219)
	                            attr.fillColor = point.color;
	                        }
	                        if (!defaultLineColor) {
	                            attr.lineColor = point.color; // Bubbles take point color, line markers use white
	                        }
	                        // Color is explicitly set to null or undefined (#1288, #4068)
	                        if (normalOptions.hasOwnProperty('color') && !normalOptions.color) {
	                            delete normalOptions.color;
	                        }
	                        pointAttr[NORMAL_STATE] = series.convertAttribs(extend(attr, normalOptions), seriesPointAttr[NORMAL_STATE]);

	                        // inherit from point normal and series hover
	                        pointAttr[HOVER_STATE] = series.convertAttribs(
	                            stateOptions[HOVER_STATE],
	                            seriesPointAttr[HOVER_STATE],
	                            pointAttr[NORMAL_STATE]
	                        );

	                        // inherit from point normal and series hover
	                        pointAttr[SELECT_STATE] = series.convertAttribs(
	                            stateOptions[SELECT_STATE],
	                            seriesPointAttr[SELECT_STATE],
	                            pointAttr[NORMAL_STATE]
	                        );


	                    // no marker config object is created: copy a reference to the series-wide
	                    // attribute collection
	                    } else {
	                        pointAttr = seriesPointAttr;
	                    }

	                    point.pointAttr = pointAttr;
	                }
	            }
	        },

	        /**
	         * Clear DOM objects and free up memory
	         */
	        destroy: function () {
	            var series = this,
	                chart = series.chart,
	                issue134 = /AppleWebKit\/533/.test(userAgent),
	                destroy,
	                i,
	                data = series.data || [],
	                point,
	                prop,
	                axis;

	            // add event hook
	            fireEvent(series, 'destroy');

	            // remove all events
	            removeEvent(series);

	            // erase from axes
	            each(series.axisTypes || [], function (AXIS) {
	                axis = series[AXIS];
	                if (axis) {
	                    erase(axis.series, series);
	                    axis.isDirty = axis.forceRedraw = true;
	                }
	            });

	            // remove legend items
	            if (series.legendItem) {
	                series.chart.legend.destroyItem(series);
	            }

	            // destroy all points with their elements
	            i = data.length;
	            while (i--) {
	                point = data[i];
	                if (point && point.destroy) {
	                    point.destroy();
	                }
	            }
	            series.points = null;

	            // Clear the animation timeout if we are destroying the series during initial animation
	            clearTimeout(series.animationTimeout);

	            // Destroy all SVGElements associated to the series
	            for (prop in series) {
	                if (series[prop] instanceof SVGElement && !series[prop].survive) { // Survive provides a hook for not destroying

	                    // issue 134 workaround
	                    destroy = issue134 && prop === 'group' ?
	                        'hide' :
	                        'destroy';

	                    series[prop][destroy]();
	                }
	            }

	            // remove from hoverSeries
	            if (chart.hoverSeries === series) {
	                chart.hoverSeries = null;
	            }
	            erase(chart.series, series);

	            // clear all members
	            for (prop in series) {
	                delete series[prop];
	            }
	        },

	        /**
	         * Get the graph path
	         */
	        getGraphPath: function (points, nullsAsZeroes, connectCliffs) {
	            var series = this,
	                options = series.options,
	                step = options.step,
	                reversed,
	                graphPath = [],
	                gap;

	            points = points || series.points;

	            // Bottom of a stack is reversed
	            reversed = points.reversed;
	            if (reversed) {
	                points.reverse();
	            }
	            // Reverse the steps (#5004)
	            step = { right: 1, center: 2 }[step] || (step && 3);
	            if (step && reversed) {
	                step = 4 - step;
	            }

	            // Remove invalid points, especially in spline (#5015)
	            if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {
	                points = this.getValidPoints(points);
	            }

	            // Build the line
	            each(points, function (point, i) {

	                var plotX = point.plotX,
	                    plotY = point.plotY,
	                    lastPoint = points[i - 1],                
	                    pathToPoint; // the path to this point from the previous

	                if ((point.leftCliff || (lastPoint && lastPoint.rightCliff)) && !connectCliffs) {
	                    gap = true; // ... and continue
	                }

	                // Line series, nullsAsZeroes is not handled
	                if (point.isNull && !defined(nullsAsZeroes) && i > 0) {
	                    gap = !options.connectNulls;

	                // Area series, nullsAsZeroes is set
	                } else if (point.isNull && !nullsAsZeroes) {
	                    gap = true;

	                } else {

	                    if (i === 0 || gap) {
	                        pathToPoint = [M, point.plotX, point.plotY];
	                
	                    } else if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
	                    
	                        pathToPoint = series.getPointSpline(points, point, i);

	                    } else if (step) {

	                        if (step === 1) { // right
	                            pathToPoint = [
	                                L,
	                                lastPoint.plotX,
	                                plotY
	                            ];
	                        
	                        } else if (step === 2) { // center
	                            pathToPoint = [
	                                L,
	                                (lastPoint.plotX + plotX) / 2,
	                                lastPoint.plotY,
	                                L,
	                                (lastPoint.plotX + plotX) / 2,
	                                plotY
	                            ];
	                        
	                        } else {
	                            pathToPoint = [
	                                L,
	                                plotX,
	                                lastPoint.plotY
	                            ];
	                        }
	                        pathToPoint.push(L, plotX, plotY);

	                    } else {
	                        // normal line to next point
	                        pathToPoint = [
	                            L,
	                            plotX,
	                            plotY
	                        ];
	                    }


	                    graphPath.push.apply(graphPath, pathToPoint);
	                    gap = false;
	                }
	            });

	            series.graphPath = graphPath;

	            return graphPath;

	        },

	        /**
	         * Draw the actual graph
	         */
	        drawGraph: function () {
	            var series = this,
	                options = this.options,
	                props = [['graph', options.lineColor || this.color, options.dashStyle]],
	                lineWidth = options.lineWidth,
	                roundCap = options.linecap !== 'square',
	                graphPath = (this.gappedPath || this.getGraphPath).call(this),
	                fillColor = (this.fillGraph && this.color) || NONE, // polygon series use filled graph
	                zones = this.zones;

	            each(zones, function (threshold, i) {
	                props.push(['zoneGraph' + i, threshold.color || series.color, threshold.dashStyle || options.dashStyle]);
	            });

	            // Draw the graph
	            each(props, function (prop, i) {
	                var graphKey = prop[0],
	                    graph = series[graphKey],
	                    attribs;

	                if (graph) {
	                    graph.animate({ d: graphPath });

	                } else if ((lineWidth || fillColor) && graphPath.length) { // #1487
	                    attribs = {
	                        stroke: prop[1],
	                        'stroke-width': lineWidth,
	                        fill: fillColor,
	                        zIndex: 1 // #1069
	                    };
	                    if (prop[2]) {
	                        attribs.dashstyle = prop[2];
	                    } else if (roundCap) {
	                        attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';
	                    }

	                    series[graphKey] = series.chart.renderer.path(graphPath)
	                        .attr(attribs)
	                        .add(series.group)
	                        .shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932
	                }
	            });
	        },

	        /**
	         * Clip the graphs into the positive and negative coloured graphs
	         */
	        applyZones: function () {
	            var series = this,
	                chart = this.chart,
	                renderer = chart.renderer,
	                zones = this.zones,
	                translatedFrom,
	                translatedTo,
	                clips = this.clips || [],
	                clipAttr,
	                graph = this.graph,
	                area = this.area,
	                chartSizeMax = mathMax(chart.chartWidth, chart.chartHeight),
	                axis = this[(this.zoneAxis || 'y') + 'Axis'],
	                extremes,
	                reversed = axis.reversed,
	                inverted = chart.inverted,
	                horiz = axis.horiz,
	                pxRange,
	                pxPosMin,
	                pxPosMax,
	                ignoreZones = false;

	            if (zones.length && (graph || area) && axis.min !== UNDEFINED) {
	                // The use of the Color Threshold assumes there are no gaps
	                // so it is safe to hide the original graph and area
	                if (graph) {
	                    graph.hide();
	                }
	                if (area) {
	                    area.hide();
	                }

	                // Create the clips
	                extremes = axis.getExtremes();
	                each(zones, function (threshold, i) {

	                    translatedFrom = reversed ?
	                        (horiz ? chart.plotWidth : 0) :
	                        (horiz ? 0 : axis.toPixels(extremes.min));
	                    translatedFrom = mathMin(mathMax(pick(translatedTo, translatedFrom), 0), chartSizeMax);
	                    translatedTo = mathMin(mathMax(mathRound(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);

	                    if (ignoreZones) {
	                        translatedFrom = translatedTo = axis.toPixels(extremes.max);
	                    }

	                    pxRange = Math.abs(translatedFrom - translatedTo);
	                    pxPosMin = mathMin(translatedFrom, translatedTo);
	                    pxPosMax = mathMax(translatedFrom, translatedTo);
	                    if (axis.isXAxis) {
	                        clipAttr = {
	                            x: inverted ? pxPosMax : pxPosMin,
	                            y: 0,
	                            width: pxRange,
	                            height: chartSizeMax
	                        };
	                        if (!horiz) {
	                            clipAttr.x = chart.plotHeight - clipAttr.x;
	                        }
	                    } else {
	                        clipAttr = {
	                            x: 0,
	                            y: inverted ? pxPosMax : pxPosMin,
	                            width: chartSizeMax,
	                            height: pxRange
	                        };
	                        if (horiz) {
	                            clipAttr.y = chart.plotWidth - clipAttr.y;
	                        }
	                    }

	                    /// VML SUPPPORT
	                    if (chart.inverted && renderer.isVML) {
	                        if (axis.isXAxis) {
	                            clipAttr = {
	                                x: 0,
	                                y: reversed ? pxPosMin : pxPosMax,
	                                height: clipAttr.width,
	                                width: chart.chartWidth
	                            };
	                        } else {
	                            clipAttr = {
	                                x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
	                                y: 0,
	                                width: clipAttr.height,
	                                height: chart.chartHeight
	                            };
	                        }
	                    }
	                    /// END OF VML SUPPORT

	                    if (clips[i]) {
	                        clips[i].animate(clipAttr);
	                    } else {
	                        clips[i] = renderer.clipRect(clipAttr);

	                        if (graph) {
	                            series['zoneGraph' + i].clip(clips[i]);
	                        }

	                        if (area) {
	                            series['zoneArea' + i].clip(clips[i]);
	                        }
	                    }
	                    // if this zone extends out of the axis, ignore the others
	                    ignoreZones = threshold.value > extremes.max;
	                });
	                this.clips = clips;
	            }
	        },

	        /**
	         * Initialize and perform group inversion on series.group and series.markerGroup
	         */
	        invertGroups: function () {
	            var series = this,
	                chart = series.chart;

	            // Pie, go away (#1736)
	            if (!series.xAxis) {
	                return;
	            }

	            // A fixed size is needed for inversion to work
	            function setInvert() {
	                var size = {
	                    width: series.yAxis.len,
	                    height: series.xAxis.len
	                };

	                each(['group', 'markerGroup'], function (groupName) {
	                    if (series[groupName]) {
	                        series[groupName].attr(size).invert();
	                    }
	                });
	            }

	            addEvent(chart, 'resize', setInvert); // do it on resize
	            addEvent(series, 'destroy', function () {
	                removeEvent(chart, 'resize', setInvert);
	            });

	            // Do it now
	            setInvert(); // do it now

	            // On subsequent render and redraw, just do setInvert without setting up events again
	            series.invertGroups = setInvert;
	        },

	        /**
	         * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and
	         * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.
	         */
	        plotGroup: function (prop, name, visibility, zIndex, parent) {
	            var group = this[prop],
	                isNew = !group;

	            // Generate it on first call
	            if (isNew) {
	                this[prop] = group = this.chart.renderer.g(name)
	                    .attr({
	                        zIndex: zIndex || 0.1 // IE8 needs this
	                    })
	                    .add(parent);

	                group.addClass('highcharts-series-' + this.index);
	            }

	            // Place it on first and subsequent (redraw) calls
	            group.attr({ visibility: visibility })[isNew ? 'attr' : 'animate'](this.getPlotBox());
	            return group;
	        },

	        /**
	         * Get the translation and scale for the plot area of this series
	         */
	        getPlotBox: function () {
	            var chart = this.chart,
	                xAxis = this.xAxis,
	                yAxis = this.yAxis;

	            // Swap axes for inverted (#2339)
	            if (chart.inverted) {
	                xAxis = yAxis;
	                yAxis = this.xAxis;
	            }
	            return {
	                translateX: xAxis ? xAxis.left : chart.plotLeft,
	                translateY: yAxis ? yAxis.top : chart.plotTop,
	                scaleX: 1, // #1623
	                scaleY: 1
	            };
	        },

	        /**
	         * Render the graph and markers
	         */
	        render: function () {
	            var series = this,
	                chart = series.chart,
	                group,
	                options = series.options,
	                animation = options.animation,
	                // Animation doesn't work in IE8 quirks when the group div is hidden,
	                // and looks bad in other oldIE
	                animDuration = (animation && !!series.animate && chart.renderer.isSVG && pick(animation.duration, 500)) || 0,
	                visibility = series.visible ? 'inherit' : 'hidden', // #2597
	                zIndex = options.zIndex,
	                hasRendered = series.hasRendered,
	                chartSeriesGroup = chart.seriesGroup;

	            // the group
	            group = series.plotGroup(
	                'group',
	                'series',
	                visibility,
	                zIndex,
	                chartSeriesGroup
	            );

	            series.markerGroup = series.plotGroup(
	                'markerGroup',
	                'markers',
	                visibility,
	                zIndex,
	                chartSeriesGroup
	            );

	            // initiate the animation
	            if (animDuration) {
	                series.animate(true);
	            }

	            // cache attributes for shapes
	            series.getAttribs();

	            // SVGRenderer needs to know this before drawing elements (#1089, #1795)
	            group.inverted = series.isCartesian ? chart.inverted : false;

	            // draw the graph if any
	            if (series.drawGraph) {
	                series.drawGraph();
	                series.applyZones();
	            }

	            each(series.points, function (point) {
	                if (point.redraw) {
	                    point.redraw();
	                }
	            });

	            // draw the data labels (inn pies they go before the points)
	            if (series.drawDataLabels) {
	                series.drawDataLabels();
	            }

	            // draw the points
	            if (series.visible) {
	                series.drawPoints();
	            }


	            // draw the mouse tracking area
	            if (series.drawTracker && series.options.enableMouseTracking !== false) {
	                series.drawTracker();
	            }

	            // Handle inverted series and tracker groups
	            if (chart.inverted) {
	                series.invertGroups();
	            }

	            // Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).
	            if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
	                group.clip(chart.clipRect);
	            }

	            // Run the animation
	            if (animDuration) {
	                series.animate();
	            }

	            // Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option
	            // which should be available to the user).
	            if (!hasRendered) {
	                series.animationTimeout = syncTimeout(function () {
	                    series.afterAnimate();
	                }, animDuration);
	            }

	            series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
	            // (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
	            series.hasRendered = true;
	        },

	        /**
	         * Redraw the series after an update in the axes.
	         */
	        redraw: function () {
	            var series = this,
	                chart = series.chart,
	                wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after
	                wasDirty = series.isDirty,
	                group = series.group,
	                xAxis = series.xAxis,
	                yAxis = series.yAxis;

	            // reposition on resize
	            if (group) {
	                if (chart.inverted) {
	                    group.attr({
	                        width: chart.plotWidth,
	                        height: chart.plotHeight
	                    });
	                }

	                group.animate({
	                    translateX: pick(xAxis && xAxis.left, chart.plotLeft),
	                    translateY: pick(yAxis && yAxis.top, chart.plotTop)
	                });
	            }

	            series.translate();
	            series.render();
	            if (wasDirtyData) {
	                fireEvent(series, 'updatedData');
	            }
	            if (wasDirty || wasDirtyData) {            // #3945 recalculate the kdtree when dirty
	                delete this.kdTree; // #3868 recalculate the kdtree with dirty data
	            }
	        },

	        /**
	         * KD Tree && PointSearching Implementation
	         */

	        kdDimensions: 1,
	        kdAxisArray: ['clientX', 'plotY'],

	        searchPoint: function (e, compareX) {
	            var series = this,
	                xAxis = series.xAxis,
	                yAxis = series.yAxis,
	                inverted = series.chart.inverted;

	            return this.searchKDTree({
	                clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
	                plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
	            }, compareX);
	        },

	        buildKDTree: function () {
	            var series = this,
	                dimensions = series.kdDimensions;

	            // Internal function
	            function _kdtree(points, depth, dimensions) {
	                var axis, median, length = points && points.length;

	                if (length) {

	                    // alternate between the axis
	                    axis = series.kdAxisArray[depth % dimensions];

	                    // sort point array
	                    points.sort(function (a, b) {
	                        return a[axis] - b[axis];
	                    });

	                    median = Math.floor(length / 2);

	                    // build and return nod
	                    return {
	                        point: points[median],
	                        left: _kdtree(points.slice(0, median), depth + 1, dimensions),
	                        right: _kdtree(points.slice(median + 1), depth + 1, dimensions)
	                    };

	                }
	            }

	            // Start the recursive build process with a clone of the points array and null points filtered out (#3873)
	            function startRecursive() {
	                series.kdTree = _kdtree(series.getValidPoints(), dimensions, dimensions);
	            }
	            delete series.kdTree;

	            // For testing tooltips, don't build async
	            syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);
	        },

	        searchKDTree: function (point, compareX) {
	            var series = this,
	                kdX = this.kdAxisArray[0],
	                kdY = this.kdAxisArray[1],
	                kdComparer = compareX ? 'distX' : 'dist';

	            // Set the one and two dimensional distance on the point object
	            function setDistance(p1, p2) {
	                var x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,
	                    y = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,
	                    r = (x || 0) + (y || 0);

	                p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;
	                p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;
	            }
	            function _search(search, tree, depth, dimensions) {
	                var point = tree.point,
	                    axis = series.kdAxisArray[depth % dimensions],
	                    tdist,
	                    sideA,
	                    sideB,
	                    ret = point,
	                    nPoint1,
	                    nPoint2;

	                setDistance(search, point);

	                // Pick side based on distance to splitting point
	                tdist = search[axis] - point[axis];
	                sideA = tdist < 0 ? 'left' : 'right';
	                sideB = tdist < 0 ? 'right' : 'left';

	                // End of tree
	                if (tree[sideA]) {
	                    nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);

	                    ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);
	                }
	                if (tree[sideB]) {
	                    // compare distance to current best to splitting point to decide wether to check side B or not
	                    if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
	                        nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
	                        ret = (nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret);
	                    }
	                }

	                return ret;
	            }

	            if (!this.kdTree) {
	                this.buildKDTree();
	            }

	            if (this.kdTree) {
	                return _search(point,
	                    this.kdTree, this.kdDimensions, this.kdDimensions);
	            }
	        }

	    }; // end Series prototype

	    /**
	     * The class for stack items
	     */
	    function StackItem(axis, options, isNegative, x, stackOption) {

	        var inverted = axis.chart.inverted;

	        this.axis = axis;

	        // Tells if the stack is negative
	        this.isNegative = isNegative;

	        // Save the options to be able to style the label
	        this.options = options;

	        // Save the x value to be able to position the label later
	        this.x = x;

	        // Initialize total value
	        this.total = null;

	        // This will keep each points' extremes stored by series.index and point index
	        this.points = {};

	        // Save the stack option on the series configuration object, and whether to treat it as percent
	        this.stack = stackOption;
	        this.leftCliff = 0;
	        this.rightCliff = 0;

	        // The align options and text align varies on whether the stack is negative and
	        // if the chart is inverted or not.
	        // First test the user supplied value, then use the dynamic.
	        this.alignOptions = {
	            align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
	            verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
	            y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
	            x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
	        };

	        this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
	    }

	    StackItem.prototype = {
	        destroy: function () {
	            destroyObjectProperties(this, this.axis);
	        },

	        /**
	         * Renders the stack total label and adds it to the stack label group.
	         */
	        render: function (group) {
	            var options = this.options,
	                formatOption = options.format,
	                str = formatOption ?
	                    format(formatOption, this) :
	                    options.formatter.call(this);  // format the text in the label

	            // Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
	            if (this.label) {
	                this.label.attr({ text: str, visibility: 'hidden' });
	            // Create new label
	            } else {
	                this.label =
	                    this.axis.chart.renderer.text(str, null, null, options.useHTML)        // dummy positions, actual position updated with setOffset method in columnseries
	                        .css(options.style)                // apply style
	                        .attr({
	                            align: this.textAlign,                // fix the text-anchor
	                            rotation: options.rotation,    // rotation
	                            visibility: HIDDEN                    // hidden until setOffset is called
	                        })
	                        .add(group);                            // add to the labels-group
	            }
	        },

	        /**
	         * Sets the offset that the stack has from the x value and repositions the label.
	         */
	        setOffset: function (xOffset, xWidth) {
	            var stackItem = this,
	                axis = stackItem.axis,
	                chart = axis.chart,
	                inverted = chart.inverted,
	                reversed = axis.reversed,
	                neg = (this.isNegative && !reversed) || (!this.isNegative && reversed), // #4056
	                y = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates
	                yZero = axis.translate(0),                        // stack origin
	                h = mathAbs(y - yZero),                            // stack height
	                x = chart.xAxis[0].translate(this.x) + xOffset,    // stack x position
	                plotHeight = chart.plotHeight,
	                stackBox = {    // this is the box for the complete stack
	                    x: inverted ? (neg ? y : y - h) : x,
	                    y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
	                    width: inverted ? h : xWidth,
	                    height: inverted ? xWidth : h
	                },
	                label = this.label,
	                alignAttr;

	            if (label) {
	                label.align(this.alignOptions, null, stackBox);    // align the label to the box

	                // Set visibility (#678)
	                alignAttr = label.alignAttr;
	                label[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);
	            }
	        }
	    };

	    /**
	     * Generate stacks for each series and calculate stacks total values
	     */
	    Chart.prototype.getStacks = function () {
	        var chart = this;

	        // reset stacks for each yAxis
	        each(chart.yAxis, function (axis) {
	            if (axis.stacks && axis.hasVisibleSeries) {
	                axis.oldStacks = axis.stacks;
	            }
	        });

	        each(chart.series, function (series) {
	            if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
	                series.stackKey = series.type + pick(series.options.stack, '');
	            }
	        });
	    };


	    // Stacking methods defined on the Axis prototype

	    /**
	     * Build the stacks from top down
	     */
	    Axis.prototype.buildStacks = function () {
	        var axisSeries = this.series,
	            series,
	            reversedStacks = pick(this.options.reversedStacks, true),
	            len = axisSeries.length,
	            i;
	        if (!this.isXAxis) {
	            this.usePercentage = false;
	            i = len;
	            while (i--) {
	                axisSeries[reversedStacks ? i : len - i - 1].setStackedPoints();
	            }

	            i = len;
	            while (i--) {
	                series = axisSeries[reversedStacks ? i : len - i - 1];
	                if (series.setStackCliffs) {
	                    series.setStackCliffs();
	                }
	            }
	            // Loop up again to compute percent stack
	            if (this.usePercentage) {
	                for (i = 0; i < len; i++) {
	                    axisSeries[i].setPercentStacks();
	                }
	            }
	        }
	    };

	    Axis.prototype.renderStackTotals = function () {
	        var axis = this,
	            chart = axis.chart,
	            renderer = chart.renderer,
	            stacks = axis.stacks,
	            stackKey,
	            oneStack,
	            stackCategory,
	            stackTotalGroup = axis.stackTotalGroup;

	        // Create a separate group for the stack total labels
	        if (!stackTotalGroup) {
	            axis.stackTotalGroup = stackTotalGroup =
	                renderer.g('stack-labels')
	                    .attr({
	                        visibility: VISIBLE,
	                        zIndex: 6
	                    })
	                    .add();
	        }

	        // plotLeft/Top will change when y axis gets wider so we need to translate the
	        // stackTotalGroup at every render call. See bug #506 and #516
	        stackTotalGroup.translate(chart.plotLeft, chart.plotTop);

	        // Render each stack total
	        for (stackKey in stacks) {
	            oneStack = stacks[stackKey];
	            for (stackCategory in oneStack) {
	                oneStack[stackCategory].render(stackTotalGroup);
	            }
	        }
	    };

	    /**
	     * Set all the stacks to initial states and destroy unused ones.
	     */
	    Axis.prototype.resetStacks = function () {
	        var stacks = this.stacks,
	            type,
	            i;
	        if (!this.isXAxis) {
	            for (type in stacks) {
	                for (i in stacks[type]) {

	                    // Clean up memory after point deletion (#1044, #4320)
	                    if (stacks[type][i].touched < this.stacksTouched) {
	                        stacks[type][i].destroy();
	                        delete stacks[type][i];

	                    // Reset stacks
	                    } else {
	                        stacks[type][i].total = null;
	                        stacks[type][i].cum = 0;
	                    }
	                }
	            }
	        }
	    };

	    Axis.prototype.cleanStacks = function () {
	        var stacks, type, i;

	        if (!this.isXAxis) {
	            if (this.oldStacks) {
	                stacks = this.stacks = this.oldStacks;
	            }

	            // reset stacks
	            for (type in stacks) {
	                for (i in stacks[type]) {
	                    stacks[type][i].cum = stacks[type][i].total;
	                }
	            }
	        }
	    };


	    // Stacking methods defnied for Series prototype

	    /**
	     * Adds series' points value to corresponding stack
	     */
	    Series.prototype.setStackedPoints = function () {
	        if (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {
	            return;
	        }

	        var series = this,
	            xData = series.processedXData,
	            yData = series.processedYData,
	            stackedYData = [],
	            yDataLength = yData.length,
	            seriesOptions = series.options,
	            threshold = seriesOptions.threshold,
	            stackThreshold = seriesOptions.startFromThreshold ? threshold : 0,
	            stackOption = seriesOptions.stack,
	            stacking = seriesOptions.stacking,
	            stackKey = series.stackKey,
	            negKey = '-' + stackKey,
	            negStacks = series.negStacks,
	            yAxis = series.yAxis,
	            stacks = yAxis.stacks,
	            oldStacks = yAxis.oldStacks,
	            stackIndicator,
	            isNegative,
	            stack,
	            other,
	            key,
	            pointKey,
	            i,
	            x,
	            y;


	        yAxis.stacksTouched += 1;

	        // loop over the non-null y values and read them into a local array
	        for (i = 0; i < yDataLength; i++) {
	            x = xData[i];
	            y = yData[i];
	            stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);
	            pointKey = stackIndicator.key;
	            // Read stacked values into a stack based on the x value,
	            // the sign of y and the stack key. Stacking is also handled for null values (#739)
	            isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
	            key = isNegative ? negKey : stackKey;

	            // Create empty object for this stack if it doesn't exist yet
	            if (!stacks[key]) {
	                stacks[key] = {};
	            }

	            // Initialize StackItem for this x
	            if (!stacks[key][x]) {
	                if (oldStacks[key] && oldStacks[key][x]) {
	                    stacks[key][x] = oldStacks[key][x];
	                    stacks[key][x].total = null;
	                } else {
	                    stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);
	                }
	            }

	            // If the StackItem doesn't exist, create it first
	            stack = stacks[key][x];
	            if (y !== null) {
	                stack.points[pointKey] = stack.points[series.index] = [pick(stack.cum, stackThreshold)];
	                stack.touched = yAxis.stacksTouched;
	        

	                // In area charts, if there are multiple points on the same X value, let the 
	                // area fill the full span of those points
	                if (stackIndicator.index > 0 && series.singleStacks === false) {
	                    stack.points[pointKey][0] = stack.points[series.index + ',' + x + ',0'][0];
	                }
	            }

	            // Add value to the stack total
	            if (stacking === 'percent') {

	                // Percent stacked column, totals are the same for the positive and negative stacks
	                other = isNegative ? stackKey : negKey;
	                if (negStacks && stacks[other] && stacks[other][x]) {
	                    other = stacks[other][x];
	                    stack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;

	                // Percent stacked areas
	                } else {
	                    stack.total = correctFloat(stack.total + (mathAbs(y) || 0));
	                }
	            } else {
	                stack.total = correctFloat(stack.total + (y || 0));
	            }

	            stack.cum = pick(stack.cum, stackThreshold) + (y || 0);

	            if (y !== null) {
	                stack.points[pointKey].push(stack.cum);
	            }
	            stackedYData[i] = stack.cum;

	        }

	        if (stacking === 'percent') {
	            yAxis.usePercentage = true;
	        }

	        this.stackedYData = stackedYData; // To be used in getExtremes

	        // Reset old stacks
	        yAxis.oldStacks = {};
	    };

	    /**
	     * Iterate over all stacks and compute the absolute values to percent
	     */
	    Series.prototype.setPercentStacks = function () {
	        var series = this,
	            stackKey = series.stackKey,
	            stacks = series.yAxis.stacks,
	            processedXData = series.processedXData,
	            stackIndicator;

	        each([stackKey, '-' + stackKey], function (key) {
	            var i = processedXData.length,
	                x,
	                stack,
	                pointExtremes,
	                totalFactor;

	            while (i--) {
	                x = processedXData[i];
	                stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);
	                stack = stacks[key] && stacks[key][x];
	                pointExtremes = stack && stack.points[stackIndicator.key];
	                if (pointExtremes) {
	                    totalFactor = stack.total ? 100 / stack.total : 0;
	                    pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value
	                    pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value
	                    series.stackedYData[i] = pointExtremes[1];
	                }
	            }
	        });
	    };

	    /**
	    * Get stack indicator, according to it's x-value, to determine points with the same x-value
	    */
	    Series.prototype.getStackIndicator = function (stackIndicator, x, index) {
	        if (!defined(stackIndicator) || stackIndicator.x !== x) {
	            stackIndicator = {
	                x: x,
	                index: 0
	            };
	        } else {
	            stackIndicator.index++;
	        }

	        stackIndicator.key = [index, x, stackIndicator.index].join(',');

	        return stackIndicator;
	    };

	    // Extend the Chart prototype for dynamic methods
	    extend(Chart.prototype, {

	        /**
	         * Add a series dynamically after  time
	         *
	         * @param {Object} options The config options
	         * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
	         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	         *    configuration
	         *
	         * @return {Object} series The newly created series object
	         */
	        addSeries: function (options, redraw, animation) {
	            var series,
	                chart = this;

	            if (options) {
	                redraw = pick(redraw, true); // defaults to true

	                fireEvent(chart, 'addSeries', { options: options }, function () {
	                    series = chart.initSeries(options);

	                    chart.isDirtyLegend = true; // the series array is out of sync with the display
	                    chart.linkSeries();
	                    if (redraw) {
	                        chart.redraw(animation);
	                    }
	                });
	            }

	            return series;
	        },

	        /**
	         * Add an axis to the chart
	         * @param {Object} options The axis option
	         * @param {Boolean} isX Whether it is an X axis or a value axis
	         */
	        addAxis: function (options, isX, redraw, animation) {
	            var key = isX ? 'xAxis' : 'yAxis',
	                chartOptions = this.options;

	            new Axis(this, merge(options, { // eslint-disable-line no-new
	                index: this[key].length,
	                isX: isX
	            }));

	            // Push the new axis options to the chart options
	            chartOptions[key] = splat(chartOptions[key] || {});
	            chartOptions[key].push(options);

	            if (pick(redraw, true)) {
	                this.redraw(animation);
	            }
	        },

	        /**
	         * Dim the chart and show a loading text or symbol
	         * @param {String} str An optional text to show in the loading label instead of the default one
	         */
	        showLoading: function (str) {
	            var chart = this,
	                options = chart.options,
	                loadingDiv = chart.loadingDiv,
	                loadingOptions = options.loading,
	                setLoadingSize = function () {
	                    if (loadingDiv) {
	                        css(loadingDiv, {
	                            left: chart.plotLeft + PX,
	                            top: chart.plotTop + PX,
	                            width: chart.plotWidth + PX,
	                            height: chart.plotHeight + PX
	                        });
	                    }
	                };

	            // create the layer at the first call
	            if (!loadingDiv) {
	                chart.loadingDiv = loadingDiv = createElement(DIV, {
	                    className: PREFIX + 'loading'
	                }, extend(loadingOptions.style, {
	                    zIndex: 10,
	                    display: NONE
	                }), chart.container);

	                chart.loadingSpan = createElement(
	                    'span',
	                    null,
	                    loadingOptions.labelStyle,
	                    loadingDiv
	                );
	                addEvent(chart, 'redraw', setLoadingSize); // #1080
	            }

	            // update text
	            chart.loadingSpan.innerHTML = str || options.lang.loading;

	            // show it
	            if (!chart.loadingShown) {
	                css(loadingDiv, {
	                    opacity: 0,
	                    display: ''
	                });
	                animate(loadingDiv, {
	                    opacity: loadingOptions.style.opacity
	                }, {
	                    duration: loadingOptions.showDuration || 0
	                });
	                chart.loadingShown = true;
	            }
	            setLoadingSize();
	        },

	        /**
	         * Hide the loading layer
	         */
	        hideLoading: function () {
	            var options = this.options,
	                loadingDiv = this.loadingDiv;

	            if (loadingDiv) {
	                animate(loadingDiv, {
	                    opacity: 0
	                }, {
	                    duration: options.loading.hideDuration || 100,
	                    complete: function () {
	                        css(loadingDiv, { display: NONE });
	                    }
	                });
	            }
	            this.loadingShown = false;
	        }
	    });

	    // extend the Point prototype for dynamic methods
	    extend(Point.prototype, {
	        /**
	         * Update the point with new options (typically x/y data) and optionally redraw the series.
	         *
	         * @param {Object} options Point options as defined in the series.data array
	         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	         *    configuration
	         *
	         */
	        update: function (options, redraw, animation, runEvent) {
	            var point = this,
	                series = point.series,
	                graphic = point.graphic,
	                i,
	                chart = series.chart,
	                seriesOptions = series.options,
	                names = series.xAxis && series.xAxis.names;

	            redraw = pick(redraw, true);

	            function update() {

	                point.applyOptions(options);

	                // Update visuals
	                if (point.y === null && graphic) { // #4146
	                    point.graphic = graphic.destroy();
	                }
	                if (isObject(options) && !isArray(options)) {
	                    // Defer the actual redraw until getAttribs has been called (#3260)
	                    point.redraw = function () {
	                        if (graphic && graphic.element) {
	                            if (options && options.marker && options.marker.symbol) {
	                                point.graphic = graphic.destroy();
	                            }
	                        }
	                        if (options && options.dataLabels && point.dataLabel) { // #2468
	                            point.dataLabel = point.dataLabel.destroy();
	                        }
	                        point.redraw = null;
	                    };
	                }

	                // record changes in the parallel arrays
	                i = point.index;
	                series.updateParallelArrays(point, i);
	                if (names && point.name) {
	                    names[point.x] = point.name;
	                }

	                // Record the options to options.data. If there is an object from before,
	                // use point options, otherwise use raw options. (#4701)
	                seriesOptions.data[i] = isObject(seriesOptions.data[i]) ? point.options : options;

	                // redraw
	                series.isDirty = series.isDirtyData = true;
	                if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
	                    chart.isDirtyBox = true;
	                }

	                if (seriesOptions.legendType === 'point') { // #1831, #1885
	                    chart.isDirtyLegend = true;
	                }
	                if (redraw) {
	                    chart.redraw(animation);
	                }
	            }

	            // Fire the event with a default handler of doing the update
	            if (runEvent === false) { // When called from setData
	                update();
	            } else {
	                point.firePointEvent('update', { options: options }, update);
	            }
	        },

	        /**
	         * Remove a point and optionally redraw the series and if necessary the axes
	         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	         *    configuration
	         */
	        remove: function (redraw, animation) {
	            this.series.removePoint(inArray(this, this.series.data), redraw, animation);
	        }
	    });

	    // Extend the series prototype for dynamic methods
	    extend(Series.prototype, {
	        /**
	         * Add a point dynamically after chart load time
	         * @param {Object} options Point options as given in series.data
	         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	         * @param {Boolean} shift If shift is true, a point is shifted off the start
	         *    of the series as one is appended to the end.
	         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	         *    configuration
	         */
	        addPoint: function (options, redraw, shift, animation) {
	            var series = this,
	                seriesOptions = series.options,
	                data = series.data,
	                graph = series.graph,
	                area = series.area,
	                chart = series.chart,
	                names = series.xAxis && series.xAxis.names,
	                currentShift = (graph && graph.shift) || 0,
	                shiftShapes = ['graph', 'area'],
	                dataOptions = seriesOptions.data,
	                point,
	                isInTheMiddle,
	                xData = series.xData,
	                i,
	                x;

	            setAnimation(animation, chart);

	            // Make graph animate sideways
	            if (shift) {
	                i = series.zones.length;
	                while (i--) {
	                    shiftShapes.push('zoneGraph' + i, 'zoneArea' + i);
	                }
	                each(shiftShapes, function (shape) {
	                    if (series[shape]) {
	                        series[shape].shift = currentShift + (seriesOptions.step ? 2 : 1);
	                    }
	                });
	            }
	            if (area) {
	                area.isArea = true; // needed in animation, both with and without shift
	            }

	            // Optional redraw, defaults to true
	            redraw = pick(redraw, true);

	            // Get options and push the point to xData, yData and series.options. In series.generatePoints
	            // the Point instance will be created on demand and pushed to the series.data array.
	            point = { series: series };
	            series.pointClass.prototype.applyOptions.apply(point, [options]);
	            x = point.x;

	            // Get the insertion point
	            i = xData.length;
	            if (series.requireSorting && x < xData[i - 1]) {
	                isInTheMiddle = true;
	                while (i && xData[i - 1] > x) {
	                    i--;
	                }
	            }

	            series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item
	            series.updateParallelArrays(point, i); // update it

	            if (names && point.name) {
	                names[x] = point.name;
	            }
	            dataOptions.splice(i, 0, options);

	            if (isInTheMiddle) {
	                series.data.splice(i, 0, null);
	                series.processData();
	            }

	            // Generate points to be added to the legend (#1329)
	            if (seriesOptions.legendType === 'point') {
	                series.generatePoints();
	            }

	            // Shift the first point off the parallel arrays
	            if (shift) {
	                if (data[0] && data[0].remove) {
	                    data[0].remove(false);
	                } else {
	                    data.shift();
	                    series.updateParallelArrays(point, 'shift');

	                    dataOptions.shift();
	                }
	            }

	            // redraw
	            series.isDirty = true;
	            series.isDirtyData = true;
	            if (redraw) {
	                series.getAttribs(); // #1937
	                chart.redraw();
	            }
	        },

	        /**
	         * Remove a point (rendered or not), by index
	         */
	        removePoint: function (i, redraw, animation) {

	            var series = this,
	                data = series.data,
	                point = data[i],
	                points = series.points,
	                chart = series.chart,
	                remove = function () {

	                    if (points && points.length === data.length) { // #4935
	                        points.splice(i, 1);
	                    }
	                    data.splice(i, 1);
	                    series.options.data.splice(i, 1);
	                    series.updateParallelArrays(point || { series: series }, 'splice', i, 1);

	                    if (point) {
	                        point.destroy();
	                    }

	                    // redraw
	                    series.isDirty = true;
	                    series.isDirtyData = true;
	                    if (redraw) {
	                        chart.redraw();
	                    }
	                };

	            setAnimation(animation, chart);
	            redraw = pick(redraw, true);

	            // Fire the event with a default handler of removing the point
	            if (point) {
	                point.firePointEvent('remove', null, remove);
	            } else {
	                remove();
	            }
	        },

	        /**
	         * Remove a series and optionally redraw the chart
	         *
	         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	         *    configuration
	         */
	        remove: function (redraw, animation) {
	            var series = this,
	                chart = series.chart;

	            // Fire the event with a default handler of removing the point
	            fireEvent(series, 'remove', null, function () {

	                // Destroy elements
	                series.destroy();

	                // Redraw
	                chart.isDirtyLegend = chart.isDirtyBox = true;
	                chart.linkSeries();

	                if (pick(redraw, true)) {
	                    chart.redraw(animation);
	                }
	            });
	        },

	        /**
	         * Update the series with a new set of options
	         */
	        update: function (newOptions, redraw) {
	            var series = this,
	                chart = this.chart,
	                // must use user options when changing type because this.options is merged
	                // in with type specific plotOptions
	                oldOptions = this.userOptions,
	                oldType = this.type,
	                proto = seriesTypes[oldType].prototype,
	                preserve = ['group', 'markerGroup', 'dataLabelsGroup'],
	                n;

	            // If we're changing type or zIndex, create new groups (#3380, #3404)
	            if ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {
	                preserve.length = 0;
	            }

	            // Make sure groups are not destroyed (#3094)
	            each(preserve, function (prop) {
	                preserve[prop] = series[prop];
	                delete series[prop];
	            });

	            // Do the merge, with some forced options
	            newOptions = merge(oldOptions, {
	                animation: false,
	                index: this.index,
	                pointStart: this.xData[0] // when updating after addPoint
	            }, { data: this.options.data }, newOptions);

	            // Destroy the series and delete all properties. Reinsert all methods
	            // and properties from the new type prototype (#2270, #3719)
	            this.remove(false);
	            for (n in proto) {
	                this[n] = UNDEFINED;
	            }
	            extend(this, seriesTypes[newOptions.type || oldType].prototype);

	            // Re-register groups (#3094)
	            each(preserve, function (prop) {
	                series[prop] = preserve[prop];
	            });

	            this.init(chart, newOptions);
	            chart.linkSeries(); // Links are lost in this.remove (#3028)
	            if (pick(redraw, true)) {
	                chart.redraw(false);
	            }
	        }
	    });

	    // Extend the Axis.prototype for dynamic methods
	    extend(Axis.prototype, {

	        /**
	         * Update the axis with a new options structure
	         */
	        update: function (newOptions, redraw) {
	            var chart = this.chart;

	            newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);

	            this.destroy(true);
	            this._addedPlotLB = this.chart._labelPanes = UNDEFINED; // #1611, #2887, #4314

	            this.init(chart, extend(newOptions, { events: UNDEFINED }));

	            chart.isDirtyBox = true;
	            if (pick(redraw, true)) {
	                chart.redraw();
	            }
	        },

	        /**
	         * Remove the axis from the chart
	         */
	        remove: function (redraw) {
	            var chart = this.chart,
	                key = this.coll, // xAxis or yAxis
	                axisSeries = this.series,
	                i = axisSeries.length;

	            // Remove associated series (#2687)
	            while (i--) {
	                if (axisSeries[i]) {
	                    axisSeries[i].remove(false);
	                }
	            }

	            // Remove the axis
	            erase(chart.axes, this);
	            erase(chart[key], this);
	            chart.options[key].splice(this.options.index, 1);
	            each(chart[key], function (axis, i) { // Re-index, #1706
	                axis.options.index = i;
	            });
	            this.destroy();
	            chart.isDirtyBox = true;

	            if (pick(redraw, true)) {
	                chart.redraw();
	            }
	        },

	        /**
	         * Update the axis title by options
	         */
	        setTitle: function (newTitleOptions, redraw) {
	            this.update({ title: newTitleOptions }, redraw);
	        },

	        /**
	         * Set new axis categories and optionally redraw
	         * @param {Array} categories
	         * @param {Boolean} redraw
	         */
	        setCategories: function (categories, redraw) {
	            this.update({ categories: categories }, redraw);
	        }

	    });


	    /**
	     * LineSeries object
	     */
	    var LineSeries = extendClass(Series);
	    seriesTypes.line = LineSeries;

	    /**
	     * Set the default options for area
	     */
	    defaultPlotOptions.area = merge(defaultSeriesOptions, {
	        softThreshold: false,
	        threshold: 0
	        // trackByArea: false,
	        // lineColor: null, // overrides color, but lets fillColor be unaltered
	        // fillOpacity: 0.75,
	        // fillColor: null
	    });

	    /**
	     * AreaSeries object
	     */
	    var AreaSeries = extendClass(Series, {
	        type: 'area',
	        singleStacks: false,
	        /** 
	         * Return an array of stacked points, where null and missing points are replaced by 
	         * dummy points in order for gaps to be drawn correctly in stacks.
	         */
	        getStackPoints: function () {
	            var series = this,
	                segment = [],
	                keys = [],
	                xAxis = this.xAxis,
	                yAxis = this.yAxis,
	                stack = yAxis.stacks[this.stackKey],
	                pointMap = {},
	                points = this.points,
	                seriesIndex = series.index,
	                yAxisSeries = yAxis.series,
	                seriesLength = yAxisSeries.length,
	                visibleSeries,
	                upOrDown = pick(yAxis.options.reversedStacks, true) ? 1 : -1,
	                i,
	                x;

	            if (this.options.stacking) {
	                // Create a map where we can quickly look up the points by their X value.
	                for (i = 0; i < points.length; i++) {
	                    pointMap[points[i].x] = points[i];
	                }

	                // Sort the keys (#1651)
	                for (x in stack) {
	                    if (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)
	                        keys.push(+x);
	                    }
	                }
	                keys.sort(function (a, b) {
	                    return a - b;
	                });

	                visibleSeries = map(yAxisSeries, function () {
	                    return this.visible;
	                });

	                each(keys, function (x, idx) {
	                    var y = 0,
	                        stackPoint,
	                        stackedValues;

	                    if (pointMap[x] && !pointMap[x].isNull) {
	                        segment.push(pointMap[x]);

	                        // Find left and right cliff. -1 goes left, 1 goes right.
	                        each([-1, 1], function (direction) {
	                            var nullName = direction === 1 ? 'rightNull' : 'leftNull',
	                                cliffName = direction === 1 ? 'rightCliff' : 'leftCliff',
	                                cliff = 0,
	                                otherStack = stack[keys[idx + direction]];

	                            // If there is a stack next to this one, to the left or to the right...
	                            if (otherStack) {
	                                i = seriesIndex;
	                                while (i >= 0 && i < seriesLength) { // Can go either up or down, depending on reversedStacks
	                                    stackPoint = otherStack.points[i];
	                                    if (!stackPoint) {
	                                        // If the next point in this series is missing, mark the point
	                                        // with point.leftNull or point.rightNull = true.
	                                        if (i === seriesIndex) {
	                                            pointMap[x][nullName] = true;

	                                        // If there are missing points in the next stack in any of the 
	                                        // series below this one, we need to substract the missing values
	                                        // and add a hiatus to the left or right.
	                                        } else if (visibleSeries[i]) {
	                                            stackedValues = stack[x].points[i];
	                                            if (stackedValues) {
	                                                cliff -= stackedValues[1] - stackedValues[0];
	                                            }
	                                        }
	                                    }
	                                    // When reversedStacks is true, loop up, else loop down
	                                    i += upOrDown; 
	                                }                
	                            }
	                            pointMap[x][cliffName] = cliff;
	                        });


	                    // There is no point for this X value in this series, so we 
	                    // insert a dummy point in order for the areas to be drawn
	                    // correctly.
	                    } else {

	                        // Loop down the stack to find the series below this one that has
	                        // a value (#1991)
	                        i = seriesIndex;
	                        while (i >= 0 && i < seriesLength) {
	                            stackPoint = stack[x].points[i];
	                            if (stackPoint) {
	                                y = stackPoint[1];
	                                break;
	                            }
	                            // When reversedStacks is true, loop up, else loop down
	                            i += upOrDown;
	                        }

	                        y = yAxis.toPixels(y, true);
	                        segment.push({ 
	                            isNull: true,
	                            plotX: xAxis.toPixels(x, true),
	                            plotY: y,
	                            yBottom: y
	                        });
	                    }
	                });

	            } 

	            return segment;
	        },

	        getGraphPath: function (points) {
	            var getGraphPath = Series.prototype.getGraphPath,
	                graphPath,
	                options = this.options,
	                stacking = options.stacking,
	                yAxis = this.yAxis,
	                topPath,
	                //topPoints = [],
	                bottomPath,
	                bottomPoints = [],
	                graphPoints = [],
	                seriesIndex = this.index,
	                i,
	                areaPath,
	                plotX,
	                stacks = yAxis.stacks[this.stackKey],
	                threshold = options.threshold,
	                translatedThreshold = yAxis.getThreshold(options.threshold),
	                isNull,
	                yBottom,
	                connectNulls = options.connectNulls || stacking === 'percent',
	                /**
	                 * To display null points in underlying stacked series, this series graph must be 
	                 * broken, and the area also fall down to fill the gap left by the null point. #2069
	                 */
	                addDummyPoints = function (i, otherI, side) {
	                    var point = points[i],
	                        stackedValues = stacking && stacks[point.x].points[seriesIndex],
	                        nullVal = point[side + 'Null'] || 0,
	                        cliffVal = point[side + 'Cliff'] || 0,
	                        top,
	                        bottom,
	                        isNull = true;

	                    if (cliffVal || nullVal) {

	                        top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;
	                        bottom = stackedValues[0] + cliffVal;
	                        isNull = !!nullVal;
	                
	                    } else if (!stacking && points[otherI] && points[otherI].isNull) {
	                        top = bottom = threshold;
	                    }

	                    // Add to the top and bottom line of the area
	                    if (top !== undefined) {
	                        graphPoints.push({
	                            plotX: plotX,
	                            plotY: top === null ? translatedThreshold : yAxis.toPixels(top, true),
	                            isNull: isNull
	                        });
	                        bottomPoints.push({
	                            plotX: plotX,
	                            plotY: bottom === null ? translatedThreshold : yAxis.toPixels(bottom, true)
	                        });
	                    }
	                };

	            // Find what points to use
	            points = points || this.points;

	        
	            // Fill in missing points
	            if (stacking) {
	                points = this.getStackPoints();
	            }

	            for (i = 0; i < points.length; i++) {
	                isNull = points[i].isNull;
	                plotX = pick(points[i].rectPlotX, points[i].plotX);
	                yBottom = pick(points[i].yBottom, translatedThreshold);

	                if (!isNull || connectNulls) {

	                    if (!connectNulls) {
	                        addDummyPoints(i, i - 1, 'left');
	                    }

	                    if (!(isNull && !stacking && connectNulls)) { // Skip null point when stacking is false and connectNulls true
	                        graphPoints.push(points[i]);
	                        bottomPoints.push({
	                            x: i,
	                            plotX: plotX,
	                            plotY: yBottom
	                        });
	                    }

	                    if (!connectNulls) {
	                        addDummyPoints(i, i + 1, 'right');
	                    }
	                }
	            }

	            topPath = getGraphPath.call(this, graphPoints, true, true);
	        
	            bottomPoints.reversed = true;
	            bottomPath = getGraphPath.call(this, bottomPoints, true, true);
	            if (bottomPath.length) {
	                bottomPath[0] = L;
	            }

	            areaPath = topPath.concat(bottomPath);
	            graphPath = getGraphPath.call(this, graphPoints, false, connectNulls); // TODO: don't set leftCliff and rightCliff when connectNulls?

	            this.areaPath = areaPath;
	            return graphPath;
	        },

	        /**
	         * Draw the graph and the underlying area. This method calls the Series base
	         * function and adds the area. The areaPath is calculated in the getSegmentPath
	         * method called from Series.prototype.drawGraph.
	         */
	        drawGraph: function () {

	            // Define or reset areaPath
	            this.areaPath = [];

	            // Call the base method
	            Series.prototype.drawGraph.apply(this);

	            // Define local variables
	            var series = this,
	                areaPath = this.areaPath,
	                options = this.options,
	                zones = this.zones,
	                props = [['area', this.color, options.fillColor]]; // area name, main color, fill color

	            each(zones, function (threshold, i) {
	                props.push(['zoneArea' + i, threshold.color || series.color, threshold.fillColor || options.fillColor]);
	            });
	            each(props, function (prop) {
	                var areaKey = prop[0],
	                    area = series[areaKey],
	                    attr;

	                // Create or update the area
	                if (area) { // update
	                    area.animate({ d: areaPath });

	                } else { // create
	                    attr = {
	                        fill: prop[2] || prop[1],
	                        zIndex: 0 // #1069
	                    };
	                    if (!prop[2]) {
	                        attr['fill-opacity'] = pick(options.fillOpacity, 0.75);
	                    }
	                    series[areaKey] = series.chart.renderer.path(areaPath)
	                        .attr(attr)
	                        .add(series.group);
	                }
	            });
	        },

	        drawLegendSymbol: LegendSymbolMixin.drawRectangle
	    });

	    seriesTypes.area = AreaSeries;
	    /**
	     * Set the default options for spline
	     */
	    defaultPlotOptions.spline = merge(defaultSeriesOptions);

	    /**
	     * SplineSeries object
	     */
	    var SplineSeries = extendClass(Series, {
	        type: 'spline',

	        /**
	         * Get the spline segment from a given point's previous neighbour to the given point
	         */
	        getPointSpline: function (points, point, i) {
	            var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
	                denom = smoothing + 1,
	                plotX = point.plotX,
	                plotY = point.plotY,
	                lastPoint = points[i - 1],
	                nextPoint = points[i + 1],
	                leftContX,
	                leftContY,
	                rightContX,
	                rightContY,
	                ret;

	            // Find control points
	            if (lastPoint && !lastPoint.isNull && nextPoint && !nextPoint.isNull) {
	                var lastX = lastPoint.plotX,
	                    lastY = lastPoint.plotY,
	                    nextX = nextPoint.plotX,
	                    nextY = nextPoint.plotY,
	                    correction = 0;

	                leftContX = (smoothing * plotX + lastX) / denom;
	                leftContY = (smoothing * plotY + lastY) / denom;
	                rightContX = (smoothing * plotX + nextX) / denom;
	                rightContY = (smoothing * plotY + nextY) / denom;

	                // Have the two control points make a straight line through main point
	                if (rightContX !== leftContX) { // #5016, division by zero
	                    correction = ((rightContY - leftContY) * (rightContX - plotX)) /
	                        (rightContX - leftContX) + plotY - rightContY;
	                }

	                leftContY += correction;
	                rightContY += correction;

	                // to prevent false extremes, check that control points are between
	                // neighbouring points' y values
	                if (leftContY > lastY && leftContY > plotY) {
	                    leftContY = mathMax(lastY, plotY);
	                    rightContY = 2 * plotY - leftContY; // mirror of left control point
	                } else if (leftContY < lastY && leftContY < plotY) {
	                    leftContY = mathMin(lastY, plotY);
	                    rightContY = 2 * plotY - leftContY;
	                }
	                if (rightContY > nextY && rightContY > plotY) {
	                    rightContY = mathMax(nextY, plotY);
	                    leftContY = 2 * plotY - rightContY;
	                } else if (rightContY < nextY && rightContY < plotY) {
	                    rightContY = mathMin(nextY, plotY);
	                    leftContY = 2 * plotY - rightContY;
	                }

	                // record for drawing in next point
	                point.rightContX = rightContX;
	                point.rightContY = rightContY;

	            
	            }

	            // Visualize control points for debugging
	            /*
	            if (leftContX) {
	                this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)
	                    .attr({
	                        stroke: 'red',
	                        'stroke-width': 1,
	                        fill: 'none'
	                    })
	                    .add();
	                this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,
	                    'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
	                    .attr({
	                        stroke: 'red',
	                        'stroke-width': 1
	                    })
	                    .add();
	                this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)
	                    .attr({
	                        stroke: 'green',
	                        'stroke-width': 1,
	                        fill: 'none'
	                    })
	                    .add();
	                this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,
	                    'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
	                    .attr({
	                        stroke: 'green',
	                        'stroke-width': 1
	                    })
	                    .add();
	            }
	            // */
	            ret = [
	                'C',
	                pick(lastPoint.rightContX, lastPoint.plotX),
	                pick(lastPoint.rightContY, lastPoint.plotY),
	                pick(leftContX, plotX),
	                pick(leftContY, plotY),
	                plotX,
	                plotY
	            ];
	            lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
	            return ret;
	        }
	    });
	    seriesTypes.spline = SplineSeries;

	    /**
	     * Set the default options for areaspline
	     */
	    defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);

	    /**
	     * AreaSplineSeries object
	     */
	    var areaProto = AreaSeries.prototype,
	        AreaSplineSeries = extendClass(SplineSeries, {
	            type: 'areaspline',
	            getStackPoints: areaProto.getStackPoints,
	            getGraphPath: areaProto.getGraphPath,
	            setStackCliffs: areaProto.setStackCliffs,
	            drawGraph: areaProto.drawGraph,
	            drawLegendSymbol: LegendSymbolMixin.drawRectangle
	        });

	    seriesTypes.areaspline = AreaSplineSeries;

	    /**
	     * Set the default options for column
	     */
	    defaultPlotOptions.column = merge(defaultSeriesOptions, {
	        borderColor: '#FFFFFF',
	        //borderWidth: 1,
	        borderRadius: 0,
	        //colorByPoint: undefined,
	        groupPadding: 0.2,
	        //grouping: true,
	        marker: null, // point options are specified in the base options
	        pointPadding: 0.1,
	        //pointWidth: null,
	        minPointLength: 0,
	        cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes
	        pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories
	        states: {
	            hover: {
	                brightness: 0.1,
	                shadow: false,
	                halo: false
	            },
	            select: {
	                color: '#C0C0C0',
	                borderColor: '#000000',
	                shadow: false
	            }
	        },
	        dataLabels: {
	            align: null, // auto
	            verticalAlign: null, // auto
	            y: null
	        },
	        softThreshold: false,
	        startFromThreshold: true, // false doesn't work well: http://jsfiddle.net/highcharts/hz8fopan/14/
	        stickyTracking: false,
	        tooltip: {
	            distance: 6
	        },
	        threshold: 0
	    });

	    /**
	     * ColumnSeries object
	     */
	    var ColumnSeries = extendClass(Series, {
	        type: 'column',
	        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
	            stroke: 'borderColor',
	            fill: 'color',
	            r: 'borderRadius'
	        },
	        cropShoulder: 0,
	        directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.
	        trackerGroups: ['group', 'dataLabelsGroup'],
	        negStacks: true, // use separate negative stacks, unlike area stacks where a negative
	            // point is substracted from previous (#1910)

	        /**
	         * Initialize the series
	         */
	        init: function () {
	            Series.prototype.init.apply(this, arguments);

	            var series = this,
	                chart = series.chart;

	            // if the series is added dynamically, force redraw of other
	            // series affected by a new column
	            if (chart.hasRendered) {
	                each(chart.series, function (otherSeries) {
	                    if (otherSeries.type === series.type) {
	                        otherSeries.isDirty = true;
	                    }
	                });
	            }
	        },

	        /**
	         * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,
	         * pointWidth etc.
	         */
	        getColumnMetrics: function () {

	            var series = this,
	                options = series.options,
	                xAxis = series.xAxis,
	                yAxis = series.yAxis,
	                reversedXAxis = xAxis.reversed,
	                stackKey,
	                stackGroups = {},
	                columnCount = 0;

	            // Get the total number of column type series.
	            // This is called on every series. Consider moving this logic to a
	            // chart.orderStacks() function and call it on init, addSeries and removeSeries
	            if (options.grouping === false) {
	                columnCount = 1;
	            } else {
	                each(series.chart.series, function (otherSeries) {
	                    var otherOptions = otherSeries.options,
	                        otherYAxis = otherSeries.yAxis,
	                        columnIndex;
	                    if (otherSeries.type === series.type && otherSeries.visible &&
	                            yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086
	                        if (otherOptions.stacking) {
	                            stackKey = otherSeries.stackKey;
	                            if (stackGroups[stackKey] === UNDEFINED) {
	                                stackGroups[stackKey] = columnCount++;
	                            }
	                            columnIndex = stackGroups[stackKey];
	                        } else if (otherOptions.grouping !== false) { // #1162
	                            columnIndex = columnCount++;
	                        }
	                        otherSeries.columnIndex = columnIndex;
	                    }
	                });
	            }

	            var categoryWidth = mathMin(
	                    mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610
	                    xAxis.len // #1535
	                ),
	                groupPadding = categoryWidth * options.groupPadding,
	                groupWidth = categoryWidth - 2 * groupPadding,
	                pointOffsetWidth = groupWidth / columnCount,
	                pointWidth = mathMin(
	                    options.maxPointWidth || xAxis.len,
	                    pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))
	                ),
	                pointPadding = (pointOffsetWidth - pointWidth) / 2,
	                colIndex = (series.columnIndex || 0) + (reversedXAxis ? 1 : 0), // #1251, #3737
	                pointXOffset = pointPadding + (groupPadding + colIndex *
	                    pointOffsetWidth - (categoryWidth / 2)) *
	                    (reversedXAxis ? -1 : 1);

	            // Save it for reading in linked series (Error bars particularly)
	            series.columnMetrics = {
	                width: pointWidth,
	                offset: pointXOffset
	            };
	            return series.columnMetrics;

	        },

	        /**
	         * Make the columns crisp. The edges are rounded to the nearest full pixel.
	         */
	        crispCol: function (x, y, w, h) {
	            var chart = this.chart,
	                borderWidth = this.borderWidth,
	                xCrisp = -(borderWidth % 2 ? 0.5 : 0),
	                yCrisp = borderWidth % 2 ? 0.5 : 1,
	                right,
	                bottom,
	                fromTop;

	            if (chart.inverted && chart.renderer.isVML) {
	                yCrisp += 1;
	            }

	            // Horizontal. We need to first compute the exact right edge, then round it
	            // and compute the width from there.
	            right = Math.round(x + w) + xCrisp;
	            x = Math.round(x) + xCrisp;
	            w = right - x;

	            // Vertical
	            bottom = Math.round(y + h) + yCrisp;
	            fromTop = mathAbs(y) <= 0.5 && bottom > 0.5; // #4504, #4656
	            y = Math.round(y) + yCrisp;
	            h = bottom - y;

	            // Top edges are exceptions
	            if (fromTop) {
	                y -= 1;
	                h += 1;
	            }

	            return {
	                x: x,
	                y: y,
	                width: w,
	                height: h
	            };
	        },

	        /**
	         * Translate each point to the plot area coordinate system and find shape positions
	         */
	        translate: function () {
	            var series = this,
	                chart = series.chart,
	                options = series.options,
	                borderWidth = series.borderWidth = pick(
	                    options.borderWidth,
	                    series.closestPointRange * series.xAxis.transA < 2 ? 0 : 1 // #3635
	                ),
	                yAxis = series.yAxis,
	                threshold = options.threshold,
	                translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
	                minPointLength = pick(options.minPointLength, 5),
	                metrics = series.getColumnMetrics(),
	                pointWidth = metrics.width,
	                seriesBarW = series.barW = mathMax(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width
	                pointXOffset = series.pointXOffset = metrics.offset;

	            if (chart.inverted) {
	                translatedThreshold -= 0.5; // #3355
	            }

	            // When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual
	            // columns to have individual sizes. When pointPadding is greater, we strive for equal-width
	            // columns (#2694).
	            if (options.pointPadding) {
	                seriesBarW = mathCeil(seriesBarW);
	            }

	            Series.prototype.translate.apply(series);

	            // Record the new values
	            each(series.points, function (point) {
	                var yBottom = mathMin(pick(point.yBottom, translatedThreshold), 9e4), // #3575
	                    safeDistance = 999 + mathAbs(yBottom),
	                    plotY = mathMin(mathMax(-safeDistance, point.plotY), yAxis.len + safeDistance), // Don't draw too far outside plot area (#1303, #2241, #4264)
	                    barX = point.plotX + pointXOffset,
	                    barW = seriesBarW,
	                    barY = mathMin(plotY, yBottom),
	                    up,
	                    barH = mathMax(plotY, yBottom) - barY;

	                // Handle options.minPointLength
	                if (mathAbs(barH) < minPointLength) {
	                    if (minPointLength) {
	                        barH = minPointLength;
	                        up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);
	                        barY = mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
	                                yBottom - minPointLength : // keep position
	                                translatedThreshold - (up ? minPointLength : 0); // #1485, #4051
	                    }
	                }

	                // Cache for access in polar
	                point.barX = barX;
	                point.pointWidth = pointWidth;

	                // Fix the tooltip on center of grouped columns (#1216, #424, #3648)
	                point.tooltipPos = chart.inverted ?
	                    [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] :
	                    [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];

	                // Register shape type and arguments to be used in drawPoints
	                point.shapeType = 'rect';
	                point.shapeArgs = series.crispCol(barX, barY, barW, barH);
	            });

	        },

	        getSymbol: noop,

	        /**
	         * Use a solid rectangle like the area series types
	         */
	        drawLegendSymbol: LegendSymbolMixin.drawRectangle,


	        /**
	         * Columns have no graph
	         */
	        drawGraph: noop,

	        /**
	         * Draw the columns. For bars, the series.group is rotated, so the same coordinates
	         * apply for columns and bars. This method is inherited by scatter series.
	         *
	         */
	        drawPoints: function () {
	            var series = this,
	                chart = this.chart,
	                options = series.options,
	                renderer = chart.renderer,
	                animationLimit = options.animationLimit || 250,
	                shapeArgs,
	                pointAttr;

	            // draw the columns
	            each(series.points, function (point) {
	                var plotY = point.plotY,
	                    graphic = point.graphic,
	                    borderAttr;

	                if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
	                    shapeArgs = point.shapeArgs;

	                    borderAttr = defined(series.borderWidth) ? {
	                        'stroke-width': series.borderWidth
	                    } : {};

	                    pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || series.pointAttr[NORMAL_STATE];

	                    if (graphic) { // update
	                        stop(graphic);
	                        graphic.attr(borderAttr).attr(pointAttr)[chart.pointCount < animationLimit ? 'animate' : 'attr'](merge(shapeArgs)); // #4267

	                    } else {
	                        point.graphic = graphic = renderer[point.shapeType](shapeArgs)
	                            .attr(borderAttr)
	                            .attr(pointAttr)
	                            .add(point.group || series.group)
	                            .shadow(options.shadow, null, options.stacking && !options.borderRadius);
	                    }

	                } else if (graphic) {
	                    point.graphic = graphic.destroy(); // #1269
	                }
	            });
	        },

	        /**
	         * Animate the column heights one by one from zero
	         * @param {Boolean} init Whether to initialize the animation or run it
	         */
	        animate: function (init) {
	            var series = this,
	                yAxis = this.yAxis,
	                options = series.options,
	                inverted = this.chart.inverted,
	                attr = {},
	                translatedThreshold;

	            if (hasSVG) { // VML is too slow anyway
	                if (init) {
	                    attr.scaleY = 0.001;
	                    translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));
	                    if (inverted) {
	                        attr.translateX = translatedThreshold - yAxis.len;
	                    } else {
	                        attr.translateY = translatedThreshold;
	                    }
	                    series.group.attr(attr);

	                } else { // run the animation

	                    attr.scaleY = 1;
	                    attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;
	                    series.group.animate(attr, series.options.animation);

	                    // delete this function to allow it only once
	                    series.animate = null;
	                }
	            }
	        },

	        /**
	         * Remove this series from the chart
	         */
	        remove: function () {
	            var series = this,
	                chart = series.chart;

	            // column and bar series affects other series of the same type
	            // as they are either stacked or grouped
	            if (chart.hasRendered) {
	                each(chart.series, function (otherSeries) {
	                    if (otherSeries.type === series.type) {
	                        otherSeries.isDirty = true;
	                    }
	                });
	            }

	            Series.prototype.remove.apply(series, arguments);
	        }
	    });
	    seriesTypes.column = ColumnSeries;
	    /**
	     * Set the default options for bar
	     */
	    defaultPlotOptions.bar = merge(defaultPlotOptions.column);
	    /**
	     * The Bar series class
	     */
	    var BarSeries = extendClass(ColumnSeries, {
	        type: 'bar',
	        inverted: true
	    });
	    seriesTypes.bar = BarSeries;

	    /**
	     * Set the default options for scatter
	     */
	    defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
	        lineWidth: 0,
	        marker: {
	            enabled: true // Overrides auto-enabling in line series (#3647)
	        },
	        tooltip: {
	            headerFormat: '<span style="color:{point.color}">\u25CF</span> <span style="font-size: 10px;"> {series.name}</span><br/>',
	            pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
	        }
	    });

	    /**
	     * The scatter series class
	     */
	    var ScatterSeries = extendClass(Series, {
	        type: 'scatter',
	        sorted: false,
	        requireSorting: false,
	        noSharedTooltip: true,
	        trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
	        takeOrdinalPosition: false, // #2342
	        kdDimensions: 2,
	        drawGraph: function () {
	            if (this.options.lineWidth) {
	                Series.prototype.drawGraph.call(this);
	            }
	        }
	    });

	    seriesTypes.scatter = ScatterSeries;

	    /**
	     * Set the default options for pie
	     */
	    defaultPlotOptions.pie = merge(defaultSeriesOptions, {
	        borderColor: '#FFFFFF',
	        borderWidth: 1,
	        center: [null, null],
	        clip: false,
	        colorByPoint: true, // always true for pies
	        dataLabels: {
	            // align: null,
	            // connectorWidth: 1,
	            // connectorColor: point.color,
	            // connectorPadding: 5,
	            distance: 30,
	            enabled: true,
	            formatter: function () { // #2945
	                return this.y === null ? undefined : this.point.name;
	            },
	            // softConnector: true,
	            x: 0
	            // y: 0
	        },
	        ignoreHiddenPoint: true,
	        //innerSize: 0,
	        legendType: 'point',
	        marker: null, // point options are specified in the base options
	        size: null,
	        showInLegend: false,
	        slicedOffset: 10,
	        states: {
	            hover: {
	                brightness: 0.1,
	                shadow: false
	            }
	        },
	        stickyTracking: false,
	        tooltip: {
	            followPointer: true
	        }
	    });

	    /**
	     * Extended point object for pies
	     */
	    var PiePoint = extendClass(Point, {
	        /**
	         * Initiate the pie slice
	         */
	        init: function () {

	            Point.prototype.init.apply(this, arguments);

	            var point = this,
	                toggleSlice;

	            point.name = pick(point.name, 'Slice');

	            // add event listener for select
	            toggleSlice = function (e) {
	                point.slice(e.type === 'select');
	            };
	            addEvent(point, 'select', toggleSlice);
	            addEvent(point, 'unselect', toggleSlice);

	            return point;
	        },

	        /**
	         * Toggle the visibility of the pie slice
	         * @param {Boolean} vis Whether to show the slice or not. If undefined, the
	         *    visibility is toggled
	         */
	        setVisible: function (vis, redraw) {
	            var point = this,
	                series = point.series,
	                chart = series.chart,
	                ignoreHiddenPoint = series.options.ignoreHiddenPoint;

	            redraw = pick(redraw, ignoreHiddenPoint);

	            if (vis !== point.visible) {

	                // If called without an argument, toggle visibility
	                point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;
	                series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

	                // Show and hide associated elements. This is performed regardless of redraw or not,
	                // because chart.redraw only handles full series.
	                each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {
	                    if (point[key]) {
	                        point[key][vis ? 'show' : 'hide'](true);
	                    }
	                });

	                if (point.legendItem) {
	                    chart.legend.colorizeItem(point, vis);
	                }

	                // #4170, hide halo after hiding point
	                if (!vis && point.state === 'hover') {
	                    point.setState('');
	                }

	                // Handle ignore hidden slices
	                if (ignoreHiddenPoint) {
	                    series.isDirty = true;
	                }

	                if (redraw) {
	                    chart.redraw();
	                }
	            }
	        },

	        /**
	         * Set or toggle whether the slice is cut out from the pie
	         * @param {Boolean} sliced When undefined, the slice state is toggled
	         * @param {Boolean} redraw Whether to redraw the chart. True by default.
	         */
	        slice: function (sliced, redraw, animation) {
	            var point = this,
	                series = point.series,
	                chart = series.chart,
	                translation;

	            setAnimation(animation, chart);

	            // redraw is true by default
	            redraw = pick(redraw, true);

	            // if called without an argument, toggle
	            point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
	            series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

	            translation = sliced ? point.slicedTranslation : {
	                translateX: 0,
	                translateY: 0
	            };

	            point.graphic.animate(translation);

	            if (point.shadowGroup) {
	                point.shadowGroup.animate(translation);
	            }

	        },

	        haloPath: function (size) {
	            var shapeArgs = this.shapeArgs,
	                chart = this.series.chart;

	            return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
	                innerR: this.shapeArgs.r,
	                start: shapeArgs.start,
	                end: shapeArgs.end
	            });
	        }
	    });

	    /**
	     * The Pie series class
	     */
	    var PieSeries = {
	        type: 'pie',
	        isCartesian: false,
	        pointClass: PiePoint,
	        requireSorting: false,
	        directTouch: true,
	        noSharedTooltip: true,
	        trackerGroups: ['group', 'dataLabelsGroup'],
	        axisTypes: [],
	        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
	            stroke: 'borderColor',
	            'stroke-width': 'borderWidth',
	            fill: 'color'
	        },

	        /**
	         * Animate the pies in
	         */
	        animate: function (init) {
	            var series = this,
	                points = series.points,
	                startAngleRad = series.startAngleRad;

	            if (!init) {
	                each(points, function (point) {
	                    var graphic = point.graphic,
	                        args = point.shapeArgs;

	                    if (graphic) {
	                        // start values
	                        graphic.attr({
	                            r: point.startR || (series.center[3] / 2), // animate from inner radius (#779)
	                            start: startAngleRad,
	                            end: startAngleRad
	                        });

	                        // animate
	                        graphic.animate({
	                            r: args.r,
	                            start: args.start,
	                            end: args.end
	                        }, series.options.animation);
	                    }
	                });

	                // delete this function to allow it only once
	                series.animate = null;
	            }
	        },

	        /**
	         * Recompute total chart sum and update percentages of points.
	         */
	        updateTotals: function () {
	            var i,
	                total = 0,
	                points = this.points,
	                len = points.length,
	                point,
	                ignoreHiddenPoint = this.options.ignoreHiddenPoint;

	            // Get the total sum
	            for (i = 0; i < len; i++) {
	                point = points[i];
	                total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;
	            }
	            this.total = total;

	            // Set each point's properties
	            for (i = 0; i < len; i++) {
	                point = points[i];
	                point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;
	                point.total = total;
	            }
	        },

	        /**
	         * Extend the generatePoints method by adding total and percentage properties to each point
	         */
	        generatePoints: function () {
	            Series.prototype.generatePoints.call(this);
	            this.updateTotals();
	        },

	        /**
	         * Do translation for pie slices
	         */
	        translate: function (positions) {
	            this.generatePoints();

	            var series = this,
	                cumulative = 0,
	                precision = 1000, // issue #172
	                options = series.options,
	                slicedOffset = options.slicedOffset,
	                connectorOffset = slicedOffset + options.borderWidth,
	                start,
	                end,
	                angle,
	                startAngle = options.startAngle || 0,
	                startAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),
	                endAngleRad = series.endAngleRad = mathPI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),
	                circ = endAngleRad - startAngleRad, //2 * mathPI,
	                points = series.points,
	                radiusX, // the x component of the radius vector for a given point
	                radiusY,
	                labelDistance = options.dataLabels.distance,
	                ignoreHiddenPoint = options.ignoreHiddenPoint,
	                i,
	                len = points.length,
	                point;

	            // Get positions - either an integer or a percentage string must be given.
	            // If positions are passed as a parameter, we're in a recursive loop for adjusting
	            // space for data labels.
	            if (!positions) {
	                series.center = positions = series.getCenter();
	            }

	            // utility for getting the x value from a given y, used for anticollision logic in data labels
	            series.getX = function (y, left) {

	                angle = math.asin(mathMin((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));

	                return positions[0] +
	                    (left ? -1 : 1) *
	                    (mathCos(angle) * (positions[2] / 2 + labelDistance));
	            };

	            // Calculate the geometry for each point
	            for (i = 0; i < len; i++) {

	                point = points[i];

	                // set start and end angle
	                start = startAngleRad + (cumulative * circ);
	                if (!ignoreHiddenPoint || point.visible) {
	                    cumulative += point.percentage / 100;
	                }
	                end = startAngleRad + (cumulative * circ);

	                // set the shape
	                point.shapeType = 'arc';
	                point.shapeArgs = {
	                    x: positions[0],
	                    y: positions[1],
	                    r: positions[2] / 2,
	                    innerR: positions[3] / 2,
	                    start: mathRound(start * precision) / precision,
	                    end: mathRound(end * precision) / precision
	                };

	                // The angle must stay within -90 and 270 (#2645)
	                angle = (end + start) / 2;
	                if (angle > 1.5 * mathPI) {
	                    angle -= 2 * mathPI;
	                } else if (angle < -mathPI / 2) {
	                    angle += 2 * mathPI;
	                }

	                // Center for the sliced out slice
	                point.slicedTranslation = {
	                    translateX: mathRound(mathCos(angle) * slicedOffset),
	                    translateY: mathRound(mathSin(angle) * slicedOffset)
	                };

	                // set the anchor point for tooltips
	                radiusX = mathCos(angle) * positions[2] / 2;
	                radiusY = mathSin(angle) * positions[2] / 2;
	                point.tooltipPos = [
	                    positions[0] + radiusX * 0.7,
	                    positions[1] + radiusY * 0.7
	                ];

	                point.half = angle < -mathPI / 2 || angle > mathPI / 2 ? 1 : 0;
	                point.angle = angle;

	                // set the anchor point for data labels
	                connectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678
	                point.labelPos = [
	                    positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
	                    positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
	                    positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
	                    positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
	                    positions[0] + radiusX, // landing point for connector
	                    positions[1] + radiusY, // a/a
	                    labelDistance < 0 ? // alignment
	                        'center' :
	                        point.half ? 'right' : 'left', // alignment
	                    angle // center angle
	                ];

	            }
	        },

	        drawGraph: null,

	        /**
	         * Draw the data points
	         */
	        drawPoints: function () {
	            var series = this,
	                chart = series.chart,
	                renderer = chart.renderer,
	                groupTranslation,
	                //center,
	                graphic,
	                //group,
	                shadow = series.options.shadow,
	                shadowGroup,
	                pointAttr,
	                shapeArgs,
	                attr;

	            if (shadow && !series.shadowGroup) {
	                series.shadowGroup = renderer.g('shadow')
	                    .add(series.group);
	            }

	            // draw the slices
	            each(series.points, function (point) {
	                if (point.y !== null) {
	                    graphic = point.graphic;
	                    shapeArgs = point.shapeArgs;
	                    shadowGroup = point.shadowGroup;
	                    pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
	                    if (!pointAttr.stroke) {
	                        pointAttr.stroke = pointAttr.fill;
	                    }

	                    // put the shadow behind all points
	                    if (shadow && !shadowGroup) {
	                        shadowGroup = point.shadowGroup = renderer.g('shadow')
	                            .add(series.shadowGroup);
	                    }

	                    // if the point is sliced, use special translation, else use plot area traslation
	                    groupTranslation = point.sliced ? point.slicedTranslation : {
	                        translateX: 0,
	                        translateY: 0
	                    };

	                    //group.translate(groupTranslation[0], groupTranslation[1]);
	                    if (shadowGroup) {
	                        shadowGroup.attr(groupTranslation);
	                    }

	                    // draw the slice
	                    if (graphic) {
	                        graphic
	                            .setRadialReference(series.center)
	                            .attr(pointAttr)
	                            .animate(extend(shapeArgs, groupTranslation));
	                    } else {
	                        attr = { 'stroke-linejoin': 'round' };
	                        if (!point.visible) {
	                            attr.visibility = 'hidden';
	                        }

	                        point.graphic = graphic = renderer[point.shapeType](shapeArgs)
	                            .setRadialReference(series.center)
	                            .attr(pointAttr)
	                            .attr(attr)
	                            .attr(groupTranslation)
	                            .add(series.group)
	                            .shadow(shadow, shadowGroup);
	                    }
	                }
	            });

	        },


	        searchPoint: noop,

	        /**
	         * Utility for sorting data labels
	         */
	        sortByAngle: function (points, sign) {
	            points.sort(function (a, b) {
	                return a.angle !== undefined && (b.angle - a.angle) * sign;
	            });
	        },

	        /**
	         * Use a simple symbol from LegendSymbolMixin
	         */
	        drawLegendSymbol: LegendSymbolMixin.drawRectangle,

	        /**
	         * Use the getCenter method from drawLegendSymbol
	         */
	        getCenter: CenteredSeriesMixin.getCenter,

	        /**
	         * Pies don't have point marker symbols
	         */
	        getSymbol: noop

	    };
	    PieSeries = extendClass(Series, PieSeries);
	    seriesTypes.pie = PieSeries;

	    /**
	     * Draw the data labels
	     */
	    Series.prototype.drawDataLabels = function () {

	        var series = this,
	            seriesOptions = series.options,
	            cursor = seriesOptions.cursor,
	            options = seriesOptions.dataLabels,
	            points = series.points,
	            pointOptions,
	            generalOptions,
	            hasRendered = series.hasRendered || 0,
	            str,
	            dataLabelsGroup,
	            renderer = series.chart.renderer;

	        if (options.enabled || series._hasPointLabels) {

	            // Process default alignment of data labels for columns
	            if (series.dlProcessOptions) {
	                series.dlProcessOptions(options);
	            }

	            // Create a separate group for the data labels to avoid rotation
	            dataLabelsGroup = series.plotGroup(
	                'dataLabelsGroup',
	                'data-labels',
	                options.defer ? HIDDEN : VISIBLE,
	                options.zIndex || 6
	            );

	            if (pick(options.defer, true)) {
	                dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300
	                if (!hasRendered) {
	                    addEvent(series, 'afterAnimate', function () {
	                        if (series.visible) { // #3023, #3024
	                            dataLabelsGroup.show();
	                        }
	                        dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });
	                    });
	                }
	            }

	            // Make the labels for each point
	            generalOptions = options;
	            each(points, function (point) {

	                var enabled,
	                    dataLabel = point.dataLabel,
	                    labelConfig,
	                    attr,
	                    name,
	                    rotation,
	                    connector = point.connector,
	                    isNew = true,
	                    style,
	                    moreStyle = {};

	                // Determine if each data label is enabled
	                pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps
	                enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled) && point.y !== null; // #2282, #4641


	                // If the point is outside the plot area, destroy it. #678, #820
	                if (dataLabel && !enabled) {
	                    point.dataLabel = dataLabel.destroy();

	                // Individual labels are disabled if the are explicitly disabled
	                // in the point options, or if they fall outside the plot area.
	                } else if (enabled) {

	                    // Create individual options structure that can be extended without
	                    // affecting others
	                    options = merge(generalOptions, pointOptions);
	                    style = options.style;

	                    rotation = options.rotation;

	                    // Get the string
	                    labelConfig = point.getLabelConfig();
	                    str = options.format ?
	                        format(options.format, labelConfig) :
	                        options.formatter.call(labelConfig, options);

	                    // Determine the color
	                    style.color = pick(options.color, style.color, series.color, 'black');


	                    // update existing label
	                    if (dataLabel) {

	                        if (defined(str)) {
	                            dataLabel
	                                .attr({
	                                    text: str
	                                });
	                            isNew = false;

	                        } else { // #1437 - the label is shown conditionally
	                            point.dataLabel = dataLabel = dataLabel.destroy();
	                            if (connector) {
	                                point.connector = connector.destroy();
	                            }
	                        }

	                    // create new label
	                    } else if (defined(str)) {
	                        attr = {
	                            //align: align,
	                            fill: options.backgroundColor,
	                            stroke: options.borderColor,
	                            'stroke-width': options.borderWidth,
	                            r: options.borderRadius || 0,
	                            rotation: rotation,
	                            padding: options.padding,
	                            zIndex: 1
	                        };

	                        // Get automated contrast color
	                        if (style.color === 'contrast') {
	                            moreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ?
	                                renderer.getContrast(point.color || series.color) :
	                                '#000000';
	                        }
	                        if (cursor) {
	                            moreStyle.cursor = cursor;
	                        }


	                        // Remove unused attributes (#947)
	                        for (name in attr) {
	                            if (attr[name] === UNDEFINED) {
	                                delete attr[name];
	                            }
	                        }

	                        dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation
	                            str,
	                            0,
	                            -9999,
	                            options.shape,
	                            null,
	                            null,
	                            options.useHTML
	                        )
	                        .attr(attr)
	                        .css(extend(style, moreStyle))
	                        .add(dataLabelsGroup)
	                        .shadow(options.shadow);

	                    }

	                    if (dataLabel) {
	                        // Now the data label is created and placed at 0,0, so we need to align it
	                        series.alignDataLabel(point, dataLabel, options, null, isNew);
	                    }
	                }
	            });
	        }
	    };

	    /**
	     * Align each individual data label
	     */
	    Series.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {
	        var chart = this.chart,
	            inverted = chart.inverted,
	            plotX = pick(point.plotX, -9999),
	            plotY = pick(point.plotY, -9999),
	            bBox = dataLabel.getBBox(),
	            baseline = chart.renderer.fontMetrics(options.style.fontSize).b,
	            rotation = options.rotation,
	            normRotation,
	            negRotation,
	            align = options.align,
	            rotCorr, // rotation correction
	            // Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)
	            visible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, mathRound(plotY), inverted) ||
	                (alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),
	            alignAttr, // the final position;
	            justify = pick(options.overflow, 'justify') === 'justify';

	        if (visible) {

	            // The alignment box is a singular point
	            alignTo = extend({
	                x: inverted ? chart.plotWidth - plotY : plotX,
	                y: mathRound(inverted ? chart.plotHeight - plotX : plotY),
	                width: 0,
	                height: 0
	            }, alignTo);

	            // Add the text size for alignment calculation
	            extend(options, {
	                width: bBox.width,
	                height: bBox.height
	            });

	            // Allow a hook for changing alignment in the last moment, then do the alignment
	            if (rotation) {
	                justify = false; // Not supported for rotated text
	                rotCorr = chart.renderer.rotCorr(baseline, rotation); // #3723
	                alignAttr = {
	                    x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,
	                    y: alignTo.y + options.y + alignTo.height / 2
	                };
	                dataLabel
	                    [isNew ? 'attr' : 'animate'](alignAttr)
	                    .attr({ // #3003
	                        align: options.align
	                    });

	                // Compensate for the rotated label sticking out on the sides
	                normRotation = (rotation + 720) % 360;
	                negRotation = normRotation > 180 && normRotation < 360;

	                if (align === 'left') {
	                    alignAttr.y -= negRotation ? bBox.height : 0;
	                } else if (align === 'center') {
	                    alignAttr.x -= bBox.width / 2;
	                    alignAttr.y -= bBox.height / 2;
	                } else if (align === 'right') {
	                    alignAttr.x -= bBox.width;
	                    alignAttr.y -= negRotation ? 0 : bBox.height;
	                }
	            

	            } else {
	                dataLabel.align(options, null, alignTo);
	                alignAttr = dataLabel.alignAttr;
	            }

	            // Handle justify or crop
	            if (justify) {
	                this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);
	            
	            // Now check that the data label is within the plot area
	            } else if (pick(options.crop, true)) {
	                visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);
	            }

	            // When we're using a shape, make it possible with a connector or an arrow pointing to thie point
	            if (options.shape && !rotation) {
	                dataLabel.attr({
	                    anchorX: point.plotX,
	                    anchorY: point.plotY
	                });
	            }
	        }

	        // Show or hide based on the final aligned position
	        if (!visible) {
	            stop(dataLabel);
	            dataLabel.attr({ y: -9999 });
	            dataLabel.placed = false; // don't animate back in
	        }

	    };

	    /**
	     * If data labels fall partly outside the plot area, align them back in, in a way that
	     * doesn't hide the point.
	     */
	    Series.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {
	        var chart = this.chart,
	            align = options.align,
	            verticalAlign = options.verticalAlign,
	            off,
	            justified,
	            padding = dataLabel.box ? 0 : (dataLabel.padding || 0);

	        // Off left
	        off = alignAttr.x + padding;
	        if (off < 0) {
	            if (align === 'right') {
	                options.align = 'left';
	            } else {
	                options.x = -off;
	            }
	            justified = true;
	        }

	        // Off right
	        off = alignAttr.x + bBox.width - padding;
	        if (off > chart.plotWidth) {
	            if (align === 'left') {
	                options.align = 'right';
	            } else {
	                options.x = chart.plotWidth - off;
	            }
	            justified = true;
	        }

	        // Off top
	        off = alignAttr.y + padding;
	        if (off < 0) {
	            if (verticalAlign === 'bottom') {
	                options.verticalAlign = 'top';
	            } else {
	                options.y = -off;
	            }
	            justified = true;
	        }

	        // Off bottom
	        off = alignAttr.y + bBox.height - padding;
	        if (off > chart.plotHeight) {
	            if (verticalAlign === 'top') {
	                options.verticalAlign = 'bottom';
	            } else {
	                options.y = chart.plotHeight - off;
	            }
	            justified = true;
	        }

	        if (justified) {
	            dataLabel.placed = !isNew;
	            dataLabel.align(options, null, alignTo);
	        }
	    };

	    /**
	     * Override the base drawDataLabels method by pie specific functionality
	     */
	    if (seriesTypes.pie) {
	        seriesTypes.pie.prototype.drawDataLabels = function () {
	            var series = this,
	                data = series.data,
	                point,
	                chart = series.chart,
	                options = series.options.dataLabels,
	                connectorPadding = pick(options.connectorPadding, 10),
	                connectorWidth = pick(options.connectorWidth, 1),
	                plotWidth = chart.plotWidth,
	                plotHeight = chart.plotHeight,
	                connector,
	                connectorPath,
	                softConnector = pick(options.softConnector, true),
	                distanceOption = options.distance,
	                seriesCenter = series.center,
	                radius = seriesCenter[2] / 2,
	                centerY = seriesCenter[1],
	                outside = distanceOption > 0,
	                dataLabel,
	                dataLabelWidth,
	                labelPos,
	                labelHeight,
	                halves = [// divide the points into right and left halves for anti collision
	                    [], // right
	                    []  // left
	                ],
	                x,
	                y,
	                visibility,
	                rankArr,
	                i,
	                j,
	                overflow = [0, 0, 0, 0], // top, right, bottom, left
	                sort = function (a, b) {
	                    return b.y - a.y;
	                };

	            // get out if not enabled
	            if (!series.visible || (!options.enabled && !series._hasPointLabels)) {
	                return;
	            }

	            // run parent method
	            Series.prototype.drawDataLabels.apply(series);

	            each(data, function (point) {
	                if (point.dataLabel && point.visible) { // #407, #2510

	                    // Arrange points for detection collision
	                    halves[point.half].push(point);

	                    // Reset positions (#4905)
	                    point.dataLabel._pos = null;
	                }
	            });

	            /* Loop over the points in each half, starting from the top and bottom
	             * of the pie to detect overlapping labels.
	             */
	            i = 2;
	            while (i--) {

	                var slots = [],
	                    slotsLength,
	                    usedSlots = [],
	                    points = halves[i],
	                    pos,
	                    bottom,
	                    length = points.length,
	                    slotIndex;

	                if (!length) {
	                    continue;
	                }

	                // Sort by angle
	                series.sortByAngle(points, i - 0.5);

	                // Assume equal label heights on either hemisphere (#2630)
	                j = labelHeight = 0;
	                while (!labelHeight && points[j]) { // #1569
	                    labelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968
	                    j++;
	                }

	                // Only do anti-collision when we are outside the pie and have connectors (#856)
	                if (distanceOption > 0) {

	                    // Build the slots
	                    bottom = mathMin(centerY + radius + distanceOption, chart.plotHeight);
	                    for (pos = mathMax(0, centerY - radius - distanceOption); pos <= bottom; pos += labelHeight) {
	                        slots.push(pos);
	                    }
	                    slotsLength = slots.length;


	                    /* Visualize the slots
	                    if (!series.slotElements) {
	                        series.slotElements = [];
	                    }
	                    if (i === 1) {
	                        series.slotElements.forEach(function (elem) {
	                            elem.destroy();
	                        });
	                        series.slotElements.length = 0;
	                    }

	                    slots.forEach(function (pos, no) {
	                        var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),
	                            slotY = pos + chart.plotTop;

	                        if (!isNaN(slotX)) {
	                            series.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)
	                                .attr({
	                                    'stroke-width': 1,
	                                    stroke: 'silver',
	                                    fill: 'rgba(0,0,255,0.1)'
	                                })
	                                .add());
	                            series.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)
	                                .attr({
	                                    fill: 'silver'
	                                }).add());
	                        }
	                    });
	                    // */

	                    // if there are more values than available slots, remove lowest values
	                    if (length > slotsLength) {
	                        // create an array for sorting and ranking the points within each quarter
	                        rankArr = [].concat(points);
	                        rankArr.sort(sort);
	                        j = length;
	                        while (j--) {
	                            rankArr[j].rank = j;
	                        }
	                        j = length;
	                        while (j--) {
	                            if (points[j].rank >= slotsLength) {
	                                points.splice(j, 1);
	                            }
	                        }
	                        length = points.length;
	                    }

	                    // The label goes to the nearest open slot, but not closer to the edge than
	                    // the label's index.
	                    for (j = 0; j < length; j++) {

	                        point = points[j];
	                        labelPos = point.labelPos;

	                        var closest = 9999,
	                            distance,
	                            slotI;

	                        // find the closest slot index
	                        for (slotI = 0; slotI < slotsLength; slotI++) {
	                            distance = mathAbs(slots[slotI] - labelPos[1]);
	                            if (distance < closest) {
	                                closest = distance;
	                                slotIndex = slotI;
	                            }
	                        }

	                        // if that slot index is closer to the edges of the slots, move it
	                        // to the closest appropriate slot
	                        if (slotIndex < j && slots[j] !== null) { // cluster at the top
	                            slotIndex = j;
	                        } else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom
	                            slotIndex = slotsLength - length + j;
	                            while (slots[slotIndex] === null) { // make sure it is not taken
	                                slotIndex++;
	                            }
	                        } else {
	                            // Slot is taken, find next free slot below. In the next run, the next slice will find the
	                            // slot above these, because it is the closest one
	                            while (slots[slotIndex] === null) { // make sure it is not taken
	                                slotIndex++;
	                            }
	                        }

	                        usedSlots.push({ i: slotIndex, y: slots[slotIndex] });
	                        slots[slotIndex] = null; // mark as taken
	                    }
	                    // sort them in order to fill in from the top
	                    usedSlots.sort(sort);
	                }

	                // now the used slots are sorted, fill them up sequentially
	                for (j = 0; j < length; j++) {

	                    var slot, naturalY;

	                    point = points[j];
	                    labelPos = point.labelPos;
	                    dataLabel = point.dataLabel;
	                    visibility = point.visible === false ? HIDDEN : 'inherit';
	                    naturalY = labelPos[1];

	                    if (distanceOption > 0) {
	                        slot = usedSlots.pop();
	                        slotIndex = slot.i;

	                        // if the slot next to currrent slot is free, the y value is allowed
	                        // to fall back to the natural position
	                        y = slot.y;
	                        if ((naturalY > y && slots[slotIndex + 1] !== null) ||
	                                (naturalY < y &&  slots[slotIndex - 1] !== null)) {
	                            y = mathMin(mathMax(0, naturalY), chart.plotHeight);
	                        }

	                    } else {
	                        y = naturalY;
	                    }

	                    // get the x - use the natural x position for first and last slot, to prevent the top
	                    // and botton slice connectors from touching each other on either side
	                    x = options.justify ?
	                        seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :
	                        series.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);


	                    // Record the placement and visibility
	                    dataLabel._attr = {
	                        visibility: visibility,
	                        align: labelPos[6]
	                    };
	                    dataLabel._pos = {
	                        x: x + options.x +
	                            ({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
	                        y: y + options.y - 10 // 10 is for the baseline (label vs text)
	                    };
	                    dataLabel.connX = x;
	                    dataLabel.connY = y;


	                    // Detect overflowing data labels
	                    if (this.options.size === null) {
	                        dataLabelWidth = dataLabel.width;
	                        // Overflow left
	                        if (x - dataLabelWidth < connectorPadding) {
	                            overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);

	                        // Overflow right
	                        } else if (x + dataLabelWidth > plotWidth - connectorPadding) {
	                            overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);
	                        }

	                        // Overflow top
	                        if (y - labelHeight / 2 < 0) {
	                            overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);

	                        // Overflow left
	                        } else if (y + labelHeight / 2 > plotHeight) {
	                            overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);
	                        }
	                    }
	                } // for each point
	            } // for each half

	            // Do not apply the final placement and draw the connectors until we have verified
	            // that labels are not spilling over.
	            if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {

	                // Place the labels in the final position
	                this.placeDataLabels();

	                // Draw the connectors
	                if (outside && connectorWidth) {
	                    each(this.points, function (point) {
	                        connector = point.connector;
	                        labelPos = point.labelPos;
	                        dataLabel = point.dataLabel;

	                        if (dataLabel && dataLabel._pos && point.visible) {
	                            visibility = dataLabel._attr.visibility;
	                            x = dataLabel.connX;
	                            y = dataLabel.connY;
	                            connectorPath = softConnector ? [
	                                M,
	                                x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
	                                'C',
	                                x, y, // first break, next to the label
	                                2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
	                                labelPos[2], labelPos[3], // second break
	                                L,
	                                labelPos[4], labelPos[5] // base
	                            ] : [
	                                M,
	                                x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
	                                L,
	                                labelPos[2], labelPos[3], // second break
	                                L,
	                                labelPos[4], labelPos[5] // base
	                            ];

	                            if (connector) {
	                                connector.animate({ d: connectorPath });
	                                connector.attr('visibility', visibility);

	                            } else {
	                                point.connector = connector = series.chart.renderer.path(connectorPath).attr({
	                                    'stroke-width': connectorWidth,
	                                    stroke: options.connectorColor || point.color || '#606060',
	                                    visibility: visibility
	                                    //zIndex: 0 // #2722 (reversed)
	                                })
	                                .add(series.dataLabelsGroup);
	                            }
	                        } else if (connector) {
	                            point.connector = connector.destroy();
	                        }
	                    });
	                }
	            }
	        };
	        /**
	         * Perform the final placement of the data labels after we have verified that they
	         * fall within the plot area.
	         */
	        seriesTypes.pie.prototype.placeDataLabels = function () {
	            each(this.points, function (point) {
	                var dataLabel = point.dataLabel,
	                    _pos;

	                if (dataLabel && point.visible) {
	                    _pos = dataLabel._pos;
	                    if (_pos) {
	                        dataLabel.attr(dataLabel._attr);
	                        dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
	                        dataLabel.moved = true;
	                    } else if (dataLabel) {
	                        dataLabel.attr({ y: -9999 });
	                    }
	                }
	            });
	        };

	        seriesTypes.pie.prototype.alignDataLabel =  noop;

	        /**
	         * Verify whether the data labels are allowed to draw, or we should run more translation and data
	         * label positioning to keep them inside the plot area. Returns true when data labels are ready
	         * to draw.
	         */
	        seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {

	            var center = this.center,
	                options = this.options,
	                centerOption = options.center,
	                minSize = options.minSize || 80,
	                newSize = minSize,
	                ret;

	            // Handle horizontal size and center
	            if (centerOption[0] !== null) { // Fixed center
	                newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);

	            } else { // Auto center
	                newSize = mathMax(
	                    center[2] - overflow[1] - overflow[3], // horizontal overflow
	                    minSize
	                );
	                center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center
	            }

	            // Handle vertical size and center
	            if (centerOption[1] !== null) { // Fixed center
	                newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);

	            } else { // Auto center
	                newSize = mathMax(
	                    mathMin(
	                        newSize,
	                        center[2] - overflow[0] - overflow[2] // vertical overflow
	                    ),
	                    minSize
	                );
	                center[1] += (overflow[0] - overflow[2]) / 2; // vertical center
	            }

	            // If the size must be decreased, we need to run translate and drawDataLabels again
	            if (newSize < center[2]) {
	                center[2] = newSize;
	                center[3] = Math.min(relativeLength(options.innerSize || 0, newSize), newSize); // #3632
	                this.translate(center);
	            
	                if (this.drawDataLabels) {
	                    this.drawDataLabels();
	                }
	            // Else, return true to indicate that the pie and its labels is within the plot area
	            } else {
	                ret = true;
	            }
	            return ret;
	        };
	    }

	    if (seriesTypes.column) {

	        /**
	         * Override the basic data label alignment by adjusting for the position of the column
	         */
	        seriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {
	            var inverted = this.chart.inverted,
	                series = point.series,
	                dlBox = point.dlBox || point.shapeArgs, // data label box for alignment
	                below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len)), // point.below is used in range series
	                inside = pick(options.inside, !!this.options.stacking), // draw it inside the box?
	                overshoot;

	            // Align to the column itself, or the top of it
	            if (dlBox) { // Area range uses this method but not alignTo
	                alignTo = merge(dlBox);

	                if (alignTo.y < 0) {
	                    alignTo.height += alignTo.y;
	                    alignTo.y = 0;
	                }
	                overshoot = alignTo.y + alignTo.height - series.yAxis.len;
	                if (overshoot > 0) {
	                    alignTo.height -= overshoot;
	                }

	                if (inverted) {
	                    alignTo = {
	                        x: series.yAxis.len - alignTo.y - alignTo.height,
	                        y: series.xAxis.len - alignTo.x - alignTo.width,
	                        width: alignTo.height,
	                        height: alignTo.width
	                    };
	                }

	                // Compute the alignment box
	                if (!inside) {
	                    if (inverted) {
	                        alignTo.x += below ? 0 : alignTo.width;
	                        alignTo.width = 0;
	                    } else {
	                        alignTo.y += below ? alignTo.height : 0;
	                        alignTo.height = 0;
	                    }
	                }
	            }


	            // When alignment is undefined (typically columns and bars), display the individual
	            // point below or above the point depending on the threshold
	            options.align = pick(
	                options.align,
	                !inverted || inside ? 'center' : below ? 'right' : 'left'
	            );
	            options.verticalAlign = pick(
	                options.verticalAlign,
	                inverted || inside ? 'middle' : below ? 'top' : 'bottom'
	            );

	            // Call the parent method
	            Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
	        };
	    }



	    /**
	     * Highcharts module to hide overlapping data labels. This module is included in Highcharts.
	     */
	    (function (H) {
	        var Chart = H.Chart,
	            each = H.each,
	            pick = H.pick,
	            addEvent = H.addEvent;

	        // Collect potensial overlapping data labels. Stack labels probably don't need to be 
	        // considered because they are usually accompanied by data labels that lie inside the columns.
	        Chart.prototype.callbacks.push(function (chart) {
	            function collectAndHide() {
	                var labels = [];

	                each(chart.series, function (series) {
	                    var dlOptions = series.options.dataLabels,
	                        collections = series.dataLabelCollections || ['dataLabel']; // Range series have two collections
	                    if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866
	                        each(collections, function (coll) {
	                            each(series.points, function (point) {
	                                if (point[coll]) {
	                                    point[coll].labelrank = pick(point.labelrank, point.shapeArgs && point.shapeArgs.height); // #4118
	                                    labels.push(point[coll]);
	                                }
	                            });
	                        });
	                    }
	                });
	                chart.hideOverlappingLabels(labels);
	            }

	            // Do it now ...
	            collectAndHide();

	            // ... and after each chart redraw
	            addEvent(chart, 'redraw', collectAndHide);

	        });

	        /**
	         * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth 
	         * visual imression.
	         */    
	        Chart.prototype.hideOverlappingLabels = function (labels) {

	            var len = labels.length,
	                label,
	                i,
	                j,
	                label1,
	                label2,
	                isIntersecting,
	                pos1,
	                pos2,
	                parent1,
	                parent2,
	                padding,
	                intersectRect = function (x1, y1, w1, h1, x2, y2, w2, h2) {
	                    return !(
	                        x2 > x1 + w1 ||
	                        x2 + w2 < x1 ||
	                        y2 > y1 + h1 ||
	                        y2 + h2 < y1
	                    );
	                };
	    
	            // Mark with initial opacity
	            for (i = 0; i < len; i++) {
	                label = labels[i];
	                if (label) {
	                    label.oldOpacity = label.opacity;
	                    label.newOpacity = 1;
	                }
	            }

	            // Prevent a situation in a gradually rising slope, that each label
	            // will hide the previous one because the previous one always has
	            // lower rank.
	            labels.sort(function (a, b) {
	                return (b.labelrank || 0) - (a.labelrank || 0);
	            });

	            // Detect overlapping labels
	            for (i = 0; i < len; i++) {
	                label1 = labels[i];

	                for (j = i + 1; j < len; ++j) {
	                    label2 = labels[j];
	                    if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0) {
	                        pos1 = label1.alignAttr;
	                        pos2 = label2.alignAttr;
	                        parent1 = label1.parentGroup; // Different panes have different positions
	                        parent2 = label2.parentGroup;
	                        padding = 2 * (label1.box ? 0 : label1.padding); // Substract the padding if no background or border (#4333)
	                        isIntersecting = intersectRect(
	                            pos1.x + parent1.translateX,
	                            pos1.y + parent1.translateY,
	                            label1.width - padding,
	                            label1.height - padding,
	                            pos2.x + parent2.translateX,
	                            pos2.y + parent2.translateY,
	                            label2.width - padding,
	                            label2.height - padding
	                        );

	                        if (isIntersecting) {
	                            (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;
	                        }
	                    }
	                }
	            }

	            // Hide or show
	            each(labels, function (label) {
	                var complete,
	                    newOpacity;

	                if (label) {
	                    newOpacity = label.newOpacity;

	                    if (label.oldOpacity !== newOpacity && label.placed) {

	                        // Make sure the label is completely hidden to avoid catching clicks (#4362)
	                        if (newOpacity) {
	                            label.show(true);
	                        } else {
	                            complete = function () {
	                                label.hide();
	                            };
	                        }

	                        // Animate or set the opacity                
	                        label.alignAttr.opacity = newOpacity;
	                        label[label.isOld ? 'animate' : 'attr'](label.alignAttr, null, complete);
	                    
	                    }
	                    label.isOld = true;
	                }
	            });
	        };
	    }(Highcharts));
	    /**
	     * TrackerMixin for points and graphs
	     */

	    var TrackerMixin = Highcharts.TrackerMixin = {

	        drawTrackerPoint: function () {
	            var series = this,
	                chart = series.chart,
	                pointer = chart.pointer,
	                cursor = series.options.cursor,
	                css = cursor && { cursor: cursor },
	                onMouseOver = function (e) {
	                    var target = e.target,
	                        point;

	                    while (target && !point) {
	                        point = target.point;
	                        target = target.parentNode;
	                    }

	                    if (point !== UNDEFINED && point !== chart.hoverPoint) { // undefined on graph in scatterchart
	                        point.onMouseOver(e);
	                    }
	                };

	            // Add reference to the point
	            each(series.points, function (point) {
	                if (point.graphic) {
	                    point.graphic.element.point = point;
	                }
	                if (point.dataLabel) {
	                    point.dataLabel.element.point = point;
	                }
	            });

	            // Add the event listeners, we need to do this only once
	            if (!series._hasTracking) {
	                each(series.trackerGroups, function (key) {
	                    if (series[key]) { // we don't always have dataLabelsGroup
	                        series[key]
	                            .addClass(PREFIX + 'tracker')
	                            .on('mouseover', onMouseOver)
	                            .on('mouseout', function (e) {
	                                pointer.onTrackerMouseOut(e);
	                            })
	                            .css(css);
	                        if (hasTouch) {
	                            series[key].on('touchstart', onMouseOver);
	                        }
	                    }
	                });
	                series._hasTracking = true;
	            }
	        },

	        /**
	         * Draw the tracker object that sits above all data labels and markers to
	         * track mouse events on the graph or points. For the line type charts
	         * the tracker uses the same graphPath, but with a greater stroke width
	         * for better control.
	         */
	        drawTrackerGraph: function () {
	            var series = this,
	                options = series.options,
	                trackByArea = options.trackByArea,
	                trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
	                trackerPathLength = trackerPath.length,
	                chart = series.chart,
	                pointer = chart.pointer,
	                renderer = chart.renderer,
	                snap = chart.options.tooltip.snap,
	                tracker = series.tracker,
	                cursor = options.cursor,
	                css = cursor && { cursor: cursor },
	                i,
	                onMouseOver = function () {
	                    if (chart.hoverSeries !== series) {
	                        series.onMouseOver();
	                    }
	                },
	                /*
	                 * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable
	                 * IE6: 0.002
	                 * IE7: 0.002
	                 * IE8: 0.002
	                 * IE9: 0.00000000001 (unlimited)
	                 * IE10: 0.0001 (exporting only)
	                 * FF: 0.00000000001 (unlimited)
	                 * Chrome: 0.000001
	                 * Safari: 0.000001
	                 * Opera: 0.00000000001 (unlimited)
	                 */
	                TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')';

	            // Extend end points. A better way would be to use round linecaps,
	            // but those are not clickable in VML.
	            if (trackerPathLength && !trackByArea) {
	                i = trackerPathLength + 1;
	                while (i--) {
	                    if (trackerPath[i] === M) { // extend left side
	                        trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
	                    }
	                    if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
	                        trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
	                    }
	                }
	            }

	            // handle single points
	            /*for (i = 0; i < singlePoints.length; i++) {
	                singlePoint = singlePoints[i];
	                trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
	                L, singlePoint.plotX + snap, singlePoint.plotY);
	            }*/

	            // draw the tracker
	            if (tracker) {
	                tracker.attr({ d: trackerPath });
	            } else { // create

	                series.tracker = renderer.path(trackerPath)
	                .attr({
	                    'stroke-linejoin': 'round', // #1225
	                    visibility: series.visible ? VISIBLE : HIDDEN,
	                    stroke: TRACKER_FILL,
	                    fill: trackByArea ? TRACKER_FILL : NONE,
	                    'stroke-width': options.lineWidth + (trackByArea ? 0 : 2 * snap),
	                    zIndex: 2
	                })
	                .add(series.group);

	                // The tracker is added to the series group, which is clipped, but is covered
	                // by the marker group. So the marker group also needs to capture events.
	                each([series.tracker, series.markerGroup], function (tracker) {
	                    tracker.addClass(PREFIX + 'tracker')
	                        .on('mouseover', onMouseOver)
	                        .on('mouseout', function (e) {
	                            pointer.onTrackerMouseOut(e);
	                        })
	                        .css(css);

	                    if (hasTouch) {
	                        tracker.on('touchstart', onMouseOver);
	                    }
	                });
	            }
	        }
	    };
	    /* End TrackerMixin */


	    /**
	     * Add tracking event listener to the series group, so the point graphics
	     * themselves act as trackers
	     */

	    if (seriesTypes.column) {
	        ColumnSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	    }

	    if (seriesTypes.pie) {
	        seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	    }

	    if (seriesTypes.scatter) {
	        ScatterSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	    }

	    /*
	     * Extend Legend for item events
	     */
	    extend(Legend.prototype, {

	        setItemEvents: function (item, legendItem, useHTML, itemStyle, itemHiddenStyle) {
	            var legend = this;
	            // Set the events on the item group, or in case of useHTML, the item itself (#1249)
	            (useHTML ? legendItem : item.legendGroup).on('mouseover', function () {
	                item.setState(HOVER_STATE);
	                legendItem.css(legend.options.itemHoverStyle);
	            })
	            .on('mouseout', function () {
	                legendItem.css(item.visible ? itemStyle : itemHiddenStyle);
	                item.setState();
	            })
	            .on('click', function (event) {
	                var strLegendItemClick = 'legendItemClick',
	                    fnLegendItemClick = function () {
	                        if (item.setVisible) {
	                            item.setVisible();
	                        }
	                    };

	                // Pass over the click/touch event. #4.
	                event = {
	                    browserEvent: event
	                };

	                // click the name or symbol
	                if (item.firePointEvent) { // point
	                    item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
	                } else {
	                    fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
	                }
	            });
	        },

	        createCheckboxForItem: function (item) {
	            var legend = this;

	            item.checkbox = createElement('input', {
	                type: 'checkbox',
	                checked: item.selected,
	                defaultChecked: item.selected // required by IE7
	            }, legend.options.itemCheckboxStyle, legend.chart.container);

	            addEvent(item.checkbox, 'click', function (event) {
	                var target = event.target;
	                fireEvent(
	                    item.series || item, 
	                    'checkboxClick', 
	                    { // #3712
	                        checked: target.checked,
	                        item: item
	                    },
	                    function () {
	                        item.select();
	                    }
	                );
	            });
	        }
	    });

	    /*
	     * Add pointer cursor to legend itemstyle in defaultOptions
	     */
	    defaultOptions.legend.itemStyle.cursor = 'pointer';


	    /*
	     * Extend the Chart object with interaction
	     */

	    extend(Chart.prototype, {
	        /**
	         * Display the zoom button
	         */
	        showResetZoom: function () {
	            var chart = this,
	                lang = defaultOptions.lang,
	                btnOptions = chart.options.chart.resetZoomButton,
	                theme = btnOptions.theme,
	                states = theme.states,
	                alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';

	            function zoomOut() {
	                chart.zoomOut();
	            }

	            this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover)
	                .attr({
	                    align: btnOptions.position.align,
	                    title: lang.resetZoomTitle
	                })
	                .add()
	                .align(btnOptions.position, false, alignTo);

	        },

	        /**
	         * Zoom out to 1:1
	         */
	        zoomOut: function () {
	            var chart = this;
	            fireEvent(chart, 'selection', { resetSelection: true }, function () {
	                chart.zoom();
	            });
	        },

	        /**
	         * Zoom into a given portion of the chart given by axis coordinates
	         * @param {Object} event
	         */
	        zoom: function (event) {
	            var chart = this,
	                hasZoomed,
	                pointer = chart.pointer,
	                displayButton = false,
	                resetZoomButton;

	            // If zoom is called with no arguments, reset the axes
	            if (!event || event.resetSelection) {
	                each(chart.axes, function (axis) {
	                    hasZoomed = axis.zoom();
	                });
	            } else { // else, zoom in on all axes
	                each(event.xAxis.concat(event.yAxis), function (axisData) {
	                    var axis = axisData.axis,
	                        isXAxis = axis.isXAxis;

	                    // don't zoom more than minRange
	                    if (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {
	                        hasZoomed = axis.zoom(axisData.min, axisData.max);
	                        if (axis.displayBtn) {
	                            displayButton = true;
	                        }
	                    }
	                });
	            }

	            // Show or hide the Reset zoom button
	            resetZoomButton = chart.resetZoomButton;
	            if (displayButton && !resetZoomButton) {
	                chart.showResetZoom();
	            } else if (!displayButton && isObject(resetZoomButton)) {
	                chart.resetZoomButton = resetZoomButton.destroy();
	            }


	            // Redraw
	            if (hasZoomed) {
	                chart.redraw(
	                    pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation
	                );
	            }
	        },

	        /**
	         * Pan the chart by dragging the mouse across the pane. This function is called
	         * on mouse move, and the distance to pan is computed from chartX compared to
	         * the first chartX position in the dragging operation.
	         */
	        pan: function (e, panning) {

	            var chart = this,
	                hoverPoints = chart.hoverPoints,
	                doRedraw;

	            // remove active points for shared tooltip
	            if (hoverPoints) {
	                each(hoverPoints, function (point) {
	                    point.setState();
	                });
	            }

	            each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps
	                var axis = chart[isX ? 'xAxis' : 'yAxis'][0],
	                    horiz = axis.horiz,
	                    mousePos = e[horiz ? 'chartX' : 'chartY'],
	                    mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',
	                    startPos = chart[mouseDown],
	                    halfPointRange = (axis.pointRange || 0) / 2,
	                    extremes = axis.getExtremes(),
	                    newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,
	                    newMax = axis.toValue(startPos + axis.len - mousePos, true) - halfPointRange,
	                    goingLeft = startPos > mousePos; // #3613
	            
	                if (axis.series.length &&
	                        (goingLeft || newMin > mathMin(extremes.dataMin, extremes.min)) &&    
	                        (!goingLeft || newMax < mathMax(extremes.dataMax, extremes.max))) {
	                    axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });
	                    doRedraw = true;
	                }

	                chart[mouseDown] = mousePos; // set new reference for next run
	            });

	            if (doRedraw) {
	                chart.redraw(false);
	            }
	            css(chart.container, { cursor: 'move' });
	        }
	    });

	    /*
	     * Extend the Point object with interaction
	     */
	    extend(Point.prototype, {
	        /**
	         * Toggle the selection status of a point
	         * @param {Boolean} selected Whether to select or unselect the point.
	         * @param {Boolean} accumulate Whether to add to the previous selection. By default,
	         *         this happens if the control key (Cmd on Mac) was pressed during clicking.
	         */
	        select: function (selected, accumulate) {
	            var point = this,
	                series = point.series,
	                chart = series.chart;

	            selected = pick(selected, !point.selected);

	            // fire the event with the default handler
	            point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {
	                point.selected = point.options.selected = selected;
	                series.options.data[inArray(point, series.data)] = point.options;

	                point.setState(selected && SELECT_STATE);

	                // unselect all other points unless Ctrl or Cmd + click
	                if (!accumulate) {
	                    each(chart.getSelectedPoints(), function (loopPoint) {
	                        if (loopPoint.selected && loopPoint !== point) {
	                            loopPoint.selected = loopPoint.options.selected = false;
	                            series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
	                            loopPoint.setState(NORMAL_STATE);
	                            loopPoint.firePointEvent('unselect');
	                        }
	                    });
	                }
	            });
	        },

	        /**
	         * Runs on mouse over the point
	         *
	         * @param {Object} e The event arguments
	         * @param {Boolean} byProximity Falsy for kd points that are closest to the mouse, or to
	         *        actually hovered points. True for other points in shared tooltip.
	         */
	        onMouseOver: function (e, byProximity) {
	            var point = this,
	                series = point.series,
	                chart = series.chart,
	                tooltip = chart.tooltip,
	                hoverPoint = chart.hoverPoint;

	            if (chart.hoverSeries !== series) {
	                series.onMouseOver();
	            }

	            // set normal state to previous series
	            if (hoverPoint && hoverPoint !== point) {
	                hoverPoint.onMouseOut();
	            }

	            if (point.series) { // It may have been destroyed, #4130

	                // trigger the event
	                point.firePointEvent('mouseOver');

	                // update the tooltip
	                if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {
	                    tooltip.refresh(point, e);
	                }

	                // hover this
	                point.setState(HOVER_STATE);
	                if (!byProximity) {
	                    chart.hoverPoint = point;
	                }
	            }
	        },

	        /**
	         * Runs on mouse out from the point
	         */
	        onMouseOut: function () {
	            var chart = this.series.chart,
	                hoverPoints = chart.hoverPoints;

	            this.firePointEvent('mouseOut');

	            if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240
	                this.setState();
	                chart.hoverPoint = null;
	            }
	        },

	        /**
	         * Import events from the series' and point's options. Only do it on
	         * demand, to save processing time on hovering.
	         */
	        importEvents: function () {
	            if (!this.hasImportedEvents) {
	                var point = this,
	                    options = merge(point.series.options.point, point.options),
	                    events = options.events,
	                    eventType;

	                point.events = events;

	                for (eventType in events) {
	                    addEvent(point, eventType, events[eventType]);
	                }
	                this.hasImportedEvents = true;

	            }
	        },

	        /**
	         * Set the point's state
	         * @param {String} state
	         */
	        setState: function (state, move) {
	            var point = this,
	                plotX = mathFloor(point.plotX), // #4586
	                plotY = point.plotY,
	                series = point.series,
	                stateOptions = series.options.states,
	                markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
	                normalDisabled = markerOptions && !markerOptions.enabled,
	                markerStateOptions = markerOptions && markerOptions.states[state],
	                stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
	                stateMarkerGraphic = series.stateMarkerGraphic,
	                pointMarker = point.marker || {},
	                chart = series.chart,
	                radius,
	                halo = series.halo,
	                haloOptions,
	                newSymbol,
	                pointAttr;

	            state = state || NORMAL_STATE; // empty string
	            pointAttr = point.pointAttr[state] || series.pointAttr[state];

	            if (
	                    // already has this state
	                    (state === point.state && !move) ||
	                    // selected points don't respond to hover
	                    (point.selected && state !== SELECT_STATE) ||
	                    // series' state options is disabled
	                    (stateOptions[state] && stateOptions[state].enabled === false) ||
	                    // general point marker's state options is disabled
	                    (state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||
	                    // individual point marker's state options is disabled
	                    (state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610

	                ) {
	                return;
	            }

	            // apply hover styles to the existing point
	            if (point.graphic) {
	                radius = markerOptions && point.graphic.symbolName && pointAttr.r;
	                point.graphic.attr(merge(
	                    pointAttr,
	                    radius ? { // new symbol attributes (#507, #612)
	                        x: plotX - radius,
	                        y: plotY - radius,
	                        width: 2 * radius,
	                        height: 2 * radius
	                    } : {}
	                ));

	                // Zooming in from a range with no markers to a range with markers
	                if (stateMarkerGraphic) {
	                    stateMarkerGraphic.hide();
	                }
	            } else {
	                // if a graphic is not applied to each point in the normal state, create a shared
	                // graphic for the hover state
	                if (state && markerStateOptions) {
	                    radius = markerStateOptions.radius;
	                    newSymbol = pointMarker.symbol || series.symbol;

	                    // If the point has another symbol than the previous one, throw away the
	                    // state marker graphic and force a new one (#1459)
	                    if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
	                        stateMarkerGraphic = stateMarkerGraphic.destroy();
	                    }

	                    // Add a new state marker graphic
	                    if (!stateMarkerGraphic) {
	                        if (newSymbol) {
	                            series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
	                                newSymbol,
	                                plotX - radius,
	                                plotY - radius,
	                                2 * radius,
	                                2 * radius
	                            )
	                            .attr(pointAttr)
	                            .add(series.markerGroup);
	                            stateMarkerGraphic.currentSymbol = newSymbol;
	                        }

	                    // Move the existing graphic
	                    } else {
	                        stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054
	                            x: plotX - radius,
	                            y: plotY - radius
	                        });
	                    }
	                }

	                if (stateMarkerGraphic) {
	                    stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450
	                    stateMarkerGraphic.element.point = point; // #4310
	                }
	            }

	            // Show me your halo
	            haloOptions = stateOptions[state] && stateOptions[state].halo;
	            if (haloOptions && haloOptions.size) {
	                if (!halo) {
	                    series.halo = halo = chart.renderer.path()
	                        .add(chart.seriesGroup);
	                }
	                halo.attr(extend({
	                    'fill': point.color || series.color,
	                    'fill-opacity': haloOptions.opacity,
	                    'zIndex': -1 // #4929, IE8 added halo above everything
	                },
	                haloOptions.attributes))[move ? 'animate' : 'attr']({
	                    d: point.haloPath(haloOptions.size)
	                });
	            } else if (halo) {
	                halo.attr({ d: [] });
	            }

	            point.state = state;
	        },

	        /**
	         * Get the circular path definition for the halo
	         * @param  {Number} size The radius of the circular halo
	         * @returns {Array} The path definition
	         */
	        haloPath: function (size) {
	            var series = this.series,
	                chart = series.chart,
	                plotBox = series.getPlotBox(),
	                inverted = chart.inverted,
	                plotX = Math.floor(this.plotX);

	            return chart.renderer.symbols.circle(
	                plotBox.translateX + (inverted ? series.yAxis.len - this.plotY : plotX) - size, 
	                plotBox.translateY + (inverted ? series.xAxis.len - plotX : this.plotY) - size, 
	                size * 2, 
	                size * 2
	            );
	        }
	    });

	    /*
	     * Extend the Series object with interaction
	     */

	    extend(Series.prototype, {
	        /**
	         * Series mouse over handler
	         */
	        onMouseOver: function () {
	            var series = this,
	                chart = series.chart,
	                hoverSeries = chart.hoverSeries;

	            // set normal state to previous series
	            if (hoverSeries && hoverSeries !== series) {
	                hoverSeries.onMouseOut();
	            }

	            // trigger the event, but to save processing time,
	            // only if defined
	            if (series.options.events.mouseOver) {
	                fireEvent(series, 'mouseOver');
	            }

	            // hover this
	            series.setState(HOVER_STATE);
	            chart.hoverSeries = series;
	        },

	        /**
	         * Series mouse out handler
	         */
	        onMouseOut: function () {
	            // trigger the event only if listeners exist
	            var series = this,
	                options = series.options,
	                chart = series.chart,
	                tooltip = chart.tooltip,
	                hoverPoint = chart.hoverPoint;

	            chart.hoverSeries = null; // #182, set to null before the mouseOut event fires

	            // trigger mouse out on the point, which must be in this series
	            if (hoverPoint) {
	                hoverPoint.onMouseOut();
	            }

	            // fire the mouse out event
	            if (series && options.events.mouseOut) {
	                fireEvent(series, 'mouseOut');
	            }


	            // hide the tooltip
	            if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
	                tooltip.hide();
	            }

	            // set normal state
	            series.setState();
	        },

	        /**
	         * Set the state of the graph
	         */
	        setState: function (state) {
	            var series = this,
	                options = series.options,
	                graph = series.graph,
	                stateOptions = options.states,
	                lineWidth = options.lineWidth,
	                attribs,
	                i = 0;

	            state = state || NORMAL_STATE;

	            if (series.state !== state) {
	                series.state = state;

	                if (stateOptions[state] && stateOptions[state].enabled === false) {
	                    return;
	                }

	                if (state) {
	                    lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035
	                }

	                if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
	                    attribs = {
	                        'stroke-width': lineWidth
	                    };
	                    // use attr because animate will cause any other animation on the graph to stop
	                    graph.attr(attribs);
	                    while (series['zoneGraph' + i]) {
	                        series['zoneGraph' + i].attr(attribs);
	                        i = i + 1;
	                    }
	                }
	            }
	        },

	        /**
	         * Set the visibility of the graph
	         *
	         * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
	         *                the visibility is toggled.
	         */
	        setVisible: function (vis, redraw) {
	            var series = this,
	                chart = series.chart,
	                legendItem = series.legendItem,
	                showOrHide,
	                ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
	                oldVisibility = series.visible;

	            // if called without an argument, toggle visibility
	            series.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;
	            showOrHide = vis ? 'show' : 'hide';

	            // show or hide elements
	            each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {
	                if (series[key]) {
	                    series[key][showOrHide]();
	                }
	            });


	            // hide tooltip (#1361)
	            if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
	                series.onMouseOut();
	            }


	            if (legendItem) {
	                chart.legend.colorizeItem(series, vis);
	            }


	            // rescale or adapt to resized chart
	            series.isDirty = true;
	            // in a stack, all other series are affected
	            if (series.options.stacking) {
	                each(chart.series, function (otherSeries) {
	                    if (otherSeries.options.stacking && otherSeries.visible) {
	                        otherSeries.isDirty = true;
	                    }
	                });
	            }

	            // show or hide linked series
	            each(series.linkedSeries, function (otherSeries) {
	                otherSeries.setVisible(vis, false);
	            });

	            if (ignoreHiddenSeries) {
	                chart.isDirtyBox = true;
	            }
	            if (redraw !== false) {
	                chart.redraw();
	            }

	            fireEvent(series, showOrHide);
	        },

	        /**
	         * Show the graph
	         */
	        show: function () {
	            this.setVisible(true);
	        },

	        /**
	         * Hide the graph
	         */
	        hide: function () {
	            this.setVisible(false);
	        },


	        /**
	         * Set the selected state of the graph
	         *
	         * @param selected {Boolean} True to select the series, false to unselect. If
	         *                UNDEFINED, the selection state is toggled.
	         */
	        select: function (selected) {
	            var series = this;
	            // if called without an argument, toggle
	            series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;

	            if (series.checkbox) {
	                series.checkbox.checked = selected;
	            }

	            fireEvent(series, selected ? 'select' : 'unselect');
	        },

	        drawTracker: TrackerMixin.drawTrackerGraph
	    });
	    /* ****************************************************************************
	     * Start ordinal axis logic                                                   *
	     *****************************************************************************/


	    wrap(Series.prototype, 'init', function (proceed) {
	        var series = this,
	            xAxis;

	        // call the original function
	        proceed.apply(this, Array.prototype.slice.call(arguments, 1));

	        xAxis = series.xAxis;

	        // Destroy the extended ordinal index on updated data
	        if (xAxis && xAxis.options.ordinal) {
	            addEvent(series, 'updatedData', function () {
	                delete xAxis.ordinalIndex;
	            });
	        }
	    });

	    /**
	     * In an ordinal axis, there might be areas with dense consentrations of points, then large
	     * gaps between some. Creating equally distributed ticks over this entire range
	     * may lead to a huge number of ticks that will later be removed. So instead, break the
	     * positions up in segments, find the tick positions for each segment then concatenize them.
	     * This method is used from both data grouping logic and X axis tick position logic.
	     */
	    wrap(Axis.prototype, 'getTimeTicks', function (proceed, normalizedInterval, min, max, startOfWeek, positions, closestDistance, findHigherRanks) {

	        var start = 0,
	            end,
	            segmentPositions,
	            higherRanks = {},
	            hasCrossedHigherRank,
	            info,
	            posLength,
	            outsideMax,
	            groupPositions = [],
	            lastGroupPosition = -Number.MAX_VALUE,
	            tickPixelIntervalOption = this.options.tickPixelInterval;

	        // The positions are not always defined, for example for ordinal positions when data
	        // has regular interval (#1557, #2090)
	        if ((!this.options.ordinal && !this.options.breaks) || !positions || positions.length < 3 || min === UNDEFINED) {
	            return proceed.call(this, normalizedInterval, min, max, startOfWeek);
	        }

	        // Analyze the positions array to split it into segments on gaps larger than 5 times
	        // the closest distance. The closest distance is already found at this point, so
	        // we reuse that instead of computing it again.
	        posLength = positions.length;

	        for (end = 0; end < posLength; end++) {

	            outsideMax = end && positions[end - 1] > max;

	            if (positions[end] < min) { // Set the last position before min
	                start = end;
	            }

	            if (end === posLength - 1 || positions[end + 1] - positions[end] > closestDistance * 5 || outsideMax) {

	                // For each segment, calculate the tick positions from the getTimeTicks utility
	                // function. The interval will be the same regardless of how long the segment is.
	                if (positions[end] > lastGroupPosition) { // #1475

	                    segmentPositions = proceed.call(this, normalizedInterval, positions[start], positions[end], startOfWeek);

	                    // Prevent duplicate groups, for example for multiple segments within one larger time frame (#1475)
	                    while (segmentPositions.length && segmentPositions[0] <= lastGroupPosition) {
	                        segmentPositions.shift();
	                    }
	                    if (segmentPositions.length) {
	                        lastGroupPosition = segmentPositions[segmentPositions.length - 1];
	                    }

	                    groupPositions = groupPositions.concat(segmentPositions);
	                }
	                // Set start of next segment
	                start = end + 1;
	            }

	            if (outsideMax) {
	                break;
	            }
	        }

	        // Get the grouping info from the last of the segments. The info is the same for
	        // all segments.
	        info = segmentPositions.info;

	        // Optionally identify ticks with higher rank, for example when the ticks
	        // have crossed midnight.
	        if (findHigherRanks && info.unitRange <= timeUnits.hour) {
	            end = groupPositions.length - 1;

	            // Compare points two by two
	            for (start = 1; start < end; start++) {
	                if (dateFormat('%d', groupPositions[start]) !== dateFormat('%d', groupPositions[start - 1])) {
	                    higherRanks[groupPositions[start]] = 'day';
	                    hasCrossedHigherRank = true;
	                }
	            }

	            // If the complete array has crossed midnight, we want to mark the first
	            // positions also as higher rank
	            if (hasCrossedHigherRank) {
	                higherRanks[groupPositions[0]] = 'day';
	            }
	            info.higherRanks = higherRanks;
	        }

	        // Save the info
	        groupPositions.info = info;



	        // Don't show ticks within a gap in the ordinal axis, where the space between
	        // two points is greater than a portion of the tick pixel interval
	        if (findHigherRanks && defined(tickPixelIntervalOption)) { // check for squashed ticks

	            var length = groupPositions.length,
	                i = length,
	                itemToRemove,
	                translated,
	                translatedArr = [],
	                lastTranslated,
	                medianDistance,
	                distance,
	                distances = [];

	            // Find median pixel distance in order to keep a reasonably even distance between
	            // ticks (#748)
	            while (i--) {
	                translated = this.translate(groupPositions[i]);
	                if (lastTranslated) {
	                    distances[i] = lastTranslated - translated;
	                }
	                translatedArr[i] = lastTranslated = translated;
	            }
	            distances.sort();
	            medianDistance = distances[mathFloor(distances.length / 2)];
	            if (medianDistance < tickPixelIntervalOption * 0.6) {
	                medianDistance = null;
	            }

	            // Now loop over again and remove ticks where needed
	            i = groupPositions[length - 1] > max ? length - 1 : length; // #817
	            lastTranslated = undefined;
	            while (i--) {
	                translated = translatedArr[i];
	                distance = lastTranslated - translated;

	                // Remove ticks that are closer than 0.6 times the pixel interval from the one to the right,
	                // but not if it is close to the median distance (#748).
	                if (lastTranslated && distance < tickPixelIntervalOption * 0.8 &&
	                        (medianDistance === null || distance < medianDistance * 0.8)) {

	                    // Is this a higher ranked position with a normal position to the right?
	                    if (higherRanks[groupPositions[i]] && !higherRanks[groupPositions[i + 1]]) {

	                        // Yes: remove the lower ranked neighbour to the right
	                        itemToRemove = i + 1;
	                        lastTranslated = translated; // #709

	                    } else {

	                        // No: remove this one
	                        itemToRemove = i;
	                    }

	                    groupPositions.splice(itemToRemove, 1);

	                } else {
	                    lastTranslated = translated;
	                }
	            }
	        }
	        return groupPositions;
	    });

	    // Extend the Axis prototype
	    extend(Axis.prototype, {

	        /**
	         * Calculate the ordinal positions before tick positions are calculated.
	         */
	        beforeSetTickPositions: function () {
	            var axis = this,
	                len,
	                ordinalPositions = [],
	                useOrdinal = false,
	                dist,
	                extremes = axis.getExtremes(),
	                min = extremes.min,
	                max = extremes.max,
	                minIndex,
	                maxIndex,
	                slope,
	                hasBreaks = axis.isXAxis && !!axis.options.breaks,
	                isOrdinal = axis.options.ordinal,
	                i;

	            // apply the ordinal logic
	            if (isOrdinal || hasBreaks) { // #4167 YAxis is never ordinal ?

	                each(axis.series, function (series, i) {

	                    if (series.visible !== false && (series.takeOrdinalPosition !== false || hasBreaks)) {

	                        // concatenate the processed X data into the existing positions, or the empty array
	                        ordinalPositions = ordinalPositions.concat(series.processedXData);
	                        len = ordinalPositions.length;

	                        // remove duplicates (#1588)
	                        ordinalPositions.sort(function (a, b) {
	                            return a - b; // without a custom function it is sorted as strings
	                        });

	                        if (len) {
	                            i = len - 1;
	                            while (i--) {
	                                if (ordinalPositions[i] === ordinalPositions[i + 1]) {
	                                    ordinalPositions.splice(i, 1);
	                                }
	                            }
	                        }
	                    }

	                });

	                // cache the length
	                len = ordinalPositions.length;

	                // Check if we really need the overhead of mapping axis data against the ordinal positions.
	                // If the series consist of evenly spaced data any way, we don't need any ordinal logic.
	                if (len > 2) { // two points have equal distance by default
	                    dist = ordinalPositions[1] - ordinalPositions[0];
	                    i = len - 1;
	                    while (i-- && !useOrdinal) {
	                        if (ordinalPositions[i + 1] - ordinalPositions[i] !== dist) {
	                            useOrdinal = true;
	                        }
	                    }

	                    // When zooming in on a week, prevent axis padding for weekends even though the data within
	                    // the week is evenly spaced.
	                    if (!axis.options.keepOrdinalPadding && (ordinalPositions[0] - min > dist || max - ordinalPositions[ordinalPositions.length - 1] > dist)) {
	                        useOrdinal = true;
	                    }
	                }

	                // Record the slope and offset to compute the linear values from the array index.
	                // Since the ordinal positions may exceed the current range, get the start and
	                // end positions within it (#719, #665b)
	                if (useOrdinal) {

	                    // Register
	                    axis.ordinalPositions = ordinalPositions;

	                    // This relies on the ordinalPositions being set. Use mathMax and mathMin to prevent
	                    // padding on either sides of the data.
	                    minIndex = axis.val2lin(mathMax(min, ordinalPositions[0]), true);
	                    maxIndex = mathMax(axis.val2lin(mathMin(max, ordinalPositions[ordinalPositions.length - 1]), true), 1); // #3339

	                    // Set the slope and offset of the values compared to the indices in the ordinal positions
	                    axis.ordinalSlope = slope = (max - min) / (maxIndex - minIndex);
	                    axis.ordinalOffset = min - (minIndex * slope);

	                } else {
	                    axis.ordinalPositions = axis.ordinalSlope = axis.ordinalOffset = UNDEFINED;
	                }
	            }
	            axis.isOrdinal = isOrdinal && useOrdinal; // #3818, #4196, #4926
	            axis.groupIntervalFactor = null; // reset for next run
	        },
	        /**
	         * Translate from a linear axis value to the corresponding ordinal axis position. If there
	         * are no gaps in the ordinal axis this will be the same. The translated value is the value
	         * that the point would have if the axis were linear, using the same min and max.
	         *
	         * @param Number val The axis value
	         * @param Boolean toIndex Whether to return the index in the ordinalPositions or the new value
	         */
	        val2lin: function (val, toIndex) {
	            var axis = this,
	                ordinalPositions = axis.ordinalPositions,
	                ret;

	            if (!ordinalPositions) {
	                ret = val;

	            } else {

	                var ordinalLength = ordinalPositions.length,
	                    i,
	                    distance,
	                    ordinalIndex;

	                // first look for an exact match in the ordinalpositions array
	                i = ordinalLength;
	                while (i--) {
	                    if (ordinalPositions[i] === val) {
	                        ordinalIndex = i;
	                        break;
	                    }
	                }

	                // if that failed, find the intermediate position between the two nearest values
	                i = ordinalLength - 1;
	                while (i--) {
	                    if (val > ordinalPositions[i] || i === 0) { // interpolate
	                        distance = (val - ordinalPositions[i]) / (ordinalPositions[i + 1] - ordinalPositions[i]); // something between 0 and 1
	                        ordinalIndex = i + distance;
	                        break;
	                    }
	                }
	                ret = toIndex ?
	                    ordinalIndex :
	                    axis.ordinalSlope * (ordinalIndex || 0) + axis.ordinalOffset;
	            }
	            return ret;
	        },
	        /**
	         * Translate from linear (internal) to axis value
	         *
	         * @param Number val The linear abstracted value
	         * @param Boolean fromIndex Translate from an index in the ordinal positions rather than a value
	         */
	        lin2val: function (val, fromIndex) {
	            var axis = this,
	                ordinalPositions = axis.ordinalPositions,
	                ret;

	            if (!ordinalPositions) { // the visible range contains only equally spaced values
	                ret = val;

	            } else {

	                var ordinalSlope = axis.ordinalSlope,
	                    ordinalOffset = axis.ordinalOffset,
	                    i = ordinalPositions.length - 1,
	                    linearEquivalentLeft,
	                    linearEquivalentRight,
	                    distance;


	                // Handle the case where we translate from the index directly, used only
	                // when panning an ordinal axis
	                if (fromIndex) {

	                    if (val < 0) { // out of range, in effect panning to the left
	                        val = ordinalPositions[0];
	                    } else if (val > i) { // out of range, panning to the right
	                        val = ordinalPositions[i];
	                    } else { // split it up
	                        i = mathFloor(val);
	                        distance = val - i; // the decimal
	                    }

	                // Loop down along the ordinal positions. When the linear equivalent of i matches
	                // an ordinal position, interpolate between the left and right values.
	                } else {
	                    while (i--) {
	                        linearEquivalentLeft = (ordinalSlope * i) + ordinalOffset;
	                        if (val >= linearEquivalentLeft) {
	                            linearEquivalentRight = (ordinalSlope * (i + 1)) + ordinalOffset;
	                            distance = (val - linearEquivalentLeft) / (linearEquivalentRight - linearEquivalentLeft); // something between 0 and 1
	                            break;
	                        }
	                    }
	                }

	                // If the index is within the range of the ordinal positions, return the associated
	                // or interpolated value. If not, just return the value
	                ret = distance !== UNDEFINED && ordinalPositions[i] !== UNDEFINED ?
	                    ordinalPositions[i] + (distance ? distance * (ordinalPositions[i + 1] - ordinalPositions[i]) : 0) :
	                    val;
	            }
	            return ret;
	        },
	        /**
	         * Get the ordinal positions for the entire data set. This is necessary in chart panning
	         * because we need to find out what points or data groups are available outside the
	         * visible range. When a panning operation starts, if an index for the given grouping
	         * does not exists, it is created and cached. This index is deleted on updated data, so
	         * it will be regenerated the next time a panning operation starts.
	         */
	        getExtendedPositions: function () {
	            var axis = this,
	                chart = axis.chart,
	                grouping = axis.series[0].currentDataGrouping,
	                ordinalIndex = axis.ordinalIndex,
	                key = grouping ? grouping.count + grouping.unitName : 'raw',
	                extremes = axis.getExtremes(),
	                fakeAxis,
	                fakeSeries;

	            // If this is the first time, or the ordinal index is deleted by updatedData,
	            // create it.
	            if (!ordinalIndex) {
	                ordinalIndex = axis.ordinalIndex = {};
	            }


	            if (!ordinalIndex[key]) {

	                // Create a fake axis object where the extended ordinal positions are emulated
	                fakeAxis = {
	                    series: [],
	                    getExtremes: function () {
	                        return {
	                            min: extremes.dataMin,
	                            max: extremes.dataMax
	                        };
	                    },
	                    options: {
	                        ordinal: true
	                    },
	                    val2lin: Axis.prototype.val2lin // #2590
	                };

	                // Add the fake series to hold the full data, then apply processData to it
	                each(axis.series, function (series) {
	                    fakeSeries = {
	                        xAxis: fakeAxis,
	                        xData: series.xData,
	                        chart: chart,
	                        destroyGroupedData: noop
	                    };
	                    fakeSeries.options = {
	                        dataGrouping: grouping ? {
	                            enabled: true,
	                            forced: true,
	                            approximation: 'open', // doesn't matter which, use the fastest
	                            units: [[grouping.unitName, [grouping.count]]]
	                        } : {
	                            enabled: false
	                        }
	                    };
	                    series.processData.apply(fakeSeries);

	                    fakeAxis.series.push(fakeSeries);
	                });

	                // Run beforeSetTickPositions to compute the ordinalPositions
	                axis.beforeSetTickPositions.apply(fakeAxis);

	                // Cache it
	                ordinalIndex[key] = fakeAxis.ordinalPositions;
	            }
	            return ordinalIndex[key];
	        },

	        /**
	         * Find the factor to estimate how wide the plot area would have been if ordinal
	         * gaps were included. This value is used to compute an imagined plot width in order
	         * to establish the data grouping interval.
	         *
	         * A real world case is the intraday-candlestick
	         * example. Without this logic, it would show the correct data grouping when viewing
	         * a range within each day, but once moving the range to include the gap between two
	         * days, the interval would include the cut-away night hours and the data grouping
	         * would be wrong. So the below method tries to compensate by identifying the most
	         * common point interval, in this case days.
	         *
	         * An opposite case is presented in issue #718. We have a long array of daily data,
	         * then one point is appended one hour after the last point. We expect the data grouping
	         * not to change.
	         *
	         * In the future, if we find cases where this estimation doesn't work optimally, we
	         * might need to add a second pass to the data grouping logic, where we do another run
	         * with a greater interval if the number of data groups is more than a certain fraction
	         * of the desired group count.
	         */
	        getGroupIntervalFactor: function (xMin, xMax, series) {
	            var i,
	                processedXData = series.processedXData,
	                len = processedXData.length,
	                distances = [],
	                median,
	                groupIntervalFactor = this.groupIntervalFactor;

	            // Only do this computation for the first series, let the other inherit it (#2416)
	            if (!groupIntervalFactor) {

	                // Register all the distances in an array
	                for (i = 0; i < len - 1; i++) {
	                    distances[i] = processedXData[i + 1] - processedXData[i];
	                }

	                // Sort them and find the median
	                distances.sort(function (a, b) {
	                        return a - b;
	                });
	                median = distances[mathFloor(len / 2)];

	                // Compensate for series that don't extend through the entire axis extent. #1675.
	                xMin = mathMax(xMin, processedXData[0]);
	                xMax = mathMin(xMax, processedXData[len - 1]);

	                this.groupIntervalFactor = groupIntervalFactor = (len * median) / (xMax - xMin);
	            }

	            // Return the factor needed for data grouping
	            return groupIntervalFactor;
	        },

	        /**
	         * Make the tick intervals closer because the ordinal gaps make the ticks spread out or cluster
	         */
	        postProcessTickInterval: function (tickInterval) {
	            // Problem: http://jsfiddle.net/highcharts/FQm4E/1/
	            // This is a case where this algorithm doesn't work optimally. In this case, the
	            // tick labels are spread out per week, but all the gaps reside within weeks. So
	            // we have a situation where the labels are courser than the ordinal gaps, and
	            // thus the tick interval should not be altered
	            var ordinalSlope = this.ordinalSlope,
	                ret;


	            if (ordinalSlope) {
	                if (!this.options.breaks) {
	                    ret = tickInterval / (ordinalSlope / this.closestPointRange);
	                } else {
	                    ret = this.closestPointRange;
	                }
	            } else {
	                ret = tickInterval;
	            }
	            return ret;
	        }
	    });

	    // Extending the Chart.pan method for ordinal axes
	    wrap(Chart.prototype, 'pan', function (proceed, e) {
	        var chart = this,
	            xAxis = chart.xAxis[0],
	            chartX = e.chartX,
	            runBase = false;

	        if (xAxis.options.ordinal && xAxis.series.length) {

	            var mouseDownX = chart.mouseDownX,
	                extremes = xAxis.getExtremes(),
	                dataMax = extremes.dataMax,
	                min = extremes.min,
	                max = extremes.max,
	                trimmedRange,
	                hoverPoints = chart.hoverPoints,
	                closestPointRange = xAxis.closestPointRange,
	                pointPixelWidth = xAxis.translationSlope * (xAxis.ordinalSlope || closestPointRange),
	                movedUnits = (mouseDownX - chartX) / pointPixelWidth, // how many ordinal units did we move?
	                extendedAxis = { ordinalPositions: xAxis.getExtendedPositions() }, // get index of all the chart's points
	                ordinalPositions,
	                searchAxisLeft,
	                lin2val = xAxis.lin2val,
	                val2lin = xAxis.val2lin,
	                searchAxisRight;

	            if (!extendedAxis.ordinalPositions) { // we have an ordinal axis, but the data is equally spaced
	                runBase = true;

	            } else if (mathAbs(movedUnits) > 1) {

	                // Remove active points for shared tooltip
	                if (hoverPoints) {
	                    each(hoverPoints, function (point) {
	                        point.setState();
	                    });
	                }

	                if (movedUnits < 0) {
	                    searchAxisLeft = extendedAxis;
	                    searchAxisRight = xAxis.ordinalPositions ? xAxis : extendedAxis;
	                } else {
	                    searchAxisLeft = xAxis.ordinalPositions ? xAxis : extendedAxis;
	                    searchAxisRight = extendedAxis;
	                }

	                // In grouped data series, the last ordinal position represents the grouped data, which is
	                // to the left of the real data max. If we don't compensate for this, we will be allowed
	                // to pan grouped data series passed the right of the plot area.
	                ordinalPositions = searchAxisRight.ordinalPositions;
	                if (dataMax > ordinalPositions[ordinalPositions.length - 1]) {
	                    ordinalPositions.push(dataMax);
	                }

	                // Get the new min and max values by getting the ordinal index for the current extreme,
	                // then add the moved units and translate back to values. This happens on the
	                // extended ordinal positions if the new position is out of range, else it happens
	                // on the current x axis which is smaller and faster.
	                chart.fixedRange = max - min;
	                trimmedRange = xAxis.toFixedRange(null, null,
	                    lin2val.apply(searchAxisLeft, [
	                        val2lin.apply(searchAxisLeft, [min, true]) + movedUnits, // the new index
	                        true // translate from index
	                    ]),
	                    lin2val.apply(searchAxisRight, [
	                        val2lin.apply(searchAxisRight, [max, true]) + movedUnits, // the new index
	                        true // translate from index
	                    ])
	                );

	                // Apply it if it is within the available data range
	                if (trimmedRange.min >= mathMin(extremes.dataMin, min) && trimmedRange.max <= mathMax(dataMax, max)) {
	                    xAxis.setExtremes(trimmedRange.min, trimmedRange.max, true, false, { trigger: 'pan' });
	                }

	                chart.mouseDownX = chartX; // set new reference for next run
	                css(chart.container, { cursor: 'move' });
	            }

	        } else {
	            runBase = true;
	        }

	        // revert to the linear chart.pan version
	        if (runBase) {
	            // call the original function
	            proceed.apply(this, Array.prototype.slice.call(arguments, 1));
	        }
	    });



	    /**
	     * Extend getGraphPath by identifying gaps in the ordinal data so that we can draw a gap in the
	     * line or area
	     */
	    Series.prototype.gappedPath = function () {
	        var gapSize = this.options.gapSize,
	            xAxis = this.xAxis,
	            points = this.points.slice(),
	            i = points.length - 1;

	        if (gapSize && i > 0) { // #5008

	            // extension for ordinal breaks
	            while (i--) {
	                if (points[i + 1].x - points[i].x > xAxis.closestPointRange * gapSize) {
	                    points.splice( // insert after this one
	                        i + 1,
	                        0,
	                        { isNull: true }
	                    );
	                }
	            }
	        }

	        // Call base method
	        //return proceed.call(this, points, a, b);
	        return this.getGraphPath(points);
	    };

	    /* ****************************************************************************
	     * End ordinal axis logic                                                   *
	     *****************************************************************************/
	    /**
	     * Highstock JS v4.2.3 (2016-02-08)
	     * Highcharts Broken Axis module
	     * 
	     * License: www.highcharts.com/license
	     */

	    (function (factory) {
	        
	        factory(Highcharts);
	    
	    }(function (H) {

	        'use strict';

	        var pick = H.pick,
	            wrap = H.wrap,
	            each = H.each,
	            extend = H.extend,
	            fireEvent = H.fireEvent,
	            Axis = H.Axis,
	            Series = H.Series;

	        function stripArguments() {
	            return Array.prototype.slice.call(arguments, 1);
	        }

	        extend(Axis.prototype, {
	            isInBreak: function (brk, val) {
	                var ret,
	                    repeat = brk.repeat || Infinity,
	                    from = brk.from,
	                    length = brk.to - brk.from,
	                    test = (val >= from ? (val - from) % repeat :  repeat - ((from - val) % repeat));

	                if (!brk.inclusive) {
	                    ret = test < length && test !== 0;
	                } else {
	                    ret = test <= length;
	                }
	                return ret;
	            },

	            isInAnyBreak: function (val, testKeep) {

	                var breaks = this.options.breaks,
	                    i = breaks && breaks.length,
	                    inbrk,
	                    keep,
	                    ret;

	            
	                if (i) { 

	                    while (i--) {
	                        if (this.isInBreak(breaks[i], val)) {
	                            inbrk = true;
	                            if (!keep) {
	                                keep = pick(breaks[i].showPoints, this.isXAxis ? false : true);
	                            }
	                        }
	                    }

	                    if (inbrk && testKeep) {
	                        ret = inbrk && !keep;
	                    } else {
	                        ret = inbrk;
	                    }
	                }
	                return ret;
	            }
	        });

	        wrap(Axis.prototype, 'setTickPositions', function (proceed) {
	            proceed.apply(this, Array.prototype.slice.call(arguments, 1));
	        
	            if (this.options.breaks) {
	                var axis = this,
	                    tickPositions = this.tickPositions,
	                    info = this.tickPositions.info,
	                    newPositions = [],
	                    i;

	                for (i = 0; i < tickPositions.length; i++) {
	                    if (!axis.isInAnyBreak(tickPositions[i])) {
	                        newPositions.push(tickPositions[i]);
	                    }
	                }

	                this.tickPositions = newPositions;
	                this.tickPositions.info = info;
	            }
	        });
	    
	        wrap(Axis.prototype, 'init', function (proceed, chart, userOptions) {
	            // Force Axis to be not-ordinal when breaks are defined
	            if (userOptions.breaks && userOptions.breaks.length) {
	                userOptions.ordinal = false;
	            }

	            proceed.call(this, chart, userOptions);

	            if (this.options.breaks) {

	                var axis = this;
	            
	                axis.isBroken = true;

	                this.val2lin = function (val) {
	                    var nval = val,
	                        brk,
	                        i;

	                    for (i = 0; i < axis.breakArray.length; i++) {
	                        brk = axis.breakArray[i];
	                        if (brk.to <= val) {
	                            nval -= brk.len;
	                        } else if (brk.from >= val) {
	                            break;
	                        } else if (axis.isInBreak(brk, val)) {
	                            nval -= (val - brk.from);
	                            break;
	                        }
	                    }

	                    return nval;
	                };
	            
	                this.lin2val = function (val) {
	                    var nval = val,
	                        brk,
	                        i;

	                    for (i = 0; i < axis.breakArray.length; i++) {
	                        brk = axis.breakArray[i];
	                        if (brk.from >= nval) {
	                            break;
	                        } else if (brk.to < nval) {
	                            nval += brk.len;
	                        } else if (axis.isInBreak(brk, nval)) {
	                            nval += brk.len;
	                        }
	                    }
	                    return nval;
	                };

	                this.setExtremes = function (newMin, newMax, redraw, animation, eventArguments) {
	                    // If trying to set extremes inside a break, extend it to before and after the break ( #3857 )
	                    while (this.isInAnyBreak(newMin)) {
	                        newMin -= this.closestPointRange;
	                    }            
	                    while (this.isInAnyBreak(newMax)) {
	                        newMax -= this.closestPointRange;
	                    }
	                    Axis.prototype.setExtremes.call(this, newMin, newMax, redraw, animation, eventArguments);
	                };

	                this.setAxisTranslation = function (saveOld) {
	                    Axis.prototype.setAxisTranslation.call(this, saveOld);

	                    var breaks = axis.options.breaks,
	                        breakArrayT = [],    // Temporary one
	                        breakArray = [],
	                        length = 0, 
	                        inBrk,
	                        repeat,
	                        brk,
	                        min = axis.userMin || axis.min,
	                        max = axis.userMax || axis.max,
	                        start,
	                        i,
	                        j;

	                    // Min & max check (#4247)
	                    for (i in breaks) {
	                        brk = breaks[i];
	                        repeat = brk.repeat || Infinity;
	                        if (axis.isInBreak(brk, min)) {
	                            min += (brk.to % repeat) - (min % repeat);
	                        }
	                        if (axis.isInBreak(brk, max)) {
	                            max -= (max % repeat) - (brk.from % repeat);
	                        }
	                    }

	                    // Construct an array holding all breaks in the axis
	                    for (i in breaks) {
	                        brk = breaks[i];
	                        start = brk.from;
	                        repeat = brk.repeat || Infinity;

	                        while (start - repeat > min) {
	                            start -= repeat;
	                        }
	                        while (start < min) {
	                            start += repeat;
	                        }

	                        for (j = start; j < max; j += repeat) {
	                            breakArrayT.push({
	                                value: j,
	                                move: 'in'
	                            });
	                            breakArrayT.push({
	                                value: j + (brk.to - brk.from),
	                                move: 'out',
	                                size: brk.breakSize
	                            });
	                        }
	                    }

	                    breakArrayT.sort(function (a, b) {
	                        var ret;
	                        if (a.value === b.value) {
	                            ret = (a.move === 'in' ? 0 : 1) - (b.move === 'in' ? 0 : 1);
	                        } else {
	                            ret = a.value - b.value;
	                        }
	                        return ret;
	                    });
	                
	                    // Simplify the breaks
	                    inBrk = 0;
	                    start = min;

	                    for (i in breakArrayT) {
	                        brk = breakArrayT[i];
	                        inBrk += (brk.move === 'in' ? 1 : -1);

	                        if (inBrk === 1 && brk.move === 'in') {
	                            start = brk.value;
	                        }
	                        if (inBrk === 0) {
	                            breakArray.push({
	                                from: start,
	                                to: brk.value,
	                                len: brk.value - start - (brk.size || 0)
	                            });
	                            length += brk.value - start - (brk.size || 0);
	                        }
	                    }

	                    axis.breakArray = breakArray;

	                    fireEvent(axis, 'afterBreaks');
	                
	                    axis.transA *= ((max - axis.min) / (max - min - length));

	                    axis.min = min;
	                    axis.max = max;
	                };
	            }
	        });

	        wrap(Series.prototype, 'generatePoints', function (proceed) {

	            proceed.apply(this, stripArguments(arguments));

	            var series = this,
	                xAxis = series.xAxis,
	                yAxis = series.yAxis,
	                points = series.points,
	                point,
	                i = points.length,
	                connectNulls = series.options.connectNulls,
	                nullGap;


	            if (xAxis && yAxis && (xAxis.options.breaks || yAxis.options.breaks)) {
	                while (i--) {
	                    point = points[i];

	                    nullGap = point.y === null && connectNulls === false; // respect nulls inside the break (#4275)
	                    if (!nullGap && (xAxis.isInAnyBreak(point.x, true) || yAxis.isInAnyBreak(point.y, true))) {
	                        points.splice(i, 1);
	                        if (this.data[i]) {
	                            this.data[i].destroyElements(); // removes the graphics for this point if they exist
	                        }
	                    }
	                }
	            }

	        });

	        function drawPointsWrapped(proceed) {
	            proceed.apply(this);
	            this.drawBreaks();
	        }

	        H.Series.prototype.drawBreaks = function () {
	            var series = this,
	                points = series.points,
	                axis,
	                breaks,
	                threshold,
	                axisName = 'Axis',
	                eventName,
	                y;

	            each(['y', 'x'], function (key) {
	                axis = series[key + axisName];
	                breaks = axis.breakArray || [];
	                threshold = axis.isXAxis ? axis.min : pick(series.options.threshold, axis.min);
	                each(points, function (point) {
	                    y = pick(point['stack' + key.toUpperCase()], point[key]);
	                    each(breaks, function (brk) {
	                        eventName = false;

	                        if ((threshold < brk.from && y > brk.to) || (threshold > brk.from && y < brk.from)) { 
	                            eventName = 'pointBreak';
	                        } else if ((threshold < brk.from && y > brk.from && y < brk.to) || (threshold > brk.from && y > brk.to && y < brk.from)) { // point falls inside the break
	                            eventName = 'pointInBreak';
	                        } 
	                        if (eventName) {
	                            fireEvent(axis, eventName, { point: point, brk: brk });
	                        }
	                    });
	                });
	            });
	        };

	        wrap(H.seriesTypes.column.prototype, 'drawPoints', drawPointsWrapped);
	        wrap(H.Series.prototype, 'drawPoints', drawPointsWrapped);

	    }));
	    /* ****************************************************************************
	     * Start data grouping module                                                 *
	     ******************************************************************************/
	    var DATA_GROUPING = 'dataGrouping',
	        seriesProto = Series.prototype,
	        baseProcessData = seriesProto.processData,
	        baseGeneratePoints = seriesProto.generatePoints,
	        baseDestroy = seriesProto.destroy,

	        commonOptions = {
	            approximation: 'average', // average, open, high, low, close, sum
	            //enabled: null, // (true for stock charts, false for basic),
	            //forced: undefined,
	            groupPixelWidth: 2,
	            // the first one is the point or start value, the second is the start value if we're dealing with range,
	            // the third one is the end value if dealing with a range
	            dateTimeLabelFormats: {
	                millisecond: ['%A, %b %e, %H:%M:%S.%L', '%A, %b %e, %H:%M:%S.%L', '-%H:%M:%S.%L'],
	                second: ['%A, %b %e, %H:%M:%S', '%A, %b %e, %H:%M:%S', '-%H:%M:%S'],
	                minute: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
	                hour: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
	                day: ['%A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
	                week: ['Week from %A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
	                month: ['%B %Y', '%B', '-%B %Y'],
	                year: ['%Y', '%Y', '-%Y']
	            }
	            // smoothed = false, // enable this for navigator series only
	        },

	        specificOptions = { // extends common options
	            line: {},
	            spline: {},
	            area: {},
	            areaspline: {},
	            column: {
	                approximation: 'sum',
	                groupPixelWidth: 10
	            },
	            arearange: {
	                approximation: 'range'
	            },
	            areasplinerange: {
	                approximation: 'range'
	            },
	            columnrange: {
	                approximation: 'range',
	                groupPixelWidth: 10
	            },
	            candlestick: {
	                approximation: 'ohlc',
	                groupPixelWidth: 10
	            },
	            ohlc: {
	                approximation: 'ohlc',
	                groupPixelWidth: 5
	            }
	        },

	        // units are defined in a separate array to allow complete overriding in case of a user option
	        defaultDataGroupingUnits = [
	            [
	                'millisecond', // unit name
	                [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
	            ], [
	                'second',
	                [1, 2, 5, 10, 15, 30]
	            ], [
	                'minute',
	                [1, 2, 5, 10, 15, 30]
	            ], [
	                'hour',
	                [1, 2, 3, 4, 6, 8, 12]
	            ], [
	                'day',
	                [1]
	            ], [
	                'week',
	                [1]
	            ], [
	                'month',
	                [1, 3, 6]
	            ], [
	                'year',
	                null
	            ]
	        ],


	        /**
	         * Define the available approximation types. The data grouping approximations takes an array
	         * or numbers as the first parameter. In case of ohlc, four arrays are sent in as four parameters.
	         * Each array consists only of numbers. In case null values belong to the group, the property
	         * .hasNulls will be set to true on the array.
	         */
	        approximations = {
	            sum: function (arr) {
	                var len = arr.length,
	                    ret;

	                // 1. it consists of nulls exclusively
	                if (!len && arr.hasNulls) {
	                    ret = null;
	                // 2. it has a length and real values
	                } else if (len) {
	                    ret = 0;
	                    while (len--) {
	                        ret += arr[len];
	                    }
	                }
	                // 3. it has zero length, so just return undefined
	                // => doNothing()

	                return ret;
	            },
	            average: function (arr) {
	                var len = arr.length,
	                    ret = approximations.sum(arr);

	                // If we have a number, return it divided by the length. If not, return
	                // null or undefined based on what the sum method finds.
	                if (typeof ret === 'number' && len) {
	                    ret = ret / len;
	                }

	                return ret;
	            },
	            open: function (arr) {
	                return arr.length ? arr[0] : (arr.hasNulls ? null : UNDEFINED);
	            },
	            high: function (arr) {
	                return arr.length ? arrayMax(arr) : (arr.hasNulls ? null : UNDEFINED);
	            },
	            low: function (arr) {
	                return arr.length ? arrayMin(arr) : (arr.hasNulls ? null : UNDEFINED);
	            },
	            close: function (arr) {
	                return arr.length ? arr[arr.length - 1] : (arr.hasNulls ? null : UNDEFINED);
	            },
	            // ohlc and range are special cases where a multidimensional array is input and an array is output
	            ohlc: function (open, high, low, close) {
	                open = approximations.open(open);
	                high = approximations.high(high);
	                low = approximations.low(low);
	                close = approximations.close(close);

	                if (typeof open === 'number' || typeof high === 'number' || typeof low === 'number' || typeof close === 'number') {
	                    return [open, high, low, close];
	                }
	                // else, return is undefined
	            },
	            range: function (low, high) {
	                low = approximations.low(low);
	                high = approximations.high(high);

	                if (typeof low === 'number' || typeof high === 'number') {
	                    return [low, high];
	                }
	                // else, return is undefined
	            }
	        };


	    /**
	     * Takes parallel arrays of x and y data and groups the data into intervals defined by groupPositions, a collection
	     * of starting x values for each group.
	     */
	    seriesProto.groupData = function (xData, yData, groupPositions, approximation) {
	        var series = this,
	            data = series.data,
	            dataOptions = series.options.data,
	            groupedXData = [],
	            groupedYData = [],
	            dataLength = xData.length,
	            pointX,
	            pointY,
	            groupedY,
	            handleYData = !!yData, // when grouping the fake extended axis for panning, we don't need to consider y
	            values = [[], [], [], []],
	            approximationFn = typeof approximation === 'function' ? approximation : approximations[approximation],
	            pointArrayMap = series.pointArrayMap,
	            pointArrayMapLength = pointArrayMap && pointArrayMap.length,
	            i;

	        // Start with the first point within the X axis range (#2696)
	        for (i = 0; i <= dataLength; i++) {
	            if (xData[i] >= groupPositions[0]) {
	                break;
	            }
	        }

	        for (i; i <= dataLength; i++) {

	            // when a new group is entered, summarize and initiate the previous group
	            while ((groupPositions[1] !== UNDEFINED && xData[i] >= groupPositions[1]) ||
	                    i === dataLength) { // get the last group

	                // get group x and y
	                pointX = groupPositions.shift();
	                groupedY = approximationFn.apply(0, values);

	                // push the grouped data
	                if (groupedY !== UNDEFINED) {
	                    groupedXData.push(pointX);
	                    groupedYData.push(groupedY);
	                }

	                // reset the aggregate arrays
	                values[0] = [];
	                values[1] = [];
	                values[2] = [];
	                values[3] = [];

	                // don't loop beyond the last group
	                if (i === dataLength) {
	                    break;
	                }
	            }

	            // break out
	            if (i === dataLength) {
	                break;
	            }

	            // for each raw data point, push it to an array that contains all values for this specific group
	            if (pointArrayMap) {

	                var index = series.cropStart + i,
	                    point = (data && data[index]) || series.pointClass.prototype.applyOptions.apply({ series: series }, [dataOptions[index]]),
	                    j,
	                    val;

	                for (j = 0; j < pointArrayMapLength; j++) {
	                    val = point[pointArrayMap[j]];
	                    if (typeof val === 'number') {
	                        values[j].push(val);
	                    } else if (val === null) {
	                        values[j].hasNulls = true;
	                    }
	                }

	            } else {
	                pointY = handleYData ? yData[i] : null;

	                if (typeof pointY === 'number') {
	                    values[0].push(pointY);
	                } else if (pointY === null) {
	                    values[0].hasNulls = true;
	                }
	            }
	        }

	        return [groupedXData, groupedYData];
	    };

	    /**
	     * Extend the basic processData method, that crops the data to the current zoom
	     * range, with data grouping logic.
	     */
	    seriesProto.processData = function () {
	        var series = this,
	            chart = series.chart,
	            options = series.options,
	            dataGroupingOptions = options[DATA_GROUPING],
	            groupingEnabled = series.allowDG !== false && dataGroupingOptions && pick(dataGroupingOptions.enabled, chart.options._stock),
	            hasGroupedData,
	            skip;

	        // run base method
	        series.forceCrop = groupingEnabled; // #334
	        series.groupPixelWidth = null; // #2110
	        series.hasProcessed = true; // #2692

	        // skip if processData returns false or if grouping is disabled (in that order)
	        skip = baseProcessData.apply(series, arguments) === false || !groupingEnabled;
	        if (!skip) {
	            series.destroyGroupedData();

	            var i,
	                processedXData = series.processedXData,
	                processedYData = series.processedYData,
	                plotSizeX = chart.plotSizeX,
	                xAxis = series.xAxis,
	                ordinal = xAxis.options.ordinal,
	                groupPixelWidth = series.groupPixelWidth = xAxis.getGroupPixelWidth && xAxis.getGroupPixelWidth();

	            // Execute grouping if the amount of points is greater than the limit defined in groupPixelWidth
	            if (groupPixelWidth) {
	                hasGroupedData = true;

	                series.points = null; // force recreation of point instances in series.translate

	                var extremes = xAxis.getExtremes(),
	                    xMin = extremes.min,
	                    xMax = extremes.max,
	                    groupIntervalFactor = (ordinal && xAxis.getGroupIntervalFactor(xMin, xMax, series)) || 1,
	                    interval = (groupPixelWidth * (xMax - xMin) / plotSizeX) * groupIntervalFactor,
	                    groupPositions = xAxis.getTimeTicks(
	                        xAxis.normalizeTimeTickInterval(interval, dataGroupingOptions.units || defaultDataGroupingUnits),
	                        Math.min(xMin, processedXData[0]), // Processed data may extend beyond axis (#4907)
	                        Math.max(xMax, processedXData[processedXData.length - 1]),
	                        xAxis.options.startOfWeek,
	                        processedXData,
	                        series.closestPointRange
	                    ),
	                    groupedXandY = seriesProto.groupData.apply(series, [processedXData, processedYData, groupPositions, dataGroupingOptions.approximation]),
	                    groupedXData = groupedXandY[0],
	                    groupedYData = groupedXandY[1];

	                // prevent the smoothed data to spill out left and right, and make
	                // sure data is not shifted to the left
	                if (dataGroupingOptions.smoothed) {
	                    i = groupedXData.length - 1;
	                    groupedXData[i] = Math.min(groupedXData[i], xMax);
	                    while (i-- && i > 0) {
	                        groupedXData[i] += interval / 2;
	                    }
	                    groupedXData[0] = Math.max(groupedXData[0], xMin);
	                }

	                // record what data grouping values were used
	                series.currentDataGrouping = groupPositions.info;
	                series.closestPointRange = groupPositions.info.totalRange;

	                // Make sure the X axis extends to show the first group (#2533)
	                if (defined(groupedXData[0]) && groupedXData[0] < xAxis.dataMin) {
	                    if (xAxis.min === xAxis.dataMin) {
	                        xAxis.min = groupedXData[0];
	                    }
	                    xAxis.dataMin = groupedXData[0];
	                }

	                // set series props
	                series.processedXData = groupedXData;
	                series.processedYData = groupedYData;
	            } else {
	                series.currentDataGrouping = null;
	            }
	            series.hasGroupedData = hasGroupedData;
	        }
	    };

	    /**
	     * Destroy the grouped data points. #622, #740
	     */
	    seriesProto.destroyGroupedData = function () {

	        var groupedData = this.groupedData;

	        // clear previous groups
	        each(groupedData || [], function (point, i) {
	            if (point) {
	                groupedData[i] = point.destroy ? point.destroy() : null;
	            }
	        });
	        this.groupedData = null;
	    };

	    /**
	     * Override the generatePoints method by adding a reference to grouped data
	     */
	    seriesProto.generatePoints = function () {

	        baseGeneratePoints.apply(this);

	        // record grouped data in order to let it be destroyed the next time processData runs
	        this.destroyGroupedData(); // #622
	        this.groupedData = this.hasGroupedData ? this.points : null;
	    };

	    /**
	     * Extend the original method, make the tooltip's header reflect the grouped range
	     */
	    wrap(Tooltip.prototype, 'tooltipFooterHeaderFormatter', function (proceed, point, isFooter) {
	        var tooltip = this,
	            series = point.series,
	            options = series.options,
	            tooltipOptions = series.tooltipOptions,
	            dataGroupingOptions = options.dataGrouping,
	            xDateFormat = tooltipOptions.xDateFormat,
	            xDateFormatEnd,
	            xAxis = series.xAxis,
	            currentDataGrouping,
	            dateTimeLabelFormats,
	            labelFormats,
	            formattedKey;

	        // apply only to grouped series
	        if (xAxis && xAxis.options.type === 'datetime' && dataGroupingOptions && isNumber(point.key)) {

	            // set variables
	            currentDataGrouping = series.currentDataGrouping;
	            dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats;

	            // if we have grouped data, use the grouping information to get the right format
	            if (currentDataGrouping) {
	                labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];
	                if (currentDataGrouping.count === 1) {
	                    xDateFormat = labelFormats[0];
	                } else {
	                    xDateFormat = labelFormats[1];
	                    xDateFormatEnd = labelFormats[2];
	                }
	            // if not grouped, and we don't have set the xDateFormat option, get the best fit,
	            // so if the least distance between points is one minute, show it, but if the
	            // least distance is one day, skip hours and minutes etc.
	            } else if (!xDateFormat && dateTimeLabelFormats) {
	                xDateFormat = tooltip.getXDateFormat(point, tooltipOptions, xAxis);
	            }

	            // now format the key
	            formattedKey = dateFormat(xDateFormat, point.key);
	            if (xDateFormatEnd) {
	                formattedKey += dateFormat(xDateFormatEnd, point.key + currentDataGrouping.totalRange - 1);
	            }

	            // return the replaced format
	            return format(tooltipOptions[(isFooter ? 'footer' : 'header') + 'Format'], {
	                point: extend(point, { key: formattedKey }),
	                series: series
	            });
	    
	        }

	        // else, fall back to the regular formatter
	        return proceed.call(tooltip, point, isFooter);
	    });

	    /**
	     * Extend the series destroyer
	     */
	    seriesProto.destroy = function () {
	        var series = this,
	            groupedData = series.groupedData || [],
	            i = groupedData.length;

	        while (i--) {
	            if (groupedData[i]) {
	                groupedData[i].destroy();
	            }
	        }
	        baseDestroy.apply(series);
	    };


	    // Handle default options for data grouping. This must be set at runtime because some series types are
	    // defined after this.
	    wrap(seriesProto, 'setOptions', function (proceed, itemOptions) {

	        var options = proceed.call(this, itemOptions),
	            type = this.type,
	            plotOptions = this.chart.options.plotOptions,
	            defaultOptions = defaultPlotOptions[type].dataGrouping;

	        if (specificOptions[type]) { // #1284
	            if (!defaultOptions) {
	                defaultOptions = merge(commonOptions, specificOptions[type]);
	            }

	            options.dataGrouping = merge(
	                defaultOptions,
	                plotOptions.series && plotOptions.series.dataGrouping, // #1228
	                plotOptions[type].dataGrouping, // Set by the StockChart constructor
	                itemOptions.dataGrouping
	            );
	        }

	        if (this.chart.options._stock) {
	            this.requireSorting = true;
	        }

	        return options;
	    });


	    /**
	     * When resetting the scale reset the hasProccessed flag to avoid taking previous data grouping
	     * of neighbour series into accound when determining group pixel width (#2692).
	     */
	    wrap(Axis.prototype, 'setScale', function (proceed) {
	        proceed.call(this);
	        each(this.series, function (series) {
	            series.hasProcessed = false;
	        });
	    });

	    /**
	     * Get the data grouping pixel width based on the greatest defined individual width
	     * of the axis' series, and if whether one of the axes need grouping.
	     */
	    Axis.prototype.getGroupPixelWidth = function () {

	        var series = this.series,
	            len = series.length,
	            i,
	            groupPixelWidth = 0,
	            doGrouping = false,
	            dataLength,
	            dgOptions;

	        // If multiple series are compared on the same x axis, give them the same
	        // group pixel width (#334)
	        i = len;
	        while (i--) {
	            dgOptions = series[i].options.dataGrouping;
	            if (dgOptions) {
	                groupPixelWidth = mathMax(groupPixelWidth, dgOptions.groupPixelWidth);

	            }
	        }

	        // If one of the series needs grouping, apply it to all (#1634)
	        i = len;
	        while (i--) {
	            dgOptions = series[i].options.dataGrouping;

	            if (dgOptions && series[i].hasProcessed) { // #2692

	                dataLength = (series[i].processedXData || series[i].data).length;

	                // Execute grouping if the amount of points is greater than the limit defined in groupPixelWidth
	                if (series[i].groupPixelWidth || dataLength > (this.chart.plotSizeX / groupPixelWidth) || (dataLength && dgOptions.forced)) {
	                    doGrouping = true;
	                }
	            }
	        }

	        return doGrouping ? groupPixelWidth : 0;
	    };

	    /**
	     * Force data grouping on all the axis' series.
	     */
	    Axis.prototype.setDataGrouping = function (dataGrouping, redraw) {
	        var i;

	        redraw = pick(redraw, true);

	        if (!dataGrouping) {
	            dataGrouping = {
	                forced: false,
	                units: null
	            };
	        }

	        // Axis is instantiated, update all series
	        if (this instanceof Axis) {
	            i = this.series.length;
	            while (i--) {
	                this.series[i].update({
	                    dataGrouping: dataGrouping
	                }, false);
	            }

	        // Axis not yet instanciated, alter series options
	        } else {
	            each(this.chart.options.series, function (seriesOptions) {
	                seriesOptions.dataGrouping = dataGrouping;
	            }, false);
	        }

	        if (redraw) {
	            this.chart.redraw();
	        }
	    };



	    /* ****************************************************************************
	     * End data grouping module                                                   *
	     ******************************************************************************/
	    /* ****************************************************************************
	     * Start OHLC series code                                                     *
	     *****************************************************************************/

	    // 1 - Set default options
	    defaultPlotOptions.ohlc = merge(defaultPlotOptions.column, {
	        lineWidth: 1,
	        tooltip: {
	            pointFormat: '<span style="color:{point.color}">\u25CF</span> <b> {series.name}</b><br/>' +
	                'Open: {point.open}<br/>' +
	                'High: {point.high}<br/>' +
	                'Low: {point.low}<br/>' +
	                'Close: {point.close}<br/>'
	        },
	        states: {
	            hover: {
	                lineWidth: 3
	            }
	        },
	        threshold: null
	        //upColor: undefined
	    });

	    // 2 - Create the OHLCSeries object
	    var OHLCSeries = extendClass(seriesTypes.column, {
	        type: 'ohlc',
	        pointArrayMap: ['open', 'high', 'low', 'close'], // array point configs are mapped to this
	        toYData: function (point) { // return a plain array for speedy calculation
	            return [point.open, point.high, point.low, point.close];
	        },
	        pointValKey: 'high',

	        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
	            stroke: 'color',
	            'stroke-width': 'lineWidth'
	        },
	        upColorProp: 'stroke',

	        /**
	         * Postprocess mapping between options and SVG attributes
	         */
	        getAttribs: function () {
	            seriesTypes.column.prototype.getAttribs.apply(this, arguments);
	            var series = this,
	                options = series.options,
	                stateOptions = options.states,
	                upColor = options.upColor || series.color,
	                seriesDownPointAttr = merge(series.pointAttr),
	                upColorProp = series.upColorProp;

	            seriesDownPointAttr[''][upColorProp] = upColor;
	            seriesDownPointAttr.hover[upColorProp] = stateOptions.hover.upColor || upColor;
	            seriesDownPointAttr.select[upColorProp] = stateOptions.select.upColor || upColor;

	            each(series.points, function (point) {
	                if (point.open < point.close && !point.options.color) {
	                    point.pointAttr = seriesDownPointAttr;
	                }
	            });
	        },

	        /**
	         * Translate data points from raw values x and y to plotX and plotY
	         */
	        translate: function () {
	            var series = this,
	                yAxis = series.yAxis;

	            seriesTypes.column.prototype.translate.apply(series);

	            // do the translation
	            each(series.points, function (point) {
	                // the graphics
	                if (point.open !== null) {
	                    point.plotOpen = yAxis.translate(point.open, 0, 1, 0, 1);
	                }
	                if (point.close !== null) {
	                    point.plotClose = yAxis.translate(point.close, 0, 1, 0, 1);
	                }

	            });
	        },

	        /**
	         * Draw the data points
	         */
	        drawPoints: function () {
	            var series = this,
	                points = series.points,
	                chart = series.chart,
	                pointAttr,
	                plotOpen,
	                plotClose,
	                crispCorr,
	                halfWidth,
	                path,
	                graphic,
	                crispX;


	            each(points, function (point) {
	                if (point.plotY !== UNDEFINED) {

	                    graphic = point.graphic;
	                    pointAttr = point.pointAttr[point.selected ? 'selected' : ''] || series.pointAttr[NORMAL_STATE];

	                    // crisp vector coordinates
	                    crispCorr = (pointAttr['stroke-width'] % 2) / 2;
	                    crispX = mathRound(point.plotX) - crispCorr;  // #2596
	                    halfWidth = mathRound(point.shapeArgs.width / 2);

	                    // the vertical stem
	                    path = [
	                        'M',
	                        crispX, mathRound(point.yBottom),
	                        'L',
	                        crispX, mathRound(point.plotY)
	                    ];

	                    // open
	                    if (point.open !== null) {
	                        plotOpen = mathRound(point.plotOpen) + crispCorr;
	                        path.push(
	                            'M',
	                            crispX,
	                            plotOpen,
	                            'L',
	                            crispX - halfWidth,
	                            plotOpen
	                        );
	                    }

	                    // close
	                    if (point.close !== null) {
	                        plotClose = mathRound(point.plotClose) + crispCorr;
	                        path.push(
	                            'M',
	                            crispX,
	                            plotClose,
	                            'L',
	                            crispX + halfWidth,
	                            plotClose
	                        );
	                    }

	                    // create and/or update the graphic
	                    if (graphic) {
	                        graphic
	                            .attr(pointAttr) // #3897
	                            .animate({ d: path });
	                    } else {
	                        point.graphic = chart.renderer.path(path)
	                            .attr(pointAttr)
	                            .add(series.group);
	                    }

	                }


	            });

	        },

	        /**
	         * Disable animation
	         */
	        animate: null


	    });
	    seriesTypes.ohlc = OHLCSeries;
	    /* ****************************************************************************
	     * End OHLC series code                                                       *
	     *****************************************************************************/
	    /* ****************************************************************************
	     * Start Candlestick series code                                              *
	     *****************************************************************************/

	    // 1 - set default options
	    defaultPlotOptions.candlestick = merge(defaultPlotOptions.column, {
	        lineColor: 'black',
	        lineWidth: 1,
	        states: {
	            hover: {
	                lineWidth: 2
	            }
	        },
	        tooltip: defaultPlotOptions.ohlc.tooltip,
	        threshold: null,
	        upColor: 'white'
	        // upLineColor: null
	    });

	    // 2 - Create the CandlestickSeries object
	    var CandlestickSeries = extendClass(OHLCSeries, {
	        type: 'candlestick',

	        /**
	         * One-to-one mapping from options to SVG attributes
	         */
	        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
	            fill: 'color',
	            stroke: 'lineColor',
	            'stroke-width': 'lineWidth'
	        },
	        upColorProp: 'fill',

	        /**
	         * Postprocess mapping between options and SVG attributes
	         */
	        getAttribs: function () {
	            seriesTypes.ohlc.prototype.getAttribs.apply(this, arguments);
	            var series = this,
	                options = series.options,
	                stateOptions = options.states,
	                upLineColor = options.upLineColor || options.lineColor,
	                hoverStroke = stateOptions.hover.upLineColor || upLineColor,
	                selectStroke = stateOptions.select.upLineColor || upLineColor;

	            // Add custom line color for points going up (close > open).
	            // Fill is handled by OHLCSeries' getAttribs.
	            each(series.points, function (point) {
	                if (point.open < point.close) {

	                    // If an individual line color is set, we need to merge the
	                    // point attributes, because they are shared between all up
	                    // points by inheritance from OHCLSeries.
	                    if (point.lineColor) {
	                        point.pointAttr = merge(point.pointAttr);
	                        upLineColor = point.lineColor;
	                    }

	                    point.pointAttr[''].stroke = upLineColor;
	                    point.pointAttr.hover.stroke = hoverStroke;
	                    point.pointAttr.select.stroke = selectStroke;
	                }
	            });
	        },

	        /**
	         * Draw the data points
	         */
	        drawPoints: function () {
	            var series = this,  //state = series.state,
	                points = series.points,
	                chart = series.chart,
	                pointAttr,
	                seriesPointAttr = series.pointAttr[''],
	                plotOpen,
	                plotClose,
	                topBox,
	                bottomBox,
	                hasTopWhisker,
	                hasBottomWhisker,
	                crispCorr,
	                crispX,
	                graphic,
	                path,
	                halfWidth;


	            each(points, function (point) {

	                graphic = point.graphic;
	                if (point.plotY !== UNDEFINED) {

	                    pointAttr = point.pointAttr[point.selected ? 'selected' : ''] || seriesPointAttr;

	                    // crisp vector coordinates
	                    crispCorr = (pointAttr['stroke-width'] % 2) / 2;
	                    crispX = mathRound(point.plotX) - crispCorr; // #2596
	                    plotOpen = point.plotOpen;
	                    plotClose = point.plotClose;
	                    topBox = math.min(plotOpen, plotClose);
	                    bottomBox = math.max(plotOpen, plotClose);
	                    halfWidth = mathRound(point.shapeArgs.width / 2);
	                    hasTopWhisker = mathRound(topBox) !== mathRound(point.plotY);
	                    hasBottomWhisker = bottomBox !== point.yBottom;
	                    topBox = mathRound(topBox) + crispCorr;
	                    bottomBox = mathRound(bottomBox) + crispCorr;

	                    // create the path
	                    path = [
	                        'M',
	                        crispX - halfWidth, bottomBox,
	                        'L',
	                        crispX - halfWidth, topBox,
	                        'L',
	                        crispX + halfWidth, topBox,
	                        'L',
	                        crispX + halfWidth, bottomBox,
	                        'Z', // Use a close statement to ensure a nice rectangle #2602
	                        'M',
	                        crispX, topBox,
	                        'L',
	                        crispX, hasTopWhisker ? mathRound(point.plotY) : topBox, // #460, #2094
	                        'M',
	                        crispX, bottomBox,
	                        'L',
	                        crispX, hasBottomWhisker ? mathRound(point.yBottom) : bottomBox // #460, #2094
	                    ];

	                    if (graphic) {
	                        graphic
	                            .attr(pointAttr) // #3897
	                            .animate({ d: path });
	                    } else {
	                        point.graphic = chart.renderer.path(path)
	                            .attr(pointAttr)
	                            .add(series.group)
	                            .shadow(series.options.shadow);
	                    }

	                }
	            });

	        }


	    });

	    seriesTypes.candlestick = CandlestickSeries;

	    /* ****************************************************************************
	     * End Candlestick series code                                                *
	     *****************************************************************************/
	    /* ****************************************************************************
	     * Start Flags series code                                                    *
	     *****************************************************************************/

	    var symbols = SVGRenderer.prototype.symbols;

	    // 1 - set default options
	    defaultPlotOptions.flags = merge(defaultPlotOptions.column, {
	        fillColor: 'white',
	        lineWidth: 1,
	        pointRange: 0, // #673
	        //radius: 2,
	        shape: 'flag',
	        stackDistance: 12,
	        states: {
	            hover: {
	                lineColor: 'black',
	                fillColor: '#FCFFC5'
	            }
	        },
	        style: {
	            fontSize: '11px',
	            fontWeight: 'bold',
	            textAlign: 'center'
	        },
	        tooltip: {
	            pointFormat: '{point.text}<br/>'
	        },
	        threshold: null,
	        y: -30
	    });

	    // 2 - Create the CandlestickSeries object
	    seriesTypes.flags = extendClass(seriesTypes.column, {
	        type: 'flags',
	        sorted: false,
	        noSharedTooltip: true,
	        allowDG: false,
	        takeOrdinalPosition: false, // #1074
	        trackerGroups: ['markerGroup'],
	        forceCrop: true,
	        /**
	         * Inherit the initialization from base Series
	         */
	        init: Series.prototype.init,

	        /**
	         * One-to-one mapping from options to SVG attributes
	         */
	        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
	            fill: 'fillColor',
	            stroke: 'color',
	            'stroke-width': 'lineWidth',
	            r: 'radius'
	        },

	        /**
	         * Extend the translate method by placing the point on the related series
	         */
	        translate: function () {

	            seriesTypes.column.prototype.translate.apply(this);

	            var series = this,
	                options = series.options,
	                chart = series.chart,
	                points = series.points,
	                cursor = points.length - 1,
	                point,
	                lastPoint,
	                optionsOnSeries = options.onSeries,
	                onSeries = optionsOnSeries && chart.get(optionsOnSeries),
	                onKey = options.onKey || 'y',
	                step = onSeries && onSeries.options.step,
	                onData = onSeries && onSeries.points,
	                i = onData && onData.length,
	                xAxis = series.xAxis,
	                xAxisExt = xAxis.getExtremes(),
	                leftPoint,
	                lastX,
	                rightPoint,
	                currentDataGrouping;

	            // relate to a master series
	            if (onSeries && onSeries.visible && i) {
	                currentDataGrouping = onSeries.currentDataGrouping;
	                lastX = onData[i - 1].x + (currentDataGrouping ? currentDataGrouping.totalRange : 0); // #2374

	                // sort the data points
	                points.sort(function (a, b) {
	                    return (a.x - b.x);
	                });

	                onKey = 'plot' + onKey[0].toUpperCase() + onKey.substr(1);
	                while (i-- && points[cursor]) {
	                    point = points[cursor];
	                    leftPoint = onData[i];
	                    if (leftPoint.x <= point.x && leftPoint[onKey] !== undefined) {
	                        if (point.x <= lastX) { // #803

	                            point.plotY = leftPoint[onKey];

	                            // interpolate between points, #666
	                            if (leftPoint.x < point.x && !step) {
	                                rightPoint = onData[i + 1];
	                                if (rightPoint && rightPoint[onKey] !== UNDEFINED) {
	                                    point.plotY +=
	                                        ((point.x - leftPoint.x) / (rightPoint.x - leftPoint.x)) * // the distance ratio, between 0 and 1
	                                        (rightPoint[onKey] - leftPoint[onKey]); // the y distance
	                                }
	                            }
	                        }
	                        cursor--;
	                        i++; // check again for points in the same x position
	                        if (cursor < 0) {
	                            break;
	                        }
	                    }
	                }
	            }

	            // Add plotY position and handle stacking
	            each(points, function (point, i) {

	                var stackIndex;

	                // Undefined plotY means the point is either on axis, outside series range or hidden series.
	                // If the series is outside the range of the x axis it should fall through with
	                // an undefined plotY, but then we must remove the shapeArgs (#847).
	                if (point.plotY === UNDEFINED) {
	                    if (point.x >= xAxisExt.min && point.x <= xAxisExt.max) { // we're inside xAxis range
	                        point.plotY = chart.chartHeight - xAxis.bottom - (xAxis.opposite ? xAxis.height : 0) + xAxis.offset - chart.plotTop;
	                    } else {
	                        point.shapeArgs = {}; // 847
	                    }
	                }
	                // if multiple flags appear at the same x, order them into a stack
	                lastPoint = points[i - 1];
	                if (lastPoint && lastPoint.plotX === point.plotX) {
	                    if (lastPoint.stackIndex === UNDEFINED) {
	                        lastPoint.stackIndex = 0;
	                    }
	                    stackIndex = lastPoint.stackIndex + 1;
	                }
	                point.stackIndex = stackIndex; // #3639
	            });


	        },

	        /**
	         * Draw the markers
	         */
	        drawPoints: function () {
	            var series = this,
	                pointAttr,
	                seriesPointAttr = series.pointAttr[''],
	                points = series.points,
	                chart = series.chart,
	                renderer = chart.renderer,
	                plotX,
	                plotY,
	                options = series.options,
	                optionsY = options.y,
	                shape,
	                i,
	                point,
	                graphic,
	                stackIndex,
	                anchorX,
	                anchorY,
	                outsideRight;

	            i = points.length;
	            while (i--) {
	                point = points[i];
	                outsideRight = point.plotX > series.xAxis.len;
	                plotX = point.plotX;
	                if (plotX > 0) { // #3119
	                    plotX -= pick(point.lineWidth, options.lineWidth) % 2; // #4285
	                }
	                stackIndex = point.stackIndex;
	                shape = point.options.shape || options.shape;
	                plotY = point.plotY;
	                if (plotY !== UNDEFINED) {
	                    plotY = point.plotY + optionsY - (stackIndex !== UNDEFINED && stackIndex * options.stackDistance);
	                }
	                anchorX = stackIndex ? UNDEFINED : point.plotX; // skip connectors for higher level stacked points
	                anchorY = stackIndex ? UNDEFINED : point.plotY;

	                graphic = point.graphic;

	                // only draw the point if y is defined and the flag is within the visible area
	                if (plotY !== UNDEFINED && plotX >= 0 && !outsideRight) {
	                    // shortcuts
	                    pointAttr = point.pointAttr[point.selected ? 'select' : ''] || seriesPointAttr;
	                    if (graphic) { // update
	                        graphic.attr({
	                            x: plotX,
	                            y: plotY,
	                            r: pointAttr.r,
	                            anchorX: anchorX,
	                            anchorY: anchorY
	                        });
	                    } else {
	                        graphic = point.graphic = renderer.label(
	                            point.options.title || options.title || 'A',
	                            plotX,
	                            plotY,
	                            shape,
	                            anchorX,
	                            anchorY,
	                            options.useHTML
	                        )
	                        .css(merge(options.style, point.style))
	                        .attr(pointAttr)
	                        .attr({
	                            align: shape === 'flag' ? 'left' : 'center',
	                            width: options.width,
	                            height: options.height
	                        })
	                        .add(series.markerGroup)
	                        .shadow(options.shadow);

	                    }

	                    // Set the tooltip anchor position
	                    point.tooltipPos = [plotX, plotY];

	                } else if (graphic) {
	                    point.graphic = graphic.destroy();
	                }

	            }

	        },

	        /**
	         * Extend the column trackers with listeners to expand and contract stacks
	         */
	        drawTracker: function () {
	            var series = this,
	                points = series.points;

	            TrackerMixin.drawTrackerPoint.apply(this);

	            // Bring each stacked flag up on mouse over, this allows readability of vertically
	            // stacked elements as well as tight points on the x axis. #1924.
	            each(points, function (point) {
	                var graphic = point.graphic;
	                if (graphic) {
	                    addEvent(graphic.element, 'mouseover', function () {

	                        // Raise this point
	                        if (point.stackIndex > 0 && !point.raised) {
	                            point._y = graphic.y;
	                            graphic.attr({
	                                y: point._y - 8
	                            });
	                            point.raised = true;
	                        }

	                        // Revert other raised points
	                        each(points, function (otherPoint) {
	                            if (otherPoint !== point && otherPoint.raised && otherPoint.graphic) {
	                                otherPoint.graphic.attr({
	                                    y: otherPoint._y
	                                });
	                                otherPoint.raised = false;
	                            }
	                        });
	                    });
	                }
	            });
	        },

	        /**
	         * Disable animation
	         */
	        animate: noop,
	        buildKDTree: noop,
	        setClip: noop

	    });

	    // create the flag icon with anchor
	    symbols.flag = function (x, y, w, h, options) {
	        var anchorX = (options && options.anchorX) || x,
	            anchorY = (options &&  options.anchorY) || y;

	        return [
	            'M', anchorX, anchorY,
	            'L', x, y + h,
	            x, y,
	            x + w, y,
	            x + w, y + h,
	            x, y + h,
	            'Z'
	        ];
	    };

	    // create the circlepin and squarepin icons with anchor
	    each(['circle', 'square'], function (shape) {
	        symbols[shape + 'pin'] = function (x, y, w, h, options) {

	            var anchorX = options && options.anchorX,
	                anchorY = options &&  options.anchorY,
	                path,
	                labelTopOrBottomY;

	            // For single-letter flags, make sure circular flags are not taller than their width
	            if (shape === 'circle' && h > w) {
	                x -= mathRound((h - w) / 2);
	                w = h;
	            }

	            path = symbols[shape](x, y, w, h);

	            if (anchorX && anchorY) {
	                // if the label is below the anchor, draw the connecting line from the top edge of the label
	                // otherwise start drawing from the bottom edge
	                labelTopOrBottomY = (y > anchorY) ? y : y + h;
	                path.push('M', anchorX, labelTopOrBottomY, 'L', anchorX, anchorY);
	            }

	            return path;
	        };
	    });

	    // The symbol callbacks are generated on the SVGRenderer object in all browsers. Even
	    // VML browsers need this in order to generate shapes in export. Now share
	    // them with the VMLRenderer.
	    if (Renderer === Highcharts.VMLRenderer) {
	        each(['flag', 'circlepin', 'squarepin'], function (shape) {
	            VMLRenderer.prototype.symbols[shape] = symbols[shape];
	        });
	    }

	    /* ****************************************************************************
	     * End Flags series code                                                      *
	     *****************************************************************************/
	    /* ****************************************************************************
	     * Start Scroller code                                                        *
	     *****************************************************************************/
	    var units = [].concat(defaultDataGroupingUnits), // copy
	        defaultSeriesType,

	        // Finding the min or max of a set of variables where we don't know if they are defined,
	        // is a pattern that is repeated several places in Highcharts. Consider making this
	        // a global utility method.
	        numExt = function (extreme) {
	            var numbers = grep(arguments, function (n) {
	                return typeof n === 'number';
	            });
	            if (numbers.length) {
	                return Math[extreme].apply(0, numbers);
	            }
	        };

	    // add more resolution to units
	    units[4] = ['day', [1, 2, 3, 4]]; // allow more days
	    units[5] = ['week', [1, 2, 3]]; // allow more weeks

	    defaultSeriesType = seriesTypes.areaspline === UNDEFINED ? 'line' : 'areaspline';

	    extend(defaultOptions, {
	        navigator: {
	            //enabled: true,
	            handles: {
	                backgroundColor: '#ebe7e8',
	                borderColor: '#b2b1b6'
	            },
	            height: 40,
	            margin: 25,
	            maskFill: 'rgba(128,179,236,0.3)',
	            maskInside: true,
	            outlineColor: '#b2b1b6',
	            outlineWidth: 1,
	            series: {
	                type: defaultSeriesType,
	                color: '#4572A7',
	                compare: null,
	                fillOpacity: 0.05,
	                dataGrouping: {
	                    approximation: 'average',
	                    enabled: true,
	                    groupPixelWidth: 2,
	                    smoothed: true,
	                    units: units
	                },
	                dataLabels: {
	                    enabled: false,
	                    zIndex: 2 // #1839
	                },
	                id: PREFIX + 'navigator-series',
	                lineColor: null, // Allow color setting while disallowing default candlestick setting (#4602)
	                lineWidth: 1,
	                marker: {
	                    enabled: false
	                },
	                pointRange: 0,
	                shadow: false,
	                threshold: null
	            },
	            //top: undefined,
	            xAxis: {
	                tickWidth: 0,
	                lineWidth: 0,
	                gridLineColor: '#EEE',
	                gridLineWidth: 1,
	                tickPixelInterval: 200,
	                labels: {
	                    align: 'left',
	                    style: {
	                        color: '#888'
	                    },
	                    x: 3,
	                    y: -4
	                },
	                crosshair: false
	            },
	            yAxis: {
	                gridLineWidth: 0,
	                startOnTick: false,
	                endOnTick: false,
	                minPadding: 0.1,
	                maxPadding: 0.1,
	                labels: {
	                    enabled: false
	                },
	                crosshair: false,
	                title: {
	                    text: null
	                },
	                tickWidth: 0
	            }
	        },
	        scrollbar: {
	            //enabled: true
	            height: isTouchDevice ? 20 : 14,
	            barBackgroundColor: '#bfc8d1',
	            barBorderRadius: 0,
	            barBorderWidth: 1,
	            barBorderColor: '#bfc8d1',
	            buttonArrowColor: '#666',
	            buttonBackgroundColor: '#ebe7e8',
	            buttonBorderColor: '#bbb',
	            buttonBorderRadius: 0,
	            buttonBorderWidth: 1,
	            minWidth: 6,
	            rifleColor: '#666',
	            trackBackgroundColor: '#eeeeee',
	            trackBorderColor: '#eeeeee',
	            trackBorderWidth: 1,
	            // trackBorderRadius: 0
	            liveRedraw: hasSVG && !isTouchDevice
	        }
	    });

	    /**
	     * The Scroller class
	     * @param {Object} chart
	     */
	    function Scroller(chart) {
	        var chartOptions = chart.options,
	            navigatorOptions = chartOptions.navigator,
	            navigatorEnabled = navigatorOptions.enabled,
	            scrollbarOptions = chartOptions.scrollbar,
	            scrollbarEnabled = scrollbarOptions.enabled,
	            height = navigatorEnabled ? navigatorOptions.height : 0,
	            scrollbarHeight = scrollbarEnabled ? scrollbarOptions.height : 0;


	        this.handles = [];
	        this.scrollbarButtons = [];
	        this.elementsToDestroy = []; // Array containing the elements to destroy when Scroller is destroyed

	        this.chart = chart;
	        this.setBaseSeries();

	        this.height = height;
	        this.scrollbarHeight = scrollbarHeight;
	        this.scrollbarEnabled = scrollbarEnabled;
	        this.navigatorEnabled = navigatorEnabled;
	        this.navigatorOptions = navigatorOptions;
	        this.scrollbarOptions = scrollbarOptions;
	        this.outlineHeight = height + scrollbarHeight;

	        // Run scroller
	        this.init();
	    }

	    Scroller.prototype = {
	        /**
	         * Draw one of the handles on the side of the zoomed range in the navigator
	         * @param {Number} x The x center for the handle
	         * @param {Number} index 0 for left and 1 for right
	         */
	        drawHandle: function (x, index) {
	            var scroller = this,
	                chart = scroller.chart,
	                renderer = chart.renderer,
	                elementsToDestroy = scroller.elementsToDestroy,
	                handles = scroller.handles,
	                handlesOptions = scroller.navigatorOptions.handles,
	                attr = {
	                    fill: handlesOptions.backgroundColor,
	                    stroke: handlesOptions.borderColor,
	                    'stroke-width': 1
	                },
	                tempElem;

	            // create the elements
	            if (!scroller.rendered) {
	                // the group
	                handles[index] = renderer.g('navigator-handle-' + ['left', 'right'][index])
	                    .css({ cursor: 'ew-resize' })
	                    .attr({ zIndex: 10 - index }) // zIndex = 3 for right handle, 4 for left / 10 - #2908
	                    .add();

	                // the rectangle
	                tempElem = renderer.rect(-4.5, 0, 9, 16, 0, 1)
	                    .attr(attr)
	                    .add(handles[index]);
	                elementsToDestroy.push(tempElem);

	                // the rifles
	                tempElem = renderer
	                    .path([
	                        'M',
	                        -1.5, 4,
	                        'L',
	                        -1.5, 12,
	                        'M',
	                        0.5, 4,
	                        'L',
	                        0.5, 12
	                    ]).attr(attr)
	                    .add(handles[index]);
	                elementsToDestroy.push(tempElem);
	            }

	            // Place it
	            handles[index][chart.isResizing ? 'animate' : 'attr']({
	                translateX: scroller.scrollerLeft + scroller.scrollbarHeight + parseInt(x, 10),
	                translateY: scroller.top + scroller.height / 2 - 8
	            });
	        },

	        /**
	         * Draw the scrollbar buttons with arrows
	         * @param {Number} index 0 is left, 1 is right
	         */
	        drawScrollbarButton: function (index) {
	            var scroller = this,
	                chart = scroller.chart,
	                renderer = chart.renderer,
	                elementsToDestroy = scroller.elementsToDestroy,
	                scrollbarButtons = scroller.scrollbarButtons,
	                scrollbarHeight = scroller.scrollbarHeight,
	                scrollbarOptions = scroller.scrollbarOptions,
	                tempElem;

	            if (!scroller.rendered) {
	                scrollbarButtons[index] = renderer.g().add(scroller.scrollbarGroup);

	                tempElem = renderer.rect(
	                        -0.5,
	                        -0.5,
	                        scrollbarHeight + 1, // +1 to compensate for crispifying in rect method
	                        scrollbarHeight + 1,
	                        scrollbarOptions.buttonBorderRadius,
	                        scrollbarOptions.buttonBorderWidth
	                    ).attr({
	                        stroke: scrollbarOptions.buttonBorderColor,
	                        'stroke-width': scrollbarOptions.buttonBorderWidth,
	                        fill: scrollbarOptions.buttonBackgroundColor
	                    }).add(scrollbarButtons[index]);
	                elementsToDestroy.push(tempElem);

	                tempElem = renderer
	                    .path([
	                        'M',
	                        scrollbarHeight / 2 + (index ? -1 : 1), scrollbarHeight / 2 - 3,
	                        'L',
	                        scrollbarHeight / 2 + (index ? -1 : 1), scrollbarHeight / 2 + 3,
	                        scrollbarHeight / 2 + (index ? 2 : -2), scrollbarHeight / 2
	                    ]).attr({
	                        fill: scrollbarOptions.buttonArrowColor
	                    }).add(scrollbarButtons[index]);
	                elementsToDestroy.push(tempElem);
	            }

	            // adjust the right side button to the varying length of the scroll track
	            if (index) {
	                scrollbarButtons[index].attr({
	                    translateX: scroller.scrollerWidth - scrollbarHeight
	                });
	            }
	        },

	        /**
	         * Render the navigator and scroll bar
	         * @param {Number} min X axis value minimum
	         * @param {Number} max X axis value maximum
	         * @param {Number} pxMin Pixel value minimum
	         * @param {Number} pxMax Pixel value maximum
	         */
	        render: function (min, max, pxMin, pxMax) {
	            var scroller = this,
	                chart = scroller.chart,
	                renderer = chart.renderer,
	                navigatorLeft,
	                navigatorWidth,
	                scrollerLeft,
	                scrollerWidth,
	                scrollbarGroup = scroller.scrollbarGroup,
	                navigatorGroup = scroller.navigatorGroup,
	                scrollbar = scroller.scrollbar,
	                xAxis = scroller.xAxis,
	                scrollbarTrack = scroller.scrollbarTrack,
	                scrollbarHeight = scroller.scrollbarHeight,
	                scrollbarEnabled = scroller.scrollbarEnabled,
	                navigatorOptions = scroller.navigatorOptions,
	                scrollbarOptions = scroller.scrollbarOptions,
	                scrollbarMinWidth = scrollbarOptions.minWidth,
	                height = scroller.height,
	                top = scroller.top,
	                navigatorEnabled = scroller.navigatorEnabled,
	                outlineWidth = navigatorOptions.outlineWidth,
	                halfOutline = outlineWidth / 2,
	                zoomedMin,
	                zoomedMax,
	                range,
	                scrX,
	                scrWidth,
	                scrollbarPad = 0,
	                outlineHeight = scroller.outlineHeight,
	                barBorderRadius = scrollbarOptions.barBorderRadius,
	                strokeWidth,
	                scrollbarStrokeWidth = scrollbarOptions.barBorderWidth,
	                centerBarX,
	                outlineTop = top + halfOutline,
	                verb,
	                unionExtremes;

	            // Don't render the navigator until we have data (#486, #4202). Don't redraw while moving the handles (#4703).
	            if (!defined(min) || isNaN(min) || (scroller.hasDragged && !defined(pxMin))) {
	                return;
	            }

	            scroller.navigatorLeft = navigatorLeft = pick(
	                xAxis.left,
	                chart.plotLeft + scrollbarHeight // in case of scrollbar only, without navigator
	            );
	            scroller.navigatorWidth = navigatorWidth = pick(xAxis.len, chart.plotWidth - 2 * scrollbarHeight);
	            scroller.scrollerLeft = scrollerLeft = navigatorLeft - scrollbarHeight;
	            scroller.scrollerWidth = scrollerWidth = scrollerWidth = navigatorWidth + 2 * scrollbarHeight;

	            // Set the scroller x axis extremes to reflect the total. The navigator extremes
	            // should always be the extremes of the union of all series in the chart as
	            // well as the navigator series.
	            if (xAxis.getExtremes) {
	                unionExtremes = scroller.getUnionExtremes(true);

	                if (unionExtremes && (unionExtremes.dataMin !== xAxis.min || unionExtremes.dataMax !== xAxis.max)) {
	                    xAxis.setExtremes(unionExtremes.dataMin, unionExtremes.dataMax, true, false);
	                }
	            }

	            // Get the pixel position of the handles
	            pxMin = pick(pxMin, xAxis.translate(min));
	            pxMax = pick(pxMax, xAxis.translate(max));
	            if (isNaN(pxMin) || mathAbs(pxMin) === Infinity) { // Verify (#1851, #2238)
	                pxMin = 0;
	                pxMax = scrollerWidth;
	            }

	            // Are we below the minRange? (#2618)
	            if (xAxis.translate(pxMax, true) - xAxis.translate(pxMin, true) < chart.xAxis[0].minRange) {
	                return;
	            }


	            // handles are allowed to cross, but never exceed the plot area
	            scroller.zoomedMax = mathMin(mathMax(pxMin, pxMax, 0), navigatorWidth);
	            scroller.zoomedMin =
	                mathMax(scroller.fixedWidth ? scroller.zoomedMax - scroller.fixedWidth : mathMin(pxMin, pxMax), 0);
	            scroller.range = scroller.zoomedMax - scroller.zoomedMin;
	            zoomedMax = mathRound(scroller.zoomedMax);
	            zoomedMin = mathRound(scroller.zoomedMin);
	            range = zoomedMax - zoomedMin;



	            // on first render, create all elements
	            if (!scroller.rendered) {

	                if (navigatorEnabled) {

	                    // draw the navigator group
	                    scroller.navigatorGroup = navigatorGroup = renderer.g('navigator')
	                        .attr({
	                            zIndex: 3
	                        })
	                        .add();

	                    scroller.leftShade = renderer.rect()
	                        .attr({
	                            fill: navigatorOptions.maskFill
	                        }).add(navigatorGroup);

	                    if (navigatorOptions.maskInside) {
	                        scroller.leftShade.css({ cursor: 'ew-resize' });
	                    } else {
	                        scroller.rightShade = renderer.rect()
	                            .attr({
	                                fill: navigatorOptions.maskFill
	                            }).add(navigatorGroup);
	                    }


	                    scroller.outline = renderer.path()
	                        .attr({
	                            'stroke-width': outlineWidth,
	                            stroke: navigatorOptions.outlineColor
	                        })
	                        .add(navigatorGroup);
	                }

	                if (scrollbarEnabled) {

	                    // draw the scrollbar group
	                    scroller.scrollbarGroup = scrollbarGroup = renderer.g('scrollbar').add();

	                    // the scrollbar track
	                    strokeWidth = scrollbarOptions.trackBorderWidth;
	                    scroller.scrollbarTrack = scrollbarTrack = renderer.rect().attr({
	                        x: 0,
	                        y: -strokeWidth % 2 / 2,
	                        fill: scrollbarOptions.trackBackgroundColor,
	                        stroke: scrollbarOptions.trackBorderColor,
	                        'stroke-width': strokeWidth,
	                        r: scrollbarOptions.trackBorderRadius || 0,
	                        height: scrollbarHeight
	                    }).add(scrollbarGroup);

	                    // the scrollbar itself
	                    scroller.scrollbar = scrollbar = renderer.rect()
	                        .attr({
	                            y: -scrollbarStrokeWidth % 2 / 2,
	                            height: scrollbarHeight,
	                            fill: scrollbarOptions.barBackgroundColor,
	                            stroke: scrollbarOptions.barBorderColor,
	                            'stroke-width': scrollbarStrokeWidth,
	                            r: barBorderRadius
	                        })
	                        .add(scrollbarGroup);

	                    scroller.scrollbarRifles = renderer.path()
	                        .attr({
	                            stroke: scrollbarOptions.rifleColor,
	                            'stroke-width': 1
	                        })
	                        .add(scrollbarGroup);
	                }
	            }

	            // place elements
	            verb = chart.isResizing ? 'animate' : 'attr';

	            if (navigatorEnabled) {
	                scroller.leftShade[verb](navigatorOptions.maskInside ? {
	                    x: navigatorLeft + zoomedMin,
	                    y: top,
	                    width: zoomedMax - zoomedMin,
	                    height: height
	                } : {
	                    x: navigatorLeft,
	                    y: top,
	                    width: zoomedMin,
	                    height: height
	                });
	                if (scroller.rightShade) {
	                    scroller.rightShade[verb]({
	                        x: navigatorLeft + zoomedMax,
	                        y: top,
	                        width: navigatorWidth - zoomedMax,
	                        height: height
	                    });
	                }

	                scroller.outline[verb]({ d: [
	                    M,
	                    scrollerLeft, outlineTop, // left
	                    L,
	                    navigatorLeft + zoomedMin - halfOutline, outlineTop, // upper left of zoomed range
	                    navigatorLeft + zoomedMin - halfOutline, outlineTop + outlineHeight, // lower left of z.r.
	                    L,
	                    navigatorLeft + zoomedMax - halfOutline, outlineTop + outlineHeight, // lower right of z.r.
	                    L,
	                    navigatorLeft + zoomedMax - halfOutline, outlineTop, // upper right of z.r.
	                    scrollerLeft + scrollerWidth, outlineTop // right
	                ].concat(navigatorOptions.maskInside ? [
	                    M,
	                    navigatorLeft + zoomedMin + halfOutline, outlineTop, // upper left of zoomed range
	                    L,
	                    navigatorLeft + zoomedMax - halfOutline, outlineTop // upper right of z.r.
	                ] : []) });
	                // draw handles
	                scroller.drawHandle(zoomedMin + halfOutline, 0);
	                scroller.drawHandle(zoomedMax + halfOutline, 1);
	            }

	            // draw the scrollbar
	            if (scrollbarEnabled && scrollbarGroup) {

	                // draw the buttons
	                scroller.drawScrollbarButton(0);
	                scroller.drawScrollbarButton(1);

	                scrollbarGroup[verb]({
	                    translateX: scrollerLeft,
	                    translateY: mathRound(outlineTop + height)
	                });

	                scrollbarTrack[verb]({
	                    width: scrollerWidth
	                });

	                // prevent the scrollbar from drawing to small (#1246)
	                scrX = scrollbarHeight + zoomedMin;
	                scrWidth = range - scrollbarStrokeWidth;
	                if (scrWidth < scrollbarMinWidth) {
	                    scrollbarPad = (scrollbarMinWidth - scrWidth) / 2;
	                    scrWidth = scrollbarMinWidth;
	                    scrX -= scrollbarPad;
	                }
	                scroller.scrollbarPad = scrollbarPad;
	                scrollbar[verb]({
	                    x: mathFloor(scrX) + (scrollbarStrokeWidth % 2 / 2),
	                    width: scrWidth
	                });

	                centerBarX = scrollbarHeight + zoomedMin + range / 2 - 0.5;

	                scroller.scrollbarRifles
	                    .attr({
	                        visibility: range > 12 ? VISIBLE : HIDDEN
	                    })[verb]({
	                        d: [
	                            M,
	                            centerBarX - 3, scrollbarHeight / 4,
	                            L,
	                            centerBarX - 3, 2 * scrollbarHeight / 3,
	                            M,
	                            centerBarX, scrollbarHeight / 4,
	                            L,
	                            centerBarX, 2 * scrollbarHeight / 3,
	                            M,
	                            centerBarX + 3, scrollbarHeight / 4,
	                            L,
	                            centerBarX + 3, 2 * scrollbarHeight / 3
	                        ]
	                    });
	            }

	            scroller.scrollbarPad = scrollbarPad;
	            scroller.rendered = true;
	        },

	        /**
	         * Set up the mouse and touch events for the navigator and scrollbar
	         */
	        addEvents: function () {
	            var container = this.chart.container,
	                mouseDownHandler = this.mouseDownHandler,
	                mouseMoveHandler = this.mouseMoveHandler,
	                mouseUpHandler = this.mouseUpHandler,
	                _events;

	            // Mouse events
	            _events = [
	                [container, 'mousedown', mouseDownHandler],
	                [container, 'mousemove', mouseMoveHandler],
	                [doc, 'mouseup', mouseUpHandler]
	            ];

	            // Touch events
	            if (hasTouch) {
	                _events.push(
	                    [container, 'touchstart', mouseDownHandler],
	                    [container, 'touchmove', mouseMoveHandler],
	                    [doc, 'touchend', mouseUpHandler]
	                );
	            }

	            // Add them all
	            each(_events, function (args) {
	                addEvent.apply(null, args);
	            });
	            this._events = _events;
	        },

	        /**
	         * Removes the event handlers attached previously with addEvents.
	         */
	        removeEvents: function () {

	            each(this._events, function (args) {
	                removeEvent.apply(null, args);
	            });
	            this._events = UNDEFINED;
	            if (this.navigatorEnabled && this.baseSeries) {
	                removeEvent(this.baseSeries, 'updatedData', this.updatedDataHandler);
	            }
	        },

	        /**
	         * Initiate the Scroller object
	         */
	        init: function () {
	            var scroller = this,
	                chart = scroller.chart,
	                xAxis,
	                yAxis,
	                scrollbarHeight = scroller.scrollbarHeight,
	                navigatorOptions = scroller.navigatorOptions,
	                height = scroller.height,
	                top = scroller.top,
	                dragOffset,
	                baseSeries = scroller.baseSeries;

	            /**
	             * Event handler for the mouse down event.
	             */
	            scroller.mouseDownHandler = function (e) {
	                e = chart.pointer.normalize(e);

	                var zoomedMin = scroller.zoomedMin,
	                    zoomedMax = scroller.zoomedMax,
	                    top = scroller.top,
	                    scrollbarHeight = scroller.scrollbarHeight,
	                    scrollerLeft = scroller.scrollerLeft,
	                    scrollerWidth = scroller.scrollerWidth,
	                    navigatorLeft = scroller.navigatorLeft,
	                    navigatorWidth = scroller.navigatorWidth,
	                    scrollbarPad = scroller.scrollbarPad,
	                    range = scroller.range,
	                    chartX = e.chartX,
	                    chartY = e.chartY,
	                    baseXAxis = chart.xAxis[0],
	                    fixedMax,
	                    ext,
	                    handleSensitivity = isTouchDevice ? 10 : 7,
	                    left,
	                    isOnNavigator;

	                if (chartY > top && chartY < top + height + scrollbarHeight) { // we're vertically inside the navigator
	                    isOnNavigator = !scroller.scrollbarEnabled || chartY < top + height;

	                    // grab the left handle
	                    if (isOnNavigator && math.abs(chartX - zoomedMin - navigatorLeft) < handleSensitivity) {
	                        scroller.grabbedLeft = true;
	                        scroller.otherHandlePos = zoomedMax;
	                        scroller.fixedExtreme = baseXAxis.max;
	                        chart.fixedRange = null;

	                    // grab the right handle
	                    } else if (isOnNavigator && math.abs(chartX - zoomedMax - navigatorLeft) < handleSensitivity) {
	                        scroller.grabbedRight = true;
	                        scroller.otherHandlePos = zoomedMin;
	                        scroller.fixedExtreme = baseXAxis.min;
	                        chart.fixedRange = null;

	                    // grab the zoomed range
	                    } else if (chartX > navigatorLeft + zoomedMin - scrollbarPad && chartX < navigatorLeft + zoomedMax + scrollbarPad) {
	                        scroller.grabbedCenter = chartX;
	                        scroller.fixedWidth = range;

	                        dragOffset = chartX - zoomedMin;


	                    // shift the range by clicking on shaded areas, scrollbar track or scrollbar buttons
	                    } else if (chartX > scrollerLeft && chartX < scrollerLeft + scrollerWidth) {

	                        // Center around the clicked point
	                        if (isOnNavigator) {
	                            left = chartX - navigatorLeft - range / 2;

	                        // Click on scrollbar
	                        } else {

	                            // Click left scrollbar button
	                            if (chartX < navigatorLeft) {
	                                left = zoomedMin - range * 0.2;

	                            // Click right scrollbar button
	                            } else if (chartX > scrollerLeft + scrollerWidth - scrollbarHeight) {
	                                left = zoomedMin + range * 0.2;

	                            // Click on scrollbar track, shift the scrollbar by one range
	                            } else {
	                                left = chartX < navigatorLeft + zoomedMin ? // on the left
	                                    zoomedMin - range :
	                                    zoomedMax;
	                            }
	                        }
	                        if (left < 0) {
	                            left = 0;
	                        } else if (left + range >= navigatorWidth) {
	                            left = navigatorWidth - range;
	                            fixedMax = scroller.getUnionExtremes().dataMax; // #2293, #3543
	                        }
	                        if (left !== zoomedMin) { // it has actually moved
	                            scroller.fixedWidth = range; // #1370

	                            ext = xAxis.toFixedRange(left, left + range, null, fixedMax);
	                            baseXAxis.setExtremes(
	                                ext.min,
	                                ext.max,
	                                true,
	                                false,
	                                { trigger: 'navigator' }
	                            );
	                        }
	                    }

	                }
	            };

	            /**
	             * Event handler for the mouse move event.
	             */
	            scroller.mouseMoveHandler = function (e) {
	                var scrollbarHeight = scroller.scrollbarHeight,
	                    navigatorLeft = scroller.navigatorLeft,
	                    navigatorWidth = scroller.navigatorWidth,
	                    scrollerLeft = scroller.scrollerLeft,
	                    scrollerWidth = scroller.scrollerWidth,
	                    range = scroller.range,
	                    chartX,
	                    hasDragged;

	                // In iOS, a mousemove event with e.pageX === 0 is fired when holding the finger
	                // down in the center of the scrollbar. This should be ignored.
	                if (!e.touches || e.touches[0].pageX !== 0) { // #4696, scrollbar failed on Android

	                    e = chart.pointer.normalize(e);
	                    chartX = e.chartX;

	                    // validation for handle dragging
	                    if (chartX < navigatorLeft) {
	                        chartX = navigatorLeft;
	                    } else if (chartX > scrollerLeft + scrollerWidth - scrollbarHeight) {
	                        chartX = scrollerLeft + scrollerWidth - scrollbarHeight;
	                    }

	                    // drag left handle
	                    if (scroller.grabbedLeft) {
	                        hasDragged = true;
	                        scroller.render(0, 0, chartX - navigatorLeft, scroller.otherHandlePos);

	                    // drag right handle
	                    } else if (scroller.grabbedRight) {
	                        hasDragged = true;
	                        scroller.render(0, 0, scroller.otherHandlePos, chartX - navigatorLeft);

	                    // drag scrollbar or open area in navigator
	                    } else if (scroller.grabbedCenter) {

	                        hasDragged = true;
	                        if (chartX < dragOffset) { // outside left
	                            chartX = dragOffset;
	                        } else if (chartX > navigatorWidth + dragOffset - range) { // outside right
	                            chartX = navigatorWidth + dragOffset - range;
	                        }

	                        scroller.render(0, 0, chartX - dragOffset, chartX - dragOffset + range);

	                    }
	                    if (hasDragged && scroller.scrollbarOptions.liveRedraw) {
	                        setTimeout(function () {
	                            scroller.mouseUpHandler(e);
	                        }, 0);
	                    }
	                    scroller.hasDragged = hasDragged;
	                }
	            };

	            /**
	             * Event handler for the mouse up event.
	             */
	            scroller.mouseUpHandler = function (e) {
	                var ext,
	                    fixedMin,
	                    fixedMax;

	                if (scroller.hasDragged) {
	                    // When dragging one handle, make sure the other one doesn't change
	                    if (scroller.zoomedMin === scroller.otherHandlePos) {
	                        fixedMin = scroller.fixedExtreme;
	                    } else if (scroller.zoomedMax === scroller.otherHandlePos) {
	                        fixedMax = scroller.fixedExtreme;
	                    }

	                    // Snap to right edge (#4076)
	                    if (scroller.zoomedMax === scroller.navigatorWidth) {
	                        fixedMax = scroller.getUnionExtremes().dataMax;
	                    }

	                    ext = xAxis.toFixedRange(scroller.zoomedMin, scroller.zoomedMax, fixedMin, fixedMax);
	                    if (defined(ext.min)) {
	                        chart.xAxis[0].setExtremes(
	                            ext.min,
	                            ext.max,
	                            true,
	                            false,
	                            {
	                                trigger: 'navigator',
	                                triggerOp: 'navigator-drag',
	                                DOMEvent: e // #1838
	                            }
	                        );
	                    }
	                }

	                if (e.type !== 'mousemove') {
	                    scroller.grabbedLeft = scroller.grabbedRight = scroller.grabbedCenter = scroller.fixedWidth =
	                        scroller.fixedExtreme = scroller.otherHandlePos = scroller.hasDragged = dragOffset = null;
	                }

	            };



	            var xAxisIndex = chart.xAxis.length,
	                yAxisIndex = chart.yAxis.length;

	            // make room below the chart
	            chart.extraBottomMargin = scroller.outlineHeight + navigatorOptions.margin;

	            if (scroller.navigatorEnabled) {
	                // an x axis is required for scrollbar also
	                scroller.xAxis = xAxis = new Axis(chart, merge({
	                    // inherit base xAxis' break and ordinal options
	                    breaks: baseSeries && baseSeries.xAxis.options.breaks,
	                    ordinal: baseSeries && baseSeries.xAxis.options.ordinal
	                }, navigatorOptions.xAxis, {
	                    id: 'navigator-x-axis',
	                    isX: true,
	                    type: 'datetime',
	                    index: xAxisIndex,
	                    height: height,
	                    offset: 0,
	                    offsetLeft: scrollbarHeight,
	                    offsetRight: -scrollbarHeight,
	                    keepOrdinalPadding: true, // #2436
	                    startOnTick: false,
	                    endOnTick: false,
	                    minPadding: 0,
	                    maxPadding: 0,
	                    zoomEnabled: false
	                }));

	                scroller.yAxis = yAxis = new Axis(chart, merge(navigatorOptions.yAxis, {
	                    id: 'navigator-y-axis',
	                    alignTicks: false,
	                    height: height,
	                    offset: 0,
	                    index: yAxisIndex,
	                    zoomEnabled: false
	                }));

	                // If we have a base series, initialize the navigator series
	                if (baseSeries || navigatorOptions.series.data) {
	                    scroller.addBaseSeries();

	                // If not, set up an event to listen for added series
	                } else if (chart.series.length === 0) {

	                    wrap(chart, 'redraw', function (proceed, animation) {
	                        // We've got one, now add it as base and reset chart.redraw
	                        if (chart.series.length > 0 && !scroller.series) {
	                            scroller.setBaseSeries();
	                            chart.redraw = proceed; // reset
	                        }
	                        proceed.call(chart, animation);
	                    });
	                }


	            // in case of scrollbar only, fake an x axis to get translation
	            } else {
	                scroller.xAxis = xAxis = {
	                    translate: function (value, reverse) {
	                        var axis = chart.xAxis[0],
	                            ext = axis.getExtremes(),
	                            scrollTrackWidth = chart.plotWidth - 2 * scrollbarHeight,
	                            min = numExt('min', axis.options.min, ext.dataMin),
	                            valueRange = numExt('max', axis.options.max, ext.dataMax) - min;

	                        return reverse ?
	                            // from pixel to value
	                            (value * valueRange / scrollTrackWidth) + min :
	                            // from value to pixel
	                            scrollTrackWidth * (value - min) / valueRange;
	                    },
	                    toFixedRange: Axis.prototype.toFixedRange
	                };
	            }


	            /**
	             * For stock charts, extend the Chart.getMargins method so that we can set the final top position
	             * of the navigator once the height of the chart, including the legend, is determined. #367.
	             */
	            wrap(chart, 'getMargins', function (proceed) {

	                var legend = this.legend,
	                    legendOptions = legend.options;

	                proceed.apply(this, [].slice.call(arguments, 1));

	                // Compute the top position
	                scroller.top = top = scroller.navigatorOptions.top ||
	                    this.chartHeight - scroller.height - scroller.scrollbarHeight - this.spacing[2] -
	                            (legendOptions.verticalAlign === 'bottom' && legendOptions.enabled && !legendOptions.floating ?
	                                legend.legendHeight + pick(legendOptions.margin, 10) : 0);

	                if (xAxis && yAxis) { // false if navigator is disabled (#904)

	                    xAxis.options.top = yAxis.options.top = top;

	                    xAxis.setAxisSize();
	                    yAxis.setAxisSize();
	                }
	            });


	            scroller.addEvents();
	        },

	        /**
	         * Get the union data extremes of the chart - the outer data extremes of the base
	         * X axis and the navigator axis.
	         */
	        getUnionExtremes: function (returnFalseOnNoBaseSeries) {
	            var baseAxis = this.chart.xAxis[0],
	                navAxis = this.xAxis,
	                navAxisOptions = navAxis.options,
	                baseAxisOptions = baseAxis.options,
	                ret;

	            if (!returnFalseOnNoBaseSeries || baseAxis.dataMin !== null) {
	                ret = {
	                    dataMin: pick( // #4053
	                        navAxisOptions && navAxisOptions.min,
	                        numExt(
	                            'min',
	                            baseAxisOptions.min,
	                            baseAxis.dataMin,
	                            navAxis.dataMin
	                        )
	                    ),
	                    dataMax: pick(
	                        navAxisOptions && navAxisOptions.max,
	                        numExt(
	                            'max',
	                            baseAxisOptions.max,
	                            baseAxis.dataMax,
	                            navAxis.dataMax
	                        )
	                    )
	                };
	            }
	            return ret;
	        },

	        /**
	         * Set the base series. With a bit of modification we should be able to make
	         * this an API method to be called from the outside
	         */
	        setBaseSeries: function (baseSeriesOption) {
	            var chart = this.chart;

	            baseSeriesOption = baseSeriesOption || chart.options.navigator.baseSeries;

	            // If we're resetting, remove the existing series
	            if (this.series) {
	                this.series.remove();
	            }

	            // Set the new base series
	            this.baseSeries = chart.series[baseSeriesOption] ||
	                (typeof baseSeriesOption === 'string' && chart.get(baseSeriesOption)) ||
	                chart.series[0];

	            // When run after render, this.xAxis already exists
	            if (this.xAxis) {
	                this.addBaseSeries();
	            }
	        },

	        addBaseSeries: function () {
	            var baseSeries = this.baseSeries,
	                baseOptions = baseSeries ? baseSeries.options : {},
	                baseData = baseOptions.data,
	                mergedNavSeriesOptions,
	                navigatorSeriesOptions = this.navigatorOptions.series,
	                navigatorData;

	            // remove it to prevent merging one by one
	            navigatorData = navigatorSeriesOptions.data;
	            this.hasNavigatorData = !!navigatorData;

	            // Merge the series options
	            mergedNavSeriesOptions = merge(baseOptions, navigatorSeriesOptions, {
	                enableMouseTracking: false,
	                group: 'nav', // for columns
	                padXAxis: false,
	                xAxis: 'navigator-x-axis',
	                yAxis: 'navigator-y-axis',
	                name: 'Navigator',
	                showInLegend: false,
	                stacking: false, // We only allow one series anyway (#4823)
	                isInternal: true,
	                visible: true
	            });

	            // Set the data. Do a slice to avoid mutating the navigator options from base series (#4923).
	            mergedNavSeriesOptions.data = navigatorData || baseData.slice(0);

	            // add the series
	            this.series = this.chart.initSeries(mergedNavSeriesOptions);

	            // Respond to updated data in the base series.
	            // Abort if lazy-loading data from the server.
	            if (baseSeries && this.navigatorOptions.adaptToUpdatedData !== false) {
	                addEvent(baseSeries, 'updatedData', this.updatedDataHandler);
	                // Survive Series.update()
	                baseSeries.userOptions.events = extend(baseSeries.userOptions.event, { updatedData: this.updatedDataHandler });

	            }
	        },

	        updatedDataHandler: function () {
	            var scroller = this.chart.scroller,
	                baseSeries = scroller.baseSeries,
	                baseXAxis = baseSeries.xAxis,
	                baseExtremes = baseXAxis.getExtremes(),
	                baseMin = baseExtremes.min,
	                baseMax = baseExtremes.max,
	                baseDataMin = baseExtremes.dataMin,
	                baseDataMax = baseExtremes.dataMax,
	                range = baseMax - baseMin,
	                stickToMin,
	                stickToMax,
	                newMax,
	                newMin,
	                doRedraw,
	                navigatorSeries = scroller.series,
	                navXData = navigatorSeries.xData,
	                hasSetExtremes = !!baseXAxis.setExtremes;

	            // detect whether to move the range
	            stickToMax = baseMax >= navXData[navXData.length - 1] - (this.closestPointRange || 0); // #570
	            stickToMin = baseMin <= baseDataMin;

	            // set the navigator series data to the new data of the base series
	            if (!scroller.hasNavigatorData) {
	                navigatorSeries.options.pointStart = baseSeries.xData[0];
	                navigatorSeries.setData(baseSeries.options.data, false);
	                doRedraw = true;
	            }

	            // if the zoomed range is already at the min, move it to the right as new data
	            // comes in
	            if (stickToMin) {
	                newMin = baseDataMin;
	                newMax = newMin + range;
	            }

	            // if the zoomed range is already at the max, move it to the right as new data
	            // comes in
	            if (stickToMax) {
	                newMax = baseDataMax;
	                if (!stickToMin) { // if stickToMin is true, the new min value is set above
	                    newMin = mathMax(newMax - range, navigatorSeries.xData[0]);
	                }
	            }

	            // update the extremes
	            if (hasSetExtremes && (stickToMin || stickToMax)) {
	                if (!isNaN(newMin)) {
	                    baseXAxis.setExtremes(newMin, newMax, true, false, { trigger: 'updatedData' });
	                }

	            // if it is not at any edge, just move the scroller window to reflect the new series data
	            } else {
	                if (doRedraw) {
	                    this.chart.redraw(false);
	                }

	                scroller.render(
	                    mathMax(baseMin, baseDataMin),
	                    mathMin(baseMax, baseDataMax)
	                );
	            }
	        },

	        /**
	         * Destroys allocated elements.
	         */
	        destroy: function () {
	            var scroller = this;

	            // Disconnect events added in addEvents
	            scroller.removeEvents();

	            // Destroy properties
	            each([scroller.xAxis, scroller.yAxis, scroller.leftShade, scroller.rightShade, scroller.outline, scroller.scrollbarTrack, scroller.scrollbarRifles, scroller.scrollbarGroup, scroller.scrollbar], function (prop) {
	                if (prop && prop.destroy) {
	                    prop.destroy();
	                }
	            });
	            scroller.xAxis = scroller.yAxis = scroller.leftShade = scroller.rightShade = scroller.outline = scroller.scrollbarTrack = scroller.scrollbarRifles = scroller.scrollbarGroup = scroller.scrollbar = null;

	            // Destroy elements in collection
	            each([scroller.scrollbarButtons, scroller.handles, scroller.elementsToDestroy], function (coll) {
	                destroyObjectProperties(coll);
	            });
	        }
	    };

	    Highcharts.Scroller = Scroller;


	    /**
	     * For Stock charts, override selection zooming with some special features because
	     * X axis zooming is already allowed by the Navigator and Range selector.
	     */
	    wrap(Axis.prototype, 'zoom', function (proceed, newMin, newMax) {
	        var chart = this.chart,
	            chartOptions = chart.options,
	            zoomType = chartOptions.chart.zoomType,
	            previousZoom,
	            navigator = chartOptions.navigator,
	            rangeSelector = chartOptions.rangeSelector,
	            ret;

	        if (this.isXAxis && ((navigator && navigator.enabled) ||
	                (rangeSelector && rangeSelector.enabled))) {

	            // For x only zooming, fool the chart.zoom method not to create the zoom button
	            // because the property already exists
	            if (zoomType === 'x') {
	                chart.resetZoomButton = 'blocked';

	            // For y only zooming, ignore the X axis completely
	            } else if (zoomType === 'y') {
	                ret = false;

	            // For xy zooming, record the state of the zoom before zoom selection, then when
	            // the reset button is pressed, revert to this state
	            } else if (zoomType === 'xy') {
	                previousZoom = this.previousZoom;
	                if (defined(newMin)) {
	                    this.previousZoom = [this.min, this.max];
	                } else if (previousZoom) {
	                    newMin = previousZoom[0];
	                    newMax = previousZoom[1];
	                    delete this.previousZoom;
	                }
	            }

	        }
	        return ret !== UNDEFINED ? ret : proceed.call(this, newMin, newMax);
	    });

	    // Initialize scroller for stock charts
	    wrap(Chart.prototype, 'init', function (proceed, options, callback) {

	        addEvent(this, 'beforeRender', function () {
	            var options = this.options;
	            if (options.navigator.enabled || options.scrollbar.enabled) {
	                this.scroller = new Scroller(this);
	            }
	        });

	        proceed.call(this, options, callback);

	    });

	    // Pick up badly formatted point options to addPoint
	    wrap(Series.prototype, 'addPoint', function (proceed, options, redraw, shift, animation) {
	        var turboThreshold = this.options.turboThreshold;
	        if (turboThreshold && this.xData.length > turboThreshold && isObject(options) && !isArray(options) && this.chart.scroller) {
	            error(20, true);
	        }
	        proceed.call(this, options, redraw, shift, animation);
	    });

	    /* ****************************************************************************
	     * End Scroller code                                                          *
	     *****************************************************************************/
	    /* ****************************************************************************
	     * Start Range Selector code                                                  *
	     *****************************************************************************/
	    extend(defaultOptions, {
	        rangeSelector: {
	            // allButtonsEnabled: false,
	            // enabled: true,
	            // buttons: {Object}
	            // buttonSpacing: 0,
	            buttonTheme: {
	                width: 28,
	                height: 18,
	                fill: '#f7f7f7',
	                padding: 2,
	                r: 0,
	                'stroke-width': 0,
	                style: {
	                    color: '#444',
	                    cursor: 'pointer',
	                    fontWeight: 'normal'
	                },
	                zIndex: 7, // #484, #852
	                states: {
	                    hover: {
	                        fill: '#e7e7e7'
	                    },
	                    select: {
	                        fill: '#e7f0f9',
	                        style: {
	                            color: 'black',
	                            fontWeight: 'bold'
	                        }
	                    }
	                }
	            },
	            height: 35, // reserved space for buttons and input
	            inputPosition: {
	                align: 'right'
	            },
	            // inputDateFormat: '%b %e, %Y',
	            // inputEditDateFormat: '%Y-%m-%d',
	            // inputEnabled: true,
	            // inputStyle: {},
	            labelStyle: {
	                color: '#666'
	            }
	            // selected: undefined
	        }
	    });
	    defaultOptions.lang = merge(defaultOptions.lang, {
	        rangeSelectorZoom: 'Zoom',
	        rangeSelectorFrom: 'From',
	        rangeSelectorTo: 'To'
	    });

	    /**
	     * The object constructor for the range selector
	     * @param {Object} chart
	     */
	    function RangeSelector(chart) {

	        // Run RangeSelector
	        this.init(chart);
	    }

	    RangeSelector.prototype = {
	        /**
	         * The method to run when one of the buttons in the range selectors is clicked
	         * @param {Number} i The index of the button
	         * @param {Object} rangeOptions
	         * @param {Boolean} redraw
	         */
	        clickButton: function (i, redraw) {
	            var rangeSelector = this,
	                selected = rangeSelector.selected,
	                chart = rangeSelector.chart,
	                buttons = rangeSelector.buttons,
	                rangeOptions = rangeSelector.buttonOptions[i],
	                baseAxis = chart.xAxis[0],
	                unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis || {},
	                dataMin = unionExtremes.dataMin,
	                dataMax = unionExtremes.dataMax,
	                newMin,
	                newMax = baseAxis && mathRound(mathMin(baseAxis.max, pick(dataMax, baseAxis.max))), // #1568
	                now,
	                type = rangeOptions.type,
	                baseXAxisOptions,
	                range = rangeOptions._range,
	                rangeMin,
	                year,
	                minSetting,
	                rangeSetting,
	                ctx,
	                dataGrouping = rangeOptions.dataGrouping;

	            if (dataMin === null || dataMax === null || // chart has no data, base series is removed
	                    i === rangeSelector.selected) { // same button is clicked twice
	                return;
	            }

	            // Set the fixed range before range is altered
	            chart.fixedRange = range;

	            // Apply dataGrouping associated to button
	            if (dataGrouping) {
	                this.forcedDataGrouping = true;
	                Axis.prototype.setDataGrouping.call(baseAxis || { chart: this.chart }, dataGrouping, false);
	            }

	            // Apply range
	            if (type === 'month' || type === 'year') {
	                if (!baseAxis) {
	                    // This is set to the user options and picked up later when the axis is instantiated
	                    // so that we know the min and max.
	                    range = rangeOptions;
	                } else {
	                    ctx = {
	                        range: rangeOptions,
	                        max: newMax,
	                        dataMin: dataMin,
	                        dataMax: dataMax
	                    };
	                    newMin = baseAxis.minFromRange.call(ctx);
	                    if (typeof ctx.newMax === 'number') {
	                        newMax = ctx.newMax;
	                    }
	                }

	            // Fixed times like minutes, hours, days
	            } else if (range) {
	                newMin = mathMax(newMax - range, dataMin);
	                newMax = mathMin(newMin + range, dataMax);

	            } else if (type === 'ytd') {

	                // On user clicks on the buttons, or a delayed action running from the beforeRender
	                // event (below), the baseAxis is defined.
	                if (baseAxis) {

	                    // When "ytd" is the pre-selected button for the initial view, its calculation
	                    // is delayed and rerun in the beforeRender event (below). When the series
	                    // are initialized, but before the chart is rendered, we have access to the xData
	                    // array (#942).
	                    if (dataMax === UNDEFINED) {
	                        dataMin = Number.MAX_VALUE;
	                        dataMax = Number.MIN_VALUE;
	                        each(chart.series, function (series) {
	                            var xData = series.xData; // reassign it to the last item
	                            dataMin = mathMin(xData[0], dataMin);
	                            dataMax = mathMax(xData[xData.length - 1], dataMax);
	                        });
	                        redraw = false;
	                    }
	                    now = new Date(dataMax);
	                    year = now.getFullYear();
	                    newMin = rangeMin = mathMax(dataMin || 0, Date.UTC(year, 0, 1));
	                    now = now.getTime();
	                    newMax = mathMin(dataMax || now, now);

	                // "ytd" is pre-selected. We don't yet have access to processed point and extremes data
	                // (things like pointStart and pointInterval are missing), so we delay the process (#942)
	                } else {
	                    addEvent(chart, 'beforeRender', function () {
	                        rangeSelector.clickButton(i);
	                    });
	                    return;
	                }
	            } else if (type === 'all' && baseAxis) {
	                newMin = dataMin;
	                newMax = dataMax;
	            }

	            // Deselect previous button
	            if (buttons[selected]) {
	                buttons[selected].setState(0);
	            }
	            // Select this button
	            if (buttons[i]) {
	                buttons[i].setState(2);
	                rangeSelector.lastSelected = i;
	            }

	            // Update the chart
	            if (!baseAxis) {
	                // Axis not yet instanciated. Temporarily set min and range
	                // options and remove them on chart load (#4317).
	                baseXAxisOptions = chart.options.xAxis[0];
	                rangeSetting = baseXAxisOptions.range;
	                baseXAxisOptions.range = range;
	                minSetting = baseXAxisOptions.min;
	                baseXAxisOptions.min = rangeMin;
	                rangeSelector.setSelected(i);
	                addEvent(chart, 'load', function resetMinAndRange() {
	                    baseXAxisOptions.range = rangeSetting;
	                    baseXAxisOptions.min = minSetting;
	                });
	            } else {
	                // Existing axis object. Set extremes after render time.
	                baseAxis.setExtremes(
	                    newMin,
	                    newMax,
	                    pick(redraw, 1),
	                    0,
	                    {
	                        trigger: 'rangeSelectorButton',
	                        rangeSelectorButton: rangeOptions
	                    }
	                );
	                rangeSelector.setSelected(i);
	            }
	        },

	        /**
	         * Set the selected option. This method only sets the internal flag, it doesn't
	         * update the buttons or the actual zoomed range.
	         */
	        setSelected: function (selected) {
	            this.selected = this.options.selected = selected;
	        },

	        /**
	         * The default buttons for pre-selecting time frames
	         */
	        defaultButtons: [{
	            type: 'month',
	            count: 1,
	            text: '1m'
	        }, {
	            type: 'month',
	            count: 3,
	            text: '3m'
	        }, {
	            type: 'month',
	            count: 6,
	            text: '6m'
	        }, {
	            type: 'ytd',
	            text: 'YTD'
	        }, {
	            type: 'year',
	            count: 1,
	            text: '1y'
	        }, {
	            type: 'all',
	            text: 'All'
	        }],

	        /**
	         * Initialize the range selector
	         */
	        init: function (chart) {

	            var rangeSelector = this,
	                options = chart.options.rangeSelector,
	                buttonOptions = options.buttons || [].concat(rangeSelector.defaultButtons),
	                selectedOption = options.selected,
	                blurInputs = rangeSelector.blurInputs = function () {
	                    var minInput = rangeSelector.minInput,
	                        maxInput = rangeSelector.maxInput;
	                    if (minInput && minInput.blur) { //#3274 in some case blur is not defined
	                        fireEvent(minInput, 'blur'); //#3274
	                    }
	                    if (maxInput && maxInput.blur) { //#3274 in some case blur is not defined
	                        fireEvent(maxInput, 'blur'); //#3274
	                    }
	                };

	            rangeSelector.chart = chart;
	            rangeSelector.options = options;
	            rangeSelector.buttons = [];

	            chart.extraTopMargin = options.height;
	            rangeSelector.buttonOptions = buttonOptions;

	            addEvent(chart.container, 'mousedown', blurInputs);
	            addEvent(chart, 'resize', blurInputs);

	            // Extend the buttonOptions with actual range
	            each(buttonOptions, rangeSelector.computeButtonRange);

	            // zoomed range based on a pre-selected button index
	            if (selectedOption !== UNDEFINED && buttonOptions[selectedOption]) {
	                this.clickButton(selectedOption, false);
	            }


	            addEvent(chart, 'load', function () {
	                // If a data grouping is applied to the current button, release it when extremes change
	                addEvent(chart.xAxis[0], 'setExtremes', function (e) {
	                    if (this.max - this.min !== chart.fixedRange && e.trigger !== 'rangeSelectorButton' &&
	                            e.trigger !== 'updatedData' && rangeSelector.forcedDataGrouping) {
	                        this.setDataGrouping(false, false);
	                    }
	                });
	                // Normalize the pressed button whenever a new range is selected
	                addEvent(chart.xAxis[0], 'afterSetExtremes', function () {
	                    rangeSelector.updateButtonStates(true);
	                });
	            });
	        },

	        /**
	         * Dynamically update the range selector buttons after a new range has been set
	         */
	        updateButtonStates: function (updating) {
	            var rangeSelector = this,
	                chart = this.chart,
	                baseAxis = chart.xAxis[0],
	                unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis,
	                dataMin = unionExtremes.dataMin,
	                dataMax = unionExtremes.dataMax,
	                selected = rangeSelector.selected,
	                allButtonsEnabled = rangeSelector.options.allButtonsEnabled,
	                buttons = rangeSelector.buttons;

	            if (updating && chart.fixedRange !== mathRound(baseAxis.max - baseAxis.min)) {
	                if (buttons[selected]) {
	                    buttons[selected].setState(0);
	                }
	                rangeSelector.setSelected(null);
	            }

	            each(rangeSelector.buttonOptions, function (rangeOptions, i) {
	                var actualRange = mathRound(baseAxis.max - baseAxis.min),
	                    range = rangeOptions._range,
	                    type = rangeOptions.type,
	                    count = rangeOptions.count || 1,
	                    // Disable buttons where the range exceeds what is allowed in the current view
	                    isTooGreatRange = range > dataMax - dataMin,
	                    // Disable buttons where the range is smaller than the minimum range
	                    isTooSmallRange = range < baseAxis.minRange,
	                    // Disable the All button if we're already showing all
	                    isAllButAlreadyShowingAll = rangeOptions.type === 'all' && baseAxis.max - baseAxis.min >= dataMax - dataMin &&
	                        buttons[i].state !== 2,
	                    // Disable the YTD button if the complete range is within the same year
	                    isYTDButNotAvailable = rangeOptions.type === 'ytd' && dateFormat('%Y', dataMin) === dateFormat('%Y', dataMax),
	                    // Set a button on export
	                    isSelectedForExport = chart.renderer.forExport && i === selected,

	                    isSameRange = range === actualRange,

	                    hasNoData = !baseAxis.hasVisibleSeries;

	                // Months and years have a variable range so we check the extremes
	                if ((type === 'month' || type === 'year') && (actualRange >= { month: 28, year: 365 }[type] * 24 * 36e5 * count) &&
	                        (actualRange <= { month: 31, year: 366 }[type] * 24 * 36e5 * count)) {
	                    isSameRange = true;
	                }
	                // The new zoom area happens to match the range for a button - mark it selected.
	                // This happens when scrolling across an ordinal gap. It can be seen in the intraday
	                // demos when selecting 1h and scroll across the night gap.
	                if (isSelectedForExport || (isSameRange && i !== selected) && i === rangeSelector.lastSelected) {
	                    rangeSelector.setSelected(i);
	                    buttons[i].setState(2);

	                } else if (!allButtonsEnabled && (isTooGreatRange || isTooSmallRange || isAllButAlreadyShowingAll || isYTDButNotAvailable || hasNoData)) {
	                    buttons[i].setState(3);

	                } else if (buttons[i].state === 3) {
	                    buttons[i].setState(0);
	                }
	            });
	        },

	        /**
	         * Compute and cache the range for an individual button
	         */
	        computeButtonRange: function (rangeOptions) {
	            var type = rangeOptions.type,
	                count = rangeOptions.count || 1,

	                // these time intervals have a fixed number of milliseconds, as opposed
	                // to month, ytd and year
	                fixedTimes = {
	                    millisecond: 1,
	                    second: 1000,
	                    minute: 60 * 1000,
	                    hour: 3600 * 1000,
	                    day: 24 * 3600 * 1000,
	                    week: 7 * 24 * 3600 * 1000
	                };

	            // Store the range on the button object
	            if (fixedTimes[type]) {
	                rangeOptions._range = fixedTimes[type] * count;
	            } else if (type === 'month' || type === 'year') {
	                rangeOptions._range = { month: 30, year: 365 }[type] * 24 * 36e5 * count;
	            }
	        },

	        /**
	         * Set the internal and displayed value of a HTML input for the dates
	         * @param {String} name
	         * @param {Number} time
	         */
	        setInputValue: function (name, time) {
	            var options = this.chart.options.rangeSelector;

	            if (defined(time)) {
	                this[name + 'Input'].HCTime = time;
	            }

	            this[name + 'Input'].value = dateFormat(
	                options.inputEditDateFormat || '%Y-%m-%d',
	                this[name + 'Input'].HCTime
	            );
	            this[name + 'DateBox'].attr({
	                text: dateFormat(options.inputDateFormat || '%b %e, %Y', this[name + 'Input'].HCTime)
	            });
	        },

	        showInput: function (name) {
	            var inputGroup = this.inputGroup,
	                dateBox = this[name + 'DateBox'];

	            css(this[name + 'Input'], {
	                left: (inputGroup.translateX + dateBox.x) + PX,
	                top: inputGroup.translateY + PX,
	                width: (dateBox.width - 2) + PX,
	                height: (dateBox.height - 2) + PX,
	                border: '2px solid silver'
	            });
	        },

	        hideInput: function (name) {
	            css(this[name + 'Input'], {
	                border: 0,
	                width: '1px',
	                height: '1px'
	            });
	            this.setInputValue(name);
	        },

	        /**
	         * Draw either the 'from' or the 'to' HTML input box of the range selector
	         * @param {Object} name
	         */
	        drawInput: function (name) {
	            var rangeSelector = this,
	                chart = rangeSelector.chart,
	                chartStyle = chart.renderer.style,
	                renderer = chart.renderer,
	                options = chart.options.rangeSelector,
	                lang = defaultOptions.lang,
	                div = rangeSelector.div,
	                isMin = name === 'min',
	                input,
	                label,
	                dateBox,
	                inputGroup = this.inputGroup;

	            // Create the text label
	            this[name + 'Label'] = label = renderer.label(lang[isMin ? 'rangeSelectorFrom' : 'rangeSelectorTo'], this.inputGroup.offset)
	                .attr({
	                    padding: 2
	                })
	                .css(merge(chartStyle, options.labelStyle))
	                .add(inputGroup);
	            inputGroup.offset += label.width + 5;

	            // Create an SVG label that shows updated date ranges and and records click events that
	            // bring in the HTML input.
	            this[name + 'DateBox'] = dateBox = renderer.label('', inputGroup.offset)
	                .attr({
	                    padding: 2,
	                    width: options.inputBoxWidth || 90,
	                    height: options.inputBoxHeight || 17,
	                    stroke: options.inputBoxBorderColor || 'silver',
	                    'stroke-width': 1
	                })
	                .css(merge({
	                    textAlign: 'center',
	                    color: '#444'
	                }, chartStyle, options.inputStyle))
	                .on('click', function () {
	                    rangeSelector.showInput(name); // If it is already focused, the onfocus event doesn't fire (#3713)
	                    rangeSelector[name + 'Input'].focus();
	                })
	                .add(inputGroup);
	            inputGroup.offset += dateBox.width + (isMin ? 10 : 0);


	            // Create the HTML input element. This is rendered as 1x1 pixel then set to the right size
	            // when focused.
	            this[name + 'Input'] = input = createElement('input', {
	                name: name,
	                className: PREFIX + 'range-selector',
	                type: 'text'
	            }, extend({
	                position: ABSOLUTE,
	                border: 0,
	                width: '1px', // Chrome needs a pixel to see it
	                height: '1px',
	                padding: 0,
	                textAlign: 'center',
	                fontSize: chartStyle.fontSize,
	                fontFamily: chartStyle.fontFamily,
	                left: '-9em', // #4798
	                top: chart.plotTop + PX // prevent jump on focus in Firefox
	            }, options.inputStyle), div);

	            // Blow up the input box
	            input.onfocus = function () {
	                rangeSelector.showInput(name);
	            };
	            // Hide away the input box
	            input.onblur = function () {
	                rangeSelector.hideInput(name);
	            };

	            // handle changes in the input boxes
	            input.onchange = function () {
	                var inputValue = input.value,
	                    value = (options.inputDateParser || Date.parse)(inputValue),
	                    xAxis = chart.xAxis[0],
	                    dataMin = xAxis.dataMin,
	                    dataMax = xAxis.dataMax;

	                // If the value isn't parsed directly to a value by the browser's Date.parse method,
	                // like YYYY-MM-DD in IE, try parsing it a different way
	                if (isNaN(value)) {
	                    value = inputValue.split('-');
	                    value = Date.UTC(pInt(value[0]), pInt(value[1]) - 1, pInt(value[2]));
	                }

	                if (!isNaN(value)) {

	                    // Correct for timezone offset (#433)
	                    if (!defaultOptions.global.useUTC) {
	                        value = value + new Date().getTimezoneOffset() * 60 * 1000;
	                    }

	                    // Validate the extremes. If it goes beyound the data min or max, use the
	                    // actual data extreme (#2438).
	                    if (isMin) {
	                        if (value > rangeSelector.maxInput.HCTime) {
	                            value = UNDEFINED;
	                        } else if (value < dataMin) {
	                            value = dataMin;
	                        }
	                    } else {
	                        if (value < rangeSelector.minInput.HCTime) {
	                            value = UNDEFINED;
	                        } else if (value > dataMax) {
	                            value = dataMax;
	                        }
	                    }

	                    // Set the extremes
	                    if (value !== UNDEFINED) {
	                        chart.xAxis[0].setExtremes(
	                            isMin ? value : xAxis.min,
	                            isMin ? xAxis.max : value,
	                            UNDEFINED,
	                            UNDEFINED,
	                            { trigger: 'rangeSelectorInput' }
	                        );
	                    }
	                }
	            };
	        },

	        /**
	         * Get the position of the range selector buttons and inputs. This can be overridden from outside for custom positioning.
	         */
	        getPosition: function () {
	            var chart = this.chart,
	                options = chart.options.rangeSelector,
	                buttonTop = pick((options.buttonPosition || {}).y, chart.plotTop - chart.axisOffset[0] - options.height);

	            return {
	                buttonTop: buttonTop,
	                inputTop: buttonTop - 10
	            };
	        },

	        /**
	         * Render the range selector including the buttons and the inputs. The first time render
	         * is called, the elements are created and positioned. On subsequent calls, they are
	         * moved and updated.
	         * @param {Number} min X axis minimum
	         * @param {Number} max X axis maximum
	         */
	        render: function (min, max) {

	            var rangeSelector = this,
	                chart = rangeSelector.chart,
	                renderer = chart.renderer,
	                container = chart.container,
	                chartOptions = chart.options,
	                navButtonOptions = chartOptions.exporting && chartOptions.navigation && chartOptions.navigation.buttonOptions,
	                options = chartOptions.rangeSelector,
	                buttons = rangeSelector.buttons,
	                lang = defaultOptions.lang,
	                div = rangeSelector.div,
	                inputGroup = rangeSelector.inputGroup,
	                buttonTheme = options.buttonTheme,
	                buttonPosition = options.buttonPosition || {},
	                inputEnabled = options.inputEnabled,
	                states = buttonTheme && buttonTheme.states,
	                plotLeft = chart.plotLeft,
	                buttonLeft,
	                pos = this.getPosition(),
	                buttonGroup = rangeSelector.group,
	                buttonBBox,
	                rendered = rangeSelector.rendered;


	            // create the elements
	            if (!rendered) {

	                rangeSelector.group = buttonGroup = renderer.g('range-selector-buttons').add();

	                rangeSelector.zoomText = renderer.text(lang.rangeSelectorZoom, pick(buttonPosition.x, plotLeft), 15)
	                    .css(options.labelStyle)
	                    .add(buttonGroup);

	                // button starting position
	                buttonLeft = pick(buttonPosition.x, plotLeft) + rangeSelector.zoomText.getBBox().width + 5;

	                each(rangeSelector.buttonOptions, function (rangeOptions, i) {
	                    buttons[i] = renderer.button(
	                            rangeOptions.text,
	                            buttonLeft,
	                            0,
	                            function () {
	                                rangeSelector.clickButton(i);
	                                rangeSelector.isActive = true;
	                            },
	                            buttonTheme,
	                            states && states.hover,
	                            states && states.select,
	                            states && states.disabled
	                        )
	                        .css({
	                            textAlign: 'center'
	                        })
	                        .add(buttonGroup);

	                    // increase button position for the next button
	                    buttonLeft += buttons[i].width + pick(options.buttonSpacing, 5);

	                    if (rangeSelector.selected === i) {
	                        buttons[i].setState(2);
	                    }
	                });

	                rangeSelector.updateButtonStates();

	                // first create a wrapper outside the container in order to make
	                // the inputs work and make export correct
	                if (inputEnabled !== false) {
	                    rangeSelector.div = div = createElement('div', null, {
	                        position: 'relative',
	                        height: 0,
	                        zIndex: 1 // above container
	                    });

	                    container.parentNode.insertBefore(div, container);

	                    // Create the group to keep the inputs
	                    rangeSelector.inputGroup = inputGroup = renderer.g('input-group')
	                        .add();
	                    inputGroup.offset = 0;

	                    rangeSelector.drawInput('min');
	                    rangeSelector.drawInput('max');
	                }
	            }

	            // Set or update the group position
	            buttonGroup[rendered ? 'animate' : 'attr']({
	                translateY: pos.buttonTop
	            });

	            if (inputEnabled !== false) {

	                // Update the alignment to the updated spacing box
	                inputGroup.align(extend({
	                    y: pos.inputTop,
	                    width: inputGroup.offset,
	                    // Detect collision with the exporting buttons
	                    x: navButtonOptions && (pos.inputTop < (navButtonOptions.y || 0) + navButtonOptions.height - chart.spacing[0]) ?
	                        -40 : 0
	                }, options.inputPosition), true, chart.spacingBox);

	                // Hide if overlapping - inputEnabled is null or undefined
	                if (!defined(inputEnabled)) {
	                    buttonBBox = buttonGroup.getBBox();
	                    inputGroup[inputGroup.translateX < buttonBBox.x + buttonBBox.width + 10 ? 'hide' : 'show']();
	                }

	                // Set or reset the input values
	                rangeSelector.setInputValue('min', min);
	                rangeSelector.setInputValue('max', max);
	            }

	            rangeSelector.rendered = true;
	        },

	        /**
	         * Destroys allocated elements.
	         */
	        destroy: function () {
	            var minInput = this.minInput,
	                maxInput = this.maxInput,
	                chart = this.chart,
	                blurInputs = this.blurInputs,
	                key;

	            removeEvent(chart.container, 'mousedown', blurInputs);
	            removeEvent(chart, 'resize', blurInputs);

	            // Destroy elements in collections
	            destroyObjectProperties(this.buttons);

	            // Clear input element events
	            if (minInput) {
	                minInput.onfocus = minInput.onblur = minInput.onchange = null;
	            }
	            if (maxInput) {
	                maxInput.onfocus = maxInput.onblur = maxInput.onchange = null;
	            }

	            // Destroy HTML and SVG elements
	            for (key in this) {
	                if (this[key] && key !== 'chart') {
	                    if (this[key].destroy) { // SVGElement
	                        this[key].destroy();
	                    } else if (this[key].nodeType) { // HTML element
	                        discardElement(this[key]);
	                    }
	                }
	                this[key] = null;
	            }
	        }
	    };

	    /**
	     * Add logic to normalize the zoomed range in order to preserve the pressed state of range selector buttons
	     */
	    Axis.prototype.toFixedRange = function (pxMin, pxMax, fixedMin, fixedMax) {
	        var fixedRange = this.chart && this.chart.fixedRange,
	            newMin = pick(fixedMin, this.translate(pxMin, true)),
	            newMax = pick(fixedMax, this.translate(pxMax, true)),
	            changeRatio = fixedRange && (newMax - newMin) / fixedRange;

	        // If the difference between the fixed range and the actual requested range is
	        // too great, the user is dragging across an ordinal gap, and we need to release
	        // the range selector button.
	        if (changeRatio > 0.7 && changeRatio < 1.3) {
	            if (fixedMax) {
	                newMin = newMax - fixedRange;
	            } else {
	                newMax = newMin + fixedRange;
	            }
	        }
	        if (isNaN(newMin)) { // #1195
	            newMin = newMax = undefined;
	        }

	        return {
	            min: newMin,
	            max: newMax
	        };
	    };

	    Axis.prototype.minFromRange = function () {
	        var rangeOptions = this.range,
	            type = rangeOptions.type,
	            timeName = { month: 'Month', year: 'FullYear' }[type],
	            min,
	            max = this.max,
	            dataMin,
	            range,
	            // Get the true range from a start date
	            getTrueRange = function (base, count) {
	                var date = new Date(base);
	                date['set' + timeName](date['get' + timeName]() + count);
	                return date.getTime() - base;
	            };

	        if (typeof rangeOptions === 'number') {
	            min = this.max - rangeOptions;
	            range = rangeOptions;
	        } else {
	            min = max + getTrueRange(max, -rangeOptions.count);
	        }

	        dataMin = pick(this.dataMin, Number.MIN_VALUE);
	        if (isNaN(min)) {
	            min = dataMin;
	        }
	        if (min <= dataMin) {
	            min = dataMin;
	            if (range === undefined) { // #4501
	                range = getTrueRange(min, rangeOptions.count);
	            }
	            this.newMax = mathMin(min + range, this.dataMax);
	        }
	        if (isNaN(max)) {
	            min = undefined;
	        }
	        return min;

	    };

	    // Initialize scroller for stock charts
	    wrap(Chart.prototype, 'init', function (proceed, options, callback) {

	        addEvent(this, 'init', function () {
	            if (this.options.rangeSelector.enabled) {
	                this.rangeSelector = new RangeSelector(this);
	            }
	        });

	        proceed.call(this, options, callback);

	    });


	    Highcharts.RangeSelector = RangeSelector;

	    /* ****************************************************************************
	     * End Range Selector code                                                    *
	     *****************************************************************************/



	    Chart.prototype.callbacks.push(function (chart) {
	        var extremes,
	            scroller = chart.scroller,
	            rangeSelector = chart.rangeSelector;

	        function renderScroller() {
	            extremes = chart.xAxis[0].getExtremes();
	            scroller.render(extremes.min, extremes.max);
	        }

	        function renderRangeSelector() {
	            extremes = chart.xAxis[0].getExtremes();
	            if (!isNaN(extremes.min)) {
	                rangeSelector.render(extremes.min, extremes.max);
	            }
	        }

	        function afterSetExtremesHandlerScroller(e) {
	            if (e.triggerOp !== 'navigator-drag') {
	                scroller.render(e.min, e.max);
	            }
	        }

	        function afterSetExtremesHandlerRangeSelector(e) {
	            rangeSelector.render(e.min, e.max);
	        }

	        function destroyEvents() {
	            if (scroller) {
	                removeEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerScroller);
	            }
	            if (rangeSelector) {
	                removeEvent(chart, 'resize', renderRangeSelector);
	                removeEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerRangeSelector);
	            }
	        }

	        // initiate the scroller
	        if (scroller) {
	            // redraw the scroller on setExtremes
	            addEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerScroller);

	            // redraw the scroller on chart resize or box resize
	            wrap(chart, 'drawChartBox', function (proceed) {
	                var isDirtyBox = this.isDirtyBox;
	                proceed.call(this);
	                if (isDirtyBox) {
	                    renderScroller();
	                }
	            });

	            // do it now
	            renderScroller();
	        }
	        if (rangeSelector) {
	            // redraw the scroller on setExtremes
	            addEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerRangeSelector);

	            // redraw the scroller chart resize
	            addEvent(chart, 'resize', renderRangeSelector);

	            // do it now
	            renderRangeSelector();
	        }

	        // Remove resize/afterSetExtremes at chart destroy
	        addEvent(chart, 'destroy', destroyEvents);
	    });
	    /**
	     * A wrapper for Chart with all the default values for a Stock chart
	     */
	    Highcharts.StockChart = Highcharts.stockChart = function (a, b, c) {
	        var hasRenderToArg = isString(a) || a.nodeName,
	            options = arguments[hasRenderToArg ? 1 : 0],
	            seriesOptions = options.series, // to increase performance, don't merge the data
	            opposite,

	            // Always disable startOnTick:true on the main axis when the navigator is enabled (#1090)
	            navigatorEnabled = pick(options.navigator && options.navigator.enabled, true),
	            disableStartOnTick = navigatorEnabled ? {
	                startOnTick: false,
	                endOnTick: false
	            } : null,

	            lineOptions = {

	                marker: {
	                    enabled: false,
	                    radius: 2
	                }
	                // gapSize: 0
	            },
	            columnOptions = {
	                shadow: false,
	                borderWidth: 0
	            };

	        // apply X axis options to both single and multi y axes
	        options.xAxis = map(splat(options.xAxis || {}), function (xAxisOptions) {
	            return merge(
	                { // defaults
	                    minPadding: 0,
	                    maxPadding: 0,
	                    ordinal: true,
	                    title: {
	                        text: null
	                    },
	                    labels: {
	                        overflow: 'justify'
	                    },
	                    showLastLabel: true
	                }, xAxisOptions, // user options
	                { // forced options
	                    type: 'datetime',
	                    categories: null
	                },
	                disableStartOnTick
	            );
	        });

	        // apply Y axis options to both single and multi y axes
	        options.yAxis = map(splat(options.yAxis || {}), function (yAxisOptions) {
	            opposite = pick(yAxisOptions.opposite, true);
	            return merge({ // defaults
	                labels: {
	                    y: -2
	                },
	                opposite: opposite,
	                showLastLabel: false,
	                title: {
	                    text: null
	                }
	            }, yAxisOptions // user options
	            );
	        });

	        options.series = null;

	        options = merge(
	            {
	                chart: {
	                    panning: true,
	                    pinchType: 'x'
	                },
	                navigator: {
	                    enabled: true
	                },
	                scrollbar: {
	                    enabled: true
	                },
	                rangeSelector: {
	                    enabled: true
	                },
	                title: {
	                    text: null,
	                    style: {
	                        fontSize: '16px'
	                    }
	                },
	                tooltip: {
	                    shared: true,
	                    crosshairs: true
	                },
	                legend: {
	                    enabled: false
	                },

	                plotOptions: {
	                    line: lineOptions,
	                    spline: lineOptions,
	                    area: lineOptions,
	                    areaspline: lineOptions,
	                    arearange: lineOptions,
	                    areasplinerange: lineOptions,
	                    column: columnOptions,
	                    columnrange: columnOptions,
	                    candlestick: columnOptions,
	                    ohlc: columnOptions
	                }

	            },
	            options, // user's options

	            { // forced options
	                _stock: true, // internal flag
	                chart: {
	                    inverted: false
	                }
	            }
	        );

	        options.series = seriesOptions;

	        return hasRenderToArg ? 
	            new Chart(a, options, c) :
	            new Chart(options, b);
	    };

	    // Implement the pinchType option
	    wrap(Pointer.prototype, 'init', function (proceed, chart, options) {

	        var pinchType = options.chart.pinchType || '';

	        proceed.call(this, chart, options);

	        // Pinch status
	        this.pinchX = this.pinchHor = pinchType.indexOf('x') !== -1;
	        this.pinchY = this.pinchVert = pinchType.indexOf('y') !== -1;
	        this.hasZoom = this.hasZoom || this.pinchHor || this.pinchVert;
	    });

	    // Override the automatic label alignment so that the first Y axis' labels
	    // are drawn on top of the grid line, and subsequent axes are drawn outside
	    wrap(Axis.prototype, 'autoLabelAlign', function (proceed) {
	        var chart = this.chart,
	            options = this.options,
	            panes = chart._labelPanes = chart._labelPanes || {},
	            key,
	            labelOptions = this.options.labels;
	        if (this.chart.options._stock && this.coll === 'yAxis') {
	            key = options.top + ',' + options.height;
	            if (!panes[key] && labelOptions.enabled) { // do it only for the first Y axis of each pane
	                if (labelOptions.x === 15) { // default
	                    labelOptions.x = 0;
	                }
	                if (labelOptions.align === undefined) {
	                    labelOptions.align = 'right';
	                }
	                panes[key] = 1;
	                return 'right';
	            }
	        }
	        return proceed.call(this, [].slice.call(arguments, 1));
	    });

	    // Override getPlotLinePath to allow for multipane charts
	    wrap(Axis.prototype, 'getPlotLinePath', function (proceed, value, lineWidth, old, force, translatedValue) {
	        var axis = this,
	            series = (this.isLinked && !this.series ? this.linkedParent.series : this.series),
	            chart = axis.chart,
	            renderer = chart.renderer,
	            axisLeft = axis.left,
	            axisTop = axis.top,
	            x1,
	            y1,
	            x2,
	            y2,
	            result = [],
	            axes = [], //#3416 need a default array
	            axes2,
	            uniqueAxes,
	            transVal;

	        // Ignore in case of color Axis. #3360, #3524
	        if (axis.coll === 'colorAxis') {
	            return proceed.apply(this, [].slice.call(arguments, 1));
	        }

	        // Get the related axes based on series
	        axes = (axis.isXAxis ?
	            (defined(axis.options.yAxis) ?
	                [chart.yAxis[axis.options.yAxis]] :
	                map(series, function (s) {
	                    return s.yAxis;
	                })
	            ) :
	            (defined(axis.options.xAxis) ?
	                [chart.xAxis[axis.options.xAxis]] :
	                map(series, function (s) {
	                    return s.xAxis;
	                })
	            )
	        );

	        // Get the related axes based options.*Axis setting #2810
	        axes2 = (axis.isXAxis ? chart.yAxis : chart.xAxis);
	        each(axes2, function (A) {
	            if (defined(A.options.id) ? A.options.id.indexOf('navigator') === -1 : true) {
	                var a = (A.isXAxis ? 'yAxis' : 'xAxis'),
	                    rax = (defined(A.options[a]) ? chart[a][A.options[a]] : chart[a][0]);

	                if (axis === rax) {
	                    axes.push(A);
	                }
	            }
	        });


	        // Remove duplicates in the axes array. If there are no axes in the axes array,
	        // we are adding an axis without data, so we need to populate this with grid
	        // lines (#2796).
	        uniqueAxes = axes.length ? [] : [axis.isXAxis ? chart.yAxis[0] : chart.xAxis[0]]; //#3742
	        each(axes, function (axis2) {
	            if (inArray(axis2, uniqueAxes) === -1) {
	                uniqueAxes.push(axis2);
	            }
	        });

	        transVal = pick(translatedValue, axis.translate(value, null, null, old));

	        if (!isNaN(transVal)) {
	            if (axis.horiz) {
	                each(uniqueAxes, function (axis2) {
	                    var skip;

	                    y1 = axis2.pos;
	                    y2 = y1 + axis2.len;
	                    x1 = x2 = mathRound(transVal + axis.transB);

	                    if (x1 < axisLeft || x1 > axisLeft + axis.width) { // outside plot area
	                        if (force) {
	                            x1 = x2 = mathMin(mathMax(axisLeft, x1), axisLeft + axis.width);
	                        } else {
	                            skip = true;
	                        }
	                    }
	                    if (!skip) {
	                        result.push('M', x1, y1, 'L', x2, y2);
	                    }
	                });
	            } else {
	                each(uniqueAxes, function (axis2) {
	                    var skip;

	                    x1 = axis2.pos;
	                    x2 = x1 + axis2.len;
	                    y1 = y2 = mathRound(axisTop + axis.height - transVal);

	                    if (y1 < axisTop || y1 > axisTop + axis.height) { // outside plot area
	                        if (force) {
	                            y1 = y2 = mathMin(mathMax(axisTop, y1), axis.top + axis.height);
	                        } else {
	                            skip = true;
	                        }
	                    }
	                    if (!skip) {
	                        result.push('M', x1, y1, 'L', x2, y2);
	                    }
	                });
	            }
	        }
	        return result.length > 0 ?
	            renderer.crispPolyLine(result, lineWidth || 1) :
	            null; //#3557 getPlotLinePath in regular Highcharts also returns null
	    });

	    // Override getPlotBandPath to allow for multipane charts
	    Axis.prototype.getPlotBandPath = function (from, to) {
	        var toPath = this.getPlotLinePath(to, null, null, true),
	            path = this.getPlotLinePath(from, null, null, true),
	            result = [],
	            i;

	        if (path && toPath && path.toString() !== toPath.toString()) {
	            // Go over each subpath
	            for (i = 0; i < path.length; i += 6) {
	                result.push('M', path[i + 1], path[i + 2], 'L', path[i + 4], path[i + 5], toPath[i + 4], toPath[i + 5], toPath[i + 1], toPath[i + 2]);
	            }
	        } else { // outside the axis area
	            result = null;
	        }

	        return result;
	    };

	    // Function to crisp a line with multiple segments
	    SVGRenderer.prototype.crispPolyLine = function (points, width) {
	        // points format: [M, 0, 0, L, 100, 0]
	        // normalize to a crisp line
	        var i;
	        for (i = 0; i < points.length; i = i + 6) {
	            if (points[i + 1] === points[i + 4]) {
	                // Substract due to #1129. Now bottom and left axis gridlines behave the same.
	                points[i + 1] = points[i + 4] = mathRound(points[i + 1]) - (width % 2 / 2);
	            }
	            if (points[i + 2] === points[i + 5]) {
	                points[i + 2] = points[i + 5] = mathRound(points[i + 2]) + (width % 2 / 2);
	            }
	        }
	        return points;
	    };
	    if (Renderer === Highcharts.VMLRenderer) {
	        VMLRenderer.prototype.crispPolyLine = SVGRenderer.prototype.crispPolyLine;
	    }


	    // Wrapper to hide the label
	    wrap(Axis.prototype, 'hideCrosshair', function (proceed, i) {
	        proceed.call(this, i);

	        if (this.crossLabel) {
	            this.crossLabel = this.crossLabel.hide();
	        }
	    });

	    // Wrapper to draw the label
	    wrap(Axis.prototype, 'drawCrosshair', function (proceed, e, point) {
	        // Draw the crosshair
	        proceed.call(this, e, point);

	        // Check if the label has to be drawn
	        if (!defined(this.crosshair.label) || !this.crosshair.label.enabled) {
	            return;
	        }

	        var chart = this.chart,
	            options = this.options.crosshair.label,        // the label's options
	            horiz = this.horiz,                            // axis orientation
	            opposite = this.opposite,                    // axis position
	            left = this.left,                            // left position
	            top = this.top,                                // top position
	            crossLabel = this.crossLabel,                // reference to the svgElement
	            posx,
	            posy,
	            crossBox,
	            formatOption = options.format,
	            formatFormat = '',
	            limit,
	            align,
	            tickInside = this.options.tickPosition === 'inside',
	            snap = this.crosshair.snap !== false,
	            value;

	        align = (horiz ? 'center' : opposite ? (this.labelAlign === 'right' ? 'right' : 'left') : (this.labelAlign === 'left' ? 'left' : 'center'));

	        // If the label does not exist yet, create it.
	        if (!crossLabel) {
	            crossLabel = this.crossLabel = chart.renderer.label(null, null, null, options.shape || 'callout')
	            .attr({
	                align: options.align || align,
	                zIndex: 12,
	                fill: options.backgroundColor || (this.series[0] && this.series[0].color) || 'gray',
	                padding: pick(options.padding, 8),
	                stroke: options.borderColor || '',
	                'stroke-width': options.borderWidth || 0,
	                r: pick(options.borderRadius, 3)
	            })
	            .css(extend({
	                color: 'white',
	                fontWeight: 'normal',
	                fontSize: '11px',
	                textAlign: 'center'
	            }, options.style))
	            .add();
	        }

	        if (horiz) {
	            posx = snap ? point.plotX + left : e.chartX;
	            posy = top + (opposite ? 0 : this.height);
	        } else {
	            posx = opposite ? this.width + left : 0;
	            posy = snap ? point.plotY + top : e.chartY;
	        }

	        if (!formatOption && !options.formatter) {
	            if (this.isDatetimeAxis) {
	                formatFormat = '%b %d, %Y';
	            }
	            formatOption = '{value' + (formatFormat ? ':' + formatFormat : '') + '}';
	        }

	        // Show the label
	        value = snap ? point[this.isXAxis ? 'x' : 'y'] : this.toValue(horiz ? e.chartX : e.chartY);
	        crossLabel.attr({
	            text: formatOption ? format(formatOption, { value: value }) : options.formatter.call(this, value),
	            anchorX: horiz ? posx : (this.opposite ? 0 : chart.chartWidth),
	            anchorY: horiz ? (this.opposite ? chart.chartHeight : 0) : posy,
	            x: posx,
	            y: posy,
	            visibility: VISIBLE
	        });
	        crossBox = crossLabel.getBBox();

	        // now it is placed we can correct its position
	        if (horiz) {
	            if ((tickInside && !opposite) || (!tickInside && opposite)) {
	                posy = crossLabel.y - crossBox.height;
	            }
	        } else {
	            posy = crossLabel.y - (crossBox.height / 2);
	        }

	        // check the edges
	        if (horiz) {
	            limit = {
	                left: left - crossBox.x,
	                right: left + this.width - crossBox.x
	            };
	        } else {
	            limit = {
	                left: this.labelAlign === 'left' ? left : 0,
	                right: this.labelAlign === 'right' ? left + this.width : chart.chartWidth
	            };
	        }

	        // left edge
	        if (crossLabel.translateX < limit.left) {
	            posx += limit.left - crossLabel.translateX;
	        }
	        // right edge
	        if (crossLabel.translateX + crossBox.width >= limit.right) {
	            posx -= crossLabel.translateX + crossBox.width - limit.right;
	        }

	        // show the crosslabel
	        crossLabel.attr({ x: posx, y: posy, visibility: 'visible' });
	    });

	    /* ****************************************************************************
	     * Start value compare logic                                                  *
	     *****************************************************************************/

	    var seriesInit = seriesProto.init,
	        seriesProcessData = seriesProto.processData,
	        pointTooltipFormatter = Point.prototype.tooltipFormatter;

	    /**
	     * Extend series.init by adding a method to modify the y value used for plotting
	     * on the y axis. This method is called both from the axis when finding dataMin
	     * and dataMax, and from the series.translate method.
	     */
	    seriesProto.init = function () {

	        // Call base method
	        seriesInit.apply(this, arguments);

	        // Set comparison mode
	        this.setCompare(this.options.compare);
	    };

	    /**
	     * The setCompare method can be called also from the outside after render time
	     */
	    seriesProto.setCompare = function (compare) {

	        // Set or unset the modifyValue method
	        this.modifyValue = (compare === 'value' || compare === 'percent') ? function (value, point) {
	            var compareValue = this.compareValue;

	            if (value !== UNDEFINED) { // #2601

	                // get the modified value
	                value = compare === 'value' ?
	                    value - compareValue : // compare value
	                    value = 100 * (value / compareValue) - 100; // compare percent

	                // record for tooltip etc.
	                if (point) {
	                    point.change = value;
	                }

	            }

	            return value;
	        } : null;

	        // Mark dirty
	        if (this.chart.hasRendered) {
	            this.isDirty = true;
	        }

	    };

	    /**
	     * Extend series.processData by finding the first y value in the plot area,
	     * used for comparing the following values
	     */
	    seriesProto.processData = function () {
	        var series = this,
	            i,
	            keyIndex = -1,
	            processedXData,
	            processedYData,
	            length,
	            compareValue;

	        // call base method
	        seriesProcessData.apply(this, arguments);

	        if (series.xAxis && series.processedYData) { // not pies

	            // local variables
	            processedXData = series.processedXData;
	            processedYData = series.processedYData;
	            length = processedYData.length;

	            // For series with more than one value (range, OHLC etc), compare against
	            // the pointValKey (#4922)
	            if (series.pointArrayMap) {
	                keyIndex = inArray(series.pointValKey || 'y', series.pointArrayMap);
	            }

	            // find the first value for comparison
	            for (i = 0; i < length; i++) {
	                compareValue = keyIndex > -1 ? 
	                    processedYData[i][keyIndex] :
	                    processedYData[i];
	                if (typeof compareValue === 'number' && processedXData[i] >= series.xAxis.min && compareValue !== 0) {
	                    series.compareValue = compareValue;
	                    break;
	                }
	            }
	        }
	    };

	    /**
	     * Modify series extremes
	     */
	    wrap(seriesProto, 'getExtremes', function (proceed) {
	        var extremes;

	        proceed.apply(this, [].slice.call(arguments, 1));

	        if (this.modifyValue) {
	            extremes = [this.modifyValue(this.dataMin), this.modifyValue(this.dataMax)];
	            this.dataMin = arrayMin(extremes);
	            this.dataMax = arrayMax(extremes);
	        }
	    });

	    /**
	     * Add a utility method, setCompare, to the Y axis
	     */
	    Axis.prototype.setCompare = function (compare, redraw) {
	        if (!this.isXAxis) {
	            each(this.series, function (series) {
	                series.setCompare(compare);
	            });
	            if (pick(redraw, true)) {
	                this.chart.redraw();
	            }
	        }
	    };

	    /**
	     * Extend the tooltip formatter by adding support for the point.change variable
	     * as well as the changeDecimals option
	     */
	    Point.prototype.tooltipFormatter = function (pointFormat) {
	        var point = this;

	        pointFormat = pointFormat.replace(
	            '{point.change}',
	            (point.change > 0 ? '+' : '') + Highcharts.numberFormat(point.change, pick(point.series.tooltipOptions.changeDecimals, 2))
	        );

	        return pointTooltipFormatter.apply(this, [pointFormat]);
	    };

	    /* ****************************************************************************
	     * End value compare logic                                                    *
	     *****************************************************************************/


	    /**
	     * Extend the Series prototype to create a separate series clip box. This is related
	     * to using multiple panes, and a future pane logic should incorporate this feature (#2754).
	     */
	    wrap(Series.prototype, 'render', function (proceed) {
	        // Only do this on stock charts (#2939), and only if the series type handles clipping
	        // in the animate method (#2975).
	        if (this.chart.options._stock && this.xAxis) {

	            // First render, initial clip box
	            if (!this.clipBox && this.animate) {
	                this.clipBox = merge(this.chart.clipBox);
	                this.clipBox.width = this.xAxis.len;
	                this.clipBox.height = this.yAxis.len;

	            // On redrawing, resizing etc, update the clip rectangle
	            } else if (this.chart[this.sharedClipKey]) {
	                stop(this.chart[this.sharedClipKey]); // #2998
	                this.chart[this.sharedClipKey].attr({
	                    width: this.xAxis.len,
	                    height: this.yAxis.len
	                });
	            }
	        }
	        proceed.call(this);
	    });

	    // global variables
	    extend(Highcharts, {

	        // Constructors
	        Color: Color,
	        Point: Point,
	        Tick: Tick,
	        Renderer: Renderer,
	        SVGElement: SVGElement,
	        SVGRenderer: SVGRenderer,

	        // Various
	        arrayMin: arrayMin,
	        arrayMax: arrayMax,
	        charts: charts,
	        dateFormat: dateFormat,
	        error: error,
	        format: format,
	        pathAnim: pathAnim,
	        getOptions: getOptions,
	        hasBidiBug: hasBidiBug,
	        isTouchDevice: isTouchDevice,
	        setOptions: setOptions,
	        addEvent: addEvent,
	        removeEvent: removeEvent,
	        createElement: createElement,
	        discardElement: discardElement,
	        css: css,
	        each: each,
	        map: map,
	        merge: merge,
	        splat: splat,
	        stableSort: stableSort,
	        extendClass: extendClass,
	        pInt: pInt,
	        svg: hasSVG,
	        canvas: useCanVG,
	        vml: !hasSVG && !useCanVG,
	        product: PRODUCT,
	        version: VERSION
	    });
	    
	    return Highcharts;
	}));


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var Application, Backbone, GA, Marionette, Nav, RootView, Router, User,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	GA = __webpack_require__(7);

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	Nav = __webpack_require__(11);

	Router = __webpack_require__(20);

	User = (function(superClass) {
	  extend(User, superClass);

	  function User() {
	    return User.__super__.constructor.apply(this, arguments);
	  }

	  User.prototype.url = '/api/user';

	  User.prototype.defaults = {
	    firstname: '',
	    lastname: '',
	    email: ''
	  };

	  return User;

	})(Backbone.Model);

	RootView = (function(superClass) {
	  extend(RootView, superClass);

	  function RootView() {
	    return RootView.__super__.constructor.apply(this, arguments);
	  }

	  RootView.prototype.el = 'body';

	  RootView.prototype.regions = {
	    header: '.header',
	    content: '.content'
	  };

	  return RootView;

	})(Marionette.LayoutView);

	Application = (function(superClass) {
	  extend(Application, superClass);

	  function Application() {
	    return Application.__super__.constructor.apply(this, arguments);
	  }

	  Application.prototype.onStart = function() {
	    var googleAnalytics, navChannel, rootChannel, rootView, user, userChannel;
	    googleAnalytics = new GA();
	    user = new User();
	    user.fetch();
	    rootView = new RootView();
	    userChannel = Backbone.Radio.channel('user');
	    rootChannel = Backbone.Radio.channel('root');
	    navChannel = Backbone.Radio.channel('nav');
	    userChannel.reply({
	      'user': function() {
	        return user;
	      }
	    });
	    rootChannel.reply({
	      'rootview': function() {
	        return rootView;
	      }
	    });
	    navChannel.reply({
	      'nav:index': function() {
	        rootView.showChildView('header', new Nav.Index());
	      },
	      'nav:main': function() {
	        rootView.showChildView('header', new Nav.Main({
	          model: user
	        }));
	      }
	    });
	    new Router({
	      mode: 'auto',
	      trailingSlash: 'ignore'
	    });
	    Backbone.history.on('route', function(router, route, params) {
	      googleAnalytics.send(route);
	    });
	    Backbone.history.start({
	      pushState: true,
	      hashChange: false
	    });
	  };

	  return Application;

	})(Marionette.Application);

	module.exports = new Application();


/***/ },
/* 7 */
/***/ function(module, exports) {

	var GoogleAnalytic;

	GoogleAnalytic = (function() {
	  function GoogleAnalytic() {}

	  GoogleAnalytic.prototype.send = function(route) {
	    var _gaq;
	    _gaq = _gaq || [];
	    _gaq.push(['_setAccount', 'UA-74126093-1']);
	    _gaq.push(['_trackPageview']);
	    (function() {
	      var ga, s;
	      ga = document.createElement('script');
	      ga.type = 'text/javascript';
	      ga.async = true;
	      ga.src = ('https:' === document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	      s = document.getElementsByTagName('script')[0];
	      return s.parentNode.insertBefore(ga, s);
	    })();
	    _gaq.push(['_trackPageview', "/" + route]);
	    ga('send', 'pageview');
	  };

	  return GoogleAnalytic;

	})();

	module.exports = GoogleAnalytic;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {/*** IMPORTS FROM imports-loader ***/
	var Backbone = __webpack_require__(8);

	//     Backbone.js 1.2.3

	//     (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Backbone may be freely distributed under the MIT license.
	//     For all details and documentation:
	//     http://backbonejs.org

	(function(factory) {

	  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
	  // We use `self` instead of `window` for `WebWorker` support.
	  var root = (typeof self == 'object' && self.self == self && self) ||
	      (typeof global == 'object' && global.global == global && global);

	  // Set up Backbone appropriately for the environment. Start with AMD.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9), __webpack_require__(2), exports], __WEBPACK_AMD_DEFINE_RESULT__ = function(_, $, exports) {
	      // Export global even in AMD case in case this script is loaded with
	      // others that may still expect a global Backbone.
	      root.Backbone = factory(root, exports, _, $);
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	    // Next for Node.js or CommonJS. jQuery may not be needed as a module.
	  } else if (typeof exports !== 'undefined') {
	    var _ = require('underscore'), $;
	    try { $ = require('jquery'); } catch(e) {}
	    factory(root, exports, _, $);

	    // Finally, as a browser global.
	  } else {
	    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
	  }

	}(function(root, Backbone, _, $) {

	  // Initial Setup
	  // -------------

	  // Save the previous value of the `Backbone` variable, so that it can be
	  // restored later on, if `noConflict` is used.
	  var previousBackbone = root.Backbone;

	  // Create a local reference to a common array method we'll want to use later.
	  var slice = Array.prototype.slice;

	  // Current version of the library. Keep in sync with `package.json`.
	  Backbone.VERSION = '1.2.3';

	  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
	  // the `$` variable.
	  Backbone.$ = $;

	  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
	  // to its previous owner. Returns a reference to this Backbone object.
	  Backbone.noConflict = function() {
	    root.Backbone = previousBackbone;
	    return this;
	  };

	  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
	  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
	  // set a `X-Http-Method-Override` header.
	  Backbone.emulateHTTP = false;

	  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
	  // `application/json` requests ... this will encode the body as
	  // `application/x-www-form-urlencoded` instead and will send the model in a
	  // form param named `model`.
	  Backbone.emulateJSON = false;

	  // Proxy Backbone class methods to Underscore functions, wrapping the model's
	  // `attributes` object or collection's `models` array behind the scenes.
	  //
	  // collection.filter(function(model) { return model.get('age') > 10 });
	  // collection.each(this.addView);
	  //
	  // `Function#apply` can be slow so we use the method's arg count, if we know it.
	  var addMethod = function(length, method, attribute) {
	    switch (length) {
	      case 1: return function() {
	        return _[method](this[attribute]);
	      };
	      case 2: return function(value) {
	        return _[method](this[attribute], value);
	      };
	      case 3: return function(iteratee, context) {
	        return _[method](this[attribute], cb(iteratee, this), context);
	      };
	      case 4: return function(iteratee, defaultVal, context) {
	        return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
	      };
	      default: return function() {
	        var args = slice.call(arguments);
	        args.unshift(this[attribute]);
	        return _[method].apply(_, args);
	      };
	    }
	  };
	  var addUnderscoreMethods = function(Class, methods, attribute) {
	    _.each(methods, function(length, method) {
	      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
	    });
	  };

	  // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.
	  var cb = function(iteratee, instance) {
	    if (_.isFunction(iteratee)) return iteratee;
	    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
	    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };
	    return iteratee;
	  };
	  var modelMatcher = function(attrs) {
	    var matcher = _.matches(attrs);
	    return function(model) {
	      return matcher(model.attributes);
	    };
	  };

	  // Backbone.Events
	  // ---------------

	  // A module that can be mixed in to *any object* in order to provide it with
	  // a custom event channel. You may bind a callback to an event with `on` or
	  // remove with `off`; `trigger`-ing an event fires all callbacks in
	  // succession.
	  //
	  //     var object = {};
	  //     _.extend(object, Backbone.Events);
	  //     object.on('expand', function(){ alert('expanded'); });
	  //     object.trigger('expand');
	  //
	  var Events = Backbone.Events = {};

	  // Regular expression used to split event strings.
	  var eventSplitter = /\s+/;

	  // Iterates over the standard `event, callback` (as well as the fancy multiple
	  // space-separated events `"change blur", callback` and jQuery-style event
	  // maps `{event: callback}`).
	  var eventsApi = function(iteratee, events, name, callback, opts) {
	    var i = 0, names;
	    if (name && typeof name === 'object') {
	      // Handle event maps.
	      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
	      for (names = _.keys(name); i < names.length ; i++) {
	        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
	      }
	    } else if (name && eventSplitter.test(name)) {
	      // Handle space separated event names by delegating them individually.
	      for (names = name.split(eventSplitter); i < names.length; i++) {
	        events = iteratee(events, names[i], callback, opts);
	      }
	    } else {
	      // Finally, standard events.
	      events = iteratee(events, name, callback, opts);
	    }
	    return events;
	  };

	  // Bind an event to a `callback` function. Passing `"all"` will bind
	  // the callback to all events fired.
	  Events.on = function(name, callback, context) {
	    return internalOn(this, name, callback, context);
	  };

	  // Guard the `listening` argument from the public API.
	  var internalOn = function(obj, name, callback, context, listening) {
	    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
	      context: context,
	      ctx: obj,
	      listening: listening
	    });

	    if (listening) {
	      var listeners = obj._listeners || (obj._listeners = {});
	      listeners[listening.id] = listening;
	    }

	    return obj;
	  };

	  // Inversion-of-control versions of `on`. Tell *this* object to listen to
	  // an event in another object... keeping track of what it's listening to
	  // for easier unbinding later.
	  Events.listenTo =  function(obj, name, callback) {
	    if (!obj) return this;
	    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
	    var listeningTo = this._listeningTo || (this._listeningTo = {});
	    var listening = listeningTo[id];

	    // This object is not listening to any other events on `obj` yet.
	    // Setup the necessary references to track the listening callbacks.
	    if (!listening) {
	      var thisId = this._listenId || (this._listenId = _.uniqueId('l'));
	      listening = listeningTo[id] = {obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0};
	    }

	    // Bind callbacks on obj, and keep track of them on listening.
	    internalOn(obj, name, callback, this, listening);
	    return this;
	  };

	  // The reducing API that adds a callback to the `events` object.
	  var onApi = function(events, name, callback, options) {
	    if (callback) {
	      var handlers = events[name] || (events[name] = []);
	      var context = options.context, ctx = options.ctx, listening = options.listening;
	      if (listening) listening.count++;

	      handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });
	    }
	    return events;
	  };

	  // Remove one or many callbacks. If `context` is null, removes all
	  // callbacks with that function. If `callback` is null, removes all
	  // callbacks for the event. If `name` is null, removes all bound
	  // callbacks for all events.
	  Events.off =  function(name, callback, context) {
	    if (!this._events) return this;
	    this._events = eventsApi(offApi, this._events, name, callback, {
	      context: context,
	      listeners: this._listeners
	    });
	    return this;
	  };

	  // Tell this object to stop listening to either specific events ... or
	  // to every object it's currently listening to.
	  Events.stopListening =  function(obj, name, callback) {
	    var listeningTo = this._listeningTo;
	    if (!listeningTo) return this;

	    var ids = obj ? [obj._listenId] : _.keys(listeningTo);

	    for (var i = 0; i < ids.length; i++) {
	      var listening = listeningTo[ids[i]];

	      // If listening doesn't exist, this object is not currently
	      // listening to obj. Break out early.
	      if (!listening) break;

	      listening.obj.off(name, callback, this);
	    }
	    if (_.isEmpty(listeningTo)) this._listeningTo = void 0;

	    return this;
	  };

	  // The reducing API that removes a callback from the `events` object.
	  var offApi = function(events, name, callback, options) {
	    if (!events) return;

	    var i = 0, listening;
	    var context = options.context, listeners = options.listeners;

	    // Delete all events listeners and "drop" events.
	    if (!name && !callback && !context) {
	      var ids = _.keys(listeners);
	      for (; i < ids.length; i++) {
	        listening = listeners[ids[i]];
	        delete listeners[listening.id];
	        delete listening.listeningTo[listening.objId];
	      }
	      return;
	    }

	    var names = name ? [name] : _.keys(events);
	    for (; i < names.length; i++) {
	      name = names[i];
	      var handlers = events[name];

	      // Bail out if there are no events stored.
	      if (!handlers) break;

	      // Replace events if there are any remaining.  Otherwise, clean up.
	      var remaining = [];
	      for (var j = 0; j < handlers.length; j++) {
	        var handler = handlers[j];
	        if (
	            callback && callback !== handler.callback &&
	            callback !== handler.callback._callback ||
	            context && context !== handler.context
	        ) {
	          remaining.push(handler);
	        } else {
	          listening = handler.listening;
	          if (listening && --listening.count === 0) {
	            delete listeners[listening.id];
	            delete listening.listeningTo[listening.objId];
	          }
	        }
	      }

	      // Update tail event if the list has any events.  Otherwise, clean up.
	      if (remaining.length) {
	        events[name] = remaining;
	      } else {
	        delete events[name];
	      }
	    }
	    if (_.size(events)) return events;
	  };

	  // Bind an event to only be triggered a single time. After the first time
	  // the callback is invoked, its listener will be removed. If multiple events
	  // are passed in using the space-separated syntax, the handler will fire
	  // once for each event, not once for a combination of all events.
	  Events.once =  function(name, callback, context) {
	    // Map the event into a `{event: once}` object.
	    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
	    return this.on(events, void 0, context);
	  };

	  // Inversion-of-control versions of `once`.
	  Events.listenToOnce =  function(obj, name, callback) {
	    // Map the event into a `{event: once}` object.
	    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
	    return this.listenTo(obj, events);
	  };

	  // Reduces the event callbacks into a map of `{event: onceWrapper}`.
	  // `offer` unbinds the `onceWrapper` after it has been called.
	  var onceMap = function(map, name, callback, offer) {
	    if (callback) {
	      var once = map[name] = _.once(function() {
	        offer(name, once);
	        callback.apply(this, arguments);
	      });
	      once._callback = callback;
	    }
	    return map;
	  };

	  // Trigger one or many events, firing all bound callbacks. Callbacks are
	  // passed the same arguments as `trigger` is, apart from the event name
	  // (unless you're listening on `"all"`, which will cause your callback to
	  // receive the true name of the event as the first argument).
	  Events.trigger =  function(name) {
	    if (!this._events) return this;

	    var length = Math.max(0, arguments.length - 1);
	    var args = Array(length);
	    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];

	    eventsApi(triggerApi, this._events, name, void 0, args);
	    return this;
	  };

	  // Handles triggering the appropriate event callbacks.
	  var triggerApi = function(objEvents, name, cb, args) {
	    if (objEvents) {
	      var events = objEvents[name];
	      var allEvents = objEvents.all;
	      if (events && allEvents) allEvents = allEvents.slice();
	      if (events) triggerEvents(events, args);
	      if (allEvents) triggerEvents(allEvents, [name].concat(args));
	    }
	    return objEvents;
	  };

	  // A difficult-to-believe, but optimized internal dispatch function for
	  // triggering events. Tries to keep the usual cases speedy (most internal
	  // Backbone events have 3 arguments).
	  var triggerEvents = function(events, args) {
	    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
	    switch (args.length) {
	      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
	      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
	      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
	      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
	      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
	    }
	  };

	  // Aliases for backwards compatibility.
	  Events.bind   = Events.on;
	  Events.unbind = Events.off;

	  // Allow the `Backbone` object to serve as a global event bus, for folks who
	  // want global "pubsub" in a convenient place.
	  _.extend(Backbone, Events);

	  // Backbone.Model
	  // --------------

	  // Backbone **Models** are the basic data object in the framework --
	  // frequently representing a row in a table in a database on your server.
	  // A discrete chunk of data and a bunch of useful, related methods for
	  // performing computations and transformations on that data.

	  // Create a new model with the specified attributes. A client id (`cid`)
	  // is automatically generated and assigned for you.
	  var Model = Backbone.Model = function(attributes, options) {
	    var attrs = attributes || {};
	    options || (options = {});
	    this.cid = _.uniqueId(this.cidPrefix);
	    this.attributes = {};
	    if (options.collection) this.collection = options.collection;
	    if (options.parse) attrs = this.parse(attrs, options) || {};
	    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
	    this.set(attrs, options);
	    this.changed = {};
	    this.initialize.apply(this, arguments);
	  };

	  // Attach all inheritable methods to the Model prototype.
	  _.extend(Model.prototype, Events, {

	    // A hash of attributes whose current and previous value differ.
	    changed: null,

	    // The value returned during the last failed validation.
	    validationError: null,

	    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
	    // CouchDB users may want to set this to `"_id"`.
	    idAttribute: 'id',

	    // The prefix is used to create the client id which is used to identify models locally.
	    // You may want to override this if you're experiencing name clashes with model ids.
	    cidPrefix: 'c',

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // Return a copy of the model's `attributes` object.
	    toJSON: function(options) {
	      return _.clone(this.attributes);
	    },

	    // Proxy `Backbone.sync` by default -- but override this if you need
	    // custom syncing semantics for *this* particular model.
	    sync: function() {
	      return Backbone.sync.apply(this, arguments);
	    },

	    // Get the value of an attribute.
	    get: function(attr) {
	      return this.attributes[attr];
	    },

	    // Get the HTML-escaped value of an attribute.
	    escape: function(attr) {
	      return _.escape(this.get(attr));
	    },

	    // Returns `true` if the attribute contains a value that is not null
	    // or undefined.
	    has: function(attr) {
	      return this.get(attr) != null;
	    },

	    // Special-cased proxy to underscore's `_.matches` method.
	    matches: function(attrs) {
	      return !!_.iteratee(attrs, this)(this.attributes);
	    },

	    // Set a hash of model attributes on the object, firing `"change"`. This is
	    // the core primitive operation of a model, updating the data and notifying
	    // anyone who needs to know about the change in state. The heart of the beast.
	    set: function(key, val, options) {
	      if (key == null) return this;

	      // Handle both `"key", value` and `{key: value}` -style arguments.
	      var attrs;
	      if (typeof key === 'object') {
	        attrs = key;
	        options = val;
	      } else {
	        (attrs = {})[key] = val;
	      }

	      options || (options = {});

	      // Run validation.
	      if (!this._validate(attrs, options)) return false;

	      // Extract attributes and options.
	      var unset      = options.unset;
	      var silent     = options.silent;
	      var changes    = [];
	      var changing   = this._changing;
	      this._changing = true;

	      if (!changing) {
	        this._previousAttributes = _.clone(this.attributes);
	        this.changed = {};
	      }

	      var current = this.attributes;
	      var changed = this.changed;
	      var prev    = this._previousAttributes;

	      // For each `set` attribute, update or delete the current value.
	      for (var attr in attrs) {
	        val = attrs[attr];
	        if (!_.isEqual(current[attr], val)) changes.push(attr);
	        if (!_.isEqual(prev[attr], val)) {
	          changed[attr] = val;
	        } else {
	          delete changed[attr];
	        }
	        unset ? delete current[attr] : current[attr] = val;
	      }

	      // Update the `id`.
	      this.id = this.get(this.idAttribute);

	      // Trigger all relevant attribute changes.
	      if (!silent) {
	        if (changes.length) this._pending = options;
	        for (var i = 0; i < changes.length; i++) {
	          this.trigger('change:' + changes[i], this, current[changes[i]], options);
	        }
	      }

	      // You might be wondering why there's a `while` loop here. Changes can
	      // be recursively nested within `"change"` events.
	      if (changing) return this;
	      if (!silent) {
	        while (this._pending) {
	          options = this._pending;
	          this._pending = false;
	          this.trigger('change', this, options);
	        }
	      }
	      this._pending = false;
	      this._changing = false;
	      return this;
	    },

	    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
	    // if the attribute doesn't exist.
	    unset: function(attr, options) {
	      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
	    },

	    // Clear all attributes on the model, firing `"change"`.
	    clear: function(options) {
	      var attrs = {};
	      for (var key in this.attributes) attrs[key] = void 0;
	      return this.set(attrs, _.extend({}, options, {unset: true}));
	    },

	    // Determine if the model has changed since the last `"change"` event.
	    // If you specify an attribute name, determine if that attribute has changed.
	    hasChanged: function(attr) {
	      if (attr == null) return !_.isEmpty(this.changed);
	      return _.has(this.changed, attr);
	    },

	    // Return an object containing all the attributes that have changed, or
	    // false if there are no changed attributes. Useful for determining what
	    // parts of a view need to be updated and/or what attributes need to be
	    // persisted to the server. Unset attributes will be set to undefined.
	    // You can also pass an attributes object to diff against the model,
	    // determining if there *would be* a change.
	    changedAttributes: function(diff) {
	      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
	      var old = this._changing ? this._previousAttributes : this.attributes;
	      var changed = {};
	      for (var attr in diff) {
	        var val = diff[attr];
	        if (_.isEqual(old[attr], val)) continue;
	        changed[attr] = val;
	      }
	      return _.size(changed) ? changed : false;
	    },

	    // Get the previous value of an attribute, recorded at the time the last
	    // `"change"` event was fired.
	    previous: function(attr) {
	      if (attr == null || !this._previousAttributes) return null;
	      return this._previousAttributes[attr];
	    },

	    // Get all of the attributes of the model at the time of the previous
	    // `"change"` event.
	    previousAttributes: function() {
	      return _.clone(this._previousAttributes);
	    },

	    // Fetch the model from the server, merging the response with the model's
	    // local attributes. Any changed attributes will trigger a "change" event.
	    fetch: function(options) {
	      options = _.extend({parse: true}, options);
	      var model = this;
	      var success = options.success;
	      options.success = function(resp) {
	        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
	        if (!model.set(serverAttrs, options)) return false;
	        if (success) success.call(options.context, model, resp, options);
	        model.trigger('sync', model, resp, options);
	      };
	      wrapError(this, options);
	      return this.sync('read', this, options);
	    },

	    // Set a hash of model attributes, and sync the model to the server.
	    // If the server returns an attributes hash that differs, the model's
	    // state will be `set` again.
	    save: function(key, val, options) {
	      // Handle both `"key", value` and `{key: value}` -style arguments.
	      var attrs;
	      if (key == null || typeof key === 'object') {
	        attrs = key;
	        options = val;
	      } else {
	        (attrs = {})[key] = val;
	      }

	      options = _.extend({validate: true, parse: true}, options);
	      var wait = options.wait;

	      // If we're not waiting and attributes exist, save acts as
	      // `set(attr).save(null, opts)` with validation. Otherwise, check if
	      // the model will be valid when the attributes, if any, are set.
	      if (attrs && !wait) {
	        if (!this.set(attrs, options)) return false;
	      } else {
	        if (!this._validate(attrs, options)) return false;
	      }

	      // After a successful server-side save, the client is (optionally)
	      // updated with the server-side state.
	      var model = this;
	      var success = options.success;
	      var attributes = this.attributes;
	      options.success = function(resp) {
	        // Ensure attributes are restored during synchronous saves.
	        model.attributes = attributes;
	        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
	        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
	        if (serverAttrs && !model.set(serverAttrs, options)) return false;
	        if (success) success.call(options.context, model, resp, options);
	        model.trigger('sync', model, resp, options);
	      };
	      wrapError(this, options);

	      // Set temporary attributes if `{wait: true}` to properly find new ids.
	      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);

	      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
	      if (method === 'patch' && !options.attrs) options.attrs = attrs;
	      var xhr = this.sync(method, this, options);

	      // Restore attributes.
	      this.attributes = attributes;

	      return xhr;
	    },

	    // Destroy this model on the server if it was already persisted.
	    // Optimistically removes the model from its collection, if it has one.
	    // If `wait: true` is passed, waits for the server to respond before removal.
	    destroy: function(options) {
	      options = options ? _.clone(options) : {};
	      var model = this;
	      var success = options.success;
	      var wait = options.wait;

	      var destroy = function() {
	        model.stopListening();
	        model.trigger('destroy', model, model.collection, options);
	      };

	      options.success = function(resp) {
	        if (wait) destroy();
	        if (success) success.call(options.context, model, resp, options);
	        if (!model.isNew()) model.trigger('sync', model, resp, options);
	      };

	      var xhr = false;
	      if (this.isNew()) {
	        _.defer(options.success);
	      } else {
	        wrapError(this, options);
	        xhr = this.sync('delete', this, options);
	      }
	      if (!wait) destroy();
	      return xhr;
	    },

	    // Default URL for the model's representation on the server -- if you're
	    // using Backbone's restful methods, override this to change the endpoint
	    // that will be called.
	    url: function() {
	      var base =
	          _.result(this, 'urlRoot') ||
	          _.result(this.collection, 'url') ||
	          urlError();
	      if (this.isNew()) return base;
	      var id = this.get(this.idAttribute);
	      return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
	    },

	    // **parse** converts a response into the hash of attributes to be `set` on
	    // the model. The default implementation is just to pass the response along.
	    parse: function(resp, options) {
	      return resp;
	    },

	    // Create a new model with identical attributes to this one.
	    clone: function() {
	      return new this.constructor(this.attributes);
	    },

	    // A model is new if it has never been saved to the server, and lacks an id.
	    isNew: function() {
	      return !this.has(this.idAttribute);
	    },

	    // Check if the model is currently in a valid state.
	    isValid: function(options) {
	      return this._validate({}, _.defaults({validate: true}, options));
	    },

	    // Run validation against the next complete set of model attributes,
	    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
	    _validate: function(attrs, options) {
	      if (!options.validate || !this.validate) return true;
	      attrs = _.extend({}, this.attributes, attrs);
	      var error = this.validationError = this.validate(attrs, options) || null;
	      if (!error) return true;
	      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
	      return false;
	    }

	  });

	  // Underscore methods that we want to implement on the Model, mapped to the
	  // number of arguments they take.
	  var modelMethods = { keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
	    omit: 0, chain: 1, isEmpty: 1 };

	  // Mix in each Underscore method as a proxy to `Model#attributes`.
	  addUnderscoreMethods(Model, modelMethods, 'attributes');

	  // Backbone.Collection
	  // -------------------

	  // If models tend to represent a single row of data, a Backbone Collection is
	  // more analogous to a table full of data ... or a small slice or page of that
	  // table, or a collection of rows that belong together for a particular reason
	  // -- all of the messages in this particular folder, all of the documents
	  // belonging to this particular author, and so on. Collections maintain
	  // indexes of their models, both in order, and for lookup by `id`.

	  // Create a new **Collection**, perhaps to contain a specific type of `model`.
	  // If a `comparator` is specified, the Collection will maintain
	  // its models in sort order, as they're added and removed.
	  var Collection = Backbone.Collection = function(models, options) {
	    options || (options = {});
	    if (options.model) this.model = options.model;
	    if (options.comparator !== void 0) this.comparator = options.comparator;
	    this._reset();
	    this.initialize.apply(this, arguments);
	    if (models) this.reset(models, _.extend({silent: true}, options));
	  };

	  // Default options for `Collection#set`.
	  var setOptions = {add: true, remove: true, merge: true};
	  var addOptions = {add: true, remove: false};

	  // Splices `insert` into `array` at index `at`.
	  var splice = function(array, insert, at) {
	    at = Math.min(Math.max(at, 0), array.length);
	    var tail = Array(array.length - at);
	    var length = insert.length;
	    for (var i = 0; i < tail.length; i++) tail[i] = array[i + at];
	    for (i = 0; i < length; i++) array[i + at] = insert[i];
	    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
	  };

	  // Define the Collection's inheritable methods.
	  _.extend(Collection.prototype, Events, {

	    // The default model for a collection is just a **Backbone.Model**.
	    // This should be overridden in most cases.
	    model: Model,

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // The JSON representation of a Collection is an array of the
	    // models' attributes.
	    toJSON: function(options) {
	      return this.map(function(model) { return model.toJSON(options); });
	    },

	    // Proxy `Backbone.sync` by default.
	    sync: function() {
	      return Backbone.sync.apply(this, arguments);
	    },

	    // Add a model, or list of models to the set. `models` may be Backbone
	    // Models or raw JavaScript objects to be converted to Models, or any
	    // combination of the two.
	    add: function(models, options) {
	      return this.set(models, _.extend({merge: false}, options, addOptions));
	    },

	    // Remove a model, or a list of models from the set.
	    remove: function(models, options) {
	      options = _.extend({}, options);
	      var singular = !_.isArray(models);
	      models = singular ? [models] : _.clone(models);
	      var removed = this._removeModels(models, options);
	      if (!options.silent && removed) this.trigger('update', this, options);
	      return singular ? removed[0] : removed;
	    },

	    // Update a collection by `set`-ing a new list of models, adding new ones,
	    // removing models that are no longer present, and merging models that
	    // already exist in the collection, as necessary. Similar to **Model#set**,
	    // the core operation for updating the data contained by the collection.
	    set: function(models, options) {
	      if (models == null) return;

	      options = _.defaults({}, options, setOptions);
	      if (options.parse && !this._isModel(models)) models = this.parse(models, options);

	      var singular = !_.isArray(models);
	      models = singular ? [models] : models.slice();

	      var at = options.at;
	      if (at != null) at = +at;
	      if (at < 0) at += this.length + 1;

	      var set = [];
	      var toAdd = [];
	      var toRemove = [];
	      var modelMap = {};

	      var add = options.add;
	      var merge = options.merge;
	      var remove = options.remove;

	      var sort = false;
	      var sortable = this.comparator && (at == null) && options.sort !== false;
	      var sortAttr = _.isString(this.comparator) ? this.comparator : null;

	      // Turn bare objects into model references, and prevent invalid models
	      // from being added.
	      var model;
	      for (var i = 0; i < models.length; i++) {
	        model = models[i];

	        // If a duplicate is found, prevent it from being added and
	        // optionally merge it into the existing model.
	        var existing = this.get(model);
	        if (existing) {
	          if (merge && model !== existing) {
	            var attrs = this._isModel(model) ? model.attributes : model;
	            if (options.parse) attrs = existing.parse(attrs, options);
	            existing.set(attrs, options);
	            if (sortable && !sort) sort = existing.hasChanged(sortAttr);
	          }
	          if (!modelMap[existing.cid]) {
	            modelMap[existing.cid] = true;
	            set.push(existing);
	          }
	          models[i] = existing;

	          // If this is a new, valid model, push it to the `toAdd` list.
	        } else if (add) {
	          model = models[i] = this._prepareModel(model, options);
	          if (model) {
	            toAdd.push(model);
	            this._addReference(model, options);
	            modelMap[model.cid] = true;
	            set.push(model);
	          }
	        }
	      }

	      // Remove stale models.
	      if (remove) {
	        for (i = 0; i < this.length; i++) {
	          model = this.models[i];
	          if (!modelMap[model.cid]) toRemove.push(model);
	        }
	        if (toRemove.length) this._removeModels(toRemove, options);
	      }

	      // See if sorting is needed, update `length` and splice in new models.
	      var orderChanged = false;
	      var replace = !sortable && add && remove;
	      if (set.length && replace) {
	        orderChanged = this.length != set.length || _.some(this.models, function(model, index) {
	              return model !== set[index];
	            });
	        this.models.length = 0;
	        splice(this.models, set, 0);
	        this.length = this.models.length;
	      } else if (toAdd.length) {
	        if (sortable) sort = true;
	        splice(this.models, toAdd, at == null ? this.length : at);
	        this.length = this.models.length;
	      }

	      // Silently sort the collection if appropriate.
	      if (sort) this.sort({silent: true});

	      // Unless silenced, it's time to fire all appropriate add/sort events.
	      if (!options.silent) {
	        for (i = 0; i < toAdd.length; i++) {
	          if (at != null) options.index = at + i;
	          model = toAdd[i];
	          model.trigger('add', model, this, options);
	        }
	        if (sort || orderChanged) this.trigger('sort', this, options);
	        if (toAdd.length || toRemove.length) this.trigger('update', this, options);
	      }

	      // Return the added (or merged) model (or models).
	      return singular ? models[0] : models;
	    },

	    // When you have more items than you want to add or remove individually,
	    // you can reset the entire set with a new list of models, without firing
	    // any granular `add` or `remove` events. Fires `reset` when finished.
	    // Useful for bulk operations and optimizations.
	    reset: function(models, options) {
	      options = options ? _.clone(options) : {};
	      for (var i = 0; i < this.models.length; i++) {
	        this._removeReference(this.models[i], options);
	      }
	      options.previousModels = this.models;
	      this._reset();
	      models = this.add(models, _.extend({silent: true}, options));
	      if (!options.silent) this.trigger('reset', this, options);
	      return models;
	    },

	    // Add a model to the end of the collection.
	    push: function(model, options) {
	      return this.add(model, _.extend({at: this.length}, options));
	    },

	    // Remove a model from the end of the collection.
	    pop: function(options) {
	      var model = this.at(this.length - 1);
	      return this.remove(model, options);
	    },

	    // Add a model to the beginning of the collection.
	    unshift: function(model, options) {
	      return this.add(model, _.extend({at: 0}, options));
	    },

	    // Remove a model from the beginning of the collection.
	    shift: function(options) {
	      var model = this.at(0);
	      return this.remove(model, options);
	    },

	    // Slice out a sub-array of models from the collection.
	    slice: function() {
	      return slice.apply(this.models, arguments);
	    },

	    // Get a model from the set by id.
	    get: function(obj) {
	      if (obj == null) return void 0;
	      var id = this.modelId(this._isModel(obj) ? obj.attributes : obj);
	      return this._byId[obj] || this._byId[id] || this._byId[obj.cid];
	    },

	    // Get the model at the given index.
	    at: function(index) {
	      if (index < 0) index += this.length;
	      return this.models[index];
	    },

	    // Return models with matching attributes. Useful for simple cases of
	    // `filter`.
	    where: function(attrs, first) {
	      return this[first ? 'find' : 'filter'](attrs);
	    },

	    // Return the first model with matching attributes. Useful for simple cases
	    // of `find`.
	    findWhere: function(attrs) {
	      return this.where(attrs, true);
	    },

	    // Force the collection to re-sort itself. You don't need to call this under
	    // normal circumstances, as the set will maintain sort order as each item
	    // is added.
	    sort: function(options) {
	      var comparator = this.comparator;
	      if (!comparator) throw new Error('Cannot sort a set without a comparator');
	      options || (options = {});

	      var length = comparator.length;
	      if (_.isFunction(comparator)) comparator = _.bind(comparator, this);

	      // Run sort based on type of `comparator`.
	      if (length === 1 || _.isString(comparator)) {
	        this.models = this.sortBy(comparator);
	      } else {
	        this.models.sort(comparator);
	      }
	      if (!options.silent) this.trigger('sort', this, options);
	      return this;
	    },

	    // Pluck an attribute from each model in the collection.
	    pluck: function(attr) {
	      return _.invoke(this.models, 'get', attr);
	    },

	    // Fetch the default set of models for this collection, resetting the
	    // collection when they arrive. If `reset: true` is passed, the response
	    // data will be passed through the `reset` method instead of `set`.
	    fetch: function(options) {
	      options = _.extend({parse: true}, options);
	      var success = options.success;
	      var collection = this;
	      options.success = function(resp) {
	        var method = options.reset ? 'reset' : 'set';
	        collection[method](resp, options);
	        if (success) success.call(options.context, collection, resp, options);
	        collection.trigger('sync', collection, resp, options);
	      };
	      wrapError(this, options);
	      return this.sync('read', this, options);
	    },

	    // Create a new instance of a model in this collection. Add the model to the
	    // collection immediately, unless `wait: true` is passed, in which case we
	    // wait for the server to agree.
	    create: function(model, options) {
	      options = options ? _.clone(options) : {};
	      var wait = options.wait;
	      model = this._prepareModel(model, options);
	      if (!model) return false;
	      if (!wait) this.add(model, options);
	      var collection = this;
	      var success = options.success;
	      options.success = function(model, resp, callbackOpts) {
	        if (wait) collection.add(model, callbackOpts);
	        if (success) success.call(callbackOpts.context, model, resp, callbackOpts);
	      };
	      model.save(null, options);
	      return model;
	    },

	    // **parse** converts a response into a list of models to be added to the
	    // collection. The default implementation is just to pass it through.
	    parse: function(resp, options) {
	      return resp;
	    },

	    // Create a new collection with an identical list of models as this one.
	    clone: function() {
	      return new this.constructor(this.models, {
	        model: this.model,
	        comparator: this.comparator
	      });
	    },

	    // Define how to uniquely identify models in the collection.
	    modelId: function (attrs) {
	      return attrs[this.model.prototype.idAttribute || 'id'];
	    },

	    // Private method to reset all internal state. Called when the collection
	    // is first initialized or reset.
	    _reset: function() {
	      this.length = 0;
	      this.models = [];
	      this._byId  = {};
	    },

	    // Prepare a hash of attributes (or other model) to be added to this
	    // collection.
	    _prepareModel: function(attrs, options) {
	      if (this._isModel(attrs)) {
	        if (!attrs.collection) attrs.collection = this;
	        return attrs;
	      }
	      options = options ? _.clone(options) : {};
	      options.collection = this;
	      var model = new this.model(attrs, options);
	      if (!model.validationError) return model;
	      this.trigger('invalid', this, model.validationError, options);
	      return false;
	    },

	    // Internal method called by both remove and set.
	    _removeModels: function(models, options) {
	      var removed = [];
	      for (var i = 0; i < models.length; i++) {
	        var model = this.get(models[i]);
	        if (!model) continue;

	        var index = this.indexOf(model);
	        this.models.splice(index, 1);
	        this.length--;

	        if (!options.silent) {
	          options.index = index;
	          model.trigger('remove', model, this, options);
	        }

	        removed.push(model);
	        this._removeReference(model, options);
	      }
	      return removed.length ? removed : false;
	    },

	    // Method for checking whether an object should be considered a model for
	    // the purposes of adding to the collection.
	    _isModel: function (model) {
	      return model instanceof Model;
	    },

	    // Internal method to create a model's ties to a collection.
	    _addReference: function(model, options) {
	      this._byId[model.cid] = model;
	      var id = this.modelId(model.attributes);
	      if (id != null) this._byId[id] = model;
	      model.on('all', this._onModelEvent, this);
	    },

	    // Internal method to sever a model's ties to a collection.
	    _removeReference: function(model, options) {
	      delete this._byId[model.cid];
	      var id = this.modelId(model.attributes);
	      if (id != null) delete this._byId[id];
	      if (this === model.collection) delete model.collection;
	      model.off('all', this._onModelEvent, this);
	    },

	    // Internal method called every time a model in the set fires an event.
	    // Sets need to update their indexes when models change ids. All other
	    // events simply proxy through. "add" and "remove" events that originate
	    // in other collections are ignored.
	    _onModelEvent: function(event, model, collection, options) {
	      if ((event === 'add' || event === 'remove') && collection !== this) return;
	      if (event === 'destroy') this.remove(model, options);
	      if (event === 'change') {
	        var prevId = this.modelId(model.previousAttributes());
	        var id = this.modelId(model.attributes);
	        if (prevId !== id) {
	          if (prevId != null) delete this._byId[prevId];
	          if (id != null) this._byId[id] = model;
	        }
	      }
	      this.trigger.apply(this, arguments);
	    }

	  });

	  // Underscore methods that we want to implement on the Collection.
	  // 90% of the core usefulness of Backbone Collections is actually implemented
	  // right here:
	  var collectionMethods = { forEach: 3, each: 3, map: 3, collect: 3, reduce: 4,
	    foldl: 4, inject: 4, reduceRight: 4, foldr: 4, find: 3, detect: 3, filter: 3,
	    select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,
	    contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
	    head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
	    without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
	    isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,
	    sortBy: 3, indexBy: 3};

	  // Mix in each Underscore method as a proxy to `Collection#models`.
	  addUnderscoreMethods(Collection, collectionMethods, 'models');

	  // Backbone.View
	  // -------------

	  // Backbone Views are almost more convention than they are actual code. A View
	  // is simply a JavaScript object that represents a logical chunk of UI in the
	  // DOM. This might be a single item, an entire list, a sidebar or panel, or
	  // even the surrounding frame which wraps your whole app. Defining a chunk of
	  // UI as a **View** allows you to define your DOM events declaratively, without
	  // having to worry about render order ... and makes it easy for the view to
	  // react to specific changes in the state of your models.

	  // Creating a Backbone.View creates its initial element outside of the DOM,
	  // if an existing element is not provided...
	  var View = Backbone.View = function(options) {
	    this.cid = _.uniqueId('view');
	    _.extend(this, _.pick(options, viewOptions));
	    this._ensureElement();
	    this.initialize.apply(this, arguments);
	  };

	  // Cached regex to split keys for `delegate`.
	  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

	  // List of view options to be set as properties.
	  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

	  // Set up all inheritable **Backbone.View** properties and methods.
	  _.extend(View.prototype, Events, {

	    // The default `tagName` of a View's element is `"div"`.
	    tagName: 'div',

	    // jQuery delegate for element lookup, scoped to DOM elements within the
	    // current view. This should be preferred to global lookups where possible.
	    $: function(selector) {
	      return this.$el.find(selector);
	    },

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // **render** is the core function that your view should override, in order
	    // to populate its element (`this.el`), with the appropriate HTML. The
	    // convention is for **render** to always return `this`.
	    render: function() {
	      return this;
	    },

	    // Remove this view by taking the element out of the DOM, and removing any
	    // applicable Backbone.Events listeners.
	    remove: function() {
	      this._removeElement();
	      this.stopListening();
	      return this;
	    },

	    // Remove this view's element from the document and all event listeners
	    // attached to it. Exposed for subclasses using an alternative DOM
	    // manipulation API.
	    _removeElement: function() {
	      this.$el.remove();
	    },

	    // Change the view's element (`this.el` property) and re-delegate the
	    // view's events on the new element.
	    setElement: function(element) {
	      this.undelegateEvents();
	      this._setElement(element);
	      this.delegateEvents();
	      return this;
	    },

	    // Creates the `this.el` and `this.$el` references for this view using the
	    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
	    // context or an element. Subclasses can override this to utilize an
	    // alternative DOM manipulation API and are only required to set the
	    // `this.el` property.
	    _setElement: function(el) {
	      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
	      this.el = this.$el[0];
	    },

	    // Set callbacks, where `this.events` is a hash of
	    //
	    // *{"event selector": "callback"}*
	    //
	    //     {
	    //       'mousedown .title':  'edit',
	    //       'click .button':     'save',
	    //       'click .open':       function(e) { ... }
	    //     }
	    //
	    // pairs. Callbacks will be bound to the view, with `this` set properly.
	    // Uses event delegation for efficiency.
	    // Omitting the selector binds the event to `this.el`.
	    delegateEvents: function(events) {
	      events || (events = _.result(this, 'events'));
	      if (!events) return this;
	      this.undelegateEvents();
	      for (var key in events) {
	        var method = events[key];
	        if (!_.isFunction(method)) method = this[method];
	        if (!method) continue;
	        var match = key.match(delegateEventSplitter);
	        this.delegate(match[1], match[2], _.bind(method, this));
	      }
	      return this;
	    },

	    // Add a single event listener to the view's element (or a child element
	    // using `selector`). This only works for delegate-able events: not `focus`,
	    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
	    delegate: function(eventName, selector, listener) {
	      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
	      return this;
	    },

	    // Clears all callbacks previously bound to the view by `delegateEvents`.
	    // You usually don't need to use this, but may wish to if you have multiple
	    // Backbone views attached to the same DOM element.
	    undelegateEvents: function() {
	      if (this.$el) this.$el.off('.delegateEvents' + this.cid);
	      return this;
	    },

	    // A finer-grained `undelegateEvents` for removing a single delegated event.
	    // `selector` and `listener` are both optional.
	    undelegate: function(eventName, selector, listener) {
	      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
	      return this;
	    },

	    // Produces a DOM element to be assigned to your view. Exposed for
	    // subclasses using an alternative DOM manipulation API.
	    _createElement: function(tagName) {
	      return document.createElement(tagName);
	    },

	    // Ensure that the View has a DOM element to render into.
	    // If `this.el` is a string, pass it through `$()`, take the first
	    // matching element, and re-assign it to `el`. Otherwise, create
	    // an element from the `id`, `className` and `tagName` properties.
	    _ensureElement: function() {
	      if (!this.el) {
	        var attrs = _.extend({}, _.result(this, 'attributes'));
	        if (this.id) attrs.id = _.result(this, 'id');
	        if (this.className) attrs['class'] = _.result(this, 'className');
	        this.setElement(this._createElement(_.result(this, 'tagName')));
	        this._setAttributes(attrs);
	      } else {
	        this.setElement(_.result(this, 'el'));
	      }
	    },

	    // Set attributes from a hash on this view's element.  Exposed for
	    // subclasses using an alternative DOM manipulation API.
	    _setAttributes: function(attributes) {
	      this.$el.attr(attributes);
	    }

	  });

	  // Backbone.sync
	  // -------------

	  // Override this function to change the manner in which Backbone persists
	  // models to the server. You will be passed the type of request, and the
	  // model in question. By default, makes a RESTful Ajax request
	  // to the model's `url()`. Some possible customizations could be:
	  //
	  // * Use `setTimeout` to batch rapid-fire updates into a single request.
	  // * Send up the models as XML instead of JSON.
	  // * Persist models via WebSockets instead of Ajax.
	  //
	  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
	  // as `POST`, with a `_method` parameter containing the true HTTP method,
	  // as well as all requests with the body as `application/x-www-form-urlencoded`
	  // instead of `application/json` with the model in a param named `model`.
	  // Useful when interfacing with server-side languages like **PHP** that make
	  // it difficult to read the body of `PUT` requests.
	  Backbone.sync = function(method, model, options) {
	    var type = methodMap[method];

	    // Default options, unless specified.
	    _.defaults(options || (options = {}), {
	      emulateHTTP: Backbone.emulateHTTP,
	      emulateJSON: Backbone.emulateJSON
	    });

	    // Default JSON-request options.
	    var params = {type: type, dataType: 'json'};

	    // Ensure that we have a URL.
	    if (!options.url) {
	      params.url = _.result(model, 'url') || urlError();
	    }

	    // Ensure that we have the appropriate request data.
	    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
	      params.contentType = 'application/json';
	      params.data = JSON.stringify(options.attrs || model.toJSON(options));
	    }

	    // For older servers, emulate JSON by encoding the request into an HTML-form.
	    if (options.emulateJSON) {
	      params.contentType = 'application/x-www-form-urlencoded';
	      params.data = params.data ? {model: params.data} : {};
	    }

	    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
	    // And an `X-HTTP-Method-Override` header.
	    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
	      params.type = 'POST';
	      if (options.emulateJSON) params.data._method = type;
	      var beforeSend = options.beforeSend;
	      options.beforeSend = function(xhr) {
	        xhr.setRequestHeader('X-HTTP-Method-Override', type);
	        if (beforeSend) return beforeSend.apply(this, arguments);
	      };
	    }

	    // Don't process data on a non-GET request.
	    if (params.type !== 'GET' && !options.emulateJSON) {
	      params.processData = false;
	    }

	    // Pass along `textStatus` and `errorThrown` from jQuery.
	    var error = options.error;
	    options.error = function(xhr, textStatus, errorThrown) {
	      options.textStatus = textStatus;
	      options.errorThrown = errorThrown;
	      if (error) error.call(options.context, xhr, textStatus, errorThrown);
	    };

	    // Make the request, allowing the user to override any Ajax options.
	    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
	    model.trigger('request', model, xhr, options);
	    return xhr;
	  };

	  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
	  var methodMap = {
	    'create': 'POST',
	    'update': 'PUT',
	    'patch':  'PATCH',
	    'delete': 'DELETE',
	    'read':   'GET'
	  };

	  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
	  // Override this if you'd like to use a different library.
	  Backbone.ajax = function() {
	    return Backbone.$.ajax.apply(Backbone.$, arguments);
	  };

	  // Backbone.Router
	  // ---------------

	  // Routers map faux-URLs to actions, and fire events when routes are
	  // matched. Creating a new one sets its `routes` hash, if not set statically.
	  var Router = Backbone.Router = function(options) {
	    options || (options = {});
	    if (options.routes) this.routes = options.routes;
	    this._bindRoutes();
	    this.initialize.apply(this, arguments);
	  };

	  // Cached regular expressions for matching named param parts and splatted
	  // parts of route strings.
	  var optionalParam = /\((.*?)\)/g;
	  var namedParam    = /(\(\?)?:\w+/g;
	  var splatParam    = /\*\w+/g;
	  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

	  // Set up all inheritable **Backbone.Router** properties and methods.
	  _.extend(Router.prototype, Events, {

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // Manually bind a single named route to a callback. For example:
	    //
	    //     this.route('search/:query/p:num', 'search', function(query, num) {
	    //       ...
	    //     });
	    //
	    route: function(route, name, callback) {
	      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
	      if (_.isFunction(name)) {
	        callback = name;
	        name = '';
	      }
	      if (!callback) callback = this[name];
	      var router = this;
	      Backbone.history.route(route, function(fragment) {
	        var args = router._extractParameters(route, fragment);
	        if (router.execute(callback, args, name) !== false) {
	          router.trigger.apply(router, ['route:' + name].concat(args));
	          router.trigger('route', name, args);
	          Backbone.history.trigger('route', router, name, args);
	        }
	      });
	      return this;
	    },

	    // Execute a route handler with the provided parameters.  This is an
	    // excellent place to do pre-route setup or post-route cleanup.
	    execute: function(callback, args, name) {
	      if (callback) callback.apply(this, args);
	    },

	    // Simple proxy to `Backbone.history` to save a fragment into the history.
	    navigate: function(fragment, options) {
	      Backbone.history.navigate(fragment, options);
	      return this;
	    },

	    // Bind all defined routes to `Backbone.history`. We have to reverse the
	    // order of the routes here to support behavior where the most general
	    // routes can be defined at the bottom of the route map.
	    _bindRoutes: function() {
	      if (!this.routes) return;
	      this.routes = _.result(this, 'routes');
	      var route, routes = _.keys(this.routes);
	      while ((route = routes.pop()) != null) {
	        this.route(route, this.routes[route]);
	      }
	    },

	    // Convert a route string into a regular expression, suitable for matching
	    // against the current location hash.
	    _routeToRegExp: function(route) {
	      route = route.replace(escapeRegExp, '\\$&')
	          .replace(optionalParam, '(?:$1)?')
	          .replace(namedParam, function(match, optional) {
	            return optional ? match : '([^/?]+)';
	          })
	          .replace(splatParam, '([^?]*?)');
	      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
	    },

	    // Given a route, and a URL fragment that it matches, return the array of
	    // extracted decoded parameters. Empty or unmatched parameters will be
	    // treated as `null` to normalize cross-browser behavior.
	    _extractParameters: function(route, fragment) {
	      var params = route.exec(fragment).slice(1);
	      return _.map(params, function(param, i) {
	        // Don't decode the search params.
	        if (i === params.length - 1) return param || null;
	        return param ? decodeURIComponent(param) : null;
	      });
	    }

	  });

	  // Backbone.History
	  // ----------------

	  // Handles cross-browser history management, based on either
	  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
	  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
	  // and URL fragments. If the browser supports neither (old IE, natch),
	  // falls back to polling.
	  var History = Backbone.History = function() {
	    this.handlers = [];
	    this.checkUrl = _.bind(this.checkUrl, this);

	    // Ensure that `History` can be used outside of the browser.
	    if (typeof window !== 'undefined') {
	      this.location = window.location;
	      this.history = window.history;
	    }
	  };

	  // Cached regex for stripping a leading hash/slash and trailing space.
	  var routeStripper = /^[#\/]|\s+$/g;

	  // Cached regex for stripping leading and trailing slashes.
	  var rootStripper = /^\/+|\/+$/g;

	  // Cached regex for stripping urls of hash.
	  var pathStripper = /#.*$/;

	  // Has the history handling already been started?
	  History.started = false;

	  // Set up all inheritable **Backbone.History** properties and methods.
	  _.extend(History.prototype, Events, {

	    // The default interval to poll for hash changes, if necessary, is
	    // twenty times a second.
	    interval: 50,

	    // Are we at the app root?
	    atRoot: function() {
	      var path = this.location.pathname.replace(/[^\/]$/, '$&/');
	      return path === this.root && !this.getSearch();
	    },

	    // Does the pathname match the root?
	    matchRoot: function() {
	      var path = this.decodeFragment(this.location.pathname);
	      var root = path.slice(0, this.root.length - 1) + '/';
	      return root === this.root;
	    },

	    // Unicode characters in `location.pathname` are percent encoded so they're
	    // decoded for comparison. `%25` should not be decoded since it may be part
	    // of an encoded parameter.
	    decodeFragment: function(fragment) {
	      return decodeURI(fragment.replace(/%25/g, '%2525'));
	    },

	    // In IE6, the hash fragment and search params are incorrect if the
	    // fragment contains `?`.
	    getSearch: function() {
	      var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
	      return match ? match[0] : '';
	    },

	    // Gets the true hash value. Cannot use location.hash directly due to bug
	    // in Firefox where location.hash will always be decoded.
	    getHash: function(window) {
	      var match = (window || this).location.href.match(/#(.*)$/);
	      return match ? match[1] : '';
	    },

	    // Get the pathname and search params, without the root.
	    getPath: function() {
	      var path = this.decodeFragment(
	          this.location.pathname + this.getSearch()
	      ).slice(this.root.length - 1);
	      return path.charAt(0) === '/' ? path.slice(1) : path;
	    },

	    // Get the cross-browser normalized URL fragment from the path or hash.
	    getFragment: function(fragment) {
	      if (fragment == null) {
	        if (this._usePushState || !this._wantsHashChange) {
	          fragment = this.getPath();
	        } else {
	          fragment = this.getHash();
	        }
	      }
	      return fragment.replace(routeStripper, '');
	    },

	    // Start the hash change handling, returning `true` if the current URL matches
	    // an existing route, and `false` otherwise.
	    start: function(options) {
	      if (History.started) throw new Error('Backbone.history has already been started');
	      History.started = true;

	      // Figure out the initial configuration. Do we need an iframe?
	      // Is pushState desired ... is it available?
	      this.options          = _.extend({root: '/'}, this.options, options);
	      this.root             = this.options.root;
	      this._wantsHashChange = this.options.hashChange !== false;
	      this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
	      this._useHashChange   = this._wantsHashChange && this._hasHashChange;
	      this._wantsPushState  = !!this.options.pushState;
	      this._hasPushState    = !!(this.history && this.history.pushState);
	      this._usePushState    = this._wantsPushState && this._hasPushState;
	      this.fragment         = this.getFragment();

	      // Normalize root to always include a leading and trailing slash.
	      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

	      // Transition from hashChange to pushState or vice versa if both are
	      // requested.
	      if (this._wantsHashChange && this._wantsPushState) {

	        // If we've started off with a route from a `pushState`-enabled
	        // browser, but we're currently in a browser that doesn't support it...
	        if (!this._hasPushState && !this.atRoot()) {
	          var root = this.root.slice(0, -1) || '/';
	          this.location.replace(root + '#' + this.getPath());
	          // Return immediately as browser will do redirect to new url
	          return true;

	          // Or if we've started out with a hash-based route, but we're currently
	          // in a browser where it could be `pushState`-based instead...
	        } else if (this._hasPushState && this.atRoot()) {
	          this.navigate(this.getHash(), {replace: true});
	        }

	      }

	      // Proxy an iframe to handle location events if the browser doesn't
	      // support the `hashchange` event, HTML5 history, or the user wants
	      // `hashChange` but not `pushState`.
	      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
	        this.iframe = document.createElement('iframe');
	        this.iframe.src = 'javascript:0';
	        this.iframe.style.display = 'none';
	        this.iframe.tabIndex = -1;
	        var body = document.body;
	        // Using `appendChild` will throw on IE < 9 if the document is not ready.
	        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
	        iWindow.document.open();
	        iWindow.document.close();
	        iWindow.location.hash = '#' + this.fragment;
	      }

	      // Add a cross-platform `addEventListener` shim for older browsers.
	      var addEventListener = window.addEventListener || function (eventName, listener) {
	            return attachEvent('on' + eventName, listener);
	          };

	      // Depending on whether we're using pushState or hashes, and whether
	      // 'onhashchange' is supported, determine how we check the URL state.
	      if (this._usePushState) {
	        addEventListener('popstate', this.checkUrl, false);
	      } else if (this._useHashChange && !this.iframe) {
	        addEventListener('hashchange', this.checkUrl, false);
	      } else if (this._wantsHashChange) {
	        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
	      }

	      if (!this.options.silent) return this.loadUrl();
	    },

	    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
	    // but possibly useful for unit testing Routers.
	    stop: function() {
	      // Add a cross-platform `removeEventListener` shim for older browsers.
	      var removeEventListener = window.removeEventListener || function (eventName, listener) {
	            return detachEvent('on' + eventName, listener);
	          };

	      // Remove window listeners.
	      if (this._usePushState) {
	        removeEventListener('popstate', this.checkUrl, false);
	      } else if (this._useHashChange && !this.iframe) {
	        removeEventListener('hashchange', this.checkUrl, false);
	      }

	      // Clean up the iframe if necessary.
	      if (this.iframe) {
	        document.body.removeChild(this.iframe);
	        this.iframe = null;
	      }

	      // Some environments will throw when clearing an undefined interval.
	      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
	      History.started = false;
	    },

	    // Add a route to be tested when the fragment changes. Routes added later
	    // may override previous routes.
	    route: function(route, callback) {
	      this.handlers.unshift({route: route, callback: callback});
	    },

	    // Checks the current URL to see if it has changed, and if it has,
	    // calls `loadUrl`, normalizing across the hidden iframe.
	    checkUrl: function(e) {
	      var current = this.getFragment();

	      // If the user pressed the back button, the iframe's hash will have
	      // changed and we should use that for comparison.
	      if (current === this.fragment && this.iframe) {
	        current = this.getHash(this.iframe.contentWindow);
	      }

	      if (current === this.fragment) return false;
	      if (this.iframe) this.navigate(current);
	      this.loadUrl();
	    },

	    // Attempt to load the current URL fragment. If a route succeeds with a
	    // match, returns `true`. If no defined routes matches the fragment,
	    // returns `false`.
	    loadUrl: function(fragment) {
	      // If the root doesn't match, no routes can match either.
	      if (!this.matchRoot()) return false;
	      fragment = this.fragment = this.getFragment(fragment);
	      return _.some(this.handlers, function(handler) {
	        if (handler.route.test(fragment)) {
	          handler.callback(fragment);
	          return true;
	        }
	      });
	    },

	    // Save a fragment into the hash history, or replace the URL state if the
	    // 'replace' option is passed. You are responsible for properly URL-encoding
	    // the fragment in advance.
	    //
	    // The options object can contain `trigger: true` if you wish to have the
	    // route callback be fired (not usually desirable), or `replace: true`, if
	    // you wish to modify the current URL without adding an entry to the history.
	    navigate: function(fragment, options) {
	      if (!History.started) return false;
	      if (!options || options === true) options = {trigger: !!options};

	      // Normalize the fragment.
	      fragment = this.getFragment(fragment || '');

	      // Don't include a trailing slash on the root.
	      var root = this.root;
	      if (fragment === '' || fragment.charAt(0) === '?') {
	        root = root.slice(0, -1) || '/';
	      }
	      var url = root + fragment;

	      // Strip the hash and decode for matching.
	      fragment = this.decodeFragment(fragment.replace(pathStripper, ''));

	      if (this.fragment === fragment) return;
	      this.fragment = fragment;

	      // If pushState is available, we use it to set the fragment as a real URL.
	      if (this._usePushState) {
	        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

	        // If hash changes haven't been explicitly disabled, update the hash
	        // fragment to store history.
	      } else if (this._wantsHashChange) {
	        this._updateHash(this.location, fragment, options.replace);
	        if (this.iframe && (fragment !== this.getHash(this.iframe.contentWindow))) {
	          var iWindow = this.iframe.contentWindow;

	          // Opening and closing the iframe tricks IE7 and earlier to push a
	          // history entry on hash-tag change.  When replace is true, we don't
	          // want this.
	          if (!options.replace) {
	            iWindow.document.open();
	            iWindow.document.close();
	          }

	          this._updateHash(iWindow.location, fragment, options.replace);
	        }

	        // If you've told us that you explicitly don't want fallback hashchange-
	        // based history, then `navigate` becomes a page refresh.
	      } else {
	        return this.location.assign(url);
	      }
	      if (options.trigger) return this.loadUrl(fragment);
	    },

	    // Update the hash location, either replacing the current entry, or adding
	    // a new one to the browser history.
	    _updateHash: function(location, fragment, replace) {
	      if (replace) {
	        var href = location.href.replace(/(javascript:|#).*$/, '');
	        location.replace(href + '#' + fragment);
	      } else {
	        // Some browsers require that `hash` contains a leading #.
	        location.hash = '#' + fragment;
	      }
	    }

	  });

	  // Create the default Backbone.history.
	  Backbone.history = new History;

	  // Helpers
	  // -------

	  // Helper function to correctly set up the prototype chain for subclasses.
	  // Similar to `goog.inherits`, but uses a hash of prototype properties and
	  // class properties to be extended.
	  var extend = function(protoProps, staticProps) {
	    var parent = this;
	    var child;

	    // The constructor function for the new subclass is either defined by you
	    // (the "constructor" property in your `extend` definition), or defaulted
	    // by us to simply call the parent constructor.
	    if (protoProps && _.has(protoProps, 'constructor')) {
	      child = protoProps.constructor;
	    } else {
	      child = function(){ return parent.apply(this, arguments); };
	    }

	    // Add static properties to the constructor function, if supplied.
	    _.extend(child, parent, staticProps);

	    // Set the prototype chain to inherit from `parent`, without calling
	    // `parent` constructor function.
	    var Surrogate = function(){ this.constructor = child; };
	    Surrogate.prototype = parent.prototype;
	    child.prototype = new Surrogate;

	    // Add prototype properties (instance properties) to the subclass,
	    // if supplied.
	    if (protoProps) _.extend(child.prototype, protoProps);

	    // Set a convenience property in case the parent's prototype is needed
	    // later.
	    child.__super__ = parent.prototype;

	    return child;
	  };

	  // Set up inheritance for the model, collection, router, view and history.
	  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

	  // Throw an error when a URL is needed, and none is supplied.
	  var urlError = function() {
	    throw new Error('A "url" property or function must be specified');
	  };

	  // Wrap an optional error callback with a fallback error event.
	  var wrapError = function(model, options) {
	    var error = options.error;
	    options.error = function(resp) {
	      if (error) error.call(options.context, model, resp, options);
	      model.trigger('error', model, resp, options);
	    };
	  };

	  return Backbone;

	}));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.7.0
	//     http://underscorejs.org
	//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    concat           = ArrayProto.concat,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind;

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.7.0';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var createCallback = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result  either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  _.iteratee = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return createCallback(value, context, argCount);
	    if (_.isObject(value)) return _.matches(value);
	    return _.property(value);
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    if (obj == null) return obj;
	    iteratee = createCallback(iteratee, context);
	    var i, length = obj.length;
	    if (length === +length) {
	      for (i = 0; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    if (obj == null) return [];
	    iteratee = _.iteratee(iteratee, context);
	    var keys = obj.length !== +obj.length && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length),
	        currentKey;
	    for (var index = 0; index < length; index++) {
	      currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  var reduceError = 'Reduce of empty array with no initial value';

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {
	    if (obj == null) obj = [];
	    iteratee = createCallback(iteratee, context, 4);
	    var keys = obj.length !== +obj.length && _.keys(obj),
	        length = (keys || obj).length,
	        index = 0, currentKey;
	    if (arguments.length < 3) {
	      if (!length) throw new TypeError(reduceError);
	      memo = obj[keys ? keys[index++] : index++];
	    }
	    for (; index < length; index++) {
	      currentKey = keys ? keys[index] : index;
	      memo = iteratee(memo, obj[currentKey], currentKey, obj);
	    }
	    return memo;
	  };

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {
	    if (obj == null) obj = [];
	    iteratee = createCallback(iteratee, context, 4);
	    var keys = obj.length !== + obj.length && _.keys(obj),
	        index = (keys || obj).length,
	        currentKey;
	    if (arguments.length < 3) {
	      if (!index) throw new TypeError(reduceError);
	      memo = obj[keys ? keys[--index] : --index];
	    }
	    while (index--) {
	      currentKey = keys ? keys[index] : index;
	      memo = iteratee(memo, obj[currentKey], currentKey, obj);
	    }
	    return memo;
	  };

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var result;
	    predicate = _.iteratee(predicate, context);
	    _.some(obj, function(value, index, list) {
	      if (predicate(value, index, list)) {
	        result = value;
	        return true;
	      }
	    });
	    return result;
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    if (obj == null) return results;
	    predicate = _.iteratee(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(_.iteratee(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    if (obj == null) return true;
	    predicate = _.iteratee(predicate, context);
	    var keys = obj.length !== +obj.length && _.keys(obj),
	        length = (keys || obj).length,
	        index, currentKey;
	    for (index = 0; index < length; index++) {
	      currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    if (obj == null) return false;
	    predicate = _.iteratee(predicate, context);
	    var keys = obj.length !== +obj.length && _.keys(obj),
	        length = (keys || obj).length,
	        index, currentKey;
	    for (index = 0; index < length; index++) {
	      currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given value (using `===`).
	  // Aliased as `include`.
	  _.contains = _.include = function(obj, target) {
	    if (obj == null) return false;
	    if (obj.length !== +obj.length) obj = _.values(obj);
	    return _.indexOf(obj, target) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      return (isFunc ? method : value[method]).apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matches(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matches(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = obj.length === +obj.length ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = _.iteratee(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = obj.length === +obj.length ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = _.iteratee(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
	  _.shuffle = function(obj) {
	    var set = obj && obj.length === +obj.length ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (obj.length !== +obj.length) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = _.iteratee(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = _.iteratee(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = _.iteratee(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = array.length;
	    while (low < high) {
	      var mid = low + high >>> 1;
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (obj.length === +obj.length) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return obj.length === +obj.length ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = _.iteratee(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    if (n < 0) return [];
	    return slice.call(array, 0, n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N. The **guard** check allows it to work with
	  // `_.map`.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array. The **guard** check allows it to work with `_.map`.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return slice.call(array, Math.max(array.length - n, 0));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array. The **guard**
	  // check allows it to work with `_.map`.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, output) {
	    if (shallow && _.every(input, _.isArray)) {
	      return concat.apply(output, input);
	    }
	    for (var i = 0, length = input.length; i < length; i++) {
	      var value = input[i];
	      if (!_.isArray(value) && !_.isArguments(value)) {
	        if (!strict) output.push(value);
	      } else if (shallow) {
	        push.apply(output, value);
	      } else {
	        flatten(value, shallow, strict, output);
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false, []);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (array == null) return [];
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = _.iteratee(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = array.length; i < length; i++) {
	      var value = array[i];
	      if (isSorted) {
	        if (!i || seen !== value) result.push(value);
	        seen = value;
	      } else if (iteratee) {
	        var computed = iteratee(value, i, array);
	        if (_.indexOf(seen, computed) < 0) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (_.indexOf(result, value) < 0) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true, []));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    if (array == null) return [];
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = array.length; i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(slice.call(arguments, 1), true, true, []);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function(array) {
	    if (array == null) return [];
	    var length = _.max(arguments, 'length').length;
	    var results = Array(length);
	    for (var i = 0; i < length; i++) {
	      results[i] = _.pluck(arguments, i);
	    }
	    return results;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    if (list == null) return {};
	    var result = {};
	    for (var i = 0, length = list.length; i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = function(array, item, isSorted) {
	    if (array == null) return -1;
	    var i = 0, length = array.length;
	    if (isSorted) {
	      if (typeof isSorted == 'number') {
	        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
	      } else {
	        i = _.sortedIndex(array, item);
	        return array[i] === item ? i : -1;
	      }
	    }
	    for (; i < length; i++) if (array[i] === item) return i;
	    return -1;
	  };

	  _.lastIndexOf = function(array, item, from) {
	    if (array == null) return -1;
	    var idx = array.length;
	    if (typeof from == 'number') {
	      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
	    }
	    while (--idx >= 0) if (array[idx] === item) return idx;
	    return -1;
	  };

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (arguments.length <= 1) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Reusable constructor function for prototype setting.
	  var Ctor = function(){};

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    var args, bound;
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    args = slice.call(arguments, 2);
	    bound = function() {
	      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
	      Ctor.prototype = func.prototype;
	      var self = new Ctor;
	      Ctor.prototype = null;
	      var result = func.apply(self, args.concat(slice.call(arguments)));
	      if (_.isObject(result)) return result;
	      return self;
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    return function() {
	      var position = 0;
	      var args = boundArgs.slice();
	      for (var i = 0, length = args.length; i < length; i++) {
	        if (args[i] === _) args[i] = arguments[position++];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return func.apply(this, args);
	    };
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = hasher ? hasher.apply(this, arguments) : key;
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = function(func) {
	    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
	  };

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        clearTimeout(timeout);
	        timeout = null;
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last > 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed after being called N times.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed before being called N times.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      } else {
	        func = null;
	      }
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Retrieve the names of an object's properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    var source, prop;
	    for (var i = 1, length = arguments.length; i < length; i++) {
	      source = arguments[i];
	      for (prop in source) {
	        if (hasOwnProperty.call(source, prop)) {
	            obj[prop] = source[prop];
	        }
	      }
	    }
	    return obj;
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(obj, iteratee, context) {
	    var result = {}, key;
	    if (obj == null) return result;
	    if (_.isFunction(iteratee)) {
	      iteratee = createCallback(iteratee, context);
	      for (key in obj) {
	        var value = obj[key];
	        if (iteratee(value, key, obj)) result[key] = value;
	      }
	    } else {
	      var keys = concat.apply([], slice.call(arguments, 1));
	      obj = new Object(obj);
	      for (var i = 0, length = keys.length; i < length; i++) {
	        key = keys[i];
	        if (key in obj) result[key] = obj[key];
	      }
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    for (var i = 1, length = arguments.length; i < length; i++) {
	      var source = arguments[i];
	      for (var prop in source) {
	        if (obj[prop] === void 0) obj[prop] = source[prop];
	      }
	    }
	    return obj;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }
	    if (typeof a != 'object' || typeof b != 'object') return false;
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }
	    // Objects with different constructors are not equivalent, but `Object`s
	    // from different frames are.
	    var aCtor = a.constructor, bCtor = b.constructor;
	    if (
	      aCtor !== bCtor &&
	      // Handle Object.create(x) cases
	      'constructor' in a && 'constructor' in b &&
	      !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	        _.isFunction(bCtor) && bCtor instanceof bCtor)
	    ) {
	      return false;
	    }
	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);
	    var size, result;
	    // Recursively compare objects and arrays.
	    if (className === '[object Array]') {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      size = a.length;
	      result = size === b.length;
	      if (result) {
	        // Deep compare the contents, ignoring non-numeric properties.
	        while (size--) {
	          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
	        }
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      size = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      result = _.keys(b).length === size;
	      if (result) {
	        while (size--) {
	          // Deep compare each member
	          key = keys[size];
	          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
	        }
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return result;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b, [], []);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return obj.length === 0;
	    for (var key in obj) if (_.has(obj, key)) return false;
	    return true;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around an IE 11 bug.
	  if (true) {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = function(key) {
	    return function(obj) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
	  _.matches = function(attrs) {
	    var pairs = _.pairs(attrs), length = pairs.length;
	    return function(obj) {
	      if (obj == null) return !length;
	      obj = new Object(obj);
	      for (var i = 0; i < length; i++) {
	        var pair = pairs[i], key = pair[0];
	        if (pair[1] !== obj[key] || !(key in obj)) return false;
	      }
	      return true;
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = createCallback(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property) {
	    if (object == null) return void 0;
	    var value = object[property];
	    return _.isFunction(value) ? object[property]() : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(obj) {
	    return this._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result.call(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result.call(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result.call(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/
	var Backbone = __webpack_require__(8);

	// MarionetteJS (Backbone.Marionette)
	// ----------------------------------
	// v2.4.4
	//
	// Copyright (c)2015 Derick Bailey, Muted Solutions, LLC.
	// Distributed under MIT license
	//
	// http://marionettejs.com


	/*!
	 * Includes BabySitter
	 * https://github.com/marionettejs/backbone.babysitter/
	 *
	 * Includes Wreqr
	 * https://github.com/marionettejs/backbone.wreqr/
	 */


	(function(root, factory) {

	  /* istanbul ignore next */
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Backbone, _) {
	      return (root.Marionette = root.Mn = factory(root, Backbone, _));
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== 'undefined') {
	    var Backbone = require('backbone');
	    var _ = require('underscore');
	    module.exports = factory(root, Backbone, _);
	  } else {
	    root.Marionette = root.Mn = factory(root, root.Backbone, root._);
	  }

	}(this, function(root, Backbone, _) {
	  'use strict';

	  /* istanbul ignore next */
	  // Backbone.BabySitter
	  // -------------------
	  // v0.1.10
	  //
	  // Copyright (c)2015 Derick Bailey, Muted Solutions, LLC.
	  // Distributed under MIT license
	  //
	  // http://github.com/marionettejs/backbone.babysitter
	  (function(Backbone, _) {
	    "use strict";
	    var previousChildViewContainer = Backbone.ChildViewContainer;
	    // BabySitter.ChildViewContainer
	    // -----------------------------
	    //
	    // Provide a container to store, retrieve and
	    // shut down child views.
	    Backbone.ChildViewContainer = function(Backbone, _) {
	      // Container Constructor
	      // ---------------------
	      var Container = function(views) {
	        this._views = {};
	        this._indexByModel = {};
	        this._indexByCustom = {};
	        this._updateLength();
	        _.each(views, this.add, this);
	      };
	      // Container Methods
	      // -----------------
	      _.extend(Container.prototype, {
	        // Add a view to this container. Stores the view
	        // by `cid` and makes it searchable by the model
	        // cid (and model itself). Optionally specify
	        // a custom key to store an retrieve the view.
	        add: function(view, customIndex) {
	          var viewCid = view.cid;
	          // store the view
	          this._views[viewCid] = view;
	          // index it by model
	          if (view.model) {
	            this._indexByModel[view.model.cid] = viewCid;
	          }
	          // index by custom
	          if (customIndex) {
	            this._indexByCustom[customIndex] = viewCid;
	          }
	          this._updateLength();
	          return this;
	        },
	        // Find a view by the model that was attached to
	        // it. Uses the model's `cid` to find it.
	        findByModel: function(model) {
	          return this.findByModelCid(model.cid);
	        },
	        // Find a view by the `cid` of the model that was attached to
	        // it. Uses the model's `cid` to find the view `cid` and
	        // retrieve the view using it.
	        findByModelCid: function(modelCid) {
	          var viewCid = this._indexByModel[modelCid];
	          return this.findByCid(viewCid);
	        },
	        // Find a view by a custom indexer.
	        findByCustom: function(index) {
	          var viewCid = this._indexByCustom[index];
	          return this.findByCid(viewCid);
	        },
	        // Find by index. This is not guaranteed to be a
	        // stable index.
	        findByIndex: function(index) {
	          return _.values(this._views)[index];
	        },
	        // retrieve a view by its `cid` directly
	        findByCid: function(cid) {
	          return this._views[cid];
	        },
	        // Remove a view
	        remove: function(view) {
	          var viewCid = view.cid;
	          // delete model index
	          if (view.model) {
	            delete this._indexByModel[view.model.cid];
	          }
	          // delete custom index
	          _.any(this._indexByCustom, function(cid, key) {
	            if (cid === viewCid) {
	              delete this._indexByCustom[key];
	              return true;
	            }
	          }, this);
	          // remove the view from the container
	          delete this._views[viewCid];
	          // update the length
	          this._updateLength();
	          return this;
	        },
	        // Call a method on every view in the container,
	        // passing parameters to the call method one at a
	        // time, like `function.call`.
	        call: function(method) {
	          this.apply(method, _.tail(arguments));
	        },
	        // Apply a method on every view in the container,
	        // passing parameters to the call method one at a
	        // time, like `function.apply`.
	        apply: function(method, args) {
	          _.each(this._views, function(view) {
	            if (_.isFunction(view[method])) {
	              view[method].apply(view, args || []);
	            }
	          });
	        },
	        // Update the `.length` attribute on this container
	        _updateLength: function() {
	          this.length = _.size(this._views);
	        }
	      });
	      // Borrowing this code from Backbone.Collection:
	      // http://backbonejs.org/docs/backbone.html#section-106
	      //
	      // Mix in methods from Underscore, for iteration, and other
	      // collection related features.
	      var methods = [ "forEach", "each", "map", "find", "detect", "filter", "select", "reject", "every", "all", "some", "any", "include", "contains", "invoke", "toArray", "first", "initial", "rest", "last", "without", "isEmpty", "pluck", "reduce" ];
	      _.each(methods, function(method) {
	        Container.prototype[method] = function() {
	          var views = _.values(this._views);
	          var args = [ views ].concat(_.toArray(arguments));
	          return _[method].apply(_, args);
	        };
	      });
	      // return the public API
	      return Container;
	    }(Backbone, _);
	    Backbone.ChildViewContainer.VERSION = "0.1.10";
	    Backbone.ChildViewContainer.noConflict = function() {
	      Backbone.ChildViewContainer = previousChildViewContainer;
	      return this;
	    };
	    return Backbone.ChildViewContainer;
	  })(Backbone, _);

	  /* istanbul ignore next */
	  // Backbone.Wreqr (Backbone.Marionette)
	  // ----------------------------------
	  // v1.3.5
	  //
	  // Copyright (c)2015 Derick Bailey, Muted Solutions, LLC.
	  // Distributed under MIT license
	  //
	  // http://github.com/marionettejs/backbone.wreqr
	  (function(Backbone, _) {
	    "use strict";
	    var previousWreqr = Backbone.Wreqr;
	    var Wreqr = Backbone.Wreqr = {};
	    Backbone.Wreqr.VERSION = "1.3.5";
	    Backbone.Wreqr.noConflict = function() {
	      Backbone.Wreqr = previousWreqr;
	      return this;
	    };
	    // Handlers
	    // --------
	    // A registry of functions to call, given a name
	    Wreqr.Handlers = function(Backbone, _) {
	      "use strict";
	      // Constructor
	      // -----------
	      var Handlers = function(options) {
	        this.options = options;
	        this._wreqrHandlers = {};
	        if (_.isFunction(this.initialize)) {
	          this.initialize(options);
	        }
	      };
	      Handlers.extend = Backbone.Model.extend;
	      // Instance Members
	      // ----------------
	      _.extend(Handlers.prototype, Backbone.Events, {
	        // Add multiple handlers using an object literal configuration
	        setHandlers: function(handlers) {
	          _.each(handlers, function(handler, name) {
	            var context = null;
	            if (_.isObject(handler) && !_.isFunction(handler)) {
	              context = handler.context;
	              handler = handler.callback;
	            }
	            this.setHandler(name, handler, context);
	          }, this);
	        },
	        // Add a handler for the given name, with an
	        // optional context to run the handler within
	        setHandler: function(name, handler, context) {
	          var config = {
	            callback: handler,
	            context: context
	          };
	          this._wreqrHandlers[name] = config;
	          this.trigger("handler:add", name, handler, context);
	        },
	        // Determine whether or not a handler is registered
	        hasHandler: function(name) {
	          return !!this._wreqrHandlers[name];
	        },
	        // Get the currently registered handler for
	        // the specified name. Throws an exception if
	        // no handler is found.
	        getHandler: function(name) {
	          var config = this._wreqrHandlers[name];
	          if (!config) {
	            return;
	          }
	          return function() {
	            return config.callback.apply(config.context, arguments);
	          };
	        },
	        // Remove a handler for the specified name
	        removeHandler: function(name) {
	          delete this._wreqrHandlers[name];
	        },
	        // Remove all handlers from this registry
	        removeAllHandlers: function() {
	          this._wreqrHandlers = {};
	        }
	      });
	      return Handlers;
	    }(Backbone, _);
	    // Wreqr.CommandStorage
	    // --------------------
	    //
	    // Store and retrieve commands for execution.
	    Wreqr.CommandStorage = function() {
	      "use strict";
	      // Constructor function
	      var CommandStorage = function(options) {
	        this.options = options;
	        this._commands = {};
	        if (_.isFunction(this.initialize)) {
	          this.initialize(options);
	        }
	      };
	      // Instance methods
	      _.extend(CommandStorage.prototype, Backbone.Events, {
	        // Get an object literal by command name, that contains
	        // the `commandName` and the `instances` of all commands
	        // represented as an array of arguments to process
	        getCommands: function(commandName) {
	          var commands = this._commands[commandName];
	          // we don't have it, so add it
	          if (!commands) {
	            // build the configuration
	            commands = {
	              command: commandName,
	              instances: []
	            };
	            // store it
	            this._commands[commandName] = commands;
	          }
	          return commands;
	        },
	        // Add a command by name, to the storage and store the
	        // args for the command
	        addCommand: function(commandName, args) {
	          var command = this.getCommands(commandName);
	          command.instances.push(args);
	        },
	        // Clear all commands for the given `commandName`
	        clearCommands: function(commandName) {
	          var command = this.getCommands(commandName);
	          command.instances = [];
	        }
	      });
	      return CommandStorage;
	    }();
	    // Wreqr.Commands
	    // --------------
	    //
	    // A simple command pattern implementation. Register a command
	    // handler and execute it.
	    Wreqr.Commands = function(Wreqr, _) {
	      "use strict";
	      return Wreqr.Handlers.extend({
	        // default storage type
	        storageType: Wreqr.CommandStorage,
	        constructor: function(options) {
	          this.options = options || {};
	          this._initializeStorage(this.options);
	          this.on("handler:add", this._executeCommands, this);
	          Wreqr.Handlers.prototype.constructor.apply(this, arguments);
	        },
	        // Execute a named command with the supplied args
	        execute: function(name) {
	          name = arguments[0];
	          var args = _.rest(arguments);
	          if (this.hasHandler(name)) {
	            this.getHandler(name).apply(this, args);
	          } else {
	            this.storage.addCommand(name, args);
	          }
	        },
	        // Internal method to handle bulk execution of stored commands
	        _executeCommands: function(name, handler, context) {
	          var command = this.storage.getCommands(name);
	          // loop through and execute all the stored command instances
	          _.each(command.instances, function(args) {
	            handler.apply(context, args);
	          });
	          this.storage.clearCommands(name);
	        },
	        // Internal method to initialize storage either from the type's
	        // `storageType` or the instance `options.storageType`.
	        _initializeStorage: function(options) {
	          var storage;
	          var StorageType = options.storageType || this.storageType;
	          if (_.isFunction(StorageType)) {
	            storage = new StorageType();
	          } else {
	            storage = StorageType;
	          }
	          this.storage = storage;
	        }
	      });
	    }(Wreqr, _);
	    // Wreqr.RequestResponse
	    // ---------------------
	    //
	    // A simple request/response implementation. Register a
	    // request handler, and return a response from it
	    Wreqr.RequestResponse = function(Wreqr, _) {
	      "use strict";
	      return Wreqr.Handlers.extend({
	        request: function(name) {
	          if (this.hasHandler(name)) {
	            return this.getHandler(name).apply(this, _.rest(arguments));
	          }
	        }
	      });
	    }(Wreqr, _);
	    // Event Aggregator
	    // ----------------
	    // A pub-sub object that can be used to decouple various parts
	    // of an application through event-driven architecture.
	    Wreqr.EventAggregator = function(Backbone, _) {
	      "use strict";
	      var EA = function() {};
	      // Copy the `extend` function used by Backbone's classes
	      EA.extend = Backbone.Model.extend;
	      // Copy the basic Backbone.Events on to the event aggregator
	      _.extend(EA.prototype, Backbone.Events);
	      return EA;
	    }(Backbone, _);
	    // Wreqr.Channel
	    // --------------
	    //
	    // An object that wraps the three messaging systems:
	    // EventAggregator, RequestResponse, Commands
	    Wreqr.Channel = function(Wreqr) {
	      "use strict";
	      var Channel = function(channelName) {
	        this.vent = new Backbone.Wreqr.EventAggregator();
	        this.reqres = new Backbone.Wreqr.RequestResponse();
	        this.commands = new Backbone.Wreqr.Commands();
	        this.channelName = channelName;
	      };
	      _.extend(Channel.prototype, {
	        // Remove all handlers from the messaging systems of this channel
	        reset: function() {
	          this.vent.off();
	          this.vent.stopListening();
	          this.reqres.removeAllHandlers();
	          this.commands.removeAllHandlers();
	          return this;
	        },
	        // Connect a hash of events; one for each messaging system
	        connectEvents: function(hash, context) {
	          this._connect("vent", hash, context);
	          return this;
	        },
	        connectCommands: function(hash, context) {
	          this._connect("commands", hash, context);
	          return this;
	        },
	        connectRequests: function(hash, context) {
	          this._connect("reqres", hash, context);
	          return this;
	        },
	        // Attach the handlers to a given message system `type`
	        _connect: function(type, hash, context) {
	          if (!hash) {
	            return;
	          }
	          context = context || this;
	          var method = type === "vent" ? "on" : "setHandler";
	          _.each(hash, function(fn, eventName) {
	            this[type][method](eventName, _.bind(fn, context));
	          }, this);
	        }
	      });
	      return Channel;
	    }(Wreqr);
	    // Wreqr.Radio
	    // --------------
	    //
	    // An object that lets you communicate with many channels.
	    Wreqr.radio = function(Wreqr, _) {
	      "use strict";
	      var Radio = function() {
	        this._channels = {};
	        this.vent = {};
	        this.commands = {};
	        this.reqres = {};
	        this._proxyMethods();
	      };
	      _.extend(Radio.prototype, {
	        channel: function(channelName) {
	          if (!channelName) {
	            throw new Error("Channel must receive a name");
	          }
	          return this._getChannel(channelName);
	        },
	        _getChannel: function(channelName) {
	          var channel = this._channels[channelName];
	          if (!channel) {
	            channel = new Wreqr.Channel(channelName);
	            this._channels[channelName] = channel;
	          }
	          return channel;
	        },
	        _proxyMethods: function() {
	          _.each([ "vent", "commands", "reqres" ], function(system) {
	            _.each(messageSystems[system], function(method) {
	              this[system][method] = proxyMethod(this, system, method);
	            }, this);
	          }, this);
	        }
	      });
	      var messageSystems = {
	        vent: [ "on", "off", "trigger", "once", "stopListening", "listenTo", "listenToOnce" ],
	        commands: [ "execute", "setHandler", "setHandlers", "removeHandler", "removeAllHandlers" ],
	        reqres: [ "request", "setHandler", "setHandlers", "removeHandler", "removeAllHandlers" ]
	      };
	      var proxyMethod = function(radio, system, method) {
	        return function(channelName) {
	          var messageSystem = radio._getChannel(channelName)[system];
	          return messageSystem[method].apply(messageSystem, _.rest(arguments));
	        };
	      };
	      return new Radio();
	    }(Wreqr, _);
	    return Backbone.Wreqr;
	  })(Backbone, _);

	  var previousMarionette = root.Marionette;
	  var previousMn = root.Mn;

	  var Marionette = Backbone.Marionette = {};

	  Marionette.VERSION = '2.4.4';

	  Marionette.noConflict = function() {
	    root.Marionette = previousMarionette;
	    root.Mn = previousMn;
	    return this;
	  };

	  Backbone.Marionette = Marionette;

	  // Get the Deferred creator for later use
	  Marionette.Deferred = Backbone.$.Deferred;

	  /* jshint unused: false *//* global console */
	  
	  // Helpers
	  // -------
	  
	  // Marionette.extend
	  // -----------------
	  
	  // Borrow the Backbone `extend` method so we can use it as needed
	  Marionette.extend = Backbone.Model.extend;
	  
	  // Marionette.isNodeAttached
	  // -------------------------
	  
	  // Determine if `el` is a child of the document
	  Marionette.isNodeAttached = function(el) {
	    return Backbone.$.contains(document.documentElement, el);
	  };
	  
	  // Merge `keys` from `options` onto `this`
	  Marionette.mergeOptions = function(options, keys) {
	    if (!options) { return; }
	    _.extend(this, _.pick(options, keys));
	  };
	  
	  // Marionette.getOption
	  // --------------------
	  
	  // Retrieve an object, function or other value from a target
	  // object or its `options`, with `options` taking precedence.
	  Marionette.getOption = function(target, optionName) {
	    if (!target || !optionName) { return; }
	    if (target.options && (target.options[optionName] !== undefined)) {
	      return target.options[optionName];
	    } else {
	      return target[optionName];
	    }
	  };
	  
	  // Proxy `Marionette.getOption`
	  Marionette.proxyGetOption = function(optionName) {
	    return Marionette.getOption(this, optionName);
	  };
	  
	  // Similar to `_.result`, this is a simple helper
	  // If a function is provided we call it with context
	  // otherwise just return the value. If the value is
	  // undefined return a default value
	  Marionette._getValue = function(value, context, params) {
	    if (_.isFunction(value)) {
	      value = params ? value.apply(context, params) : value.call(context);
	    }
	    return value;
	  };
	  
	  // Marionette.normalizeMethods
	  // ----------------------
	  
	  // Pass in a mapping of events => functions or function names
	  // and return a mapping of events => functions
	  Marionette.normalizeMethods = function(hash) {
	    return _.reduce(hash, function(normalizedHash, method, name) {
	      if (!_.isFunction(method)) {
	        method = this[method];
	      }
	      if (method) {
	        normalizedHash[name] = method;
	      }
	      return normalizedHash;
	    }, {}, this);
	  };
	  
	  // utility method for parsing @ui. syntax strings
	  // into associated selector
	  Marionette.normalizeUIString = function(uiString, ui) {
	    return uiString.replace(/@ui\.[a-zA-Z_$0-9]*/g, function(r) {
	      return ui[r.slice(4)];
	    });
	  };
	  
	  // allows for the use of the @ui. syntax within
	  // a given key for triggers and events
	  // swaps the @ui with the associated selector.
	  // Returns a new, non-mutated, parsed events hash.
	  Marionette.normalizeUIKeys = function(hash, ui) {
	    return _.reduce(hash, function(memo, val, key) {
	      var normalizedKey = Marionette.normalizeUIString(key, ui);
	      memo[normalizedKey] = val;
	      return memo;
	    }, {});
	  };
	  
	  // allows for the use of the @ui. syntax within
	  // a given value for regions
	  // swaps the @ui with the associated selector
	  Marionette.normalizeUIValues = function(hash, ui, properties) {
	    _.each(hash, function(val, key) {
	      if (_.isString(val)) {
	        hash[key] = Marionette.normalizeUIString(val, ui);
	      } else if (_.isObject(val) && _.isArray(properties)) {
	        _.extend(val, Marionette.normalizeUIValues(_.pick(val, properties), ui));
	        /* Value is an object, and we got an array of embedded property names to normalize. */
	        _.each(properties, function(property) {
	          var propertyVal = val[property];
	          if (_.isString(propertyVal)) {
	            val[property] = Marionette.normalizeUIString(propertyVal, ui);
	          }
	        });
	      }
	    });
	    return hash;
	  };
	  
	  // Mix in methods from Underscore, for iteration, and other
	  // collection related features.
	  // Borrowing this code from Backbone.Collection:
	  // http://backbonejs.org/docs/backbone.html#section-121
	  Marionette.actAsCollection = function(object, listProperty) {
	    var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',
	      'select', 'reject', 'every', 'all', 'some', 'any', 'include',
	      'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',
	      'last', 'without', 'isEmpty', 'pluck'];
	  
	    _.each(methods, function(method) {
	      object[method] = function() {
	        var list = _.values(_.result(this, listProperty));
	        var args = [list].concat(_.toArray(arguments));
	        return _[method].apply(_, args);
	      };
	    });
	  };
	  
	  var deprecate = Marionette.deprecate = function(message, test) {
	    if (_.isObject(message)) {
	      message = (
	        message.prev + ' is going to be removed in the future. ' +
	        'Please use ' + message.next + ' instead.' +
	        (message.url ? ' See: ' + message.url : '')
	      );
	    }
	  
	    if ((test === undefined || !test) && !deprecate._cache[message]) {
	      deprecate._warn('Deprecation warning: ' + message);
	      deprecate._cache[message] = true;
	    }
	  };
	  
	  deprecate._warn = typeof console !== 'undefined' && (console.warn || console.log) || function() {};
	  deprecate._cache = {};
	  
	  /* jshint maxstatements: 14, maxcomplexity: 7 */
	  
	  // Trigger Method
	  // --------------
	  
	  Marionette._triggerMethod = (function() {
	    // split the event name on the ":"
	    var splitter = /(^|:)(\w)/gi;
	  
	    // take the event section ("section1:section2:section3")
	    // and turn it in to uppercase name
	    function getEventName(match, prefix, eventName) {
	      return eventName.toUpperCase();
	    }
	  
	    return function(context, event, args) {
	      var noEventArg = arguments.length < 3;
	      if (noEventArg) {
	        args = event;
	        event = args[0];
	      }
	  
	      // get the method name from the event name
	      var methodName = 'on' + event.replace(splitter, getEventName);
	      var method = context[methodName];
	      var result;
	  
	      // call the onMethodName if it exists
	      if (_.isFunction(method)) {
	        // pass all args, except the event name
	        result = method.apply(context, noEventArg ? _.rest(args) : args);
	      }
	  
	      // trigger the event, if a trigger method exists
	      if (_.isFunction(context.trigger)) {
	        if (noEventArg + args.length > 1) {
	          context.trigger.apply(context, noEventArg ? args : [event].concat(_.drop(args, 0)));
	        } else {
	          context.trigger(event);
	        }
	      }
	  
	      return result;
	    };
	  })();
	  
	  // Trigger an event and/or a corresponding method name. Examples:
	  //
	  // `this.triggerMethod("foo")` will trigger the "foo" event and
	  // call the "onFoo" method.
	  //
	  // `this.triggerMethod("foo:bar")` will trigger the "foo:bar" event and
	  // call the "onFooBar" method.
	  Marionette.triggerMethod = function(event) {
	    return Marionette._triggerMethod(this, arguments);
	  };
	  
	  // triggerMethodOn invokes triggerMethod on a specific context
	  //
	  // e.g. `Marionette.triggerMethodOn(view, 'show')`
	  // will trigger a "show" event or invoke onShow the view.
	  Marionette.triggerMethodOn = function(context) {
	    var fnc = _.isFunction(context.triggerMethod) ?
	                  context.triggerMethod :
	                  Marionette.triggerMethod;
	  
	    return fnc.apply(context, _.rest(arguments));
	  };
	  
	  // DOM Refresh
	  // -----------
	  
	  // Monitor a view's state, and after it has been rendered and shown
	  // in the DOM, trigger a "dom:refresh" event every time it is
	  // re-rendered.
	  
	  Marionette.MonitorDOMRefresh = function(view) {
	    if (view._isDomRefreshMonitored) { return; }
	    view._isDomRefreshMonitored = true;
	  
	    // track when the view has been shown in the DOM,
	    // using a Marionette.Region (or by other means of triggering "show")
	    function handleShow() {
	      view._isShown = true;
	      triggerDOMRefresh();
	    }
	  
	    // track when the view has been rendered
	    function handleRender() {
	      view._isRendered = true;
	      triggerDOMRefresh();
	    }
	  
	    // Trigger the "dom:refresh" event and corresponding "onDomRefresh" method
	    function triggerDOMRefresh() {
	      if (view._isShown && view._isRendered && Marionette.isNodeAttached(view.el)) {
	        Marionette.triggerMethodOn(view, 'dom:refresh', view);
	      }
	    }
	  
	    view.on({
	      show: handleShow,
	      render: handleRender
	    });
	  };
	  
	  /* jshint maxparams: 5 */
	  
	  // Bind Entity Events & Unbind Entity Events
	  // -----------------------------------------
	  //
	  // These methods are used to bind/unbind a backbone "entity" (e.g. collection/model)
	  // to methods on a target object.
	  //
	  // The first parameter, `target`, must have the Backbone.Events module mixed in.
	  //
	  // The second parameter is the `entity` (Backbone.Model, Backbone.Collection or
	  // any object that has Backbone.Events mixed in) to bind the events from.
	  //
	  // The third parameter is a hash of { "event:name": "eventHandler" }
	  // configuration. Multiple handlers can be separated by a space. A
	  // function can be supplied instead of a string handler name.
	  
	  (function(Marionette) {
	    'use strict';
	  
	    // Bind the event to handlers specified as a string of
	    // handler names on the target object
	    function bindFromStrings(target, entity, evt, methods) {
	      var methodNames = methods.split(/\s+/);
	  
	      _.each(methodNames, function(methodName) {
	  
	        var method = target[methodName];
	        if (!method) {
	          throw new Marionette.Error('Method "' + methodName +
	            '" was configured as an event handler, but does not exist.');
	        }
	  
	        target.listenTo(entity, evt, method);
	      });
	    }
	  
	    // Bind the event to a supplied callback function
	    function bindToFunction(target, entity, evt, method) {
	      target.listenTo(entity, evt, method);
	    }
	  
	    // Bind the event to handlers specified as a string of
	    // handler names on the target object
	    function unbindFromStrings(target, entity, evt, methods) {
	      var methodNames = methods.split(/\s+/);
	  
	      _.each(methodNames, function(methodName) {
	        var method = target[methodName];
	        target.stopListening(entity, evt, method);
	      });
	    }
	  
	    // Bind the event to a supplied callback function
	    function unbindToFunction(target, entity, evt, method) {
	      target.stopListening(entity, evt, method);
	    }
	  
	    // generic looping function
	    function iterateEvents(target, entity, bindings, functionCallback, stringCallback) {
	      if (!entity || !bindings) { return; }
	  
	      // type-check bindings
	      if (!_.isObject(bindings)) {
	        throw new Marionette.Error({
	          message: 'Bindings must be an object or function.',
	          url: 'marionette.functions.html#marionettebindentityevents'
	        });
	      }
	  
	      // allow the bindings to be a function
	      bindings = Marionette._getValue(bindings, target);
	  
	      // iterate the bindings and bind them
	      _.each(bindings, function(methods, evt) {
	  
	        // allow for a function as the handler,
	        // or a list of event names as a string
	        if (_.isFunction(methods)) {
	          functionCallback(target, entity, evt, methods);
	        } else {
	          stringCallback(target, entity, evt, methods);
	        }
	  
	      });
	    }
	  
	    // Export Public API
	    Marionette.bindEntityEvents = function(target, entity, bindings) {
	      iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);
	    };
	  
	    Marionette.unbindEntityEvents = function(target, entity, bindings) {
	      iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);
	    };
	  
	    // Proxy `bindEntityEvents`
	    Marionette.proxyBindEntityEvents = function(entity, bindings) {
	      return Marionette.bindEntityEvents(this, entity, bindings);
	    };
	  
	    // Proxy `unbindEntityEvents`
	    Marionette.proxyUnbindEntityEvents = function(entity, bindings) {
	      return Marionette.unbindEntityEvents(this, entity, bindings);
	    };
	  })(Marionette);
	  

	  // Error
	  // -----
	  
	  var errorProps = ['description', 'fileName', 'lineNumber', 'name', 'message', 'number'];
	  
	  Marionette.Error = Marionette.extend.call(Error, {
	    urlRoot: 'http://marionettejs.com/docs/v' + Marionette.VERSION + '/',
	  
	    constructor: function(message, options) {
	      if (_.isObject(message)) {
	        options = message;
	        message = options.message;
	      } else if (!options) {
	        options = {};
	      }
	  
	      var error = Error.call(this, message);
	      _.extend(this, _.pick(error, errorProps), _.pick(options, errorProps));
	  
	      this.captureStackTrace();
	  
	      if (options.url) {
	        this.url = this.urlRoot + options.url;
	      }
	    },
	  
	    captureStackTrace: function() {
	      if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, Marionette.Error);
	      }
	    },
	  
	    toString: function() {
	      return this.name + ': ' + this.message + (this.url ? ' See: ' + this.url : '');
	    }
	  });
	  
	  Marionette.Error.extend = Marionette.extend;
	  
	  // Callbacks
	  // ---------
	  
	  // A simple way of managing a collection of callbacks
	  // and executing them at a later point in time, using jQuery's
	  // `Deferred` object.
	  Marionette.Callbacks = function() {
	    this._deferred = Marionette.Deferred();
	    this._callbacks = [];
	  };
	  
	  _.extend(Marionette.Callbacks.prototype, {
	  
	    // Add a callback to be executed. Callbacks added here are
	    // guaranteed to execute, even if they are added after the
	    // `run` method is called.
	    add: function(callback, contextOverride) {
	      var promise = _.result(this._deferred, 'promise');
	  
	      this._callbacks.push({cb: callback, ctx: contextOverride});
	  
	      promise.then(function(args) {
	        if (contextOverride) { args.context = contextOverride; }
	        callback.call(args.context, args.options);
	      });
	    },
	  
	    // Run all registered callbacks with the context specified.
	    // Additional callbacks can be added after this has been run
	    // and they will still be executed.
	    run: function(options, context) {
	      this._deferred.resolve({
	        options: options,
	        context: context
	      });
	    },
	  
	    // Resets the list of callbacks to be run, allowing the same list
	    // to be run multiple times - whenever the `run` method is called.
	    reset: function() {
	      var callbacks = this._callbacks;
	      this._deferred = Marionette.Deferred();
	      this._callbacks = [];
	  
	      _.each(callbacks, function(cb) {
	        this.add(cb.cb, cb.ctx);
	      }, this);
	    }
	  });
	  
	  // Controller
	  // ----------
	  
	  // A multi-purpose object to use as a controller for
	  // modules and routers, and as a mediator for workflow
	  // and coordination of other objects, views, and more.
	  Marionette.Controller = function(options) {
	    this.options = options || {};
	  
	    if (_.isFunction(this.initialize)) {
	      this.initialize(this.options);
	    }
	  };
	  
	  Marionette.Controller.extend = Marionette.extend;
	  
	  // Controller Methods
	  // --------------
	  
	  // Ensure it can trigger events with Backbone.Events
	  _.extend(Marionette.Controller.prototype, Backbone.Events, {
	    destroy: function() {
	      Marionette._triggerMethod(this, 'before:destroy', arguments);
	      Marionette._triggerMethod(this, 'destroy', arguments);
	  
	      this.stopListening();
	      this.off();
	      return this;
	    },
	  
	    // import the `triggerMethod` to trigger events with corresponding
	    // methods if the method exists
	    triggerMethod: Marionette.triggerMethod,
	  
	    // A handy way to merge options onto the instance
	    mergeOptions: Marionette.mergeOptions,
	  
	    // Proxy `getOption` to enable getting options from this or this.options by name.
	    getOption: Marionette.proxyGetOption
	  
	  });
	  
	  // Object
	  // ------
	  
	  // A Base Class that other Classes should descend from.
	  // Object borrows many conventions and utilities from Backbone.
	  Marionette.Object = function(options) {
	    this.options = _.extend({}, _.result(this, 'options'), options);
	  
	    this.initialize.apply(this, arguments);
	  };
	  
	  Marionette.Object.extend = Marionette.extend;
	  
	  // Object Methods
	  // --------------
	  
	  // Ensure it can trigger events with Backbone.Events
	  _.extend(Marionette.Object.prototype, Backbone.Events, {
	  
	    //this is a noop method intended to be overridden by classes that extend from this base
	    initialize: function() {},
	  
	    destroy: function(options) {
	      options = options || {};
	  
	      this.triggerMethod('before:destroy', options);
	      this.triggerMethod('destroy', options);
	      this.stopListening();
	  
	      return this;
	    },
	  
	    // Import the `triggerMethod` to trigger events with corresponding
	    // methods if the method exists
	    triggerMethod: Marionette.triggerMethod,
	  
	    // A handy way to merge options onto the instance
	    mergeOptions: Marionette.mergeOptions,
	  
	    // Proxy `getOption` to enable getting options from this or this.options by name.
	    getOption: Marionette.proxyGetOption,
	  
	    // Proxy `bindEntityEvents` to enable binding view's events from another entity.
	    bindEntityEvents: Marionette.proxyBindEntityEvents,
	  
	    // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.
	    unbindEntityEvents: Marionette.proxyUnbindEntityEvents
	  });
	  
	  /* jshint maxcomplexity: 16, maxstatements: 45, maxlen: 120 */
	  
	  // Region
	  // ------
	  
	  // Manage the visual regions of your composite application. See
	  // http://lostechies.com/derickbailey/2011/12/12/composite-js-apps-regions-and-region-managers/
	  
	  Marionette.Region = Marionette.Object.extend({
	    constructor: function(options) {
	  
	      // set options temporarily so that we can get `el`.
	      // options will be overriden by Object.constructor
	      this.options = options || {};
	      this.el = this.getOption('el');
	  
	      // Handle when this.el is passed in as a $ wrapped element.
	      this.el = this.el instanceof Backbone.$ ? this.el[0] : this.el;
	  
	      if (!this.el) {
	        throw new Marionette.Error({
	          name: 'NoElError',
	          message: 'An "el" must be specified for a region.'
	        });
	      }
	  
	      this.$el = this.getEl(this.el);
	      Marionette.Object.call(this, options);
	    },
	  
	    // Displays a backbone view instance inside of the region.
	    // Handles calling the `render` method for you. Reads content
	    // directly from the `el` attribute. Also calls an optional
	    // `onShow` and `onDestroy` method on your view, just after showing
	    // or just before destroying the view, respectively.
	    // The `preventDestroy` option can be used to prevent a view from
	    // the old view being destroyed on show.
	    // The `forceShow` option can be used to force a view to be
	    // re-rendered if it's already shown in the region.
	    show: function(view, options) {
	      if (!this._ensureElement()) {
	        return;
	      }
	  
	      this._ensureViewIsIntact(view);
	      Marionette.MonitorDOMRefresh(view);
	  
	      var showOptions     = options || {};
	      var isDifferentView = view !== this.currentView;
	      var preventDestroy  = !!showOptions.preventDestroy;
	      var forceShow       = !!showOptions.forceShow;
	  
	      // We are only changing the view if there is a current view to change to begin with
	      var isChangingView = !!this.currentView;
	  
	      // Only destroy the current view if we don't want to `preventDestroy` and if
	      // the view given in the first argument is different than `currentView`
	      var _shouldDestroyView = isDifferentView && !preventDestroy;
	  
	      // Only show the view given in the first argument if it is different than
	      // the current view or if we want to re-show the view. Note that if
	      // `_shouldDestroyView` is true, then `_shouldShowView` is also necessarily true.
	      var _shouldShowView = isDifferentView || forceShow;
	  
	      if (isChangingView) {
	        this.triggerMethod('before:swapOut', this.currentView, this, options);
	      }
	  
	      if (this.currentView) {
	        delete this.currentView._parent;
	      }
	  
	      if (_shouldDestroyView) {
	        this.empty();
	  
	      // A `destroy` event is attached to the clean up manually removed views.
	      // We need to detach this event when a new view is going to be shown as it
	      // is no longer relevant.
	      } else if (isChangingView && _shouldShowView) {
	        this.currentView.off('destroy', this.empty, this);
	      }
	  
	      if (_shouldShowView) {
	  
	        // We need to listen for if a view is destroyed
	        // in a way other than through the region.
	        // If this happens we need to remove the reference
	        // to the currentView since once a view has been destroyed
	        // we can not reuse it.
	        view.once('destroy', this.empty, this);
	  
	        // make this region the view's parent,
	        // It's important that this parent binding happens before rendering
	        // so that any events the child may trigger during render can also be
	        // triggered on the child's ancestor views
	        view._parent = this;
	        this._renderView(view);
	  
	        if (isChangingView) {
	          this.triggerMethod('before:swap', view, this, options);
	        }
	  
	        this.triggerMethod('before:show', view, this, options);
	        Marionette.triggerMethodOn(view, 'before:show', view, this, options);
	  
	        if (isChangingView) {
	          this.triggerMethod('swapOut', this.currentView, this, options);
	        }
	  
	        // An array of views that we're about to display
	        var attachedRegion = Marionette.isNodeAttached(this.el);
	  
	        // The views that we're about to attach to the document
	        // It's important that we prevent _getNestedViews from being executed unnecessarily
	        // as it's a potentially-slow method
	        var displayedViews = [];
	  
	        var attachOptions = _.extend({
	          triggerBeforeAttach: this.triggerBeforeAttach,
	          triggerAttach: this.triggerAttach
	        }, showOptions);
	  
	        if (attachedRegion && attachOptions.triggerBeforeAttach) {
	          displayedViews = this._displayedViews(view);
	          this._triggerAttach(displayedViews, 'before:');
	        }
	  
	        this.attachHtml(view);
	        this.currentView = view;
	  
	        if (attachedRegion && attachOptions.triggerAttach) {
	          displayedViews = this._displayedViews(view);
	          this._triggerAttach(displayedViews);
	        }
	  
	        if (isChangingView) {
	          this.triggerMethod('swap', view, this, options);
	        }
	  
	        this.triggerMethod('show', view, this, options);
	        Marionette.triggerMethodOn(view, 'show', view, this, options);
	  
	        return this;
	      }
	  
	      return this;
	    },
	  
	    triggerBeforeAttach: true,
	    triggerAttach: true,
	  
	    _triggerAttach: function(views, prefix) {
	      var eventName = (prefix || '') + 'attach';
	      _.each(views, function(view) {
	        Marionette.triggerMethodOn(view, eventName, view, this);
	      }, this);
	    },
	  
	    _displayedViews: function(view) {
	      return _.union([view], _.result(view, '_getNestedViews') || []);
	    },
	  
	    _renderView: function(view) {
	      if (!view.supportsRenderLifecycle) {
	        Marionette.triggerMethodOn(view, 'before:render', view);
	      }
	      view.render();
	      if (!view.supportsRenderLifecycle) {
	        Marionette.triggerMethodOn(view, 'render', view);
	      }
	    },
	  
	    _ensureElement: function() {
	      if (!_.isObject(this.el)) {
	        this.$el = this.getEl(this.el);
	        this.el = this.$el[0];
	      }
	  
	      if (!this.$el || this.$el.length === 0) {
	        if (this.getOption('allowMissingEl')) {
	          return false;
	        } else {
	          throw new Marionette.Error('An "el" ' + this.$el.selector + ' must exist in DOM');
	        }
	      }
	      return true;
	    },
	  
	    _ensureViewIsIntact: function(view) {
	      if (!view) {
	        throw new Marionette.Error({
	          name: 'ViewNotValid',
	          message: 'The view passed is undefined and therefore invalid. You must pass a view instance to show.'
	        });
	      }
	  
	      if (view.isDestroyed) {
	        throw new Marionette.Error({
	          name: 'ViewDestroyedError',
	          message: 'View (cid: "' + view.cid + '") has already been destroyed and cannot be used.'
	        });
	      }
	    },
	  
	    // Override this method to change how the region finds the DOM
	    // element that it manages. Return a jQuery selector object scoped
	    // to a provided parent el or the document if none exists.
	    getEl: function(el) {
	      return Backbone.$(el, Marionette._getValue(this.options.parentEl, this));
	    },
	  
	    // Override this method to change how the new view is
	    // appended to the `$el` that the region is managing
	    attachHtml: function(view) {
	      this.$el.contents().detach();
	  
	      this.el.appendChild(view.el);
	    },
	  
	    // Destroy the current view, if there is one. If there is no
	    // current view, it does nothing and returns immediately.
	    empty: function(options) {
	      var view = this.currentView;
	  
	      var emptyOptions = options || {};
	      var preventDestroy  = !!emptyOptions.preventDestroy;
	      // If there is no view in the region
	      // we should not remove anything
	      if (!view) { return this; }
	  
	      view.off('destroy', this.empty, this);
	      this.triggerMethod('before:empty', view);
	      if (!preventDestroy) {
	        this._destroyView();
	      }
	      this.triggerMethod('empty', view);
	  
	      // Remove region pointer to the currentView
	      delete this.currentView;
	  
	      if (preventDestroy) {
	        this.$el.contents().detach();
	      }
	  
	      return this;
	    },
	  
	    // call 'destroy' or 'remove', depending on which is found
	    // on the view (if showing a raw Backbone view or a Marionette View)
	    _destroyView: function() {
	      var view = this.currentView;
	      if (view.isDestroyed) { return; }
	  
	      if (!view.supportsDestroyLifecycle) {
	        Marionette.triggerMethodOn(view, 'before:destroy', view);
	      }
	      if (view.destroy) {
	        view.destroy();
	      } else {
	        view.remove();
	  
	        // appending isDestroyed to raw Backbone View allows regions
	        // to throw a ViewDestroyedError for this view
	        view.isDestroyed = true;
	      }
	      if (!view.supportsDestroyLifecycle) {
	        Marionette.triggerMethodOn(view, 'destroy', view);
	      }
	    },
	  
	    // Attach an existing view to the region. This
	    // will not call `render` or `onShow` for the new view,
	    // and will not replace the current HTML for the `el`
	    // of the region.
	    attachView: function(view) {
	      if (this.currentView) {
	        delete this.currentView._parent;
	      }
	      view._parent = this;
	      this.currentView = view;
	      return this;
	    },
	  
	    // Checks whether a view is currently present within
	    // the region. Returns `true` if there is and `false` if
	    // no view is present.
	    hasView: function() {
	      return !!this.currentView;
	    },
	  
	    // Reset the region by destroying any existing view and
	    // clearing out the cached `$el`. The next time a view
	    // is shown via this region, the region will re-query the
	    // DOM for the region's `el`.
	    reset: function() {
	      this.empty();
	  
	      if (this.$el) {
	        this.el = this.$el.selector;
	      }
	  
	      delete this.$el;
	      return this;
	    }
	  
	  },
	  
	  // Static Methods
	  {
	  
	    // Build an instance of a region by passing in a configuration object
	    // and a default region class to use if none is specified in the config.
	    //
	    // The config object should either be a string as a jQuery DOM selector,
	    // a Region class directly, or an object literal that specifies a selector,
	    // a custom regionClass, and any options to be supplied to the region:
	    //
	    // ```js
	    // {
	    //   selector: "#foo",
	    //   regionClass: MyCustomRegion,
	    //   allowMissingEl: false
	    // }
	    // ```
	    //
	    buildRegion: function(regionConfig, DefaultRegionClass) {
	      if (_.isString(regionConfig)) {
	        return this._buildRegionFromSelector(regionConfig, DefaultRegionClass);
	      }
	  
	      if (regionConfig.selector || regionConfig.el || regionConfig.regionClass) {
	        return this._buildRegionFromObject(regionConfig, DefaultRegionClass);
	      }
	  
	      if (_.isFunction(regionConfig)) {
	        return this._buildRegionFromRegionClass(regionConfig);
	      }
	  
	      throw new Marionette.Error({
	        message: 'Improper region configuration type.',
	        url: 'marionette.region.html#region-configuration-types'
	      });
	    },
	  
	    // Build the region from a string selector like '#foo-region'
	    _buildRegionFromSelector: function(selector, DefaultRegionClass) {
	      return new DefaultRegionClass({el: selector});
	    },
	  
	    // Build the region from a configuration object
	    // ```js
	    // { selector: '#foo', regionClass: FooRegion, allowMissingEl: false }
	    // ```
	    _buildRegionFromObject: function(regionConfig, DefaultRegionClass) {
	      var RegionClass = regionConfig.regionClass || DefaultRegionClass;
	      var options = _.omit(regionConfig, 'selector', 'regionClass');
	  
	      if (regionConfig.selector && !options.el) {
	        options.el = regionConfig.selector;
	      }
	  
	      return new RegionClass(options);
	    },
	  
	    // Build the region directly from a given `RegionClass`
	    _buildRegionFromRegionClass: function(RegionClass) {
	      return new RegionClass();
	    }
	  });
	  
	  // Region Manager
	  // --------------
	  
	  // Manage one or more related `Marionette.Region` objects.
	  Marionette.RegionManager = Marionette.Controller.extend({
	    constructor: function(options) {
	      this._regions = {};
	      this.length = 0;
	  
	      Marionette.Controller.call(this, options);
	  
	      this.addRegions(this.getOption('regions'));
	    },
	  
	    // Add multiple regions using an object literal or a
	    // function that returns an object literal, where
	    // each key becomes the region name, and each value is
	    // the region definition.
	    addRegions: function(regionDefinitions, defaults) {
	      regionDefinitions = Marionette._getValue(regionDefinitions, this, arguments);
	  
	      return _.reduce(regionDefinitions, function(regions, definition, name) {
	        if (_.isString(definition)) {
	          definition = {selector: definition};
	        }
	        if (definition.selector) {
	          definition = _.defaults({}, definition, defaults);
	        }
	  
	        regions[name] = this.addRegion(name, definition);
	        return regions;
	      }, {}, this);
	    },
	  
	    // Add an individual region to the region manager,
	    // and return the region instance
	    addRegion: function(name, definition) {
	      var region;
	  
	      if (definition instanceof Marionette.Region) {
	        region = definition;
	      } else {
	        region = Marionette.Region.buildRegion(definition, Marionette.Region);
	      }
	  
	      this.triggerMethod('before:add:region', name, region);
	  
	      region._parent = this;
	      this._store(name, region);
	  
	      this.triggerMethod('add:region', name, region);
	      return region;
	    },
	  
	    // Get a region by name
	    get: function(name) {
	      return this._regions[name];
	    },
	  
	    // Gets all the regions contained within
	    // the `regionManager` instance.
	    getRegions: function() {
	      return _.clone(this._regions);
	    },
	  
	    // Remove a region by name
	    removeRegion: function(name) {
	      var region = this._regions[name];
	      this._remove(name, region);
	  
	      return region;
	    },
	  
	    // Empty all regions in the region manager, and
	    // remove them
	    removeRegions: function() {
	      var regions = this.getRegions();
	      _.each(this._regions, function(region, name) {
	        this._remove(name, region);
	      }, this);
	  
	      return regions;
	    },
	  
	    // Empty all regions in the region manager, but
	    // leave them attached
	    emptyRegions: function() {
	      var regions = this.getRegions();
	      _.invoke(regions, 'empty');
	      return regions;
	    },
	  
	    // Destroy all regions and shut down the region
	    // manager entirely
	    destroy: function() {
	      this.removeRegions();
	      return Marionette.Controller.prototype.destroy.apply(this, arguments);
	    },
	  
	    // internal method to store regions
	    _store: function(name, region) {
	      if (!this._regions[name]) {
	        this.length++;
	      }
	  
	      this._regions[name] = region;
	    },
	  
	    // internal method to remove a region
	    _remove: function(name, region) {
	      this.triggerMethod('before:remove:region', name, region);
	      region.empty();
	      region.stopListening();
	  
	      delete region._parent;
	      delete this._regions[name];
	      this.length--;
	      this.triggerMethod('remove:region', name, region);
	    }
	  });
	  
	  Marionette.actAsCollection(Marionette.RegionManager.prototype, '_regions');
	  

	  // Template Cache
	  // --------------
	  
	  // Manage templates stored in `<script>` blocks,
	  // caching them for faster access.
	  Marionette.TemplateCache = function(templateId) {
	    this.templateId = templateId;
	  };
	  
	  // TemplateCache object-level methods. Manage the template
	  // caches from these method calls instead of creating
	  // your own TemplateCache instances
	  _.extend(Marionette.TemplateCache, {
	    templateCaches: {},
	  
	    // Get the specified template by id. Either
	    // retrieves the cached version, or loads it
	    // from the DOM.
	    get: function(templateId, options) {
	      var cachedTemplate = this.templateCaches[templateId];
	  
	      if (!cachedTemplate) {
	        cachedTemplate = new Marionette.TemplateCache(templateId);
	        this.templateCaches[templateId] = cachedTemplate;
	      }
	  
	      return cachedTemplate.load(options);
	    },
	  
	    // Clear templates from the cache. If no arguments
	    // are specified, clears all templates:
	    // `clear()`
	    //
	    // If arguments are specified, clears each of the
	    // specified templates from the cache:
	    // `clear("#t1", "#t2", "...")`
	    clear: function() {
	      var i;
	      var args = _.toArray(arguments);
	      var length = args.length;
	  
	      if (length > 0) {
	        for (i = 0; i < length; i++) {
	          delete this.templateCaches[args[i]];
	        }
	      } else {
	        this.templateCaches = {};
	      }
	    }
	  });
	  
	  // TemplateCache instance methods, allowing each
	  // template cache object to manage its own state
	  // and know whether or not it has been loaded
	  _.extend(Marionette.TemplateCache.prototype, {
	  
	    // Internal method to load the template
	    load: function(options) {
	      // Guard clause to prevent loading this template more than once
	      if (this.compiledTemplate) {
	        return this.compiledTemplate;
	      }
	  
	      // Load the template and compile it
	      var template = this.loadTemplate(this.templateId, options);
	      this.compiledTemplate = this.compileTemplate(template, options);
	  
	      return this.compiledTemplate;
	    },
	  
	    // Load a template from the DOM, by default. Override
	    // this method to provide your own template retrieval
	    // For asynchronous loading with AMD/RequireJS, consider
	    // using a template-loader plugin as described here:
	    // https://github.com/marionettejs/backbone.marionette/wiki/Using-marionette-with-requirejs
	    loadTemplate: function(templateId, options) {
	      var $template = Backbone.$(templateId);
	  
	      if (!$template.length) {
	        throw new Marionette.Error({
	          name: 'NoTemplateError',
	          message: 'Could not find template: "' + templateId + '"'
	        });
	      }
	      return $template.html();
	    },
	  
	    // Pre-compile the template before caching it. Override
	    // this method if you do not need to pre-compile a template
	    // (JST / RequireJS for example) or if you want to change
	    // the template engine used (Handebars, etc).
	    compileTemplate: function(rawTemplate, options) {
	      return _.template(rawTemplate, options);
	    }
	  });
	  
	  // Renderer
	  // --------
	  
	  // Render a template with data by passing in the template
	  // selector and the data to render.
	  Marionette.Renderer = {
	  
	    // Render a template with data. The `template` parameter is
	    // passed to the `TemplateCache` object to retrieve the
	    // template function. Override this method to provide your own
	    // custom rendering and template handling for all of Marionette.
	    render: function(template, data) {
	      if (!template) {
	        throw new Marionette.Error({
	          name: 'TemplateNotFoundError',
	          message: 'Cannot render the template since its false, null or undefined.'
	        });
	      }
	  
	      var templateFunc = _.isFunction(template) ? template : Marionette.TemplateCache.get(template);
	  
	      return templateFunc(data);
	    }
	  };
	  

	  /* jshint maxlen: 114, nonew: false */
	  // View
	  // ----
	  
	  // The core view class that other Marionette views extend from.
	  Marionette.View = Backbone.View.extend({
	    isDestroyed: false,
	    supportsRenderLifecycle: true,
	    supportsDestroyLifecycle: true,
	  
	    constructor: function(options) {
	      this.render = _.bind(this.render, this);
	  
	      options = Marionette._getValue(options, this);
	  
	      // this exposes view options to the view initializer
	      // this is a backfill since backbone removed the assignment
	      // of this.options
	      // at some point however this may be removed
	      this.options = _.extend({}, _.result(this, 'options'), options);
	  
	      this._behaviors = Marionette.Behaviors(this);
	  
	      Backbone.View.call(this, this.options);
	  
	      Marionette.MonitorDOMRefresh(this);
	    },
	  
	    // Get the template for this view
	    // instance. You can set a `template` attribute in the view
	    // definition or pass a `template: "whatever"` parameter in
	    // to the constructor options.
	    getTemplate: function() {
	      return this.getOption('template');
	    },
	  
	    // Serialize a model by returning its attributes. Clones
	    // the attributes to allow modification.
	    serializeModel: function(model) {
	      return model.toJSON.apply(model, _.rest(arguments));
	    },
	  
	    // Mix in template helper methods. Looks for a
	    // `templateHelpers` attribute, which can either be an
	    // object literal, or a function that returns an object
	    // literal. All methods and attributes from this object
	    // are copies to the object passed in.
	    mixinTemplateHelpers: function(target) {
	      target = target || {};
	      var templateHelpers = this.getOption('templateHelpers');
	      templateHelpers = Marionette._getValue(templateHelpers, this);
	      return _.extend(target, templateHelpers);
	    },
	  
	    // normalize the keys of passed hash with the views `ui` selectors.
	    // `{"@ui.foo": "bar"}`
	    normalizeUIKeys: function(hash) {
	      var uiBindings = _.result(this, '_uiBindings');
	      return Marionette.normalizeUIKeys(hash, uiBindings || _.result(this, 'ui'));
	    },
	  
	    // normalize the values of passed hash with the views `ui` selectors.
	    // `{foo: "@ui.bar"}`
	    normalizeUIValues: function(hash, properties) {
	      var ui = _.result(this, 'ui');
	      var uiBindings = _.result(this, '_uiBindings');
	      return Marionette.normalizeUIValues(hash, uiBindings || ui, properties);
	    },
	  
	    // Configure `triggers` to forward DOM events to view
	    // events. `triggers: {"click .foo": "do:foo"}`
	    configureTriggers: function() {
	      if (!this.triggers) { return; }
	  
	      // Allow `triggers` to be configured as a function
	      var triggers = this.normalizeUIKeys(_.result(this, 'triggers'));
	  
	      // Configure the triggers, prevent default
	      // action and stop propagation of DOM events
	      return _.reduce(triggers, function(events, value, key) {
	        events[key] = this._buildViewTrigger(value);
	        return events;
	      }, {}, this);
	    },
	  
	    // Overriding Backbone.View's delegateEvents to handle
	    // the `triggers`, `modelEvents`, and `collectionEvents` configuration
	    delegateEvents: function(events) {
	      this._delegateDOMEvents(events);
	      this.bindEntityEvents(this.model, this.getOption('modelEvents'));
	      this.bindEntityEvents(this.collection, this.getOption('collectionEvents'));
	  
	      _.each(this._behaviors, function(behavior) {
	        behavior.bindEntityEvents(this.model, behavior.getOption('modelEvents'));
	        behavior.bindEntityEvents(this.collection, behavior.getOption('collectionEvents'));
	      }, this);
	  
	      return this;
	    },
	  
	    // internal method to delegate DOM events and triggers
	    _delegateDOMEvents: function(eventsArg) {
	      var events = Marionette._getValue(eventsArg || this.events, this);
	  
	      // normalize ui keys
	      events = this.normalizeUIKeys(events);
	      if (_.isUndefined(eventsArg)) {this.events = events;}
	  
	      var combinedEvents = {};
	  
	      // look up if this view has behavior events
	      var behaviorEvents = _.result(this, 'behaviorEvents') || {};
	      var triggers = this.configureTriggers();
	      var behaviorTriggers = _.result(this, 'behaviorTriggers') || {};
	  
	      // behavior events will be overriden by view events and or triggers
	      _.extend(combinedEvents, behaviorEvents, events, triggers, behaviorTriggers);
	  
	      Backbone.View.prototype.delegateEvents.call(this, combinedEvents);
	    },
	  
	    // Overriding Backbone.View's undelegateEvents to handle unbinding
	    // the `triggers`, `modelEvents`, and `collectionEvents` config
	    undelegateEvents: function() {
	      Backbone.View.prototype.undelegateEvents.apply(this, arguments);
	  
	      this.unbindEntityEvents(this.model, this.getOption('modelEvents'));
	      this.unbindEntityEvents(this.collection, this.getOption('collectionEvents'));
	  
	      _.each(this._behaviors, function(behavior) {
	        behavior.unbindEntityEvents(this.model, behavior.getOption('modelEvents'));
	        behavior.unbindEntityEvents(this.collection, behavior.getOption('collectionEvents'));
	      }, this);
	  
	      return this;
	    },
	  
	    // Internal helper method to verify whether the view hasn't been destroyed
	    _ensureViewIsIntact: function() {
	      if (this.isDestroyed) {
	        throw new Marionette.Error({
	          name: 'ViewDestroyedError',
	          message: 'View (cid: "' + this.cid + '") has already been destroyed and cannot be used.'
	        });
	      }
	    },
	  
	    // Default `destroy` implementation, for removing a view from the
	    // DOM and unbinding it. Regions will call this method
	    // for you. You can specify an `onDestroy` method in your view to
	    // add custom code that is called after the view is destroyed.
	    destroy: function() {
	      if (this.isDestroyed) { return this; }
	  
	      var args = _.toArray(arguments);
	  
	      this.triggerMethod.apply(this, ['before:destroy'].concat(args));
	  
	      // mark as destroyed before doing the actual destroy, to
	      // prevent infinite loops within "destroy" event handlers
	      // that are trying to destroy other views
	      this.isDestroyed = true;
	      this.triggerMethod.apply(this, ['destroy'].concat(args));
	  
	      // unbind UI elements
	      this.unbindUIElements();
	  
	      this.isRendered = false;
	  
	      // remove the view from the DOM
	      this.remove();
	  
	      // Call destroy on each behavior after
	      // destroying the view.
	      // This unbinds event listeners
	      // that behaviors have registered for.
	      _.invoke(this._behaviors, 'destroy', args);
	  
	      return this;
	    },
	  
	    bindUIElements: function() {
	      this._bindUIElements();
	      _.invoke(this._behaviors, this._bindUIElements);
	    },
	  
	    // This method binds the elements specified in the "ui" hash inside the view's code with
	    // the associated jQuery selectors.
	    _bindUIElements: function() {
	      if (!this.ui) { return; }
	  
	      // store the ui hash in _uiBindings so they can be reset later
	      // and so re-rendering the view will be able to find the bindings
	      if (!this._uiBindings) {
	        this._uiBindings = this.ui;
	      }
	  
	      // get the bindings result, as a function or otherwise
	      var bindings = _.result(this, '_uiBindings');
	  
	      // empty the ui so we don't have anything to start with
	      this.ui = {};
	  
	      // bind each of the selectors
	      _.each(bindings, function(selector, key) {
	        this.ui[key] = this.$(selector);
	      }, this);
	    },
	  
	    // This method unbinds the elements specified in the "ui" hash
	    unbindUIElements: function() {
	      this._unbindUIElements();
	      _.invoke(this._behaviors, this._unbindUIElements);
	    },
	  
	    _unbindUIElements: function() {
	      if (!this.ui || !this._uiBindings) { return; }
	  
	      // delete all of the existing ui bindings
	      _.each(this.ui, function($el, name) {
	        delete this.ui[name];
	      }, this);
	  
	      // reset the ui element to the original bindings configuration
	      this.ui = this._uiBindings;
	      delete this._uiBindings;
	    },
	  
	    // Internal method to create an event handler for a given `triggerDef` like
	    // 'click:foo'
	    _buildViewTrigger: function(triggerDef) {
	  
	      var options = _.defaults({}, triggerDef, {
	        preventDefault: true,
	        stopPropagation: true
	      });
	  
	      var eventName = _.isObject(triggerDef) ? options.event : triggerDef;
	  
	      return function(e) {
	        if (e) {
	          if (e.preventDefault && options.preventDefault) {
	            e.preventDefault();
	          }
	  
	          if (e.stopPropagation && options.stopPropagation) {
	            e.stopPropagation();
	          }
	        }
	  
	        var args = {
	          view: this,
	          model: this.model,
	          collection: this.collection
	        };
	  
	        this.triggerMethod(eventName, args);
	      };
	    },
	  
	    setElement: function() {
	      var ret = Backbone.View.prototype.setElement.apply(this, arguments);
	  
	      // proxy behavior $el to the view's $el.
	      // This is needed because a view's $el proxy
	      // is not set until after setElement is called.
	      _.invoke(this._behaviors, 'proxyViewProperties', this);
	  
	      return ret;
	    },
	  
	    // import the `triggerMethod` to trigger events with corresponding
	    // methods if the method exists
	    triggerMethod: function() {
	      var ret = Marionette._triggerMethod(this, arguments);
	  
	      this._triggerEventOnBehaviors(arguments);
	      this._triggerEventOnParentLayout(arguments[0], _.rest(arguments));
	  
	      return ret;
	    },
	  
	    _triggerEventOnBehaviors: function(args) {
	      var triggerMethod = Marionette._triggerMethod;
	      var behaviors = this._behaviors;
	      // Use good ol' for as this is a very hot function
	      for (var i = 0, length = behaviors && behaviors.length; i < length; i++) {
	        triggerMethod(behaviors[i], args);
	      }
	    },
	  
	    _triggerEventOnParentLayout: function(eventName, args) {
	      var layoutView = this._parentLayoutView();
	      if (!layoutView) {
	        return;
	      }
	  
	      // invoke triggerMethod on parent view
	      var eventPrefix = Marionette.getOption(layoutView, 'childViewEventPrefix');
	      var prefixedEventName = eventPrefix + ':' + eventName;
	      var callArgs = [this].concat(args);
	  
	      Marionette._triggerMethod(layoutView, prefixedEventName, callArgs);
	  
	      // call the parent view's childEvents handler
	      var childEvents = Marionette.getOption(layoutView, 'childEvents');
	  
	      // since childEvents can be an object or a function use Marionette._getValue
	      // to handle the abstaction for us.
	      childEvents = Marionette._getValue(childEvents, layoutView);
	      var normalizedChildEvents = layoutView.normalizeMethods(childEvents);
	  
	      if (normalizedChildEvents && _.isFunction(normalizedChildEvents[eventName])) {
	        normalizedChildEvents[eventName].apply(layoutView, callArgs);
	      }
	    },
	  
	    // This method returns any views that are immediate
	    // children of this view
	    _getImmediateChildren: function() {
	      return [];
	    },
	  
	    // Returns an array of every nested view within this view
	    _getNestedViews: function() {
	      var children = this._getImmediateChildren();
	  
	      if (!children.length) { return children; }
	  
	      return _.reduce(children, function(memo, view) {
	        if (!view._getNestedViews) { return memo; }
	        return memo.concat(view._getNestedViews());
	      }, children);
	    },
	  
	    // Walk the _parent tree until we find a layout view (if one exists).
	    // Returns the parent layout view hierarchically closest to this view.
	    _parentLayoutView: function() {
	      var parent  = this._parent;
	  
	      while (parent) {
	        if (parent instanceof Marionette.LayoutView) {
	          return parent;
	        }
	        parent = parent._parent;
	      }
	    },
	  
	    // Imports the "normalizeMethods" to transform hashes of
	    // events=>function references/names to a hash of events=>function references
	    normalizeMethods: Marionette.normalizeMethods,
	  
	    // A handy way to merge passed-in options onto the instance
	    mergeOptions: Marionette.mergeOptions,
	  
	    // Proxy `getOption` to enable getting options from this or this.options by name.
	    getOption: Marionette.proxyGetOption,
	  
	    // Proxy `bindEntityEvents` to enable binding view's events from another entity.
	    bindEntityEvents: Marionette.proxyBindEntityEvents,
	  
	    // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.
	    unbindEntityEvents: Marionette.proxyUnbindEntityEvents
	  });
	  
	  // Item View
	  // ---------
	  
	  // A single item view implementation that contains code for rendering
	  // with underscore.js templates, serializing the view's model or collection,
	  // and calling several methods on extended views, such as `onRender`.
	  Marionette.ItemView = Marionette.View.extend({
	  
	    // Setting up the inheritance chain which allows changes to
	    // Marionette.View.prototype.constructor which allows overriding
	    constructor: function() {
	      Marionette.View.apply(this, arguments);
	    },
	  
	    // Serialize the model or collection for the view. If a model is
	    // found, the view's `serializeModel` is called. If a collection is found,
	    // each model in the collection is serialized by calling
	    // the view's `serializeCollection` and put into an `items` array in
	    // the resulting data. If both are found, defaults to the model.
	    // You can override the `serializeData` method in your own view definition,
	    // to provide custom serialization for your view's data.
	    serializeData: function() {
	      if (!this.model && !this.collection) {
	        return {};
	      }
	  
	      var args = [this.model || this.collection];
	      if (arguments.length) {
	        args.push.apply(args, arguments);
	      }
	  
	      if (this.model) {
	        return this.serializeModel.apply(this, args);
	      } else {
	        return {
	          items: this.serializeCollection.apply(this, args)
	        };
	      }
	    },
	  
	    // Serialize a collection by serializing each of its models.
	    serializeCollection: function(collection) {
	      return collection.toJSON.apply(collection, _.rest(arguments));
	    },
	  
	    // Render the view, defaulting to underscore.js templates.
	    // You can override this in your view definition to provide
	    // a very specific rendering for your view. In general, though,
	    // you should override the `Marionette.Renderer` object to
	    // change how Marionette renders views.
	    render: function() {
	      this._ensureViewIsIntact();
	  
	      this.triggerMethod('before:render', this);
	  
	      this._renderTemplate();
	      this.isRendered = true;
	      this.bindUIElements();
	  
	      this.triggerMethod('render', this);
	  
	      return this;
	    },
	  
	    // Internal method to render the template with the serialized data
	    // and template helpers via the `Marionette.Renderer` object.
	    // Throws an `UndefinedTemplateError` error if the template is
	    // any falsely value but literal `false`.
	    _renderTemplate: function() {
	      var template = this.getTemplate();
	  
	      // Allow template-less item views
	      if (template === false) {
	        return;
	      }
	  
	      if (!template) {
	        throw new Marionette.Error({
	          name: 'UndefinedTemplateError',
	          message: 'Cannot render the template since it is null or undefined.'
	        });
	      }
	  
	      // Add in entity data and template helpers
	      var data = this.mixinTemplateHelpers(this.serializeData());
	  
	      // Render and add to el
	      var html = Marionette.Renderer.render(template, data, this);
	      this.attachElContent(html);
	  
	      return this;
	    },
	  
	    // Attaches the content of a given view.
	    // This method can be overridden to optimize rendering,
	    // or to render in a non standard way.
	    //
	    // For example, using `innerHTML` instead of `$el.html`
	    //
	    // ```js
	    // attachElContent: function(html) {
	    //   this.el.innerHTML = html;
	    //   return this;
	    // }
	    // ```
	    attachElContent: function(html) {
	      this.$el.html(html);
	  
	      return this;
	    }
	  });
	  
	  /* jshint maxstatements: 20, maxcomplexity: 7 */
	  
	  // Collection View
	  // ---------------
	  
	  // A view that iterates over a Backbone.Collection
	  // and renders an individual child view for each model.
	  Marionette.CollectionView = Marionette.View.extend({
	  
	    // used as the prefix for child view events
	    // that are forwarded through the collectionview
	    childViewEventPrefix: 'childview',
	  
	    // flag for maintaining the sorted order of the collection
	    sort: true,
	  
	    // constructor
	    // option to pass `{sort: false}` to prevent the `CollectionView` from
	    // maintaining the sorted order of the collection.
	    // This will fallback onto appending childView's to the end.
	    //
	    // option to pass `{comparator: compFunction()}` to allow the `CollectionView`
	    // to use a custom sort order for the collection.
	    constructor: function(options) {
	      this.once('render', this._initialEvents);
	      this._initChildViewStorage();
	  
	      Marionette.View.apply(this, arguments);
	  
	      this.on({
	        'before:show':   this._onBeforeShowCalled,
	        'show':          this._onShowCalled,
	        'before:attach': this._onBeforeAttachCalled,
	        'attach':        this._onAttachCalled
	      });
	      this.initRenderBuffer();
	    },
	  
	    // Instead of inserting elements one by one into the page,
	    // it's much more performant to insert elements into a document
	    // fragment and then insert that document fragment into the page
	    initRenderBuffer: function() {
	      this._bufferedChildren = [];
	    },
	  
	    startBuffering: function() {
	      this.initRenderBuffer();
	      this.isBuffering = true;
	    },
	  
	    endBuffering: function() {
	      // Only trigger attach if already shown and attached, otherwise Region#show() handles this.
	      var canTriggerAttach = this._isShown && Marionette.isNodeAttached(this.el);
	      var nestedViews;
	  
	      this.isBuffering = false;
	  
	      if (this._isShown) {
	        this._triggerMethodMany(this._bufferedChildren, this, 'before:show');
	      }
	      if (canTriggerAttach && this._triggerBeforeAttach) {
	        nestedViews = this._getNestedViews();
	        this._triggerMethodMany(nestedViews, this, 'before:attach');
	      }
	  
	      this.attachBuffer(this, this._createBuffer());
	  
	      if (canTriggerAttach && this._triggerAttach) {
	        nestedViews = this._getNestedViews();
	        this._triggerMethodMany(nestedViews, this, 'attach');
	      }
	      if (this._isShown) {
	        this._triggerMethodMany(this._bufferedChildren, this, 'show');
	      }
	      this.initRenderBuffer();
	    },
	  
	    _triggerMethodMany: function(targets, source, eventName) {
	      var args = _.drop(arguments, 3);
	  
	      _.each(targets, function(target) {
	        Marionette.triggerMethodOn.apply(target, [target, eventName, target, source].concat(args));
	      });
	    },
	  
	    // Configured the initial events that the collection view
	    // binds to.
	    _initialEvents: function() {
	      if (this.collection) {
	        this.listenTo(this.collection, 'add', this._onCollectionAdd);
	        this.listenTo(this.collection, 'remove', this._onCollectionRemove);
	        this.listenTo(this.collection, 'reset', this.render);
	  
	        if (this.getOption('sort')) {
	          this.listenTo(this.collection, 'sort', this._sortViews);
	        }
	      }
	    },
	  
	    // Handle a child added to the collection
	    _onCollectionAdd: function(child, collection, opts) {
	      // `index` is present when adding with `at` since BB 1.2; indexOf fallback for < 1.2
	      var index = opts.at !== undefined && (opts.index || collection.indexOf(child));
	  
	      // When filtered or when there is no initial index, calculate index.
	      if (this.getOption('filter') || index === false) {
	        index = _.indexOf(this._filteredSortedModels(index), child);
	      }
	  
	      if (this._shouldAddChild(child, index)) {
	        this.destroyEmptyView();
	        var ChildView = this.getChildView(child);
	        this.addChild(child, ChildView, index);
	      }
	    },
	  
	    // get the child view by model it holds, and remove it
	    _onCollectionRemove: function(model) {
	      var view = this.children.findByModel(model);
	      this.removeChildView(view);
	      this.checkEmpty();
	    },
	  
	    _onBeforeShowCalled: function() {
	      // Reset attach event flags at the top of the Region#show() event lifecycle; if the Region's
	      // show() options permit onBeforeAttach/onAttach events, these flags will be set true again.
	      this._triggerBeforeAttach = this._triggerAttach = false;
	      this.children.each(function(childView) {
	        Marionette.triggerMethodOn(childView, 'before:show', childView);
	      });
	    },
	  
	    _onShowCalled: function() {
	      this.children.each(function(childView) {
	        Marionette.triggerMethodOn(childView, 'show', childView);
	      });
	    },
	  
	    // If during Region#show() onBeforeAttach was fired, continue firing it for child views
	    _onBeforeAttachCalled: function() {
	      this._triggerBeforeAttach = true;
	    },
	  
	    // If during Region#show() onAttach was fired, continue firing it for child views
	    _onAttachCalled: function() {
	      this._triggerAttach = true;
	    },
	  
	    // Render children views. Override this method to
	    // provide your own implementation of a render function for
	    // the collection view.
	    render: function() {
	      this._ensureViewIsIntact();
	      this.triggerMethod('before:render', this);
	      this._renderChildren();
	      this.isRendered = true;
	      this.triggerMethod('render', this);
	      return this;
	    },
	  
	    // Reorder DOM after sorting. When your element's rendering
	    // do not use their index, you can pass reorderOnSort: true
	    // to only reorder the DOM after a sort instead of rendering
	    // all the collectionView
	    reorder: function() {
	      var children = this.children;
	      var models = this._filteredSortedModels();
	      var anyModelsAdded = _.some(models, function(model) {
	        return !children.findByModel(model);
	      });
	  
	      // If there are any new models added due to filtering
	      // We need to add child views
	      // So render as normal
	      if (anyModelsAdded) {
	        this.render();
	      } else {
	        // get the DOM nodes in the same order as the models
	        var elsToReorder = _.map(models, function(model, index) {
	          var view = children.findByModel(model);
	          view._index = index;
	          return view.el;
	        });
	  
	        // find the views that were children before but arent in this new ordering
	        var filteredOutViews = children.filter(function(view) {
	          return !_.contains(elsToReorder, view.el);
	        });
	  
	        this.triggerMethod('before:reorder');
	  
	        // since append moves elements that are already in the DOM,
	        // appending the elements will effectively reorder them
	        this._appendReorderedChildren(elsToReorder);
	  
	        // remove any views that have been filtered out
	        _.each(filteredOutViews, this.removeChildView, this);
	        this.checkEmpty();
	  
	        this.triggerMethod('reorder');
	      }
	    },
	  
	    // Render view after sorting. Override this method to
	    // change how the view renders after a `sort` on the collection.
	    // An example of this would be to only `renderChildren` in a `CompositeView`
	    // rather than the full view.
	    resortView: function() {
	      if (Marionette.getOption(this, 'reorderOnSort')) {
	        this.reorder();
	      } else {
	        this.render();
	      }
	    },
	  
	    // Internal method. This checks for any changes in the order of the collection.
	    // If the index of any view doesn't match, it will render.
	    _sortViews: function() {
	      var models = this._filteredSortedModels();
	  
	      // check for any changes in sort order of views
	      var orderChanged = _.find(models, function(item, index) {
	        var view = this.children.findByModel(item);
	        return !view || view._index !== index;
	      }, this);
	  
	      if (orderChanged) {
	        this.resortView();
	      }
	    },
	  
	    // Internal reference to what index a `emptyView` is.
	    _emptyViewIndex: -1,
	  
	    // Internal method. Separated so that CompositeView can append to the childViewContainer
	    // if necessary
	    _appendReorderedChildren: function(children) {
	      this.$el.append(children);
	    },
	  
	    // Internal method. Separated so that CompositeView can have
	    // more control over events being triggered, around the rendering
	    // process
	    _renderChildren: function() {
	      this.destroyEmptyView();
	      this.destroyChildren({checkEmpty: false});
	  
	      if (this.isEmpty(this.collection)) {
	        this.showEmptyView();
	      } else {
	        this.triggerMethod('before:render:collection', this);
	        this.startBuffering();
	        this.showCollection();
	        this.endBuffering();
	        this.triggerMethod('render:collection', this);
	  
	        // If we have shown children and none have passed the filter, show the empty view
	        if (this.children.isEmpty() && this.getOption('filter')) {
	          this.showEmptyView();
	        }
	      }
	    },
	  
	    // Internal method to loop through collection and show each child view.
	    showCollection: function() {
	      var ChildView;
	  
	      var models = this._filteredSortedModels();
	  
	      _.each(models, function(child, index) {
	        ChildView = this.getChildView(child);
	        this.addChild(child, ChildView, index);
	      }, this);
	    },
	  
	    // Allow the collection to be sorted by a custom view comparator
	    _filteredSortedModels: function(addedAt) {
	      var viewComparator = this.getViewComparator();
	      var models = this.collection.models;
	      addedAt = Math.min(Math.max(addedAt, 0), models.length - 1);
	  
	      if (viewComparator) {
	        var addedModel;
	        // Preserve `at` location, even for a sorted view
	        if (addedAt) {
	          addedModel = models[addedAt];
	          models = models.slice(0, addedAt).concat(models.slice(addedAt + 1));
	        }
	        models = this._sortModelsBy(models, viewComparator);
	        if (addedModel) {
	          models.splice(addedAt, 0, addedModel);
	        }
	      }
	  
	      // Filter after sorting in case the filter uses the index
	      if (this.getOption('filter')) {
	        models = _.filter(models, function(model, index) {
	          return this._shouldAddChild(model, index);
	        }, this);
	      }
	  
	      return models;
	    },
	  
	    _sortModelsBy: function(models, comparator) {
	      if (typeof comparator === 'string') {
	        return _.sortBy(models, function(model) {
	          return model.get(comparator);
	        }, this);
	      } else if (comparator.length === 1) {
	        return _.sortBy(models, comparator, this);
	      } else {
	        return models.sort(_.bind(comparator, this));
	      }
	    },
	  
	    // Internal method to show an empty view in place of
	    // a collection of child views, when the collection is empty
	    showEmptyView: function() {
	      var EmptyView = this.getEmptyView();
	  
	      if (EmptyView && !this._showingEmptyView) {
	        this.triggerMethod('before:render:empty');
	  
	        this._showingEmptyView = true;
	        var model = new Backbone.Model();
	        this.addEmptyView(model, EmptyView);
	  
	        this.triggerMethod('render:empty');
	      }
	    },
	  
	    // Internal method to destroy an existing emptyView instance
	    // if one exists. Called when a collection view has been
	    // rendered empty, and then a child is added to the collection.
	    destroyEmptyView: function() {
	      if (this._showingEmptyView) {
	        this.triggerMethod('before:remove:empty');
	  
	        this.destroyChildren();
	        delete this._showingEmptyView;
	  
	        this.triggerMethod('remove:empty');
	      }
	    },
	  
	    // Retrieve the empty view class
	    getEmptyView: function() {
	      return this.getOption('emptyView');
	    },
	  
	    // Render and show the emptyView. Similar to addChild method
	    // but "add:child" events are not fired, and the event from
	    // emptyView are not forwarded
	    addEmptyView: function(child, EmptyView) {
	      // Only trigger attach if already shown, attached, and not buffering, otherwise endBuffer() or
	      // Region#show() handles this.
	      var canTriggerAttach = this._isShown && !this.isBuffering && Marionette.isNodeAttached(this.el);
	      var nestedViews;
	  
	      // get the emptyViewOptions, falling back to childViewOptions
	      var emptyViewOptions = this.getOption('emptyViewOptions') ||
	                            this.getOption('childViewOptions');
	  
	      if (_.isFunction(emptyViewOptions)) {
	        emptyViewOptions = emptyViewOptions.call(this, child, this._emptyViewIndex);
	      }
	  
	      // build the empty view
	      var view = this.buildChildView(child, EmptyView, emptyViewOptions);
	  
	      view._parent = this;
	  
	      // Proxy emptyView events
	      this.proxyChildEvents(view);
	  
	      view.once('render', function() {
	        // trigger the 'before:show' event on `view` if the collection view has already been shown
	        if (this._isShown) {
	          Marionette.triggerMethodOn(view, 'before:show', view);
	        }
	  
	        // Trigger `before:attach` following `render` to avoid adding logic and event triggers
	        // to public method `renderChildView()`.
	        if (canTriggerAttach && this._triggerBeforeAttach) {
	          nestedViews = this._getViewAndNested(view);
	          this._triggerMethodMany(nestedViews, this, 'before:attach');
	        }
	      }, this);
	  
	      // Store the `emptyView` like a `childView` so we can properly remove and/or close it later
	      this.children.add(view);
	      this.renderChildView(view, this._emptyViewIndex);
	  
	      // Trigger `attach`
	      if (canTriggerAttach && this._triggerAttach) {
	        nestedViews = this._getViewAndNested(view);
	        this._triggerMethodMany(nestedViews, this, 'attach');
	      }
	      // call the 'show' method if the collection view has already been shown
	      if (this._isShown) {
	        Marionette.triggerMethodOn(view, 'show', view);
	      }
	    },
	  
	    // Retrieve the `childView` class, either from `this.options.childView`
	    // or from the `childView` in the object definition. The "options"
	    // takes precedence.
	    // This method receives the model that will be passed to the instance
	    // created from this `childView`. Overriding methods may use the child
	    // to determine what `childView` class to return.
	    getChildView: function(child) {
	      var childView = this.getOption('childView');
	  
	      if (!childView) {
	        throw new Marionette.Error({
	          name: 'NoChildViewError',
	          message: 'A "childView" must be specified'
	        });
	      }
	  
	      return childView;
	    },
	  
	    // Render the child's view and add it to the
	    // HTML for the collection view at a given index.
	    // This will also update the indices of later views in the collection
	    // in order to keep the children in sync with the collection.
	    addChild: function(child, ChildView, index) {
	      var childViewOptions = this.getOption('childViewOptions');
	      childViewOptions = Marionette._getValue(childViewOptions, this, [child, index]);
	  
	      var view = this.buildChildView(child, ChildView, childViewOptions);
	  
	      // increment indices of views after this one
	      this._updateIndices(view, true, index);
	  
	      this.triggerMethod('before:add:child', view);
	      this._addChildView(view, index);
	      this.triggerMethod('add:child', view);
	  
	      view._parent = this;
	  
	      return view;
	    },
	  
	    // Internal method. This decrements or increments the indices of views after the
	    // added/removed view to keep in sync with the collection.
	    _updateIndices: function(view, increment, index) {
	      if (!this.getOption('sort')) {
	        return;
	      }
	  
	      if (increment) {
	        // assign the index to the view
	        view._index = index;
	      }
	  
	      // update the indexes of views after this one
	      this.children.each(function(laterView) {
	        if (laterView._index >= view._index) {
	          laterView._index += increment ? 1 : -1;
	        }
	      });
	    },
	  
	    // Internal Method. Add the view to children and render it at
	    // the given index.
	    _addChildView: function(view, index) {
	      // Only trigger attach if already shown, attached, and not buffering, otherwise endBuffer() or
	      // Region#show() handles this.
	      var canTriggerAttach = this._isShown && !this.isBuffering && Marionette.isNodeAttached(this.el);
	      var nestedViews;
	  
	      // set up the child view event forwarding
	      this.proxyChildEvents(view);
	  
	      view.once('render', function() {
	        // trigger the 'before:show' event on `view` if the collection view has already been shown
	        if (this._isShown && !this.isBuffering) {
	          Marionette.triggerMethodOn(view, 'before:show', view);
	        }
	  
	        // Trigger `before:attach` following `render` to avoid adding logic and event triggers
	        // to public method `renderChildView()`.
	        if (canTriggerAttach && this._triggerBeforeAttach) {
	          nestedViews = this._getViewAndNested(view);
	          this._triggerMethodMany(nestedViews, this, 'before:attach');
	        }
	      }, this);
	  
	      // Store the child view itself so we can properly remove and/or destroy it later
	      this.children.add(view);
	      this.renderChildView(view, index);
	  
	      // Trigger `attach`
	      if (canTriggerAttach && this._triggerAttach) {
	        nestedViews = this._getViewAndNested(view);
	        this._triggerMethodMany(nestedViews, this, 'attach');
	      }
	      // Trigger `show`
	      if (this._isShown && !this.isBuffering) {
	        Marionette.triggerMethodOn(view, 'show', view);
	      }
	    },
	  
	    // render the child view
	    renderChildView: function(view, index) {
	      if (!view.supportsRenderLifecycle) {
	        Marionette.triggerMethodOn(view, 'before:render', view);
	      }
	      view.render();
	      if (!view.supportsRenderLifecycle) {
	        Marionette.triggerMethodOn(view, 'render', view);
	      }
	      this.attachHtml(this, view, index);
	      return view;
	    },
	  
	    // Build a `childView` for a model in the collection.
	    buildChildView: function(child, ChildViewClass, childViewOptions) {
	      var options = _.extend({model: child}, childViewOptions);
	      var childView = new ChildViewClass(options);
	      Marionette.MonitorDOMRefresh(childView);
	      return childView;
	    },
	  
	    // Remove the child view and destroy it.
	    // This function also updates the indices of
	    // later views in the collection in order to keep
	    // the children in sync with the collection.
	    removeChildView: function(view) {
	      if (!view) { return view; }
	  
	      this.triggerMethod('before:remove:child', view);
	  
	      if (!view.supportsDestroyLifecycle) {
	        Marionette.triggerMethodOn(view, 'before:destroy', view);
	      }
	      // call 'destroy' or 'remove', depending on which is found
	      if (view.destroy) {
	        view.destroy();
	      } else {
	        view.remove();
	      }
	      if (!view.supportsDestroyLifecycle) {
	        Marionette.triggerMethodOn(view, 'destroy', view);
	      }
	  
	      delete view._parent;
	      this.stopListening(view);
	      this.children.remove(view);
	      this.triggerMethod('remove:child', view);
	  
	      // decrement the index of views after this one
	      this._updateIndices(view, false);
	  
	      return view;
	    },
	  
	    // check if the collection is empty
	    isEmpty: function() {
	      return !this.collection || this.collection.length === 0;
	    },
	  
	    // If empty, show the empty view
	    checkEmpty: function() {
	      if (this.isEmpty(this.collection)) {
	        this.showEmptyView();
	      }
	    },
	  
	    // You might need to override this if you've overridden attachHtml
	    attachBuffer: function(collectionView, buffer) {
	      collectionView.$el.append(buffer);
	    },
	  
	    // Create a fragment buffer from the currently buffered children
	    _createBuffer: function() {
	      var elBuffer = document.createDocumentFragment();
	      _.each(this._bufferedChildren, function(b) {
	        elBuffer.appendChild(b.el);
	      });
	      return elBuffer;
	    },
	  
	    // Append the HTML to the collection's `el`.
	    // Override this method to do something other
	    // than `.append`.
	    attachHtml: function(collectionView, childView, index) {
	      if (collectionView.isBuffering) {
	        // buffering happens on reset events and initial renders
	        // in order to reduce the number of inserts into the
	        // document, which are expensive.
	        collectionView._bufferedChildren.splice(index, 0, childView);
	      } else {
	        // If we've already rendered the main collection, append
	        // the new child into the correct order if we need to. Otherwise
	        // append to the end.
	        if (!collectionView._insertBefore(childView, index)) {
	          collectionView._insertAfter(childView);
	        }
	      }
	    },
	  
	    // Internal method. Check whether we need to insert the view into
	    // the correct position.
	    _insertBefore: function(childView, index) {
	      var currentView;
	      var findPosition = this.getOption('sort') && (index < this.children.length - 1);
	      if (findPosition) {
	        // Find the view after this one
	        currentView = this.children.find(function(view) {
	          return view._index === index + 1;
	        });
	      }
	  
	      if (currentView) {
	        currentView.$el.before(childView.el);
	        return true;
	      }
	  
	      return false;
	    },
	  
	    // Internal method. Append a view to the end of the $el
	    _insertAfter: function(childView) {
	      this.$el.append(childView.el);
	    },
	  
	    // Internal method to set up the `children` object for
	    // storing all of the child views
	    _initChildViewStorage: function() {
	      this.children = new Backbone.ChildViewContainer();
	    },
	  
	    // Handle cleanup and other destroying needs for the collection of views
	    destroy: function() {
	      if (this.isDestroyed) { return this; }
	  
	      this.triggerMethod('before:destroy:collection');
	      this.destroyChildren({checkEmpty: false});
	      this.triggerMethod('destroy:collection');
	  
	      return Marionette.View.prototype.destroy.apply(this, arguments);
	    },
	  
	    // Destroy the child views that this collection view
	    // is holding on to, if any
	    destroyChildren: function(options) {
	      var destroyOptions = options || {};
	      var shouldCheckEmpty = true;
	      var childViews = this.children.map(_.identity);
	  
	      if (!_.isUndefined(destroyOptions.checkEmpty)) {
	        shouldCheckEmpty = destroyOptions.checkEmpty;
	      }
	  
	      this.children.each(this.removeChildView, this);
	  
	      if (shouldCheckEmpty) {
	        this.checkEmpty();
	      }
	      return childViews;
	    },
	  
	    // Return true if the given child should be shown
	    // Return false otherwise
	    // The filter will be passed (child, index, collection)
	    // Where
	    //  'child' is the given model
	    //  'index' is the index of that model in the collection
	    //  'collection' is the collection referenced by this CollectionView
	    _shouldAddChild: function(child, index) {
	      var filter = this.getOption('filter');
	      return !_.isFunction(filter) || filter.call(this, child, index, this.collection);
	    },
	  
	    // Set up the child view event forwarding. Uses a "childview:"
	    // prefix in front of all forwarded events.
	    proxyChildEvents: function(view) {
	      var prefix = this.getOption('childViewEventPrefix');
	  
	      // Forward all child view events through the parent,
	      // prepending "childview:" to the event name
	      this.listenTo(view, 'all', function() {
	        var args = _.toArray(arguments);
	        var rootEvent = args[0];
	        var childEvents = this.normalizeMethods(_.result(this, 'childEvents'));
	  
	        args[0] = prefix + ':' + rootEvent;
	        args.splice(1, 0, view);
	  
	        // call collectionView childEvent if defined
	        if (typeof childEvents !== 'undefined' && _.isFunction(childEvents[rootEvent])) {
	          childEvents[rootEvent].apply(this, args.slice(1));
	        }
	  
	        this.triggerMethod.apply(this, args);
	      });
	    },
	  
	    _getImmediateChildren: function() {
	      return _.values(this.children._views);
	    },
	  
	    _getViewAndNested: function(view) {
	      // This will not fail on Backbone.View which does not have #_getNestedViews.
	      return [view].concat(_.result(view, '_getNestedViews') || []);
	    },
	  
	    getViewComparator: function() {
	      return this.getOption('viewComparator');
	    }
	  });
	  
	  /* jshint maxstatements: 17, maxlen: 117 */
	  
	  // Composite View
	  // --------------
	  
	  // Used for rendering a branch-leaf, hierarchical structure.
	  // Extends directly from CollectionView and also renders an
	  // a child view as `modelView`, for the top leaf
	  Marionette.CompositeView = Marionette.CollectionView.extend({
	  
	    // Setting up the inheritance chain which allows changes to
	    // Marionette.CollectionView.prototype.constructor which allows overriding
	    // option to pass '{sort: false}' to prevent the CompositeView from
	    // maintaining the sorted order of the collection.
	    // This will fallback onto appending childView's to the end.
	    constructor: function() {
	      Marionette.CollectionView.apply(this, arguments);
	    },
	  
	    // Configured the initial events that the composite view
	    // binds to. Override this method to prevent the initial
	    // events, or to add your own initial events.
	    _initialEvents: function() {
	  
	      // Bind only after composite view is rendered to avoid adding child views
	      // to nonexistent childViewContainer
	  
	      if (this.collection) {
	        this.listenTo(this.collection, 'add', this._onCollectionAdd);
	        this.listenTo(this.collection, 'remove', this._onCollectionRemove);
	        this.listenTo(this.collection, 'reset', this._renderChildren);
	  
	        if (this.getOption('sort')) {
	          this.listenTo(this.collection, 'sort', this._sortViews);
	        }
	      }
	    },
	  
	    // Retrieve the `childView` to be used when rendering each of
	    // the items in the collection. The default is to return
	    // `this.childView` or Marionette.CompositeView if no `childView`
	    // has been defined
	    getChildView: function(child) {
	      var childView = this.getOption('childView') || this.constructor;
	  
	      return childView;
	    },
	  
	    // Serialize the model for the view.
	    // You can override the `serializeData` method in your own view
	    // definition, to provide custom serialization for your view's data.
	    serializeData: function() {
	      var data = {};
	  
	      if (this.model) {
	        data = _.partial(this.serializeModel, this.model).apply(this, arguments);
	      }
	  
	      return data;
	    },
	  
	    // Renders the model and the collection.
	    render: function() {
	      this._ensureViewIsIntact();
	      this._isRendering = true;
	      this.resetChildViewContainer();
	  
	      this.triggerMethod('before:render', this);
	  
	      this._renderTemplate();
	      this._renderChildren();
	  
	      this._isRendering = false;
	      this.isRendered = true;
	      this.triggerMethod('render', this);
	      return this;
	    },
	  
	    _renderChildren: function() {
	      if (this.isRendered || this._isRendering) {
	        Marionette.CollectionView.prototype._renderChildren.call(this);
	      }
	    },
	  
	    // Render the root template that the children
	    // views are appended to
	    _renderTemplate: function() {
	      var data = {};
	      data = this.serializeData();
	      data = this.mixinTemplateHelpers(data);
	  
	      this.triggerMethod('before:render:template');
	  
	      var template = this.getTemplate();
	      var html = Marionette.Renderer.render(template, data, this);
	      this.attachElContent(html);
	  
	      // the ui bindings is done here and not at the end of render since they
	      // will not be available until after the model is rendered, but should be
	      // available before the collection is rendered.
	      this.bindUIElements();
	      this.triggerMethod('render:template');
	    },
	  
	    // Attaches the content of the root.
	    // This method can be overridden to optimize rendering,
	    // or to render in a non standard way.
	    //
	    // For example, using `innerHTML` instead of `$el.html`
	    //
	    // ```js
	    // attachElContent: function(html) {
	    //   this.el.innerHTML = html;
	    //   return this;
	    // }
	    // ```
	    attachElContent: function(html) {
	      this.$el.html(html);
	  
	      return this;
	    },
	  
	    // You might need to override this if you've overridden attachHtml
	    attachBuffer: function(compositeView, buffer) {
	      var $container = this.getChildViewContainer(compositeView);
	      $container.append(buffer);
	    },
	  
	    // Internal method. Append a view to the end of the $el.
	    // Overidden from CollectionView to ensure view is appended to
	    // childViewContainer
	    _insertAfter: function(childView) {
	      var $container = this.getChildViewContainer(this, childView);
	      $container.append(childView.el);
	    },
	  
	    // Internal method. Append reordered childView'.
	    // Overidden from CollectionView to ensure reordered views
	    // are appended to childViewContainer
	    _appendReorderedChildren: function(children) {
	      var $container = this.getChildViewContainer(this);
	      $container.append(children);
	    },
	  
	    // Internal method to ensure an `$childViewContainer` exists, for the
	    // `attachHtml` method to use.
	    getChildViewContainer: function(containerView, childView) {
	      if (!!containerView.$childViewContainer) {
	        return containerView.$childViewContainer;
	      }
	  
	      var container;
	      var childViewContainer = Marionette.getOption(containerView, 'childViewContainer');
	      if (childViewContainer) {
	  
	        var selector = Marionette._getValue(childViewContainer, containerView);
	  
	        if (selector.charAt(0) === '@' && containerView.ui) {
	          container = containerView.ui[selector.substr(4)];
	        } else {
	          container = containerView.$(selector);
	        }
	  
	        if (container.length <= 0) {
	          throw new Marionette.Error({
	            name: 'ChildViewContainerMissingError',
	            message: 'The specified "childViewContainer" was not found: ' + containerView.childViewContainer
	          });
	        }
	  
	      } else {
	        container = containerView.$el;
	      }
	  
	      containerView.$childViewContainer = container;
	      return container;
	    },
	  
	    // Internal method to reset the `$childViewContainer` on render
	    resetChildViewContainer: function() {
	      if (this.$childViewContainer) {
	        this.$childViewContainer = undefined;
	      }
	    }
	  });
	  
	  // Layout View
	  // -----------
	  
	  // Used for managing application layoutViews, nested layoutViews and
	  // multiple regions within an application or sub-application.
	  //
	  // A specialized view class that renders an area of HTML and then
	  // attaches `Region` instances to the specified `regions`.
	  // Used for composite view management and sub-application areas.
	  Marionette.LayoutView = Marionette.ItemView.extend({
	    regionClass: Marionette.Region,
	  
	    options: {
	      destroyImmediate: false
	    },
	  
	    // used as the prefix for child view events
	    // that are forwarded through the layoutview
	    childViewEventPrefix: 'childview',
	  
	    // Ensure the regions are available when the `initialize` method
	    // is called.
	    constructor: function(options) {
	      options = options || {};
	  
	      this._firstRender = true;
	      this._initializeRegions(options);
	  
	      Marionette.ItemView.call(this, options);
	    },
	  
	    // LayoutView's render will use the existing region objects the
	    // first time it is called. Subsequent calls will destroy the
	    // views that the regions are showing and then reset the `el`
	    // for the regions to the newly rendered DOM elements.
	    render: function() {
	      this._ensureViewIsIntact();
	  
	      if (this._firstRender) {
	        // if this is the first render, don't do anything to
	        // reset the regions
	        this._firstRender = false;
	      } else {
	        // If this is not the first render call, then we need to
	        // re-initialize the `el` for each region
	        this._reInitializeRegions();
	      }
	  
	      return Marionette.ItemView.prototype.render.apply(this, arguments);
	    },
	  
	    // Handle destroying regions, and then destroy the view itself.
	    destroy: function() {
	      if (this.isDestroyed) { return this; }
	      // #2134: remove parent element before destroying the child views, so
	      // removing the child views doesn't retrigger repaints
	      if (this.getOption('destroyImmediate') === true) {
	        this.$el.remove();
	      }
	      this.regionManager.destroy();
	      return Marionette.ItemView.prototype.destroy.apply(this, arguments);
	    },
	  
	    showChildView: function(regionName, view, options) {
	      var region = this.getRegion(regionName);
	      return region.show.apply(region, _.rest(arguments));
	    },
	  
	    getChildView: function(regionName) {
	      return this.getRegion(regionName).currentView;
	    },
	  
	    // Add a single region, by name, to the layoutView
	    addRegion: function(name, definition) {
	      var regions = {};
	      regions[name] = definition;
	      return this._buildRegions(regions)[name];
	    },
	  
	    // Add multiple regions as a {name: definition, name2: def2} object literal
	    addRegions: function(regions) {
	      this.regions = _.extend({}, this.regions, regions);
	      return this._buildRegions(regions);
	    },
	  
	    // Remove a single region from the LayoutView, by name
	    removeRegion: function(name) {
	      delete this.regions[name];
	      return this.regionManager.removeRegion(name);
	    },
	  
	    // Provides alternative access to regions
	    // Accepts the region name
	    // getRegion('main')
	    getRegion: function(region) {
	      return this.regionManager.get(region);
	    },
	  
	    // Get all regions
	    getRegions: function() {
	      return this.regionManager.getRegions();
	    },
	  
	    // internal method to build regions
	    _buildRegions: function(regions) {
	      var defaults = {
	        regionClass: this.getOption('regionClass'),
	        parentEl: _.partial(_.result, this, 'el')
	      };
	  
	      return this.regionManager.addRegions(regions, defaults);
	    },
	  
	    // Internal method to initialize the regions that have been defined in a
	    // `regions` attribute on this layoutView.
	    _initializeRegions: function(options) {
	      var regions;
	      this._initRegionManager();
	  
	      regions = Marionette._getValue(this.regions, this, [options]) || {};
	  
	      // Enable users to define `regions` as instance options.
	      var regionOptions = this.getOption.call(options, 'regions');
	  
	      // enable region options to be a function
	      regionOptions = Marionette._getValue(regionOptions, this, [options]);
	  
	      _.extend(regions, regionOptions);
	  
	      // Normalize region selectors hash to allow
	      // a user to use the @ui. syntax.
	      regions = this.normalizeUIValues(regions, ['selector', 'el']);
	  
	      this.addRegions(regions);
	    },
	  
	    // Internal method to re-initialize all of the regions by updating the `el` that
	    // they point to
	    _reInitializeRegions: function() {
	      this.regionManager.invoke('reset');
	    },
	  
	    // Enable easy overriding of the default `RegionManager`
	    // for customized region interactions and business specific
	    // view logic for better control over single regions.
	    getRegionManager: function() {
	      return new Marionette.RegionManager();
	    },
	  
	    // Internal method to initialize the region manager
	    // and all regions in it
	    _initRegionManager: function() {
	      this.regionManager = this.getRegionManager();
	      this.regionManager._parent = this;
	  
	      this.listenTo(this.regionManager, 'before:add:region', function(name) {
	        this.triggerMethod('before:add:region', name);
	      });
	  
	      this.listenTo(this.regionManager, 'add:region', function(name, region) {
	        this[name] = region;
	        this.triggerMethod('add:region', name, region);
	      });
	  
	      this.listenTo(this.regionManager, 'before:remove:region', function(name) {
	        this.triggerMethod('before:remove:region', name);
	      });
	  
	      this.listenTo(this.regionManager, 'remove:region', function(name, region) {
	        delete this[name];
	        this.triggerMethod('remove:region', name, region);
	      });
	    },
	  
	    _getImmediateChildren: function() {
	      return _.chain(this.regionManager.getRegions())
	        .pluck('currentView')
	        .compact()
	        .value();
	    }
	  });
	  

	  // Behavior
	  // --------
	  
	  // A Behavior is an isolated set of DOM /
	  // user interactions that can be mixed into any View.
	  // Behaviors allow you to blackbox View specific interactions
	  // into portable logical chunks, keeping your views simple and your code DRY.
	  
	  Marionette.Behavior = Marionette.Object.extend({
	    constructor: function(options, view) {
	      // Setup reference to the view.
	      // this comes in handle when a behavior
	      // wants to directly talk up the chain
	      // to the view.
	      this.view = view;
	      this.defaults = _.result(this, 'defaults') || {};
	      this.options  = _.extend({}, this.defaults, options);
	      // Construct an internal UI hash using
	      // the views UI hash and then the behaviors UI hash.
	      // This allows the user to use UI hash elements
	      // defined in the parent view as well as those
	      // defined in the given behavior.
	      this.ui = _.extend({}, _.result(view, 'ui'), _.result(this, 'ui'));
	  
	      Marionette.Object.apply(this, arguments);
	    },
	  
	    // proxy behavior $ method to the view
	    // this is useful for doing jquery DOM lookups
	    // scoped to behaviors view.
	    $: function() {
	      return this.view.$.apply(this.view, arguments);
	    },
	  
	    // Stops the behavior from listening to events.
	    // Overrides Object#destroy to prevent additional events from being triggered.
	    destroy: function() {
	      this.stopListening();
	  
	      return this;
	    },
	  
	    proxyViewProperties: function(view) {
	      this.$el = view.$el;
	      this.el = view.el;
	    }
	  });
	  
	  /* jshint maxlen: 143 */
	  // Behaviors
	  // ---------
	  
	  // Behaviors is a utility class that takes care of
	  // gluing your behavior instances to their given View.
	  // The most important part of this class is that you
	  // **MUST** override the class level behaviorsLookup
	  // method for things to work properly.
	  
	  Marionette.Behaviors = (function(Marionette, _) {
	    // Borrow event splitter from Backbone
	    var delegateEventSplitter = /^(\S+)\s*(.*)$/;
	  
	    function Behaviors(view, behaviors) {
	  
	      if (!_.isObject(view.behaviors)) {
	        return {};
	      }
	  
	      // Behaviors defined on a view can be a flat object literal
	      // or it can be a function that returns an object.
	      behaviors = Behaviors.parseBehaviors(view, behaviors || _.result(view, 'behaviors'));
	  
	      // Wraps several of the view's methods
	      // calling the methods first on each behavior
	      // and then eventually calling the method on the view.
	      Behaviors.wrap(view, behaviors, _.keys(methods));
	      return behaviors;
	    }
	  
	    var methods = {
	      behaviorTriggers: function(behaviorTriggers, behaviors) {
	        var triggerBuilder = new BehaviorTriggersBuilder(this, behaviors);
	        return triggerBuilder.buildBehaviorTriggers();
	      },
	  
	      behaviorEvents: function(behaviorEvents, behaviors) {
	        var _behaviorsEvents = {};
	  
	        _.each(behaviors, function(b, i) {
	          var _events = {};
	          var behaviorEvents = _.clone(_.result(b, 'events')) || {};
	  
	          // Normalize behavior events hash to allow
	          // a user to use the @ui. syntax.
	          behaviorEvents = Marionette.normalizeUIKeys(behaviorEvents, getBehaviorsUI(b));
	  
	          var j = 0;
	          _.each(behaviorEvents, function(behaviour, key) {
	            var match     = key.match(delegateEventSplitter);
	  
	            // Set event name to be namespaced using the view cid,
	            // the behavior index, and the behavior event index
	            // to generate a non colliding event namespace
	            // http://api.jquery.com/event.namespace/
	            var eventName = match[1] + '.' + [this.cid, i, j++, ' '].join('');
	            var selector  = match[2];
	  
	            var eventKey  = eventName + selector;
	            var handler   = _.isFunction(behaviour) ? behaviour : b[behaviour];
	  
	            _events[eventKey] = _.bind(handler, b);
	          }, this);
	  
	          _behaviorsEvents = _.extend(_behaviorsEvents, _events);
	        }, this);
	  
	        return _behaviorsEvents;
	      }
	    };
	  
	    _.extend(Behaviors, {
	  
	      // Placeholder method to be extended by the user.
	      // The method should define the object that stores the behaviors.
	      // i.e.
	      //
	      // ```js
	      // Marionette.Behaviors.behaviorsLookup: function() {
	      //   return App.Behaviors
	      // }
	      // ```
	      behaviorsLookup: function() {
	        throw new Marionette.Error({
	          message: 'You must define where your behaviors are stored.',
	          url: 'marionette.behaviors.html#behaviorslookup'
	        });
	      },
	  
	      // Takes care of getting the behavior class
	      // given options and a key.
	      // If a user passes in options.behaviorClass
	      // default to using that. Otherwise delegate
	      // the lookup to the users `behaviorsLookup` implementation.
	      getBehaviorClass: function(options, key) {
	        if (options.behaviorClass) {
	          return options.behaviorClass;
	        }
	  
	        // Get behavior class can be either a flat object or a method
	        return Marionette._getValue(Behaviors.behaviorsLookup, this, [options, key])[key];
	      },
	  
	      // Iterate over the behaviors object, for each behavior
	      // instantiate it and get its grouped behaviors.
	      parseBehaviors: function(view, behaviors) {
	        return _.chain(behaviors).map(function(options, key) {
	          var BehaviorClass = Behaviors.getBehaviorClass(options, key);
	  
	          var behavior = new BehaviorClass(options, view);
	          var nestedBehaviors = Behaviors.parseBehaviors(view, _.result(behavior, 'behaviors'));
	  
	          return [behavior].concat(nestedBehaviors);
	        }).flatten().value();
	      },
	  
	      // Wrap view internal methods so that they delegate to behaviors. For example,
	      // `onDestroy` should trigger destroy on all of the behaviors and then destroy itself.
	      // i.e.
	      //
	      // `view.delegateEvents = _.partial(methods.delegateEvents, view.delegateEvents, behaviors);`
	      wrap: function(view, behaviors, methodNames) {
	        _.each(methodNames, function(methodName) {
	          view[methodName] = _.partial(methods[methodName], view[methodName], behaviors);
	        });
	      }
	    });
	  
	    // Class to build handlers for `triggers` on behaviors
	    // for views
	    function BehaviorTriggersBuilder(view, behaviors) {
	      this._view      = view;
	      this._behaviors = behaviors;
	      this._triggers  = {};
	    }
	  
	    _.extend(BehaviorTriggersBuilder.prototype, {
	      // Main method to build the triggers hash with event keys and handlers
	      buildBehaviorTriggers: function() {
	        _.each(this._behaviors, this._buildTriggerHandlersForBehavior, this);
	        return this._triggers;
	      },
	  
	      // Internal method to build all trigger handlers for a given behavior
	      _buildTriggerHandlersForBehavior: function(behavior, i) {
	        var triggersHash = _.clone(_.result(behavior, 'triggers')) || {};
	  
	        triggersHash = Marionette.normalizeUIKeys(triggersHash, getBehaviorsUI(behavior));
	  
	        _.each(triggersHash, _.bind(this._setHandlerForBehavior, this, behavior, i));
	      },
	  
	      // Internal method to create and assign the trigger handler for a given
	      // behavior
	      _setHandlerForBehavior: function(behavior, i, eventName, trigger) {
	        // Unique identifier for the `this._triggers` hash
	        var triggerKey = trigger.replace(/^\S+/, function(triggerName) {
	          return triggerName + '.' + 'behaviortriggers' + i;
	        });
	  
	        this._triggers[triggerKey] = this._view._buildViewTrigger(eventName);
	      }
	    });
	  
	    function getBehaviorsUI(behavior) {
	      return behavior._uiBindings || behavior.ui;
	    }
	  
	    return Behaviors;
	  
	  })(Marionette, _);
	  

	  // App Router
	  // ----------
	  
	  // Reduce the boilerplate code of handling route events
	  // and then calling a single method on another object.
	  // Have your routers configured to call the method on
	  // your object, directly.
	  //
	  // Configure an AppRouter with `appRoutes`.
	  //
	  // App routers can only take one `controller` object.
	  // It is recommended that you divide your controller
	  // objects in to smaller pieces of related functionality
	  // and have multiple routers / controllers, instead of
	  // just one giant router and controller.
	  //
	  // You can also add standard routes to an AppRouter.
	  
	  Marionette.AppRouter = Backbone.Router.extend({
	  
	    constructor: function(options) {
	      this.options = options || {};
	  
	      Backbone.Router.apply(this, arguments);
	  
	      var appRoutes = this.getOption('appRoutes');
	      var controller = this._getController();
	      this.processAppRoutes(controller, appRoutes);
	      this.on('route', this._processOnRoute, this);
	    },
	  
	    // Similar to route method on a Backbone Router but
	    // method is called on the controller
	    appRoute: function(route, methodName) {
	      var controller = this._getController();
	      this._addAppRoute(controller, route, methodName);
	    },
	  
	    // process the route event and trigger the onRoute
	    // method call, if it exists
	    _processOnRoute: function(routeName, routeArgs) {
	      // make sure an onRoute before trying to call it
	      if (_.isFunction(this.onRoute)) {
	        // find the path that matches the current route
	        var routePath = _.invert(this.getOption('appRoutes'))[routeName];
	        this.onRoute(routeName, routePath, routeArgs);
	      }
	    },
	  
	    // Internal method to process the `appRoutes` for the
	    // router, and turn them in to routes that trigger the
	    // specified method on the specified `controller`.
	    processAppRoutes: function(controller, appRoutes) {
	      if (!appRoutes) { return; }
	  
	      var routeNames = _.keys(appRoutes).reverse(); // Backbone requires reverted order of routes
	  
	      _.each(routeNames, function(route) {
	        this._addAppRoute(controller, route, appRoutes[route]);
	      }, this);
	    },
	  
	    _getController: function() {
	      return this.getOption('controller');
	    },
	  
	    _addAppRoute: function(controller, route, methodName) {
	      var method = controller[methodName];
	  
	      if (!method) {
	        throw new Marionette.Error('Method "' + methodName + '" was not found on the controller');
	      }
	  
	      this.route(route, methodName, _.bind(method, controller));
	    },
	  
	    mergeOptions: Marionette.mergeOptions,
	  
	    // Proxy `getOption` to enable getting options from this or this.options by name.
	    getOption: Marionette.proxyGetOption,
	  
	    triggerMethod: Marionette.triggerMethod,
	  
	    bindEntityEvents: Marionette.proxyBindEntityEvents,
	  
	    unbindEntityEvents: Marionette.proxyUnbindEntityEvents
	  });
	  
	  // Application
	  // -----------
	  
	  // Contain and manage the composite application as a whole.
	  // Stores and starts up `Region` objects, includes an
	  // event aggregator as `app.vent`
	  Marionette.Application = Marionette.Object.extend({
	    constructor: function(options) {
	      this._initializeRegions(options);
	      this._initCallbacks = new Marionette.Callbacks();
	      this.submodules = {};
	      _.extend(this, options);
	      this._initChannel();
	      Marionette.Object.apply(this, arguments);
	    },
	  
	    // Command execution, facilitated by Backbone.Wreqr.Commands
	    execute: function() {
	      this.commands.execute.apply(this.commands, arguments);
	    },
	  
	    // Request/response, facilitated by Backbone.Wreqr.RequestResponse
	    request: function() {
	      return this.reqres.request.apply(this.reqres, arguments);
	    },
	  
	    // Add an initializer that is either run at when the `start`
	    // method is called, or run immediately if added after `start`
	    // has already been called.
	    addInitializer: function(initializer) {
	      this._initCallbacks.add(initializer);
	    },
	  
	    // kick off all of the application's processes.
	    // initializes all of the regions that have been added
	    // to the app, and runs all of the initializer functions
	    start: function(options) {
	      this.triggerMethod('before:start', options);
	      this._initCallbacks.run(options, this);
	      this.triggerMethod('start', options);
	    },
	  
	    // Add regions to your app.
	    // Accepts a hash of named strings or Region objects
	    // addRegions({something: "#someRegion"})
	    // addRegions({something: Region.extend({el: "#someRegion"}) });
	    addRegions: function(regions) {
	      return this._regionManager.addRegions(regions);
	    },
	  
	    // Empty all regions in the app, without removing them
	    emptyRegions: function() {
	      return this._regionManager.emptyRegions();
	    },
	  
	    // Removes a region from your app, by name
	    // Accepts the regions name
	    // removeRegion('myRegion')
	    removeRegion: function(region) {
	      return this._regionManager.removeRegion(region);
	    },
	  
	    // Provides alternative access to regions
	    // Accepts the region name
	    // getRegion('main')
	    getRegion: function(region) {
	      return this._regionManager.get(region);
	    },
	  
	    // Get all the regions from the region manager
	    getRegions: function() {
	      return this._regionManager.getRegions();
	    },
	  
	    // Create a module, attached to the application
	    module: function(moduleNames, moduleDefinition) {
	  
	      // Overwrite the module class if the user specifies one
	      var ModuleClass = Marionette.Module.getClass(moduleDefinition);
	  
	      var args = _.toArray(arguments);
	      args.unshift(this);
	  
	      // see the Marionette.Module object for more information
	      return ModuleClass.create.apply(ModuleClass, args);
	    },
	  
	    // Enable easy overriding of the default `RegionManager`
	    // for customized region interactions and business-specific
	    // view logic for better control over single regions.
	    getRegionManager: function() {
	      return new Marionette.RegionManager();
	    },
	  
	    // Internal method to initialize the regions that have been defined in a
	    // `regions` attribute on the application instance
	    _initializeRegions: function(options) {
	      var regions = _.isFunction(this.regions) ? this.regions(options) : this.regions || {};
	  
	      this._initRegionManager();
	  
	      // Enable users to define `regions` in instance options.
	      var optionRegions = Marionette.getOption(options, 'regions');
	  
	      // Enable region options to be a function
	      if (_.isFunction(optionRegions)) {
	        optionRegions = optionRegions.call(this, options);
	      }
	  
	      // Overwrite current regions with those passed in options
	      _.extend(regions, optionRegions);
	  
	      this.addRegions(regions);
	  
	      return this;
	    },
	  
	    // Internal method to set up the region manager
	    _initRegionManager: function() {
	      this._regionManager = this.getRegionManager();
	      this._regionManager._parent = this;
	  
	      this.listenTo(this._regionManager, 'before:add:region', function() {
	        Marionette._triggerMethod(this, 'before:add:region', arguments);
	      });
	  
	      this.listenTo(this._regionManager, 'add:region', function(name, region) {
	        this[name] = region;
	        Marionette._triggerMethod(this, 'add:region', arguments);
	      });
	  
	      this.listenTo(this._regionManager, 'before:remove:region', function() {
	        Marionette._triggerMethod(this, 'before:remove:region', arguments);
	      });
	  
	      this.listenTo(this._regionManager, 'remove:region', function(name) {
	        delete this[name];
	        Marionette._triggerMethod(this, 'remove:region', arguments);
	      });
	    },
	  
	    // Internal method to setup the Wreqr.radio channel
	    _initChannel: function() {
	      this.channelName = _.result(this, 'channelName') || 'global';
	      this.channel = _.result(this, 'channel') || Backbone.Wreqr.radio.channel(this.channelName);
	      this.vent = _.result(this, 'vent') || this.channel.vent;
	      this.commands = _.result(this, 'commands') || this.channel.commands;
	      this.reqres = _.result(this, 'reqres') || this.channel.reqres;
	    }
	  });
	  
	  /* jshint maxparams: 9 */
	  
	  // Module
	  // ------
	  
	  // A simple module system, used to create privacy and encapsulation in
	  // Marionette applications
	  Marionette.Module = function(moduleName, app, options) {
	    this.moduleName = moduleName;
	    this.options = _.extend({}, this.options, options);
	    // Allow for a user to overide the initialize
	    // for a given module instance.
	    this.initialize = options.initialize || this.initialize;
	  
	    // Set up an internal store for sub-modules.
	    this.submodules = {};
	  
	    this._setupInitializersAndFinalizers();
	  
	    // Set an internal reference to the app
	    // within a module.
	    this.app = app;
	  
	    if (_.isFunction(this.initialize)) {
	      this.initialize(moduleName, app, this.options);
	    }
	  };
	  
	  Marionette.Module.extend = Marionette.extend;
	  
	  // Extend the Module prototype with events / listenTo, so that the module
	  // can be used as an event aggregator or pub/sub.
	  _.extend(Marionette.Module.prototype, Backbone.Events, {
	  
	    // By default modules start with their parents.
	    startWithParent: true,
	  
	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic when extending Marionette.Module.
	    initialize: function() {},
	  
	    // Initializer for a specific module. Initializers are run when the
	    // module's `start` method is called.
	    addInitializer: function(callback) {
	      this._initializerCallbacks.add(callback);
	    },
	  
	    // Finalizers are run when a module is stopped. They are used to teardown
	    // and finalize any variables, references, events and other code that the
	    // module had set up.
	    addFinalizer: function(callback) {
	      this._finalizerCallbacks.add(callback);
	    },
	  
	    // Start the module, and run all of its initializers
	    start: function(options) {
	      // Prevent re-starting a module that is already started
	      if (this._isInitialized) { return; }
	  
	      // start the sub-modules (depth-first hierarchy)
	      _.each(this.submodules, function(mod) {
	        // check to see if we should start the sub-module with this parent
	        if (mod.startWithParent) {
	          mod.start(options);
	        }
	      });
	  
	      // run the callbacks to "start" the current module
	      this.triggerMethod('before:start', options);
	  
	      this._initializerCallbacks.run(options, this);
	      this._isInitialized = true;
	  
	      this.triggerMethod('start', options);
	    },
	  
	    // Stop this module by running its finalizers and then stop all of
	    // the sub-modules for this module
	    stop: function() {
	      // if we are not initialized, don't bother finalizing
	      if (!this._isInitialized) { return; }
	      this._isInitialized = false;
	  
	      this.triggerMethod('before:stop');
	  
	      // stop the sub-modules; depth-first, to make sure the
	      // sub-modules are stopped / finalized before parents
	      _.invoke(this.submodules, 'stop');
	  
	      // run the finalizers
	      this._finalizerCallbacks.run(undefined, this);
	  
	      // reset the initializers and finalizers
	      this._initializerCallbacks.reset();
	      this._finalizerCallbacks.reset();
	  
	      this.triggerMethod('stop');
	    },
	  
	    // Configure the module with a definition function and any custom args
	    // that are to be passed in to the definition function
	    addDefinition: function(moduleDefinition, customArgs) {
	      this._runModuleDefinition(moduleDefinition, customArgs);
	    },
	  
	    // Internal method: run the module definition function with the correct
	    // arguments
	    _runModuleDefinition: function(definition, customArgs) {
	      // If there is no definition short circut the method.
	      if (!definition) { return; }
	  
	      // build the correct list of arguments for the module definition
	      var args = _.flatten([
	        this,
	        this.app,
	        Backbone,
	        Marionette,
	        Backbone.$, _,
	        customArgs
	      ]);
	  
	      definition.apply(this, args);
	    },
	  
	    // Internal method: set up new copies of initializers and finalizers.
	    // Calling this method will wipe out all existing initializers and
	    // finalizers.
	    _setupInitializersAndFinalizers: function() {
	      this._initializerCallbacks = new Marionette.Callbacks();
	      this._finalizerCallbacks = new Marionette.Callbacks();
	    },
	  
	    // import the `triggerMethod` to trigger events with corresponding
	    // methods if the method exists
	    triggerMethod: Marionette.triggerMethod
	  });
	  
	  // Class methods to create modules
	  _.extend(Marionette.Module, {
	  
	    // Create a module, hanging off the app parameter as the parent object.
	    create: function(app, moduleNames, moduleDefinition) {
	      var module = app;
	  
	      // get the custom args passed in after the module definition and
	      // get rid of the module name and definition function
	      var customArgs = _.drop(arguments, 3);
	  
	      // Split the module names and get the number of submodules.
	      // i.e. an example module name of `Doge.Wow.Amaze` would
	      // then have the potential for 3 module definitions.
	      moduleNames = moduleNames.split('.');
	      var length = moduleNames.length;
	  
	      // store the module definition for the last module in the chain
	      var moduleDefinitions = [];
	      moduleDefinitions[length - 1] = moduleDefinition;
	  
	      // Loop through all the parts of the module definition
	      _.each(moduleNames, function(moduleName, i) {
	        var parentModule = module;
	        module = this._getModule(parentModule, moduleName, app, moduleDefinition);
	        this._addModuleDefinition(parentModule, module, moduleDefinitions[i], customArgs);
	      }, this);
	  
	      // Return the last module in the definition chain
	      return module;
	    },
	  
	    _getModule: function(parentModule, moduleName, app, def, args) {
	      var options = _.extend({}, def);
	      var ModuleClass = this.getClass(def);
	  
	      // Get an existing module of this name if we have one
	      var module = parentModule[moduleName];
	  
	      if (!module) {
	        // Create a new module if we don't have one
	        module = new ModuleClass(moduleName, app, options);
	        parentModule[moduleName] = module;
	        // store the module on the parent
	        parentModule.submodules[moduleName] = module;
	      }
	  
	      return module;
	    },
	  
	    // ## Module Classes
	    //
	    // Module classes can be used as an alternative to the define pattern.
	    // The extend function of a Module is identical to the extend functions
	    // on other Backbone and Marionette classes.
	    // This allows module lifecyle events like `onStart` and `onStop` to be called directly.
	    getClass: function(moduleDefinition) {
	      var ModuleClass = Marionette.Module;
	  
	      if (!moduleDefinition) {
	        return ModuleClass;
	      }
	  
	      // If all of the module's functionality is defined inside its class,
	      // then the class can be passed in directly. `MyApp.module("Foo", FooModule)`.
	      if (moduleDefinition.prototype instanceof ModuleClass) {
	        return moduleDefinition;
	      }
	  
	      return moduleDefinition.moduleClass || ModuleClass;
	    },
	  
	    // Add the module definition and add a startWithParent initializer function.
	    // This is complicated because module definitions are heavily overloaded
	    // and support an anonymous function, module class, or options object
	    _addModuleDefinition: function(parentModule, module, def, args) {
	      var fn = this._getDefine(def);
	      var startWithParent = this._getStartWithParent(def, module);
	  
	      if (fn) {
	        module.addDefinition(fn, args);
	      }
	  
	      this._addStartWithParent(parentModule, module, startWithParent);
	    },
	  
	    _getStartWithParent: function(def, module) {
	      var swp;
	  
	      if (_.isFunction(def) && (def.prototype instanceof Marionette.Module)) {
	        swp = module.constructor.prototype.startWithParent;
	        return _.isUndefined(swp) ? true : swp;
	      }
	  
	      if (_.isObject(def)) {
	        swp = def.startWithParent;
	        return _.isUndefined(swp) ? true : swp;
	      }
	  
	      return true;
	    },
	  
	    _getDefine: function(def) {
	      if (_.isFunction(def) && !(def.prototype instanceof Marionette.Module)) {
	        return def;
	      }
	  
	      if (_.isObject(def)) {
	        return def.define;
	      }
	  
	      return null;
	    },
	  
	    _addStartWithParent: function(parentModule, module, startWithParent) {
	      module.startWithParent = module.startWithParent && startWithParent;
	  
	      if (!module.startWithParent || !!module.startWithParentIsConfigured) {
	        return;
	      }
	  
	      module.startWithParentIsConfigured = true;
	  
	      parentModule.addInitializer(function(options) {
	        if (module.startWithParent) {
	          module.start(options);
	        }
	      });
	    }
	  });
	  

	  return Marionette;
	}));



/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	exports.Index = __webpack_require__(12);

	exports.Main = __webpack_require__(16);


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var Marionette, View, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Marionette = __webpack_require__(10);

	viewTemplate = __webpack_require__(13);

	View = (function(superClass) {
	  extend(View, superClass);

	  function View() {
	    return View.__super__.constructor.apply(this, arguments);
	  }

	  View.prototype.template = viewTemplate;

	  return View;

	})(Marionette.ItemView);

	module.exports = View;


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div id=\"p1\" data-role=\"page\"></div><div class=\"col-sm-12\"><nav class=\"navbar navbar-default navbar-fixed-top\"><div class=\"container-fluid\"><div class=\"navbar-header\"><span id=\"index-navbar-brand\" href=\"#\" class=\"navbar-brand\">App</span></div></div></nav></div>");;return buf.join("");
	}

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Merge two attribute objects giving precedence
	 * to values in object `b`. Classes are special-cased
	 * allowing for arrays and merging/joining appropriately
	 * resulting in a string.
	 *
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object} a
	 * @api private
	 */

	exports.merge = function merge(a, b) {
	  if (arguments.length === 1) {
	    var attrs = a[0];
	    for (var i = 1; i < a.length; i++) {
	      attrs = merge(attrs, a[i]);
	    }
	    return attrs;
	  }
	  var ac = a['class'];
	  var bc = b['class'];

	  if (ac || bc) {
	    ac = ac || [];
	    bc = bc || [];
	    if (!Array.isArray(ac)) ac = [ac];
	    if (!Array.isArray(bc)) bc = [bc];
	    a['class'] = ac.concat(bc).filter(nulls);
	  }

	  for (var key in b) {
	    if (key != 'class') {
	      a[key] = b[key];
	    }
	  }

	  return a;
	};

	/**
	 * Filter null `val`s.
	 *
	 * @param {*} val
	 * @return {Boolean}
	 * @api private
	 */

	function nulls(val) {
	  return val != null && val !== '';
	}

	/**
	 * join array as classes.
	 *
	 * @param {*} val
	 * @return {String}
	 */
	exports.joinClasses = joinClasses;
	function joinClasses(val) {
	  return (Array.isArray(val) ? val.map(joinClasses) :
	    (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :
	    [val]).filter(nulls).join(' ');
	}

	/**
	 * Render the given classes.
	 *
	 * @param {Array} classes
	 * @param {Array.<Boolean>} escaped
	 * @return {String}
	 */
	exports.cls = function cls(classes, escaped) {
	  var buf = [];
	  for (var i = 0; i < classes.length; i++) {
	    if (escaped && escaped[i]) {
	      buf.push(exports.escape(joinClasses([classes[i]])));
	    } else {
	      buf.push(joinClasses(classes[i]));
	    }
	  }
	  var text = joinClasses(buf);
	  if (text.length) {
	    return ' class="' + text + '"';
	  } else {
	    return '';
	  }
	};


	exports.style = function (val) {
	  if (val && typeof val === 'object') {
	    return Object.keys(val).map(function (style) {
	      return style + ':' + val[style];
	    }).join(';');
	  } else {
	    return val;
	  }
	};
	/**
	 * Render the given attribute.
	 *
	 * @param {String} key
	 * @param {String} val
	 * @param {Boolean} escaped
	 * @param {Boolean} terse
	 * @return {String}
	 */
	exports.attr = function attr(key, val, escaped, terse) {
	  if (key === 'style') {
	    val = exports.style(val);
	  }
	  if ('boolean' == typeof val || null == val) {
	    if (val) {
	      return ' ' + (terse ? key : key + '="' + key + '"');
	    } else {
	      return '';
	    }
	  } else if (0 == key.indexOf('data') && 'string' != typeof val) {
	    if (JSON.stringify(val).indexOf('&') !== -1) {
	      console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +
	                   'will be escaped to `&amp;`');
	    };
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will eliminate the double quotes around dates in ' +
	                   'ISO form after 2.0.0');
	    }
	    return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
	  } else if (escaped) {
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will stringify dates in ISO form after 2.0.0');
	    }
	    return ' ' + key + '="' + exports.escape(val) + '"';
	  } else {
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will stringify dates in ISO form after 2.0.0');
	    }
	    return ' ' + key + '="' + val + '"';
	  }
	};

	/**
	 * Render the given attributes object.
	 *
	 * @param {Object} obj
	 * @param {Object} escaped
	 * @return {String}
	 */
	exports.attrs = function attrs(obj, terse){
	  var buf = [];

	  var keys = Object.keys(obj);

	  if (keys.length) {
	    for (var i = 0; i < keys.length; ++i) {
	      var key = keys[i]
	        , val = obj[key];

	      if ('class' == key) {
	        if (val = joinClasses(val)) {
	          buf.push(' ' + key + '="' + val + '"');
	        }
	      } else {
	        buf.push(exports.attr(key, val, false, terse));
	      }
	    }
	  }

	  return buf.join('');
	};

	/**
	 * Escape the given string of `html`.
	 *
	 * @param {String} html
	 * @return {String}
	 * @api private
	 */

	var jade_encode_html_rules = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;'
	};
	var jade_match_html = /[&<>"]/g;

	function jade_encode_char(c) {
	  return jade_encode_html_rules[c] || c;
	}

	exports.escape = jade_escape;
	function jade_escape(html){
	  var result = String(html).replace(jade_match_html, jade_encode_char);
	  if (result === '' + html) return html;
	  else return result;
	};

	/**
	 * Re-throw the given `err` in context to the
	 * the jade in `filename` at the given `lineno`.
	 *
	 * @param {Error} err
	 * @param {String} filename
	 * @param {String} lineno
	 * @api private
	 */

	exports.rethrow = function rethrow(err, filename, lineno, str){
	  if (!(err instanceof Error)) throw err;
	  if ((typeof window != 'undefined' || !filename) && !str) {
	    err.message += ' on line ' + lineno;
	    throw err;
	  }
	  try {
	    str = str || __webpack_require__(15).readFileSync(filename, 'utf8')
	  } catch (ex) {
	    rethrow(err, null, lineno)
	  }
	  var context = 3
	    , lines = str.split('\n')
	    , start = Math.max(lineno - context, 0)
	    , end = Math.min(lines.length, lineno + context);

	  // Error context
	  var context = lines.slice(start, end).map(function(line, i){
	    var curr = i + start + 1;
	    return (curr == lineno ? '  > ' : '    ')
	      + curr
	      + '| '
	      + line;
	  }).join('\n');

	  // Alter exception message
	  err.path = filename;
	  err.message = (filename || 'Jade') + ':' + lineno
	    + '\n' + context + '\n\n' + err.message;
	  throw err;
	};

	exports.DebugItem = function DebugItem(lineno, filename) {
	  this.lineno = lineno;
	  this.filename = filename;
	}


/***/ },
/* 15 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var $, Backbone, Marionette, Radio, View, _, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	_ = __webpack_require__(3);

	$ = __webpack_require__(2);

	Backbone = __webpack_require__(8);

	Radio = __webpack_require__(17);

	Marionette = __webpack_require__(10);

	viewTemplate = __webpack_require__(18);

	__webpack_require__(19);

	View = (function(superClass) {
	  extend(View, superClass);

	  View.prototype.template = viewTemplate;

	  View.prototype.ui = {
	    brand: '#navbar-brand',
	    home: '.nav-home',
	    profile: '.nav-profile',
	    contacts: '.nav-contacts',
	    exercise: '.nav-exercise',
	    strength: '.nav-strength',
	    menu: '#my-menu'
	  };

	  View.prototype.bindings = {
	    '#nav-username': {
	      observe: 'firstname',
	      onGet: function(value) {
	        return value.toString().toUpperCase();
	      }
	    }
	  };

	  View.prototype.events = {
	    'click @ui.brand': function(event) {
	      event.preventDefault();
	      $("#my-menu").trigger("open.mm");
	    },
	    'click @ui.home': function() {
	      this.channel.request('home');
	    },
	    'click @ui.strength': function() {
	      this.channel.request('strength');
	    }
	  };

	  function View() {
	    View.__super__.constructor.apply(this, arguments);
	    this.channel = Backbone.Radio.channel('root');
	  }

	  View.prototype.onRender = function() {
	    this.stickit();
	  };

	  View.prototype.onShow = function() {
	    this.ui.menu.mmenu({
	      offCanvas: {
	        zposition: "front"
	      },
	      onClick: {
	        close: false
	      },
	      header: true,
	      footer: {
	        add: true,
	        content: "(c) 2015 WebApp. All rights reserved"
	      }
	    });
	    this.ui.profile.on('click', (function(_this) {
	      return function() {
	        _this.channel.request('profile');
	      };
	    })(this));
	    this.ui.contacts.on('click', (function(_this) {
	      return function() {
	        _this.channel.request('home');
	      };
	    })(this));
	    this.ui.exercise.on('click', (function(_this) {
	      return function() {
	        _this.channel.request('exercise');
	      };
	    })(this));
	  };

	  return View;

	})(Marionette.ItemView);

	module.exports = View;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var Backbone = __webpack_require__(8);

	// Backbone.Radio v1.0.2
	(function (global, factory) {
	   true ? module.exports = factory(__webpack_require__(9), __webpack_require__(8)) : typeof define === "function" && define.amd ? define(["underscore", "backbone"], factory) : global.Backbone.Radio = factory(global._, global.Backbone);
	})(this, function (_, Backbone) {
	  "use strict";

	  var previousRadio = Backbone.Radio;

	  var Radio = Backbone.Radio = {};

	  Radio.VERSION = "1.0.2";

	  // This allows you to run multiple instances of Radio on the same
	  // webapp. After loading the new version, call `noConflict()` to
	  // get a reference to it. At the same time the old version will be
	  // returned to Backbone.Radio.
	  Radio.noConflict = function () {
	    Backbone.Radio = previousRadio;
	    return this;
	  };

	  // Whether or not we're in DEBUG mode or not. DEBUG mode helps you
	  // get around the issues of lack of warnings when events are mis-typed.
	  Radio.DEBUG = false;

	  // Format debug text.
	  Radio._debugText = function (warning, eventName, channelName) {
	    return warning + (channelName ? " on the " + channelName + " channel" : "") + ": \"" + eventName + "\"";
	  };

	  // This is the method that's called when an unregistered event was called.
	  // By default, it logs warning to the console. By overriding this you could
	  // make it throw an Error, for instance. This would make firing a nonexistent event
	  // have the same consequence as firing a nonexistent method on an Object.
	  Radio.debugLog = function (warning, eventName, channelName) {
	    if (Radio.DEBUG && console && console.warn) {
	      console.warn(Radio._debugText(warning, eventName, channelName));
	    }
	  };

	  var eventSplitter = /\s+/;

	  // An internal method used to handle Radio's method overloading for Requests.
	  // It's borrowed from Backbone.Events. It differs from Backbone's overload
	  // API (which is used in Backbone.Events) in that it doesn't support space-separated
	  // event names.
	  Radio._eventsApi = function (obj, action, name, rest) {
	    if (!name) {
	      return false;
	    }

	    var results = {};

	    // Handle event maps.
	    if (typeof name === "object") {
	      for (var key in name) {
	        var result = obj[action].apply(obj, [key, name[key]].concat(rest));
	        eventSplitter.test(key) ? _.extend(results, result) : results[key] = result;
	      }
	      return results;
	    }

	    // Handle space separated event names.
	    if (eventSplitter.test(name)) {
	      var names = name.split(eventSplitter);
	      for (var i = 0, l = names.length; i < l; i++) {
	        results[names[i]] = obj[action].apply(obj, [names[i]].concat(rest));
	      }
	      return results;
	    }

	    return false;
	  };

	  // An optimized way to execute callbacks.
	  Radio._callHandler = function (callback, context, args) {
	    var a1 = args[0],
	        a2 = args[1],
	        a3 = args[2];
	    switch (args.length) {
	      case 0:
	        return callback.call(context);
	      case 1:
	        return callback.call(context, a1);
	      case 2:
	        return callback.call(context, a1, a2);
	      case 3:
	        return callback.call(context, a1, a2, a3);
	      default:
	        return callback.apply(context, args);
	    }
	  };

	  // A helper used by `off` methods to the handler from the store
	  function removeHandler(store, name, callback, context) {
	    var event = store[name];
	    if ((!callback || (callback === event.callback || callback === event.callback._callback)) && (!context || context === event.context)) {
	      delete store[name];
	      return true;
	    }
	  }

	  function removeHandlers(store, name, callback, context) {
	    store || (store = {});
	    var names = name ? [name] : _.keys(store);
	    var matched = false;

	    for (var i = 0, length = names.length; i < length; i++) {
	      name = names[i];

	      // If there's no event by this name, log it and continue
	      // with the loop
	      if (!store[name]) {
	        continue;
	      }

	      if (removeHandler(store, name, callback, context)) {
	        matched = true;
	      }
	    }

	    return matched;
	  }

	  /*
	   * tune-in
	   * -------
	   * Get console logs of a channel's activity
	   *
	   */

	  var _logs = {};

	  // This is to produce an identical function in both tuneIn and tuneOut,
	  // so that Backbone.Events unregisters it.
	  function _partial(channelName) {
	    return _logs[channelName] || (_logs[channelName] = _.partial(Radio.log, channelName));
	  }

	  _.extend(Radio, {

	    // Log information about the channel and event
	    log: function log(channelName, eventName) {
	      var args = _.rest(arguments, 2);
	      console.log("[" + channelName + "] \"" + eventName + "\"", args);
	    },

	    // Logs all events on this channel to the console. It sets an
	    // internal value on the channel telling it we're listening,
	    // then sets a listener on the Backbone.Events
	    tuneIn: function tuneIn(channelName) {
	      var channel = Radio.channel(channelName);
	      channel._tunedIn = true;
	      channel.on("all", _partial(channelName));
	      return this;
	    },

	    // Stop logging all of the activities on this channel to the console
	    tuneOut: function tuneOut(channelName) {
	      var channel = Radio.channel(channelName);
	      channel._tunedIn = false;
	      channel.off("all", _partial(channelName));
	      delete _logs[channelName];
	      return this;
	    }
	  });

	  /*
	   * Backbone.Radio.Requests
	   * -----------------------
	   * A messaging system for requesting data.
	   *
	   */

	  function makeCallback(callback) {
	    return _.isFunction(callback) ? callback : function () {
	      return callback;
	    };
	  }

	  Radio.Requests = {

	    // Make a request
	    request: function request(name) {
	      var args = _.rest(arguments);
	      var results = Radio._eventsApi(this, "request", name, args);
	      if (results) {
	        return results;
	      }
	      var channelName = this.channelName;
	      var requests = this._requests;

	      // Check if we should log the request, and if so, do it
	      if (channelName && this._tunedIn) {
	        Radio.log.apply(this, [channelName, name].concat(args));
	      }

	      // If the request isn't handled, log it in DEBUG mode and exit
	      if (requests && (requests[name] || requests["default"])) {
	        var handler = requests[name] || requests["default"];
	        args = requests[name] ? args : arguments;
	        return Radio._callHandler(handler.callback, handler.context, args);
	      } else {
	        Radio.debugLog("An unhandled request was fired", name, channelName);
	      }
	    },

	    // Set up a handler for a request
	    reply: function reply(name, callback, context) {
	      if (Radio._eventsApi(this, "reply", name, [callback, context])) {
	        return this;
	      }

	      this._requests || (this._requests = {});

	      if (this._requests[name]) {
	        Radio.debugLog("A request was overwritten", name, this.channelName);
	      }

	      this._requests[name] = {
	        callback: makeCallback(callback),
	        context: context || this
	      };

	      return this;
	    },

	    // Set up a handler that can only be requested once
	    replyOnce: function replyOnce(name, callback, context) {
	      if (Radio._eventsApi(this, "replyOnce", name, [callback, context])) {
	        return this;
	      }

	      var self = this;

	      var once = _.once(function () {
	        self.stopReplying(name);
	        return makeCallback(callback).apply(this, arguments);
	      });

	      return this.reply(name, once, context);
	    },

	    // Remove handler(s)
	    stopReplying: function stopReplying(name, callback, context) {
	      if (Radio._eventsApi(this, "stopReplying", name)) {
	        return this;
	      }

	      // Remove everything if there are no arguments passed
	      if (!name && !callback && !context) {
	        delete this._requests;
	      } else if (!removeHandlers(this._requests, name, callback, context)) {
	        Radio.debugLog("Attempted to remove the unregistered request", name, this.channelName);
	      }

	      return this;
	    }
	  };

	  /*
	   * Backbone.Radio.channel
	   * ----------------------
	   * Get a reference to a channel by name.
	   *
	   */

	  Radio._channels = {};

	  Radio.channel = function (channelName) {
	    if (!channelName) {
	      throw new Error("You must provide a name for the channel.");
	    }

	    if (Radio._channels[channelName]) {
	      return Radio._channels[channelName];
	    } else {
	      return Radio._channels[channelName] = new Radio.Channel(channelName);
	    }
	  };

	  /*
	   * Backbone.Radio.Channel
	   * ----------------------
	   * A Channel is an object that extends from Backbone.Events,
	   * and Radio.Requests.
	   *
	   */

	  Radio.Channel = function (channelName) {
	    this.channelName = channelName;
	  };

	  _.extend(Radio.Channel.prototype, Backbone.Events, Radio.Requests, {

	    // Remove all handlers from the messaging systems of this channel
	    reset: function reset() {
	      this.off();
	      this.stopListening();
	      this.stopReplying();
	      return this;
	    }
	  });

	  /*
	   * Top-level API
	   * -------------
	   * Supplies the 'top-level API' for working with Channels directly
	   * from Backbone.Radio.
	   *
	   */

	  var channel,
	      args,
	      systems = [Backbone.Events, Radio.Commands, Radio.Requests];

	  _.each(systems, function (system) {
	    _.each(system, function (method, methodName) {
	      Radio[methodName] = function (channelName) {
	        args = _.rest(arguments);
	        channel = this.channel(channelName);
	        return channel[methodName].apply(channel, args);
	      };
	    });
	  });

	  Radio.reset = function (channelName) {
	    var channels = !channelName ? this._channels : [this._channels[channelName]];
	    _.invoke(channels, "reset");
	  };

	  var backbone_radio = Radio;

	  return backbone_radio;
	});



/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"col-xs-12\"><nav class=\"navbar navbar-fixed-top navbar-default\"><div class=\"container-fluid\"><div class=\"navbar-header\"><!-- Left side icons.--><a class=\"navbar-brand\"><i id=\"navbar-brand\" class=\"fa fa-lg fa-navicon\"></i></a><!-- Right side icons.--><button type=\"button\" data-toggle=\"collapse\" data-target=\"#nav-collapse-menu\" class=\"navbar-toggle collapsed\"><span class=\"sr-only\">Toggle navigation</span><span class=\"icon-bar\"></span><span class=\"icon-bar\"></span><span class=\"icon-bar\"></span></button></div><div class=\"collapse navbar-collapse\"><ul class=\"nav navbar-nav navbar-right\"><li class=\"nav-divider-vertical hidden-xs\"></li><li data-toggle=\"collapse\" data-target=\".nav-collapse\" class=\"nav-home\"><a class=\"nav-collapse-item\"><i class=\"nav-collapse-item nav-icon fa fa-fw fa-2x fa-home\"></i></a></li><li class=\"nav-divider-vertical hidden-xs\"></li><li data-toggle=\"collapse\" data-target=\".nav-collapse\" class=\"nav-strength\"><a class=\"nav-collapse-item\"><i class=\"nav-icon fa fa-fw fa-2x fa-shield\"></i></a></li><li class=\"nav-divider-vertical hidden-xs\"></li><li data-toggle=\"collapse\" data-target=\".nav-collapse\" class=\"nav-log\"><a class=\"nav-collapse-item\"><i class=\"nav-icon fa fa-fw fa-2x fa-area-chart\"></i></a></li><li class=\"nav-divider-vertical hidden-xs\"></li><li class=\"hidden-xs\"><a><b id=\"nav-username\">USERNAME</b></a></li><li class=\"nav-divider-vertical hidden-xs\"></li><li class=\"dropdown\"><a href=\"#\" data-toggle=\"dropdown\" role=\"button\" aria-expanded=\"false\" class=\"dropdown-toggle\"><i class=\"hidden-xs fa fa-lg fa-caret-down\"></i></a><ul role=\"menu\" class=\"dropdown-menu\"><li><a><i class=\"fa fa-fw fa-lg fa-user\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "My Profile</a></li><li><a><i class=\"fa fa-fw fa-lg fa-cog\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Settings</a></li><li class=\"divider\"></li><li><a><i class=\"fa fa-fw fa-lg fa-question\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Help</a></li><li><a><i class=\"fa fa-fw fa-lg fa-ambulance\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Report a Problem</a></li><li class=\"divider\"></li><li><a><i class=\"fa fa-fw fa-lg fa-sign-out\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Sign Out</a></li></ul></li></ul></div><div id=\"nav-collapse-menu\" class=\"collapse navbar-collapse\"><ul class=\"visible-xs list-group\"><li class=\"list-group-item nav-home\"><i class=\"nav-icon fa fa-fw fa-lg fa-home\"></i><span>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Home</span></li><li class=\"list-group-item nav-stat\"><i class=\"nav-icon fa fa-fw fa-lg fa-line-chart\"></i><span>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Personal Record</span></li><li class=\"list-group-item nav-strength\"><i class=\"nav-icon fa fa-fw fa-lg fa-shield\"></i><span>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Strength Workout</span></li><li class=\"list-group-item nav-log\"><i class=\"nav-icon fa fa-fw fa-lg fa-area-chart\"></i><span>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Strength Log</span></li><li class=\"list-group-item\"><i class=\"fa fa-fw fa-lg fa-user\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "My Profile</li><li class=\"list-group-item\"><i class=\"fa fa-fw fa-lg fa-cog\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Settings</li><li class=\"list-group-item\"><i class=\"fa fa-fw fa-lg fa-sign-out\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Sign Out</li></ul></div></div></nav></div><!-- Sliding left menu--><nav id=\"my-menu\" class=\"mm-light\"><ul><li id=\"side-nav-side-home\"><a><i class=\"fa fa-fw fa-lg fa-home\"></i>&nbsp Home</a></li><li><a id=\"side-nav-exercise\"><i class=\"fa fa-fw fa-heartbeat\"></i>&nbsp Exercises<ul><li><a><i class=\"fa fa-fw fa-lg fa-shield\"></i>&nbsp Strength</a></li><li><a><i class=\"fa fa-fw fa-lg fa-bicycle\"></i>&nbsp Endurance</a></li><li><a><i class=\"fa fa-fw fa-lg fa-heart\"></i>&nbsp Flexibility</a></li><li><a><i class=\"fa fa-fw fa-lg fa-balance-scale\"></i>&nbsp Balance</a></li></ul></a></li><li><a id=\"side-nav-schedule\"><i class=\"fa fa-fw fa-lg fa-calendar\"></i>&nbsp Schedule</a></li><li><a id=\"side-nav-stat\"><i class=\"fa fa-fw fa-lg fa-line-chart\"></i>&nbsp Stats</a></li><li><a id=\"side-nav-log\"><i class=\"fa fa-fw fa-lg fa-area-chart\"></i>&nbsp Logs</a></li><li><a id=\"side-nav-contacts\"><i class=\"fa fa-fw fa-lg fa-group\"></i>&nbsp Multiplayers</a><ul><li><a><i class=\"fa fa-fw fa-lg fa-th-list\"></i>&nbsp Friends</a></li><li><a><i class=\"fa fa-fw fa-lg fa-trophy\"></i>&nbsp Ranking</a></li><li><a id=\"side-nav-chat\"><i class=\"fa fa-fw fa-lg fa-comments-o\"></i>&nbsp Chat</a></li></ul></li></ul></nav>");;return buf.join("");
	}

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/
	var Backbone = __webpack_require__(8);

	// Backbone.Stickit v0.9.2, MIT Licensed
	// Copyright (c) 2012-2015 The New York Times, CMS Group, Matthew DeLambo <delambo@gmail.com>

	(function (factory) {

	  // Set up Stickit appropriately for the environment. Start with AMD.
	  if (true)
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9), __webpack_require__(8), exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	  // Next for Node.js or CommonJS.
	  else if (typeof exports === 'object')
	    factory(require('underscore'), require('backbone'), exports);

	  // Finally, as a browser global.
	  else
	    factory(_, Backbone, {});

	}(function (_, Backbone, Stickit) {

	  // Stickit Namespace
	  // --------------------------

	  // Export onto Backbone object
	  Backbone.Stickit = Stickit;

	  Stickit._handlers = [];

	  Stickit.addHandler = function(handlers) {
	    // Fill-in default values.
	    handlers = _.map(_.flatten([handlers]), function(handler) {
	      return _.defaults({}, handler, {
	        updateModel: true,
	        updateView: true,
	        updateMethod: 'text'
	      });
	    });
	    this._handlers = this._handlers.concat(handlers);
	  };

	  // Backbone.View Mixins
	  // --------------------

	  Stickit.ViewMixin = {

	    // Collection of model event bindings.
	    //   [{model,event,fn,config}, ...]
	    _modelBindings: null,

	    // Unbind the model and event bindings from `this._modelBindings` and
	    // `this.$el`. If the optional `model` parameter is defined, then only
	    // delete bindings for the given `model` and its corresponding view events.
	    unstickit: function(model, bindingSelector) {

	      // Support passing a bindings hash in place of bindingSelector.
	      if (_.isObject(bindingSelector)) {
	        _.each(bindingSelector, function(v, selector) {
	          this.unstickit(model, selector);
	        }, this);
	        return;
	      }

	      var models = [], destroyFns = [];
	      this._modelBindings = _.reject(this._modelBindings, function(binding) {
	        if (model && binding.model !== model) return;
	        if (bindingSelector && binding.config.selector != bindingSelector) return;

	        binding.model.off(binding.event, binding.fn);
	        destroyFns.push(binding.config._destroy);
	        models.push(binding.model);
	        return true;
	      });

	      // Trigger an event for each model that was unbound.
	      _.invoke(_.uniq(models), 'trigger', 'stickit:unstuck', this.cid);

	      // Call `_destroy` on a unique list of the binding callbacks.
	      _.each(_.uniq(destroyFns), function(fn) { fn.call(this); }, this);

	      this.$el.off('.stickit' + (model ? '.' + model.cid : ''), bindingSelector);
	    },

	    // Initilize Stickit bindings for the view. Subsequent binding additions
	    // can either call `stickit` with the new bindings, or add them directly
	    // with `addBinding`. Both arguments to `stickit` are optional.
	    stickit: function(optionalModel, optionalBindingsConfig) {
	      var model = optionalModel || this.model,
	          bindings = optionalBindingsConfig || _.result(this, "bindings") || {};

	      this._modelBindings || (this._modelBindings = []);

	      // Add bindings in bulk using `addBinding`.
	      this.addBinding(model, bindings);

	      // Wrap `view.remove` to unbind stickit model and dom events.
	      var remove = this.remove;
	      if (!remove.stickitWrapped) {
	        this.remove = function() {
	          var ret = this;
	          this.unstickit();
	          if (remove) ret = remove.apply(this, arguments);
	          return ret;
	        };
	      }
	      this.remove.stickitWrapped = true;
	      return this;
	    },

	    // Add a single Stickit binding or a hash of bindings to the model. If
	    // `optionalModel` is ommitted, will default to the view's `model` property.
	    addBinding: function(optionalModel, selector, binding) {
	      var model = optionalModel || this.model,
	          namespace = '.stickit.' + model.cid;

	      binding = binding || {};

	      // Support jQuery-style {key: val} event maps.
	      if (_.isObject(selector)) {
	        var bindings = selector;
	        _.each(bindings, function(val, key) {
	          this.addBinding(model, key, val);
	        }, this);
	        return;
	      }

	      // Special case the ':el' selector to use the view's this.$el.
	      var $el = selector === ':el' ? this.$el : this.$(selector);

	      // Clear any previous matching bindings.
	      this.unstickit(model, selector);

	      // Fail fast if the selector didn't match an element.
	      if (!$el.length) return;

	      // Allow shorthand setting of model attributes - `'selector':'observe'`.
	      if (_.isString(binding)) binding = {observe: binding};

	      // Handle case where `observe` is in the form of a function.
	      if (_.isFunction(binding.observe)) binding.observe = binding.observe.call(this);

	      // Find all matching Stickit handlers that could apply to this element
	      // and store in a config object.
	      var config = getConfiguration($el, binding);

	      // The attribute we're observing in our config.
	      var modelAttr = config.observe;

	      // Store needed properties for later.
	      config.selector = selector;
	      config.view = this;

	      // Create the model set options with a unique `bindId` so that we
	      // can avoid double-binding in the `change:attribute` event handler.
	      var bindId = config.bindId = _.uniqueId();

	      // Add a reference to the view for handlers of stickitChange events
	      var options = _.extend({stickitChange: config}, config.setOptions);

	      // Add a `_destroy` callback to the configuration, in case `destroy`
	      // is a named function and we need a unique function when unsticking.
	      config._destroy = function() {
	        applyViewFn.call(this, config.destroy, $el, model, config);
	      };

	      initializeAttributes($el, config, model, modelAttr);
	      initializeVisible($el, config, model, modelAttr);
	      initializeClasses($el, config, model, modelAttr);

	      if (modelAttr) {
	        // Setup one-way (input element -> model) bindings.
	        _.each(config.events, function(type) {
	          var eventName = type + namespace;
	          var listener = function(event) {
	            var val = applyViewFn.call(this, config.getVal, $el, event, config, slice.call(arguments, 1));

	            // Don't update the model if false is returned from the `updateModel` configuration.
	            var currentVal = evaluateBoolean(config.updateModel, val, event, config);
	            if (currentVal) setAttr(model, modelAttr, val, options, config);
	          };
	          var sel = selector === ':el'? '' : selector;
	          this.$el.on(eventName, sel, _.bind(listener, this));
	        }, this);

	        // Setup a `change:modelAttr` observer to keep the view element in sync.
	        // `modelAttr` may be an array of attributes or a single string value.
	        _.each(_.flatten([modelAttr]), function(attr) {
	          observeModelEvent(model, 'change:' + attr, config, function(m, val, options) {
	            var changeId = options && options.stickitChange && options.stickitChange.bindId;
	            if (changeId !== bindId) {
	              var currentVal = getAttr(model, modelAttr, config);
	              updateViewBindEl($el, config, currentVal, model);
	            }
	          });
	        });

	        var currentVal = getAttr(model, modelAttr, config);
	        updateViewBindEl($el, config, currentVal, model, true);
	      }

	      // After each binding is setup, call the `initialize` callback.
	      applyViewFn.call(this, config.initialize, $el, model, config);
	    }
	  };

	  _.extend(Backbone.View.prototype, Stickit.ViewMixin);

	  // Helpers
	  // -------

	  var slice = [].slice;

	  // Evaluates the given `path` (in object/dot-notation) relative to the given
	  // `obj`. If the path is null/undefined, then the given `obj` is returned.
	  var evaluatePath = function(obj, path) {
	    var parts = (path || '').split('.');
	    var result = _.reduce(parts, function(memo, i) { return memo[i]; }, obj);
	    return result == null ? obj : result;
	  };

	  // If the given `fn` is a string, then view[fn] is called, otherwise it is
	  // a function that should be executed.
	  var applyViewFn = function(fn) {
	    fn = _.isString(fn) ? evaluatePath(this, fn) : fn;
	    if (fn) return (fn).apply(this, slice.call(arguments, 1));
	  };

	  // Given a function, string (view function reference), or a boolean
	  // value, returns the truthy result. Any other types evaluate as false.
	  // The first argument must be `reference` and the last must be `config`, but
	  // middle arguments can be variadic.
	  var evaluateBoolean = function(reference, val, config) {
	    if (_.isBoolean(reference)) {
	      return reference;
	    } else if (_.isFunction(reference) || _.isString(reference)) {
	      var view = _.last(arguments).view;
	      return applyViewFn.apply(view, arguments);
	    }
	    return false;
	  };

	  // Setup a model event binding with the given function, and track the event
	  // in the view's _modelBindings.
	  var observeModelEvent = function(model, event, config, fn) {
	    var view = config.view;
	    model.on(event, fn, view);
	    view._modelBindings.push({model:model, event:event, fn:fn, config:config});
	  };

	  // Prepares the given `val`ue and sets it into the `model`.
	  var setAttr = function(model, attr, val, options, config) {
	    var value = {}, view = config.view;
	    if (config.onSet) {
	      val = applyViewFn.call(view, config.onSet, val, config);
	    }

	    if (config.set) {
	      applyViewFn.call(view, config.set, attr, val, options, config);
	    } else {
	      value[attr] = val;
	      // If `observe` is defined as an array and `onSet` returned
	      // an array, then map attributes to their values.
	      if (_.isArray(attr) && _.isArray(val)) {
	        value = _.reduce(attr, function(memo, attribute, index) {
	          memo[attribute] = _.has(val, index) ? val[index] : null;
	          return memo;
	        }, {});
	      }
	      model.set(value, options);
	    }
	  };

	  // Returns the given `attr`'s value from the `model`, escaping and
	  // formatting if necessary. If `attr` is an array, then an array of
	  // respective values will be returned.
	  var getAttr = function(model, attr, config) {
	    var view = config.view;
	    var retrieveVal = function(field) {
	      return model[config.escape ? 'escape' : 'get'](field);
	    };
	    var sanitizeVal = function(val) {
	      return val == null ? '' : val;
	    };
	    var val = _.isArray(attr) ? _.map(attr, retrieveVal) : retrieveVal(attr);
	    if (config.onGet) val = applyViewFn.call(view, config.onGet, val, config);
	    return _.isArray(val) ? _.map(val, sanitizeVal) : sanitizeVal(val);
	  };

	  // Find handlers in `Backbone.Stickit._handlers` with selectors that match
	  // `$el` and generate a configuration by mixing them in the order that they
	  // were found with the given `binding`.
	  var getConfiguration = Stickit.getConfiguration = function($el, binding) {
	    var handlers = [{
	      updateModel: false,
	      updateMethod: 'text',
	      update: function($el, val, m, opts) { if ($el[opts.updateMethod]) $el[opts.updateMethod](val); },
	      getVal: function($el, e, opts) { return $el[opts.updateMethod](); }
	    }];
	    handlers = handlers.concat(_.filter(Stickit._handlers, function(handler) {
	      return $el.is(handler.selector);
	    }));
	    handlers.push(binding);

	    // Merge handlers into a single config object. Last props in wins.
	    var config = _.extend.apply(_, handlers);

	    // `updateView` is defaulted to false for configutrations with
	    // `visible`; otherwise, `updateView` is defaulted to true.
	    if (!_.has(config, 'updateView')) config.updateView = !config.visible;
	    return config;
	  };

	  // Setup the attributes configuration - a list that maps an attribute or
	  // property `name`, to an `observe`d model attribute, using an optional
	  // `onGet` formatter.
	  //
	  //     attributes: [{
	  //       name: 'attributeOrPropertyName',
	  //       observe: 'modelAttrName'
	  //       onGet: function(modelAttrVal, modelAttrName) { ... }
	  //     }, ...]
	  //
	  var initializeAttributes = function($el, config, model, modelAttr) {
	    var props = ['autofocus', 'autoplay', 'async', 'checked', 'controls',
	      'defer', 'disabled', 'hidden', 'indeterminate', 'loop', 'multiple',
	      'open', 'readonly', 'required', 'scoped', 'selected'];

	    var view = config.view;

	    _.each(config.attributes || [], function(attrConfig) {
	      attrConfig = _.clone(attrConfig);
	      attrConfig.view = view;

	      var lastClass = '';
	      var observed = attrConfig.observe || (attrConfig.observe = modelAttr);
	      var updateAttr = function() {
	        var updateType = _.contains(props, attrConfig.name) ? 'prop' : 'attr',
	            val = getAttr(model, observed, attrConfig);

	        // If it is a class then we need to remove the last value and add the new.
	        if (attrConfig.name === 'class') {
	          $el.removeClass(lastClass).addClass(val);
	          lastClass = val;
	        } else {
	          $el[updateType](attrConfig.name, val);
	        }
	      };

	      _.each(_.flatten([observed]), function(attr) {
	        observeModelEvent(model, 'change:' + attr, config, updateAttr);
	      });

	      // Initialize the matched element's state.
	      updateAttr();
	    });
	  };

	  var initializeClasses = function($el, config, model, modelAttr) {
	    _.each(config.classes || [], function(classConfig, name) {
	      if (_.isString(classConfig)) classConfig = {observe: classConfig};
	      classConfig.view = config.view;

	      var observed = classConfig.observe;
	      var updateClass = function() {
	        var val = getAttr(model, observed, classConfig);
	        $el.toggleClass(name, !!val);
	      };

	      _.each(_.flatten([observed]), function(attr) {
	        observeModelEvent(model, 'change:' + attr, config, updateClass);
	      });
	      updateClass();
	    });
	  };

	  // If `visible` is configured, then the view element will be shown/hidden
	  // based on the truthiness of the modelattr's value or the result of the
	  // given callback. If a `visibleFn` is also supplied, then that callback
	  // will be executed to manually handle showing/hiding the view element.
	  //
	  //     observe: 'isRight',
	  //     visible: true, // or function(val, options) {}
	  //     visibleFn: function($el, isVisible, options) {} // optional handler
	  //
	  var initializeVisible = function($el, config, model, modelAttr) {
	    if (config.visible == null) return;
	    var view = config.view;

	    var visibleCb = function() {
	      var visible = config.visible,
	          visibleFn = config.visibleFn,
	          val = getAttr(model, modelAttr, config),
	          isVisible = !!val;

	      // If `visible` is a function then it should return a boolean result to show/hide.
	      if (_.isFunction(visible) || _.isString(visible)) {
	        isVisible = !!applyViewFn.call(view, visible, val, config);
	      }

	      // Either use the custom `visibleFn`, if provided, or execute the standard show/hide.
	      if (visibleFn) {
	        applyViewFn.call(view, visibleFn, $el, isVisible, config);
	      } else {
	        $el.toggle(isVisible);
	      }
	    };

	    _.each(_.flatten([modelAttr]), function(attr) {
	      observeModelEvent(model, 'change:' + attr, config, visibleCb);
	    });

	    visibleCb();
	  };

	  // Update the value of `$el` using the given configuration and trigger the
	  // `afterUpdate` callback. This action may be blocked by `config.updateView`.
	  //
	  //     update: function($el, val, model, options) {},  // handler for updating
	  //     updateView: true, // defaults to true
	  //     afterUpdate: function($el, val, options) {} // optional callback
	  //
	  var updateViewBindEl = function($el, config, val, model, isInitializing) {
	    var view = config.view;
	    if (!evaluateBoolean(config.updateView, val, config)) return;
	    applyViewFn.call(view, config.update, $el, val, model, config);
	    if (!isInitializing) applyViewFn.call(view, config.afterUpdate, $el, val, config);
	  };

	  // Default Handlers
	  // ----------------

	  Stickit.addHandler([{
	    selector: '[contenteditable]',
	    updateMethod: 'html',
	    events: ['input', 'change']
	  }, {
	    selector: 'input',
	    events: ['propertychange', 'input', 'change'],
	    update: function($el, val) { $el.val(val); },
	    getVal: function($el) {
	      return $el.val();
	    }
	  }, {
	    selector: 'textarea',
	    events: ['propertychange', 'input', 'change'],
	    update: function($el, val) { $el.val(val); },
	    getVal: function($el) { return $el.val(); }
	  }, {
	    selector: 'input[type="radio"]',
	    events: ['change'],
	    update: function($el, val) {
	      $el.filter('[value="'+val+'"]').prop('checked', true);
	    },
	    getVal: function($el) {
	      return $el.filter(':checked').val();
	    }
	  }, {
	    selector: 'input[type="checkbox"]',
	    events: ['change'],
	    update: function($el, val, model, options) {
	      if ($el.length > 1) {
	        // There are multiple checkboxes so we need to go through them and check
	        // any that have value attributes that match what's in the array of `val`s.
	        val || (val = []);
	        $el.each(function(i, el) {
	          var checkbox = Backbone.$(el);
	          var checked = _.contains(val, checkbox.val());
	          checkbox.prop('checked', checked);
	        });
	      } else {
	        var checked = _.isBoolean(val) ? val : val === $el.val();
	        $el.prop('checked', checked);
	      }
	    },
	    getVal: function($el) {
	      var val;
	      if ($el.length > 1) {
	        val = _.reduce($el, function(memo, el) {
	          var checkbox = Backbone.$(el);
	          if (checkbox.prop('checked')) memo.push(checkbox.val());
	          return memo;
	        }, []);
	      } else {
	        val = $el.prop('checked');
	        // If the checkbox has a value attribute defined, then
	        // use that value. Most browsers use "on" as a default.
	        var boxval = $el.val();
	        if (boxval !== 'on' && boxval != null) {
	          val = val ? $el.val() : null;
	        }
	      }
	      return val;
	    }
	  }, {
	    selector: 'select',
	    events: ['change'],
	    update: function($el, val, model, options) {
	      var optList,
	        selectConfig = options.selectOptions,
	        list = selectConfig && selectConfig.collection || undefined,
	        isMultiple = $el.prop('multiple');

	      // If there are no `selectOptions` then we assume that the `<select>`
	      // is pre-rendered and that we need to generate the collection.
	      if (!selectConfig) {
	        selectConfig = {};
	        var getList = function($el) {
	          return $el.map(function(index, option) {
	            // Retrieve the text and value of the option, preferring "stickit-bind-val"
	            // data attribute over value property.
	            var dataVal = Backbone.$(option).data('stickit-bind-val');
	            return {
	              value: dataVal !== undefined ? dataVal : option.value,
	              label: option.text
	            };
	          }).get();
	        };
	        if ($el.find('optgroup').length) {
	          list = {opt_labels:[]};
	          // Search for options without optgroup
	          if ($el.find('> option').length) {
	            list.opt_labels.push(undefined);
	            _.each($el.find('> option'), function(el) {
	              list[undefined] = getList(Backbone.$(el));
	            });
	          }
	          _.each($el.find('optgroup'), function(el) {
	            var label = Backbone.$(el).attr('label');
	            list.opt_labels.push(label);
	            list[label] = getList(Backbone.$(el).find('option'));
	          });
	        } else {
	          list = getList($el.find('option'));
	        }
	      }

	      // Fill in default label and path values.
	      selectConfig.valuePath = selectConfig.valuePath || 'value';
	      selectConfig.labelPath = selectConfig.labelPath || 'label';
	      selectConfig.disabledPath = selectConfig.disabledPath || 'disabled';

	      var addSelectOptions = function(optList, $el, fieldVal) {
	        _.each(optList, function(obj) {
	          var option = Backbone.$('<option/>'), optionVal = obj;

	          var fillOption = function(text, val, disabled) {
	            option.text(text);
	            optionVal = val;
	            // Save the option value as data so that we can reference it later.
	            option.data('stickit-bind-val', optionVal);
	            if (!_.isArray(optionVal) && !_.isObject(optionVal)) option.val(optionVal);

	            if (disabled === true) option.prop('disabled', 'disabled');
	          };

	          var text, val, disabled;
	          if (obj === '__default__') {
	            text = fieldVal.label,
	            val = fieldVal.value,
	            disabled = fieldVal.disabled;
	          } else {
	            text = evaluatePath(obj, selectConfig.labelPath),
	            val = evaluatePath(obj, selectConfig.valuePath),
	            disabled = evaluatePath(obj, selectConfig.disabledPath);
	          }
	          fillOption(text, val, disabled);

	          // Determine if this option is selected.
	          var isSelected = function() {
	            if (!isMultiple && optionVal != null && fieldVal != null && optionVal === fieldVal) {
	              return true;
	            } else if (_.isObject(fieldVal) && _.isEqual(optionVal, fieldVal)) {
	              return true;
	            }
	            return false;
	          };

	          if (isSelected()) {
	            option.prop('selected', true);
	          } else if (isMultiple && _.isArray(fieldVal)) {
	            _.each(fieldVal, function(val) {
	              if (_.isObject(val)) val = evaluatePath(val, selectConfig.valuePath);
	              if (val === optionVal || (_.isObject(val) && _.isEqual(optionVal, val)))
	                option.prop('selected', true);
	            });
	          }

	          $el.append(option);
	        });
	      };

	      $el.find('*').remove();

	      // The `list` configuration is a function that returns the options list or a string
	      // which represents the path to the list relative to `window` or the view/`this`.
	      if (_.isString(list)) {
	        var context = window;
	        if (list.indexOf('this.') === 0) context = this;
	        list = list.replace(/^[a-z]*\.(.+)$/, '$1');
	        optList = evaluatePath(context, list);
	      } else if (_.isFunction(list)) {
	        optList = applyViewFn.call(this, list, $el, options);
	      } else {
	        optList = list;
	      }

	      // Support Backbone.Collection and deserialize.
	      if (optList instanceof Backbone.Collection) {
	        var collection = optList;
	        var refreshSelectOptions = function() {
	          var currentVal = getAttr(model, options.observe, options);
	          applyViewFn.call(this, options.update, $el, currentVal, model, options);
	        };
	        // We need to call this function after unstickit and after an update so we don't end up
	        // with multiple listeners doing the same thing
	        var removeCollectionListeners = function() {
	          collection.off('add remove reset sort', refreshSelectOptions);
	        };
	        var removeAllListeners = function() {
	          removeCollectionListeners();
	          collection.off('stickit:selectRefresh');
	          model.off('stickit:selectRefresh');
	        };
	        // Remove previously set event listeners by triggering a custom event
	        collection.trigger('stickit:selectRefresh');
	        collection.once('stickit:selectRefresh', removeCollectionListeners, this);

	        // Listen to the collection and trigger an update of the select options
	        collection.on('add remove reset sort', refreshSelectOptions, this);

	        // Remove the previous model event listener
	        model.trigger('stickit:selectRefresh');
	        model.once('stickit:selectRefresh', function() {
	          model.off('stickit:unstuck', removeAllListeners);
	        });
	        // Remove collection event listeners once this binding is unstuck
	        model.once('stickit:unstuck', removeAllListeners, this);
	        optList = optList.toJSON();
	      }

	      if (selectConfig.defaultOption) {
	        var option = _.isFunction(selectConfig.defaultOption) ?
	          selectConfig.defaultOption.call(this, $el, options) :
	          selectConfig.defaultOption;
	        addSelectOptions(["__default__"], $el, option);
	      }

	      if (_.isArray(optList)) {
	        addSelectOptions(optList, $el, val);
	      } else if (optList.opt_labels) {
	        // To define a select with optgroups, format selectOptions.collection as an object
	        // with an 'opt_labels' property, as in the following:
	        //
	        //     {
	        //       'opt_labels': ['Looney Tunes', 'Three Stooges'],
	        //       'Looney Tunes': [{id: 1, name: 'Bugs Bunny'}, {id: 2, name: 'Donald Duck'}],
	        //       'Three Stooges': [{id: 3, name : 'moe'}, {id: 4, name : 'larry'}, {id: 5, name : 'curly'}]
	        //     }
	        //
	        _.each(optList.opt_labels, function(label) {
	          var $group = Backbone.$('<optgroup/>').attr('label', label);
	          addSelectOptions(optList[label], $group, val);
	          $el.append($group);
	        });
	        // With no 'opt_labels' parameter, the object is assumed to be a simple value-label map.
	        // Pass a selectOptions.comparator to override the default order of alphabetical by label.
	      } else {
	        var opts = [], opt;
	        for (var i in optList) {
	          opt = {};
	          opt[selectConfig.valuePath] = i;
	          opt[selectConfig.labelPath] = optList[i];
	          opts.push(opt);
	        }
	        opts = _.sortBy(opts, selectConfig.comparator || selectConfig.labelPath);
	        addSelectOptions(opts, $el, val);
	      }
	    },
	    getVal: function($el) {
	      var selected = $el.find('option:selected');

	      if ($el.prop('multiple')) {
	        return _.map(selected, function(el) {
	          return Backbone.$(el).data('stickit-bind-val');
	        });
	      } else {
	        return selected.data('stickit-bind-val');
	      }
	    }
	  }]);

	  return Stickit;

	}));



/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Exercise, Home, Index, Login, Marionette, Profile, Router, Signup, Strength, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	_ = __webpack_require__(3);

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	Index = __webpack_require__(21);

	Signup = __webpack_require__(24);

	Login = __webpack_require__(28);

	Home = __webpack_require__(31);

	Profile = __webpack_require__(34);

	Exercise = __webpack_require__(37);

	Strength = __webpack_require__(49);

	Router = (function(superClass) {
	  extend(Router, superClass);

	  function Router() {
	    Router.__super__.constructor.apply(this, arguments);
	    this.navChannel = Backbone.Radio.channel('nav');
	    this.rootChannel = Backbone.Radio.channel('root');
	    this.rootView = this.rootChannel.request('rootview');
	    this.rootChannel.reply({
	      'index': (function(_this) {
	        return function() {
	          _this.navigate('');
	          _this.signup();
	        };
	      })(this),
	      'signup': (function(_this) {
	        return function() {
	          _this.navigate('signup', {
	            trigger: true
	          });
	          _this.signup();
	        };
	      })(this),
	      'login': (function(_this) {
	        return function() {
	          _this.navigate('login', {
	            trigger: true
	          });
	          _this.login();
	        };
	      })(this),
	      'home': (function(_this) {
	        return function() {
	          _this.navigate('home', {
	            trigger: true
	          });
	          _this.home();
	        };
	      })(this),
	      'profile': (function(_this) {
	        return function() {
	          _this.navigate('profile', {
	            trigger: true
	          });
	          _this.profile();
	        };
	      })(this),
	      'exercise': (function(_this) {
	        return function() {
	          _this.navigate('exercise', {
	            trigger: true
	          });
	          _this.exercise();
	        };
	      })(this),
	      'exercise:detail': (function(_this) {
	        return function(type) {
	          _this.rootChannel.request("" + type);
	        };
	      })(this),
	      'strength': (function(_this) {
	        return function() {
	          _this.navigate('strength', {
	            trigger: true
	          });
	          _this.strength();
	        };
	      })(this),
	      'strength:detail': (function(_this) {
	        return function(exerciseID) {
	          _this.navigate("strength/" + exerciseID, {
	            trigger: true
	          });
	          _this.strengthDetail(exerciseID);
	        };
	      })(this),
	      'strength:log': (function(_this) {
	        return function(exerciseID) {
	          _this.navigate("strength/" + exerciseID + "/log", {
	            trigger: true
	          });
	          _this.strengthLog(exerciseID);
	        };
	      })(this),
	      'stat': (function(_this) {
	        return function() {
	          _this.navigate('stat', {
	            trigger: true
	          });
	          _this.stat();
	        };
	      })(this),
	      'schedule': (function(_this) {
	        return function() {
	          _this.navigate('schedule', {
	            trigger: true
	          });
	          _this.schedule();
	        };
	      })(this),
	      'log': (function(_this) {
	        return function() {
	          _this.navigate('log', {
	            trigger: true
	          });
	          _this.log();
	        };
	      })(this),
	      'multiplayer': (function(_this) {
	        return function() {
	          _this.navigate('multiplayer', {
	            trigger: true
	          });
	          _this.multiplayer();
	        };
	      })(this)
	    });
	  }

	  Router.prototype.routes = {
	    '': 'signup',
	    '/': 'signup',
	    'signup': 'signup',
	    'login': 'login',
	    'home': 'home',
	    'profile': 'profile',
	    'exercise': 'exercise',
	    'strength/': 'strength',
	    'strength/:sid/': 'strengthDetail',
	    'strength/:sid/log': 'strengthLog',
	    'stat': 'stat',
	    'schedule': 'schdeule',
	    'log': 'log',
	    'multiplayer': 'multiplayer'
	  };

	  Router.prototype.index = function() {
	    this.navChannel.request('nav:index');
	    console.log('no index page, redirect to signup');
	  };

	  Router.prototype.signup = function() {
	    this.navChannel.request('nav:index');
	    this.rootView.content.show(new Signup.View({
	      model: new Signup.Model()
	    }));
	  };

	  Router.prototype.login = function() {
	    this.navChannel.request('nav:index');
	    this.rootView.content.show(new Login.View({
	      model: new Login.Model()
	    }));
	  };

	  Router.prototype.home = function() {
	    this.navChannel.request('nav:main');
	    this.rootView.content.show(new Home.View());
	  };

	  Router.prototype.profile = function() {
	    this.navChannel.request('nav:main');
	    this.rootView.content.show(new Profile.View());
	  };

	  Router.prototype.strength = function() {
	    var Collection, Model, View, collection;
	    this.navChannel.request('nav:main');
	    Collection = Strength.Master.Collection;
	    Model = Strength.Master.Model;
	    View = Strength.Master.View;
	    collection = new Collection();
	    collection.fetch({
	      success: (function(_this) {
	        return function(collection) {
	          _this.rootView.content.show(new View({
	            collection: collection,
	            model: new Model()
	          }));
	        };
	      })(this),
	      error: function() {
	        console.log('error');
	      }
	    });
	  };

	  Router.prototype.strengthDetail = function(strengthID) {
	    var Model, View, model;
	    this.navChannel.request('nav:main');
	    View = Strength.Detail.View;
	    Model = Strength.Detail.Model;
	    model = new Model({}, {
	      id: strengthID
	    });
	    model.fetch({
	      success: (function(_this) {
	        return function(model) {
	          _this.rootView.content.show(new View({
	            model: model,
	            strengthID: strengthID
	          }));
	        };
	      })(this),
	      error: function() {
	        console.log('error');
	      }
	    });
	  };

	  Router.prototype.strengthLog = function(strengthID) {
	    var Model, View, model;
	    this.navChannel.request('nav:main');
	    View = Strength.Log.View;
	    Model = Strength.Log.Model;
	    model = new Model({}, {
	      id: strengthID
	    });
	    model.fetch({
	      success: (function(_this) {
	        return function(model) {
	          _this.rootView.content.show(new View({
	            model: model,
	            strengthID: strengthID
	          }));
	        };
	      })(this),
	      error: function() {
	        console.log('error');
	      }
	    });
	  };

	  Router.prototype.exercise = function() {
	    var collection, model;
	    this.navChannel.request('nav:main');
	    collection = new Exercise.Master.Collection();
	    model = new Exercise.Master.Model();
	    collection.fetch({
	      success: (function(_this) {
	        return function(collection) {
	          _this.rootView.content.show(new Exercise.Master.View({
	            collection: collection,
	            model: model
	          }));
	        };
	      })(this),
	      error: function() {
	        console.log('error');
	      }
	    });
	  };

	  Router.prototype.stat = function() {
	    this.navChannel.request('nav:main');
	    this.rootView.content.show(new Profile.View());
	  };

	  Router.prototype.schedule = function() {
	    this.navChannel.request('nav:main');
	    this.rootView.content.show(new Profile.View());
	  };

	  Router.prototype.log = function() {
	    this.navChannel.request('nav:main');
	    this.rootView.content.show(new Profile.View());
	  };

	  Router.prototype.multiplayer = function() {
	    this.navChannel.request('nav:main');
	    this.rootView.content.show(new Profile.View());
	  };

	  return Router;

	})(Marionette.AppRouter);

	module.exports = Router;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Collection, Model,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Backbone = __webpack_require__(8);

	Model = (function(superClass) {
	  extend(Model, superClass);

	  function Model() {
	    return Model.__super__.constructor.apply(this, arguments);
	  }

	  Model.prototype.defaults = {
	    name: ''
	  };

	  return Model;

	})(Backbone.Model);

	Collection = (function(superClass) {
	  extend(Collection, superClass);

	  function Collection() {
	    return Collection.__super__.constructor.apply(this, arguments);
	  }

	  Collection.prototype.url = 'api/user';

	  Collection.prototype.model = Model;

	  return Collection;

	})(Backbone.Collection);

	exports.Model = Model;

	exports.Collection = Collection;

	exports.View = __webpack_require__(22);


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var Marionette, View, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Marionette = __webpack_require__(10);

	viewTemplate = __webpack_require__(23);

	View = (function(superClass) {
	  extend(View, superClass);

	  function View() {
	    return View.__super__.constructor.apply(this, arguments);
	  }

	  View.prototype.template = viewTemplate;

	  return View;

	})(Marionette.ItemView);

	module.exports = View;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-sm-12\"><span class=\"lead\">Welcome</span></div></div><br><div class=\"row\"><div class=\"col-sm-12\"><!-- Nav tabs--><ul role=\"tablist\" class=\"nav nav-tabs\"><li id=\"index-tab-signup\" role=\"presentation\" class=\"active\"><a href=\"#index-tab-signup\" aria-controls=\"signup\" role=\"tab\" data-toggle=\"tab\"><b>Sign Up</b></a></li><li id=\"index-tab-login\" role=\"presentation\"><a href=\"#index-tab-login\" aria-controls=\"login\" role=\"tab\" data-toggle=\"tab\"><b>Login</b></a></li></ul></div></div>");;return buf.join("");
	}

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Model,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Backbone = __webpack_require__(8);

	Model = (function(superClass) {
	  extend(Model, superClass);

	  function Model() {
	    return Model.__super__.constructor.apply(this, arguments);
	  }

	  Model.prototype.url = 'api/signup';

	  Model.prototype.defaults = {
	    firstname: '',
	    lastname: '',
	    email: '',
	    password: ''
	  };

	  Model.prototype.validation = {
	    firstname: {
	      required: true
	    }
	  };

	  return Model;

	})(Backbone.Model);

	exports.Model = Model;

	exports.View = __webpack_require__(25);


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Marionette, View, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	viewTemplate = __webpack_require__(26);

	__webpack_require__(19);

	__webpack_require__(27);

	View = (function(superClass) {
	  extend(View, superClass);

	  View.prototype.template = viewTemplate;

	  View.prototype.ui = {
	    login: '#index-tab-login',
	    submit: '#index-signup-submit'
	  };

	  View.prototype.bindings = {
	    '#index-signup-firstname': 'firstname',
	    '#index-signup-lastname': 'lastname',
	    '#index-signup-email': 'email',
	    '#index-signup-password': 'password'
	  };

	  View.prototype.events = {
	    'click @ui.login': function() {
	      this.rootChannel.request('login');
	    },
	    'submit': function(event) {
	      event.preventDefault();
	      this.model.save({}, {
	        success: (function(_this) {
	          return function() {
	            _this.rootChannel.request('home');
	          };
	        })(this),
	        error: function() {
	          console.log('fail');
	        }
	      });
	    }
	  };

	  function View() {
	    View.__super__.constructor.apply(this, arguments);
	    this.rootChannel = Backbone.Radio.channel('root');
	  }

	  View.prototype.initialize = function() {
	    Backbone.Validation.bind(this, this.model);
	    this.model.validate();
	  };

	  View.prototype.onRender = function() {
	    this.stickit();
	  };

	  return View;

	})(Marionette.ItemView);

	module.exports = View;


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-sm-12\"><span class=\"lead\">Welcome</span></div></div><br><div class=\"row\"><div class=\"col-sm-12\"><!-- Nav tabs--><ul role=\"tablist\" class=\"nav nav-tabs\"><li id=\"index-tab-signup\" role=\"presentation\" class=\"active\"><a href=\"#index-tab-signup\" aria-controls=\"signup\" role=\"tab\" data-toggle=\"tab\"><b>Sign Up</b></a></li><li id=\"index-tab-login\" role=\"presentation\"><a href=\"#index-tab-login\" aria-controls=\"login\" role=\"tab\" data-toggle=\"tab\"><b>Login</b></a></li></ul><br><!-- Tab panes--><div class=\"tab-content\"><div id=\"index-tab-pane-signup\" role=\"tabpanel\" class=\"tab-pane active\"><div class=\"row\"><div class=\"col-sm-12\"><form class=\"form-horizontal\"><div class=\"form-group\"><label for=\"index-signup-firstname\" class=\"col-sm-2 control-label\">First name</label><div class=\"col-sm-10\"><input id=\"index-signup-firstname\" placeholder=\"First name\" name=\"firstname\" required class=\"form-control\"></div></div><div class=\"form-group\"><label for=\"index-signup-lastname\" class=\"col-sm-2 control-label\">Last name</label><div class=\"col-sm-10\"><input id=\"index-signup-lastname\" placeholder=\"Last Name\" name=\"lastname\" required class=\"form-control\"></div></div><div class=\"form-group\"><label for=\"index-signup-email\" class=\"col-sm-2 control-label\">Email</label><div class=\"col-sm-10\"><input id=\"index-signup-email\" placeholder=\"Email\" name=\"email\" required class=\"form-control\"></div></div><div class=\"form-group\"><label for=\"index-signup-password\" class=\"col-sm-2 control-label\">Password</label><div class=\"col-sm-10\"><input id=\"index-signup-password\" placeholder=\"Password\" name=\"password\" required class=\"form-control\"></div></div><div class=\"form-group\"><div class=\"col-sm-12\"><button id=\"index-signup-submit\" type=\"submit\" class=\"btn btn-success pull-right\"><i class=\"fa fa-user\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Sign Up</button></div></div></form></div></div></div></div></div></div>");;return buf.join("");
	}

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var Backbone = __webpack_require__(8);

	// Backbone.Validation v0.11.5
	//
	// Copyright (c) 2011-2015 Thomas Pedersen
	// Distributed under MIT License
	//
	// Documentation and full license available at:
	// http://thedersen.com/projects/backbone-validation

	Backbone.Validation = (function(_){
	    'use strict';

	    // Default options
	    // ---------------

	    var defaultOptions = {
	        forceUpdate: false,
	        selector: 'name',
	        labelFormatter: 'sentenceCase',
	        valid: Function.prototype,
	        invalid: Function.prototype
	    };


	    // Helper functions
	    // ----------------

	    // Formatting functions used for formatting error messages
	    var formatFunctions = {
	        // Uses the configured label formatter to format the attribute name
	        // to make it more readable for the user
	        formatLabel: function(attrName, model) {
	            return defaultLabelFormatters[defaultOptions.labelFormatter](attrName, model);
	        },

	        // Replaces nummeric placeholders like {0} in a string with arguments
	        // passed to the function
	        format: function() {
	            var args = Array.prototype.slice.call(arguments),
	                text = args.shift();
	            return text.replace(/\{(\d+)\}/g, function(match, number) {
	                return typeof args[number] !== 'undefined' ? args[number] : match;
	            });
	        }
	    };

	    // Flattens an object
	    // eg:
	    //
	    //     var o = {
	    //       owner: {
	    //         name: 'Backbone',
	    //         address: {
	    //           street: 'Street',
	    //           zip: 1234
	    //         }
	    //       }
	    //     };
	    //
	    // becomes:
	    //
	    //     var o = {
	    //       'owner': {
	    //         name: 'Backbone',
	    //         address: {
	    //           street: 'Street',
	    //           zip: 1234
	    //         }
	    //       },
	    //       'owner.name': 'Backbone',
	    //       'owner.address': {
	    //         street: 'Street',
	    //         zip: 1234
	    //       },
	    //       'owner.address.street': 'Street',
	    //       'owner.address.zip': 1234
	    //     };
	    // This may seem redundant, but it allows for maximum flexibility
	    // in validation rules.
	    var flatten = function (obj, into, prefix) {
	        into = into || {};
	        prefix = prefix || '';

	        _.each(obj, function(val, key) {
	            if(obj.hasOwnProperty(key)) {
	                if (!!val && _.isArray(val)) {
	                    _.forEach(val, function(v, k) {
	                        flatten(v, into, prefix + key + '.' + k + '.');
	                        into[prefix + key + '.' + k] = v;
	                    });
	                } else if (!!val && typeof val === 'object' && val.constructor === Object) {
	                    flatten(val, into, prefix + key + '.');
	                }

	                // Register the current level object as well
	                into[prefix + key] = val;
	            }
	        });

	        return into;
	    };

	    // Validation
	    // ----------

	    var Validation = (function(){

	        // Returns an object with undefined properties for all
	        // attributes on the model that has defined one or more
	        // validation rules.
	        var getValidatedAttrs = function(model, attrs) {
	            attrs = attrs || _.keys(_.result(model, 'validation') || {});
	            return _.reduce(attrs, function(memo, key) {
	                memo[key] = void 0;
	                return memo;
	            }, {});
	        };

	        // Returns an array with attributes passed through options
	        var getOptionsAttrs = function(options, view) {
	            var attrs = options.attributes;
	            if (_.isFunction(attrs)) {
	                attrs = attrs(view);
	            } else if (_.isString(attrs) && (_.isFunction(defaultAttributeLoaders[attrs]))) {
	                attrs = defaultAttributeLoaders[attrs](view);
	            }
	            if (_.isArray(attrs)) {
	                return attrs;
	            }
	        };


	        // Looks on the model for validations for a specified
	        // attribute. Returns an array of any validators defined,
	        // or an empty array if none is defined.
	        var getValidators = function(model, attr) {
	            var attrValidationSet = model.validation ? _.result(model, 'validation')[attr] || {} : {};

	            // If the validator is a function or a string, wrap it in a function validator
	            if (_.isFunction(attrValidationSet) || _.isString(attrValidationSet)) {
	                attrValidationSet = {
	                    fn: attrValidationSet
	                };
	            }

	            // Stick the validator object into an array
	            if(!_.isArray(attrValidationSet)) {
	                attrValidationSet = [attrValidationSet];
	            }

	            // Reduces the array of validators into a new array with objects
	            // with a validation method to call, the value to validate against
	            // and the specified error message, if any
	            return _.reduce(attrValidationSet, function(memo, attrValidation) {
	                _.each(_.without(_.keys(attrValidation), 'msg'), function(validator) {
	                    memo.push({
	                        fn: defaultValidators[validator],
	                        val: attrValidation[validator],
	                        msg: attrValidation.msg
	                    });
	                });
	                return memo;
	            }, []);
	        };

	        // Validates an attribute against all validators defined
	        // for that attribute. If one or more errors are found,
	        // the first error message is returned.
	        // If the attribute is valid, an empty string is returned.
	        var validateAttr = function(model, attr, value, computed) {
	            // Reduces the array of validators to an error message by
	            // applying all the validators and returning the first error
	            // message, if any.
	            return _.reduce(getValidators(model, attr), function(memo, validator){
	                // Pass the format functions plus the default
	                // validators as the context to the validator
	                var ctx = _.extend({}, formatFunctions, defaultValidators),
	                    result = validator.fn.call(ctx, value, attr, validator.val, model, computed);

	                if(result === false || memo === false) {
	                    return false;
	                }
	                if (result && !memo) {
	                    return _.result(validator, 'msg') || result;
	                }
	                return memo;
	            }, '');
	        };

	        // Loops through the model's attributes and validates the specified attrs.
	        // Returns and object containing names of invalid attributes
	        // as well as error messages.
	        var validateModel = function(model, attrs, validatedAttrs) {
	            var error,
	                invalidAttrs = {},
	                isValid = true,
	                computed = _.clone(attrs);

	            _.each(validatedAttrs, function(val, attr) {
	                error = validateAttr(model, attr, val, computed);
	                if (error) {
	                    invalidAttrs[attr] = error;
	                    isValid = false;
	                }
	            });

	            return {
	                invalidAttrs: invalidAttrs,
	                isValid: isValid
	            };
	        };

	        // Contains the methods that are mixed in on the model when binding
	        var mixin = function(view, options) {
	            return {

	                // Check whether or not a value, or a hash of values
	                // passes validation without updating the model
	                preValidate: function(attr, value) {
	                    var self = this,
	                        result = {},
	                        error;

	                    if(_.isObject(attr)){
	                        _.each(attr, function(value, key) {
	                            error = self.preValidate(key, value);
	                            if(error){
	                                result[key] = error;
	                            }
	                        });

	                        return _.isEmpty(result) ? undefined : result;
	                    }
	                    else {
	                        return validateAttr(this, attr, value, _.extend({}, this.attributes));
	                    }
	                },

	                // Check to see if an attribute, an array of attributes or the
	                // entire model is valid. Passing true will force a validation
	                // of the model.
	                isValid: function(option) {
	                    var flattened, attrs, error, invalidAttrs;

	                    option = option || getOptionsAttrs(options, view);

	                    if(_.isString(option)){
	                        attrs = [option];
	                    } else if(_.isArray(option)) {
	                        attrs = option;
	                    }
	                    if (attrs) {
	                        flattened = flatten(this.attributes);
	                        //Loop through all associated views
	                        _.each(this.associatedViews, function(view) {
	                            _.each(attrs, function (attr) {
	                                error = validateAttr(this, attr, flattened[attr], _.extend({}, this.attributes));
	                                if (error) {
	                                    options.invalid(view, attr, error, options.selector);
	                                    invalidAttrs = invalidAttrs || {};
	                                    invalidAttrs[attr] = error;
	                                } else {
	                                    options.valid(view, attr, options.selector);
	                                }
	                            }, this);
	                        }, this);
	                    }

	                    if(option === true) {
	                        invalidAttrs = this.validate();
	                    }
	                    if (invalidAttrs) {
	                        this.trigger('invalid', this, invalidAttrs, {validationError: invalidAttrs});
	                    }
	                    return attrs ? !invalidAttrs : this.validation ? this._isValid : true;
	                },

	                // This is called by Backbone when it needs to perform validation.
	                // You can call it manually without any parameters to validate the
	                // entire model.
	                validate: function(attrs, setOptions){
	                    var model = this,
	                        validateAll = !attrs,
	                        opt = _.extend({}, options, setOptions),
	                        validatedAttrs = getValidatedAttrs(model, getOptionsAttrs(options, view)),
	                        allAttrs = _.extend({}, validatedAttrs, model.attributes, attrs),
	                        flattened = flatten(allAttrs),
	                        changedAttrs = attrs ? flatten(attrs) : flattened,
	                        result = validateModel(model, allAttrs, _.pick(flattened, _.keys(validatedAttrs)));

	                    model._isValid = result.isValid;

	                    //After validation is performed, loop through all associated views
	                    _.each(model.associatedViews, function(view){

	                        // After validation is performed, loop through all validated and changed attributes
	                        // and call the valid and invalid callbacks so the view is updated.
	                        _.each(validatedAttrs, function(val, attr){
	                            var invalid = result.invalidAttrs.hasOwnProperty(attr),
	                                changed = changedAttrs.hasOwnProperty(attr);

	                            if(!invalid){
	                                opt.valid(view, attr, opt.selector);
	                            }
	                            if(invalid && (changed || validateAll)){
	                                opt.invalid(view, attr, result.invalidAttrs[attr], opt.selector);
	                            }
	                        });
	                    });

	                    // Trigger validated events.
	                    // Need to defer this so the model is actually updated before
	                    // the event is triggered.
	                    _.defer(function() {
	                        model.trigger('validated', model._isValid, model, result.invalidAttrs);
	                        model.trigger('validated:' + (model._isValid ? 'valid' : 'invalid'), model, result.invalidAttrs);
	                    });

	                    // Return any error messages to Backbone, unless the forceUpdate flag is set.
	                    // Then we do not return anything and fools Backbone to believe the validation was
	                    // a success. That way Backbone will update the model regardless.
	                    if (!opt.forceUpdate && _.intersection(_.keys(result.invalidAttrs), _.keys(changedAttrs)).length > 0) {
	                        return result.invalidAttrs;
	                    }
	                }
	            };
	        };

	        // Helper to mix in validation on a model. Stores the view in the associated views array.
	        var bindModel = function(view, model, options) {
	            if (model.associatedViews) {
	                model.associatedViews.push(view);
	            } else {
	                model.associatedViews = [view];
	            }
	            _.extend(model, mixin(view, options));
	        };

	        // Removes view from associated views of the model or the methods
	        // added to a model if no view or single view provided
	        var unbindModel = function(model, view) {
	            if (view && model.associatedViews && model.associatedViews.length > 1){
	                model.associatedViews = _.without(model.associatedViews, view);
	            } else {
	                delete model.validate;
	                delete model.preValidate;
	                delete model.isValid;
	                delete model.associatedViews;
	            }
	        };

	        // Mix in validation on a model whenever a model is
	        // added to a collection
	        var collectionAdd = function(model) {
	            bindModel(this.view, model, this.options);
	        };

	        // Remove validation from a model whenever a model is
	        // removed from a collection
	        var collectionRemove = function(model) {
	            unbindModel(model);
	        };

	        // Returns the public methods on Backbone.Validation
	        return {

	            // Current version of the library
	            version: '0.11.3',

	            // Called to configure the default options
	            configure: function(options) {
	                _.extend(defaultOptions, options);
	            },

	            // Hooks up validation on a view with a model
	            // or collection
	            bind: function(view, options) {
	                options = _.extend({}, defaultOptions, defaultCallbacks, options);

	                var model = options.model || view.model,
	                    collection = options.collection || view.collection;

	                if(typeof model === 'undefined' && typeof collection === 'undefined'){
	                    throw 'Before you execute the binding your view must have a model or a collection.\n' +
	                    'See http://thedersen.com/projects/backbone-validation/#using-form-model-validation for more information.';
	                }

	                if(model) {
	                    bindModel(view, model, options);
	                }
	                else if(collection) {
	                    collection.each(function(model){
	                        bindModel(view, model, options);
	                    });
	                    collection.bind('add', collectionAdd, {view: view, options: options});
	                    collection.bind('remove', collectionRemove);
	                }
	            },

	            // Removes validation from a view with a model
	            // or collection
	            unbind: function(view, options) {
	                options = _.extend({}, options);
	                var model = options.model || view.model,
	                    collection = options.collection || view.collection;

	                if(model) {
	                    unbindModel(model, view);
	                }
	                else if(collection) {
	                    collection.each(function(model){
	                        unbindModel(model, view);
	                    });
	                    collection.unbind('add', collectionAdd);
	                    collection.unbind('remove', collectionRemove);
	                }
	            },

	            // Used to extend the Backbone.Model.prototype
	            // with validation
	            mixin: mixin(null, defaultOptions)
	        };
	    }());


	    // Callbacks
	    // ---------

	    var defaultCallbacks = Validation.callbacks = {

	        // Gets called when a previously invalid field in the
	        // view becomes valid. Removes any error message.
	        // Should be overridden with custom functionality.
	        valid: function(view, attr, selector) {
	            view.$('[' + selector + '~="' + attr + '"]')
	                .removeClass('invalid')
	                .removeAttr('data-error');
	        },

	        // Gets called when a field in the view becomes invalid.
	        // Adds a error message.
	        // Should be overridden with custom functionality.
	        invalid: function(view, attr, error, selector) {
	            view.$('[' + selector + '~="' + attr + '"]')
	                .addClass('invalid')
	                .attr('data-error', error);
	        }
	    };


	    // Patterns
	    // --------

	    var defaultPatterns = Validation.patterns = {
	        // Matches any digit(s) (i.e. 0-9)
	        digits: /^\d+$/,

	        // Matches any number (e.g. 100.000)
	        number: /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/,

	        // Matches a valid email address (e.g. mail@example.com)
	        email: /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i,

	        // Mathes any valid url (e.g. http://www.xample.com)
	        url: /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
	    };


	    // Error messages
	    // --------------

	    // Error message for the build in validators.
	    // {x} gets swapped out with arguments form the validator.
	    var defaultMessages = Validation.messages = {
	        required: '{0} is required',
	        acceptance: '{0} must be accepted',
	        min: '{0} must be greater than or equal to {1}',
	        max: '{0} must be less than or equal to {1}',
	        range: '{0} must be between {1} and {2}',
	        length: '{0} must be {1} characters',
	        minLength: '{0} must be at least {1} characters',
	        maxLength: '{0} must be at most {1} characters',
	        rangeLength: '{0} must be between {1} and {2} characters',
	        oneOf: '{0} must be one of: {1}',
	        equalTo: '{0} must be the same as {1}',
	        digits: '{0} must only contain digits',
	        number: '{0} must be a number',
	        email: '{0} must be a valid email',
	        url: '{0} must be a valid url',
	        inlinePattern: '{0} is invalid'
	    };

	    // Label formatters
	    // ----------------

	    // Label formatters are used to convert the attribute name
	    // to a more human friendly label when using the built in
	    // error messages.
	    // Configure which one to use with a call to
	    //
	    //     Backbone.Validation.configure({
	    //       labelFormatter: 'label'
	    //     });
	    var defaultLabelFormatters = Validation.labelFormatters = {

	        // Returns the attribute name with applying any formatting
	        none: function(attrName) {
	            return attrName;
	        },

	        // Converts attributeName or attribute_name to Attribute name
	        sentenceCase: function(attrName) {
	            return attrName.replace(/(?:^\w|[A-Z]|\b\w)/g, function(match, index) {
	                return index === 0 ? match.toUpperCase() : ' ' + match.toLowerCase();
	            }).replace(/_/g, ' ');
	        },

	        // Looks for a label configured on the model and returns it
	        //
	        //      var Model = Backbone.Model.extend({
	        //        validation: {
	        //          someAttribute: {
	        //            required: true
	        //          }
	        //        },
	        //
	        //        labels: {
	        //          someAttribute: 'Custom label'
	        //        }
	        //      });
	        label: function(attrName, model) {
	            return (model.labels && model.labels[attrName]) || defaultLabelFormatters.sentenceCase(attrName, model);
	        }
	    };

	    // AttributeLoaders

	    var defaultAttributeLoaders = Validation.attributeLoaders = {
	        inputNames: function (view) {
	            var attrs = [];
	            if (view) {
	                view.$('form [name]').each(function () {
	                    if (/^(?:input|select|textarea)$/i.test(this.nodeName) && this.name &&
	                        this.type !== 'submit' && attrs.indexOf(this.name) === -1) {
	                        attrs.push(this.name);
	                    }
	                });
	            }
	            return attrs;
	        }
	    };


	    // Built in validators
	    // -------------------

	    var defaultValidators = Validation.validators = (function(){
	        // Use native trim when defined
	        var trim = String.prototype.trim ?
	            function(text) {
	                return text === null ? '' : String.prototype.trim.call(text);
	            } :
	            function(text) {
	                var trimLeft = /^\s+/,
	                    trimRight = /\s+$/;

	                return text === null ? '' : text.toString().replace(trimLeft, '').replace(trimRight, '');
	            };

	        // Determines whether or not a value is a number
	        var isNumber = function(value){
	            return _.isNumber(value) || (_.isString(value) && value.match(defaultPatterns.number));
	        };

	        // Determines whether or not a value is empty
	        var hasValue = function(value) {
	            return !(_.isNull(value) || _.isUndefined(value) || (_.isString(value) && trim(value) === '') || (_.isArray(value) && _.isEmpty(value)));
	        };

	        return {
	            // Function validator
	            // Lets you implement a custom function used for validation
	            fn: function(value, attr, fn, model, computed) {
	                if(_.isString(fn)){
	                    fn = model[fn];
	                }
	                return fn.call(model, value, attr, computed);
	            },

	            // Required validator
	            // Validates if the attribute is required or not
	            // This can be specified as either a boolean value or a function that returns a boolean value
	            required: function(value, attr, required, model, computed) {
	                var isRequired = _.isFunction(required) ? required.call(model, value, attr, computed) : required;
	                if(!isRequired && !hasValue(value)) {
	                    return false; // overrides all other validators
	                }
	                if (isRequired && !hasValue(value)) {
	                    return this.format(defaultMessages.required, this.formatLabel(attr, model));
	                }
	            },

	            // Acceptance validator
	            // Validates that something has to be accepted, e.g. terms of use
	            // `true` or 'true' are valid
	            acceptance: function(value, attr, accept, model) {
	                if(value !== 'true' && (!_.isBoolean(value) || value === false)) {
	                    return this.format(defaultMessages.acceptance, this.formatLabel(attr, model));
	                }
	            },

	            // Min validator
	            // Validates that the value has to be a number and equal to or greater than
	            // the min value specified
	            min: function(value, attr, minValue, model) {
	                if (!isNumber(value) || value < minValue) {
	                    return this.format(defaultMessages.min, this.formatLabel(attr, model), minValue);
	                }
	            },

	            // Max validator
	            // Validates that the value has to be a number and equal to or less than
	            // the max value specified
	            max: function(value, attr, maxValue, model) {
	                if (!isNumber(value) || value > maxValue) {
	                    return this.format(defaultMessages.max, this.formatLabel(attr, model), maxValue);
	                }
	            },

	            // Range validator
	            // Validates that the value has to be a number and equal to or between
	            // the two numbers specified
	            range: function(value, attr, range, model) {
	                if(!isNumber(value) || value < range[0] || value > range[1]) {
	                    return this.format(defaultMessages.range, this.formatLabel(attr, model), range[0], range[1]);
	                }
	            },

	            // Length validator
	            // Validates that the value has to be a string with length equal to
	            // the length value specified
	            length: function(value, attr, length, model) {
	                if (!_.isString(value) || value.length !== length) {
	                    return this.format(defaultMessages.length, this.formatLabel(attr, model), length);
	                }
	            },

	            // Min length validator
	            // Validates that the value has to be a string with length equal to or greater than
	            // the min length value specified
	            minLength: function(value, attr, minLength, model) {
	                if (!_.isString(value) || value.length < minLength) {
	                    return this.format(defaultMessages.minLength, this.formatLabel(attr, model), minLength);
	                }
	            },

	            // Max length validator
	            // Validates that the value has to be a string with length equal to or less than
	            // the max length value specified
	            maxLength: function(value, attr, maxLength, model) {
	                if (!_.isString(value) || value.length > maxLength) {
	                    return this.format(defaultMessages.maxLength, this.formatLabel(attr, model), maxLength);
	                }
	            },

	            // Range length validator
	            // Validates that the value has to be a string and equal to or between
	            // the two numbers specified
	            rangeLength: function(value, attr, range, model) {
	                if (!_.isString(value) || value.length < range[0] || value.length > range[1]) {
	                    return this.format(defaultMessages.rangeLength, this.formatLabel(attr, model), range[0], range[1]);
	                }
	            },

	            // One of validator
	            // Validates that the value has to be equal to one of the elements in
	            // the specified array. Case sensitive matching
	            oneOf: function(value, attr, values, model) {
	                if(!_.include(values, value)){
	                    return this.format(defaultMessages.oneOf, this.formatLabel(attr, model), values.join(', '));
	                }
	            },

	            // Equal to validator
	            // Validates that the value has to be equal to the value of the attribute
	            // with the name specified
	            equalTo: function(value, attr, equalTo, model, computed) {
	                if(value !== computed[equalTo]) {
	                    return this.format(defaultMessages.equalTo, this.formatLabel(attr, model), this.formatLabel(equalTo, model));
	                }
	            },

	            // Pattern validator
	            // Validates that the value has to match the pattern specified.
	            // Can be a regular expression or the name of one of the built in patterns
	            pattern: function(value, attr, pattern, model) {
	                if (!hasValue(value) || !value.toString().match(defaultPatterns[pattern] || pattern)) {
	                    return this.format(defaultMessages[pattern] || defaultMessages.inlinePattern, this.formatLabel(attr, model), pattern);
	                }
	            }
	        };
	    }());

	    // Set the correct context for all validators
	    // when used from within a method validator
	    _.each(defaultValidators, function(validator, key){
	        defaultValidators[key] = _.bind(defaultValidators[key], _.extend({}, formatFunctions, defaultValidators));
	    });

	    return Validation;
	}(_));


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Model,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Backbone = __webpack_require__(8);

	Model = (function(superClass) {
	  extend(Model, superClass);

	  function Model() {
	    return Model.__super__.constructor.apply(this, arguments);
	  }

	  Model.prototype.url = 'api/login';

	  Model.prototype.defaults = {
	    email: '',
	    password: ''
	  };

	  return Model;

	})(Backbone.Model);

	exports.Model = Model;

	exports.View = __webpack_require__(29);


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Marionette, View, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	viewTemplate = __webpack_require__(30);

	__webpack_require__(19);

	__webpack_require__(27);

	View = (function(superClass) {
	  extend(View, superClass);

	  View.prototype.template = viewTemplate;

	  View.prototype.ui = {
	    signup: '#index-tab-signup'
	  };

	  View.prototype.bindings = {
	    '#index-login-email': 'email',
	    '#index-login-password': 'password'
	  };

	  View.prototype.events = {
	    'click @ui.signup': function() {
	      this.rootChannel.request('signup');
	    },
	    'submit': function(event) {
	      event.preventDefault();
	      return this.model.save({}, {
	        success: (function(_this) {
	          return function(model) {
	            _this.rootChannel.request('home');
	          };
	        })(this),
	        error: function() {
	          console.log('fail');
	        }
	      });
	    }
	  };

	  function View() {
	    View.__super__.constructor.apply(this, arguments);
	    this.rootChannel = Backbone.Radio.channel('root');
	  }

	  View.prototype.onRender = function() {
	    this.model.set({
	      email: 'admin',
	      password: '1234'
	    });
	    this.stickit();
	  };

	  return View;

	})(Marionette.ItemView);

	module.exports = View;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-sm-12\"><span class=\"lead\">Welcome</span></div></div><br><div class=\"row\"><div class=\"col-sm-12\"><!-- Nav tabs--><ul role=\"tablist\" class=\"nav nav-tabs\"><li id=\"index-tab-signup\" role=\"presentation\"><a href=\"#index-tab-signup\" aria-controls=\"signup\" role=\"tab\" data-toggle=\"tab\"><b>Sign Up</b></a></li><li id=\"index-tab-login\" role=\"presentation\" class=\"active\"><a href=\"#index-tab-login\" aria-controls=\"login\" role=\"tab\" data-toggle=\"tab\"><b>Login</b></a></li></ul><br><!-- Tab panes--><div class=\"tab-content\"><div id=\"index-tab-pane-login\" role=\"tabpanel\" class=\"tab-pane active\"><div class=\"row\"><div class=\"col-sm-12\"><form class=\"form-horizontal\"><div class=\"form-group\"><label for=\"index-login-email\" class=\"col-sm-2 control-label\">Email</label><div class=\"col-sm-10\"><input id=\"index-login-email\" placeholder=\"Email\" required class=\"form-control\"></div></div><div class=\"form-group\"><label for=\"index-login-password\" class=\"col-sm-2 control-label\">Password</label><div class=\"col-sm-10\"><input id=\"index-login-password\" placeholder=\"Password\" required class=\"form-control\"></div></div><div class=\"form-group\"><div class=\"col-sm-12\"><button class=\"btn btn-primary pull-right\"><i class=\"fa fa-sign-in\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Log In</button></div></div></form></div></div></div></div></div></div>");;return buf.join("");
	}

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Collection, Model,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Backbone = __webpack_require__(8);

	Model = (function(superClass) {
	  extend(Model, superClass);

	  function Model() {
	    return Model.__super__.constructor.apply(this, arguments);
	  }

	  Model.prototype.defaults = {
	    name: ''
	  };

	  return Model;

	})(Backbone.Model);

	Collection = (function(superClass) {
	  extend(Collection, superClass);

	  function Collection() {
	    return Collection.__super__.constructor.apply(this, arguments);
	  }

	  Collection.prototype.url = 'api/user';

	  Collection.prototype.model = Model;

	  return Collection;

	})(Backbone.Collection);

	exports.Model = Model;

	exports.Collection = Collection;

	exports.View = __webpack_require__(32);


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Marionette, View, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	viewTemplate = __webpack_require__(33);

	View = (function(superClass) {
	  extend(View, superClass);

	  View.prototype.template = viewTemplate;

	  View.prototype.events = {
	    'click #home-exercise': function() {
	      this.rootChannel.request('exercise');
	    },
	    'click #home-exercise-strength': function() {
	      this.rootChannel.request('exercise:detail', 'strength');
	    },
	    'click #home-exercise-endurance': function() {
	      this.rootChannel.request('exercise:detail', 'endurance');
	    },
	    'click #home-exercise-flexibility': function() {
	      this.rootChannel.request('exercise:detail', 'flexibility');
	    },
	    'click #home-exercise-balance': function() {
	      this.rootChannel.request('exercise:detail', 'balance');
	    },
	    'click #home-stat': function() {
	      this.rootChannel.request('stat');
	    },
	    'click #home-schedule': function() {
	      this.rootChannel.request('schedule');
	    },
	    'click #home-log': function() {
	      this.rootChannel.request('log');
	    },
	    'click #home-multiplayer': function() {
	      this.rootChannel.request('multiplayer');
	    }
	  };

	  function View() {
	    View.__super__.constructor.apply(this, arguments);
	    this.rootChannel = Backbone.Radio.channel('root');
	  }

	  return View;

	})(Marionette.ItemView);

	module.exports = View;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-xs-12\"><span class=\"lead\"><i class=\"fa fa-fw fa-lg fa-home\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "FIRSTNAME</span></div></div><br><div class=\"row\"><div class=\"col-xs-12\"><table class=\"table table-hover\"><thead><tr><td class=\"col-xs-1\"></td><td></td></tr></thead><tbody><tr id=\"home-stat\"><td><i class=\"fa fa-fw fa-lg fa-line-chart\"></i></td><td><a><b>View Personal Status</b></a></td></tr><tr id=\"home-exercise\"><td><i class=\"fa fa-fw fa-lg fa-heartbeat\"></i></td><td><a><b>Add New Workout</b></a></td></tr><tr id=\"home-logs\"><td><i class=\"fa fa-fw fa-lg fa-area-chart\"></i></td><td><a><b>View Workout Logs</b></a></td></tr></tbody></table></div></div>");;return buf.join("");
	}

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Collection, Model,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Backbone = __webpack_require__(8);

	Model = (function(superClass) {
	  extend(Model, superClass);

	  function Model() {
	    return Model.__super__.constructor.apply(this, arguments);
	  }

	  Model.prototype.defaults = {
	    name: ''
	  };

	  return Model;

	})(Backbone.Model);

	Collection = (function(superClass) {
	  extend(Collection, superClass);

	  function Collection() {
	    return Collection.__super__.constructor.apply(this, arguments);
	  }

	  Collection.prototype.url = 'api/profile';

	  Collection.prototype.model = Model;

	  return Collection;

	})(Backbone.Collection);

	exports.Model = Model;

	exports.Collection = Collection;

	exports.View = __webpack_require__(35);


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var $, Backbone, Marionette, View, _, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	$ = __webpack_require__(2);

	_ = __webpack_require__(3);

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	viewTemplate = __webpack_require__(36);

	View = (function(superClass) {
	  extend(View, superClass);

	  function View() {
	    return View.__super__.constructor.apply(this, arguments);
	  }

	  View.prototype.template = viewTemplate;

	  View.prototype.ui = {
	    reps: '#reps',
	    touchspin: '#touchspin'
	  };

	  View.prototype.events = {
	    click: function(event) {
	      console.log('event');
	      event.preventDefault();
	    }
	  };

	  View.prototype.onRender = function() {};

	  return View;

	})(Marionette.ItemView);

	module.exports = View;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-sm-12\"><span class=\"lead\">Profile</span></div></div><br><div class=\"row\"><div class=\"col-sm-12\"><form class=\"form-horizontal\"><div class=\"form-group\"><label for=\"profile-name\" class=\"col-sm-2 control-label\">Name</label><div class=\"col-sm-10\"><input id=\"profile-name\" input=\"text\" class=\"form-control\"></div></div><div class=\"form-group\"><label for=\"profile-email\" class=\"col-sm-2 control-label\">Email</label><div class=\"col-sm-10\"><input id=\"profile-email\" input=\"text\" class=\"form-control\"></div></div><div class=\"form-group\"><label for=\"profile-password\" class=\"col-sm-2 control-label\">Password</label><div class=\"col-sm-10\"><input id=\"profile-password\" input=\"text\" class=\"form-control\"></div></div><div class=\"form-group\"><div class=\"col-sm-12\"><button class=\"btn btn-primary pull-right\"><i class=\"fa fa-cloud-upload\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Update</button></div></div></form></div></div>");;return buf.join("");
	}

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	module.exports.Master = __webpack_require__(38);


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Collection, InputView, Marionette, Model, TableView, View, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	InputView = __webpack_require__(39);

	TableView = __webpack_require__(43);

	viewTemplate = __webpack_require__(47);

	__webpack_require__(48);

	Model = (function(superClass) {
	  extend(Model, superClass);

	  function Model() {
	    return Model.__super__.constructor.apply(this, arguments);
	  }

	  Model.prototype.url = '/api/exercise';

	  Model.prototype.defaults = {
	    name: '',
	    type: 0,
	    note: '',
	    date: new Date()
	  };

	  return Model;

	})(Backbone.Model);

	Collection = (function(superClass) {
	  extend(Collection, superClass);

	  function Collection() {
	    return Collection.__super__.constructor.apply(this, arguments);
	  }

	  Collection.prototype.url = '/api/exercise';

	  Collection.prototype.model = Model;

	  Collection.prototype.mode = 'client';

	  Collection.prototype.state = {
	    currentPage: 1,
	    pageSize: 10
	  };

	  Collection.prototype.comparator = function(item) {
	    return -item.get('date');
	  };

	  return Collection;

	})(Backbone.PageableCollection);

	View = (function(superClass) {
	  extend(View, superClass);

	  View.prototype.template = viewTemplate;

	  View.prototype.ui = {
	    strength: '#exercise-strength'
	  };

	  View.prototype.regions = {
	    input: '#exercise-input-view',
	    table: '#exercise-table-view'
	  };

	  View.prototype.events = {
	    'click #exercise-back-home': function() {
	      this.rootChannel.request('home');
	    }
	  };

	  View.prototype.modelEvents = {
	    'change:type': function(model, value) {
	      this.filterCollection(value);
	    }
	  };

	  function View() {
	    View.__super__.constructor.apply(this, arguments);
	    this.rootChannel = Backbone.Radio.channel('root');
	    this.channel = Backbone.Radio.channel('channel');
	    this.fullCollection = this.collection.fullCollection.clone();
	  }

	  View.prototype.onShow = function() {
	    this.filterCollection(this.model.get('type'));
	    this.showChildView('input', new InputView({
	      collection: this.collection,
	      model: this.model
	    }));
	  };

	  View.prototype.filterCollection = function(type) {
	    this.fullCollection.fetch({
	      success: (function(_this) {
	        return function() {
	          var models;
	          models = _this.fullCollection.filter(function(model) {
	            return model.get('type') === type;
	          });
	          return _this.collection.fullCollection.reset(models);
	        };
	      })(this)
	    });
	  };

	  return View;

	})(Marionette.LayoutView);

	module.exports.Model = Model;

	module.exports.Collection = Collection;

	module.exports.View = View;


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Data, Marionette, View, _, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	_ = __webpack_require__(3);

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	Data = __webpack_require__(40);

	viewTemplate = __webpack_require__(41);

	__webpack_require__(42);

	__webpack_require__(19);

	View = (function(superClass) {
	  extend(View, superClass);

	  View.prototype.template = viewTemplate;

	  View.prototype.ui = {
	    type: '#exercise-type',
	    go: '#exercise-go'
	  };

	  View.prototype.bindings = {
	    '#exercise-type': {
	      observe: 'type',
	      onSet: function(value) {
	        return parseInt(value);
	      }
	    }
	  };

	  View.prototype.events = {
	    'click @ui.go': function(event) {
	      var label;
	      event.preventDefault();
	      label = _.find(Data.Types, {
	        value: this.model.get('type')
	      }).label;
	      this.rootChannel.request('exercise:detail', label.toLowerCase());
	    }
	  };

	  function View(options) {
	    View.__super__.constructor.apply(this, arguments);
	    this.mergeOptions(options, 'channel');
	    this.rootChannel = Backbone.Radio.channel('root');
	  }

	  View.prototype.onRender = function() {
	    var Exercises;
	    Exercises = [
	      {
	        value: 0,
	        label: '<i class="fa fa-lg fa-shield exercise-select"></i><b>&nbsp Strength</b>'
	      }, {
	        value: 1,
	        label: '<i class="fa fa-lg fa-bicycle exercise-select"></i><b>&nbsp Endurance</b>'
	      }, {
	        value: 2,
	        label: '<i class="fa fa-lg fa-heart exercise-select"></i><b>&nbsp Flexibility</b>'
	      }, {
	        value: 3,
	        label: '<i class="fa fa-lg fa-balance-scale exercise-select"></i><b>&nbsp Balance</b>'
	      }
	    ];
	    this.ui.type.multiselect({
	      enableFiltering: true,
	      buttonWidth: '100%',
	      buttonClass: 'btn btn-info',
	      enableHTML: true
	    }).multiselect('dataprovider', Exercises).multiselect('deselect', 0).multiselect('select', this.model.get('type'));
	    this.stickit();
	  };

	  View.prototype.onBeforeDestroy = function() {
	    this.ui.type.multiselect('destroy');
	  };

	  return View;

	})(Marionette.ItemView);

	module.exports = View;


/***/ },
/* 40 */
/***/ function(module, exports) {

	var Muscles, Types;

	Types = [
	  {
	    value: 0,
	    label: 'Strength'
	  }, {
	    value: 1,
	    label: 'Cardio'
	  }, {
	    value: 2,
	    label: 'Flexibility'
	  }, {
	    value: 3,
	    label: 'Balance'
	  }
	];

	Muscles = [
	  {
	    value: 0,
	    label: 'Abdominals'
	  }, {
	    value: 1,
	    label: 'Arms'
	  }, {
	    value: 2,
	    label: 'Back'
	  }, {
	    value: 3,
	    label: 'Biceps'
	  }, {
	    value: 4,
	    label: 'Calves'
	  }, {
	    value: 5,
	    label: 'Chest'
	  }, {
	    value: 6,
	    label: 'Forearms'
	  }, {
	    value: 7,
	    label: 'Glutes'
	  }, {
	    value: 8,
	    label: 'Hamstrings'
	  }, {
	    value: 9,
	    label: 'Lats'
	  }, {
	    value: 10,
	    label: 'Legs'
	  }, {
	    value: 11,
	    label: 'Neck'
	  }, {
	    value: 12,
	    label: 'Quadriceps'
	  }, {
	    value: 13,
	    label: 'Shoulders'
	  }, {
	    value: 14,
	    label: 'Traps'
	  }, {
	    value: 15,
	    label: 'Triceps'
	  }
	];

	module.exports.Types = Types;

	module.exports.Muscles = Muscles;


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-sm-12\"><span><b>Go to exercise</b></span></div></div><br><div class=\"row\"><div class=\"col-sm-12\"><form class=\"form-horizontal\"><div class=\"form-group\"><div class=\"col-sm-12\"><select id=\"exercise-type\" class=\"form-control\"></select></div></div><div class=\"form-group\"><div class=\"col-sm-12\"><button id=\"exercise-go\" class=\"btn btn-success pull-right\">Go" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "<i class=\"fa fa-lg fa-arrow-circle-right\"></i></button></div></div></form></div></div>");;return buf.join("");
	}

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var jQuery = __webpack_require__(2);

	/*** IMPORTS FROM imports-loader ***/
	var jQuery = __webpack_require__(2);

	/**
	 * Bootstrap Multiselect (https://github.com/davidstutz/bootstrap-multiselect)
	 * 
	 * Apache License, Version 2.0:
	 * Copyright (c) 2012 - 2015 David Stutz
	 * 
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
	 * use this file except in compliance with the License. You may obtain a
	 * copy of the License at http://www.apache.org/licenses/LICENSE-2.0
	 * 
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	 * License for the specific language governing permissions and limitations
	 * under the License.
	 * 
	 * BSD 3-Clause License:
	 * Copyright (c) 2012 - 2015 David Stutz
	 * All rights reserved.
	 * 
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *    - Redistributions of source code must retain the above copyright notice,
	 *      this list of conditions and the following disclaimer.
	 *    - Redistributions in binary form must reproduce the above copyright notice,
	 *      this list of conditions and the following disclaimer in the documentation
	 *      and/or other materials provided with the distribution.
	 *    - Neither the name of David Stutz nor the names of its contributors may be
	 *      used to endorse or promote products derived from this software without
	 *      specific prior written permission.
	 * 
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
	 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
	 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
	 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
	 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
	 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	!function ($) {
	    "use strict";// jshint ;_;

	    if (typeof ko !== 'undefined' && ko.bindingHandlers && !ko.bindingHandlers.multiselect) {
	        ko.bindingHandlers.multiselect = {
	            after: ['options', 'value', 'selectedOptions', 'enable', 'disable'],

	            init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
	                var $element = $(element);
	                var config = ko.toJS(valueAccessor());

	                $element.multiselect(config);

	                if (allBindings.has('options')) {
	                    var options = allBindings.get('options');
	                    if (ko.isObservable(options)) {
	                        ko.computed({
	                            read: function() {
	                                options();
	                                setTimeout(function() {
	                                    var ms = $element.data('multiselect');
	                                    if (ms)
	                                        ms.updateOriginalOptions();//Not sure how beneficial this is.
	                                    $element.multiselect('rebuild');
	                                }, 1);
	                            },
	                            disposeWhenNodeIsRemoved: element
	                        });
	                    }
	                }

	                //value and selectedOptions are two-way, so these will be triggered even by our own actions.
	                //It needs some way to tell if they are triggered because of us or because of outside change.
	                //It doesn't loop but it's a waste of processing.
	                if (allBindings.has('value')) {
	                    var value = allBindings.get('value');
	                    if (ko.isObservable(value)) {
	                        ko.computed({
	                            read: function() {
	                                value();
	                                setTimeout(function() {
	                                    $element.multiselect('refresh');
	                                }, 1);
	                            },
	                            disposeWhenNodeIsRemoved: element
	                        }).extend({ rateLimit: 100, notifyWhenChangesStop: true });
	                    }
	                }

	                //Switched from arrayChange subscription to general subscription using 'refresh'.
	                //Not sure performance is any better using 'select' and 'deselect'.
	                if (allBindings.has('selectedOptions')) {
	                    var selectedOptions = allBindings.get('selectedOptions');
	                    if (ko.isObservable(selectedOptions)) {
	                        ko.computed({
	                            read: function() {
	                                selectedOptions();
	                                setTimeout(function() {
	                                    $element.multiselect('refresh');
	                                }, 1);
	                            },
	                            disposeWhenNodeIsRemoved: element
	                        }).extend({ rateLimit: 100, notifyWhenChangesStop: true });
	                    }
	                }

	                var setEnabled = function (enable) {
	                    setTimeout(function () {
	                        if (enable)
	                            $element.multiselect('enable');
	                        else
	                            $element.multiselect('disable');
	                    });
	                };

	                if (allBindings.has('enable')) {
	                    var enable = allBindings.get('enable');
	                    if (ko.isObservable(enable)) {
	                        ko.computed({
	                            read: function () {
	                                setEnabled(enable());
	                            },
	                            disposeWhenNodeIsRemoved: element
	                        }).extend({ rateLimit: 100, notifyWhenChangesStop: true });
	                    } else {
	                        setEnabled(enable);
	                    }
	                }

	                if (allBindings.has('disable')) {
	                    var disable = allBindings.get('disable');
	                    if (ko.isObservable(disable)) {
	                        ko.computed({
	                            read: function () {
	                                setEnabled(!disable());
	                            },
	                            disposeWhenNodeIsRemoved: element
	                        }).extend({ rateLimit: 100, notifyWhenChangesStop: true });
	                    } else {
	                        setEnabled(!disable);
	                    }
	                }

	                ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
	                    $element.multiselect('destroy');
	                });
	            },

	            update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
	                var $element = $(element);
	                var config = ko.toJS(valueAccessor());

	                $element.multiselect('setOptions', config);
	                $element.multiselect('rebuild');
	            }
	        };
	    }

	    function forEach(array, callback) {
	        for (var index = 0; index < array.length; ++index) {
	            callback(array[index], index);
	        }
	    }

	    /**
	     * Constructor to create a new multiselect using the given select.
	     *
	     * @param {jQuery} select
	     * @param {Object} options
	     * @returns {Multiselect}
	     */
	    function Multiselect(select, options) {

	        this.$select = $(select);
	        
	        // Placeholder via data attributes
	        if (this.$select.attr("data-placeholder")) {
	            options.nonSelectedText = this.$select.data("placeholder");
	        }
	        
	        this.options = this.mergeOptions($.extend({}, options, this.$select.data()));

	        // Initialization.
	        // We have to clone to create a new reference.
	        this.originalOptions = this.$select.clone()[0].options;
	        this.query = '';
	        this.searchTimeout = null;
	        this.lastToggledInput = null;

	        this.options.multiple = this.$select.attr('multiple') === "multiple";
	        this.options.onChange = $.proxy(this.options.onChange, this);
	        this.options.onDropdownShow = $.proxy(this.options.onDropdownShow, this);
	        this.options.onDropdownHide = $.proxy(this.options.onDropdownHide, this);
	        this.options.onDropdownShown = $.proxy(this.options.onDropdownShown, this);
	        this.options.onDropdownHidden = $.proxy(this.options.onDropdownHidden, this);
	        this.options.onInitialized = $.proxy(this.options.onInitialized, this);
	        
	        // Build select all if enabled.
	        this.buildContainer();
	        this.buildButton();
	        this.buildDropdown();
	        this.buildSelectAll();
	        this.buildDropdownOptions();
	        this.buildFilter();

	        this.updateButtonText();
	        this.updateSelectAll(true);

	        if (this.options.disableIfEmpty && $('option', this.$select).length <= 0) {
	            this.disable();
	        }
	        
	        this.$select.hide().after(this.$container);
	        this.options.onInitialized(this.$select, this.$container);
	    }

	    Multiselect.prototype = {

	        defaults: {
	            /**
	             * Default text function will either print 'None selected' in case no
	             * option is selected or a list of the selected options up to a length
	             * of 3 selected options.
	             * 
	             * @param {jQuery} options
	             * @param {jQuery} select
	             * @returns {String}
	             */
	            buttonText: function(options, select) {
	                if (this.disabledText.length > 0 
	                        && (this.disableIfEmpty || select.prop('disabled')) 
	                        && options.length == 0) {
	                    
	                    return this.disabledText;
	                }
	                else if (options.length === 0) {
	                    return this.nonSelectedText;
	                }
	                else if (this.allSelectedText 
	                        && options.length === $('option', $(select)).length 
	                        && $('option', $(select)).length !== 1 
	                        && this.multiple) {

	                    if (this.selectAllNumber) {
	                        return this.allSelectedText + ' (' + options.length + ')';
	                    }
	                    else {
	                        return this.allSelectedText;
	                    }
	                }
	                else if (options.length > this.numberDisplayed) {
	                    return options.length + ' ' + this.nSelectedText;
	                }
	                else {
	                    var selected = '';
	                    var delimiter = this.delimiterText;
	                    
	                    options.each(function() {
	                        var label = ($(this).attr('label') !== undefined) ? $(this).attr('label') : $(this).text();
	                        selected += label + delimiter;
	                    });
	                    
	                    return selected.substr(0, selected.length - 2);
	                }
	            },
	            /**
	             * Updates the title of the button similar to the buttonText function.
	             * 
	             * @param {jQuery} options
	             * @param {jQuery} select
	             * @returns {@exp;selected@call;substr}
	             */
	            buttonTitle: function(options, select) {
	                if (options.length === 0) {
	                    return this.nonSelectedText;
	                }
	                else {
	                    var selected = '';
	                    var delimiter = this.delimiterText;
	                    
	                    options.each(function () {
	                        var label = ($(this).attr('label') !== undefined) ? $(this).attr('label') : $(this).text();
	                        selected += label + delimiter;
	                    });
	                    return selected.substr(0, selected.length - 2);
	                }
	            },
	            /**
	             * Create a label.
	             *
	             * @param {jQuery} element
	             * @returns {String}
	             */
	            optionLabel: function(element){
	                return $(element).attr('label') || $(element).text();
	            },
	            /**
	             * Create a class.
	             *
	             * @param {jQuery} element
	             * @returns {String}
	             */
	            optionClass: function(element) {
	                return $(element).attr('class') || '';
	            },
	            /**
	             * Triggered on change of the multiselect.
	             * 
	             * Not triggered when selecting/deselecting options manually.
	             * 
	             * @param {jQuery} option
	             * @param {Boolean} checked
	             */
	            onChange : function(option, checked) {

	            },
	            /**
	             * Triggered when the dropdown is shown.
	             *
	             * @param {jQuery} event
	             */
	            onDropdownShow: function(event) {

	            },
	            /**
	             * Triggered when the dropdown is hidden.
	             *
	             * @param {jQuery} event
	             */
	            onDropdownHide: function(event) {

	            },
	            /**
	             * Triggered after the dropdown is shown.
	             * 
	             * @param {jQuery} event
	             */
	            onDropdownShown: function(event) {
	                
	            },
	            /**
	             * Triggered after the dropdown is hidden.
	             * 
	             * @param {jQuery} event
	             */
	            onDropdownHidden: function(event) {
	                
	            },
	            /**
	             * Triggered on select all.
	             */
	            onSelectAll: function(checked) {
	                
	            },
	            /**
	             * Triggered after initializing.
	             *
	             * @param {jQuery} $select
	             * @param {jQuery} $container
	             */
	            onInitialized: function($select, $container) {

	            },
	            enableHTML: false,
	            buttonClass: 'btn btn-default',
	            inheritClass: false,
	            buttonWidth: 'auto',
	            buttonContainer: '<div class="btn-group" />',
	            dropRight: false,
	            dropUp: false,
	            selectedClass: 'active',
	            // Maximum height of the dropdown menu.
	            // If maximum height is exceeded a scrollbar will be displayed.
	            maxHeight: false,
	            checkboxName: false,
	            includeSelectAllOption: false,
	            includeSelectAllIfMoreThan: 0,
	            selectAllText: ' Select all',
	            selectAllValue: 'multiselect-all',
	            selectAllName: false,
	            selectAllNumber: true,
	            selectAllJustVisible: true,
	            enableFiltering: false,
	            enableCaseInsensitiveFiltering: false,
	            enableFullValueFiltering: false,
	            enableClickableOptGroups: false,
	            enableCollapsibelOptGroups: false,
	            filterPlaceholder: 'Search',
	            // possible options: 'text', 'value', 'both'
	            filterBehavior: 'text',
	            includeFilterClearBtn: true,
	            preventInputChangeEvent: false,
	            nonSelectedText: 'None selected',
	            nSelectedText: 'selected',
	            allSelectedText: 'All selected',
	            numberDisplayed: 3,
	            disableIfEmpty: false,
	            disabledText: '',
	            delimiterText: ', ',
	            templates: {
	                button: '<button type="button" class="multiselect dropdown-toggle" data-toggle="dropdown"><span class="multiselect-selected-text"></span> <b class="caret"></b></button>',
	                ul: '<ul class="multiselect-container dropdown-menu"></ul>',
	                filter: '<li class="multiselect-item filter"><div class="input-group"><span class="input-group-addon"><i class="glyphicon glyphicon-search"></i></span><input class="form-control multiselect-search" type="text"></div></li>',
	                filterClearBtn: '<span class="input-group-btn"><button class="btn btn-default multiselect-clear-filter" type="button"><i class="glyphicon glyphicon-remove-circle"></i></button></span>',
	                li: '<li><a tabindex="0"><label></label></a></li>',
	                divider: '<li class="multiselect-item divider"></li>',
	                liGroup: '<li class="multiselect-item multiselect-group"><label></label></li>'
	            }
	        },

	        constructor: Multiselect,

	        /**
	         * Builds the container of the multiselect.
	         */
	        buildContainer: function() {
	            this.$container = $(this.options.buttonContainer);
	            this.$container.on('show.bs.dropdown', this.options.onDropdownShow);
	            this.$container.on('hide.bs.dropdown', this.options.onDropdownHide);
	            this.$container.on('shown.bs.dropdown', this.options.onDropdownShown);
	            this.$container.on('hidden.bs.dropdown', this.options.onDropdownHidden);
	        },

	        /**
	         * Builds the button of the multiselect.
	         */
	        buildButton: function() {
	            this.$button = $(this.options.templates.button).addClass(this.options.buttonClass);
	            if (this.$select.attr('class') && this.options.inheritClass) {
	                this.$button.addClass(this.$select.attr('class'));
	            }
	            // Adopt active state.
	            if (this.$select.prop('disabled')) {
	                this.disable();
	            }
	            else {
	                this.enable();
	            }

	            // Manually add button width if set.
	            if (this.options.buttonWidth && this.options.buttonWidth !== 'auto') {
	                this.$button.css({
	                    'width' : this.options.buttonWidth,
	                    'overflow' : 'hidden',
	                    'text-overflow' : 'ellipsis'
	                });
	                this.$container.css({
	                    'width': this.options.buttonWidth
	                });
	            }

	            // Keep the tab index from the select.
	            var tabindex = this.$select.attr('tabindex');
	            if (tabindex) {
	                this.$button.attr('tabindex', tabindex);
	            }

	            this.$container.prepend(this.$button);
	        },

	        /**
	         * Builds the ul representing the dropdown menu.
	         */
	        buildDropdown: function() {

	            // Build ul.
	            this.$ul = $(this.options.templates.ul);

	            if (this.options.dropRight) {
	                this.$ul.addClass('pull-right');
	            }

	            // Set max height of dropdown menu to activate auto scrollbar.
	            if (this.options.maxHeight) {
	                // TODO: Add a class for this option to move the css declarations.
	                this.$ul.css({
	                    'max-height': this.options.maxHeight + 'px',
	                    'overflow-y': 'auto',
	                    'overflow-x': 'hidden'
	                });
	            }
	            
	            if (this.options.dropUp) {
	                
	                var height = Math.min(this.options.maxHeight, $('option[data-role!="divider"]', this.$select).length*26 + $('option[data-role="divider"]', this.$select).length*19 + (this.options.includeSelectAllOption ? 26 : 0) + (this.options.enableFiltering || this.options.enableCaseInsensitiveFiltering ? 44 : 0));
	                var moveCalc = height + 34;
	                
	                this.$ul.css({
	                    'max-height': height + 'px',
	                    'overflow-y': 'auto',
	                    'overflow-x': 'hidden',
	                    'margin-top': "-" + moveCalc + 'px'
	                });
	            }
	            
	            this.$container.append(this.$ul);
	        },

	        /**
	         * Build the dropdown options and binds all nessecary events.
	         * 
	         * Uses createDivider and createOptionValue to create the necessary options.
	         */
	        buildDropdownOptions: function() {

	            this.$select.children().each($.proxy(function(index, element) {

	                var $element = $(element);
	                // Support optgroups and options without a group simultaneously.
	                var tag = $element.prop('tagName')
	                    .toLowerCase();
	            
	                if ($element.prop('value') === this.options.selectAllValue) {
	                    return;
	                }

	                if (tag === 'optgroup') {
	                    this.createOptgroup(element);
	                }
	                else if (tag === 'option') {

	                    if ($element.data('role') === 'divider') {
	                        this.createDivider();
	                    }
	                    else {
	                        this.createOptionValue(element);
	                    }

	                }

	                // Other illegal tags will be ignored.
	            }, this));

	            // Bind the change event on the dropdown elements.
	            $('li input', this.$ul).on('change', $.proxy(function(event) {
	                var $target = $(event.target);

	                var checked = $target.prop('checked') || false;
	                var isSelectAllOption = $target.val() === this.options.selectAllValue;

	                // Apply or unapply the configured selected class.
	                if (this.options.selectedClass) {
	                    if (checked) {
	                        $target.closest('li')
	                            .addClass(this.options.selectedClass);
	                    }
	                    else {
	                        $target.closest('li')
	                            .removeClass(this.options.selectedClass);
	                    }
	                }

	                // Get the corresponding option.
	                var value = $target.val();
	                var $option = this.getOptionByValue(value);

	                var $optionsNotThis = $('option', this.$select).not($option);
	                var $checkboxesNotThis = $('input', this.$container).not($target);

	                if (isSelectAllOption) {
	                    if (checked) {
	                        this.selectAll(this.options.selectAllJustVisible);
	                    }
	                    else {
	                        this.deselectAll(this.options.selectAllJustVisible);
	                    }
	                }
	                else {
	                    if (checked) {
	                        $option.prop('selected', true);

	                        if (this.options.multiple) {
	                            // Simply select additional option.
	                            $option.prop('selected', true);
	                        }
	                        else {
	                            // Unselect all other options and corresponding checkboxes.
	                            if (this.options.selectedClass) {
	                                $($checkboxesNotThis).closest('li').removeClass(this.options.selectedClass);
	                            }

	                            $($checkboxesNotThis).prop('checked', false);
	                            $optionsNotThis.prop('selected', false);

	                            // It's a single selection, so close.
	                            this.$button.click();
	                        }

	                        if (this.options.selectedClass === "active") {
	                            $optionsNotThis.closest("a").css("outline", "");
	                        }
	                    }
	                    else {
	                        // Unselect option.
	                        $option.prop('selected', false);
	                    }
	                    
	                    // To prevent select all from firing onChange: #575
	                    this.options.onChange($option, checked);
	                }

	                this.$select.change();

	                this.updateButtonText();
	                this.updateSelectAll();

	                if(this.options.preventInputChangeEvent) {
	                    return false;
	                }
	            }, this));

	            $('li a', this.$ul).on('mousedown', function(e) {
	                if (e.shiftKey) {
	                    // Prevent selecting text by Shift+click
	                    return false;
	                }
	            });
	        
	            $('li a', this.$ul).on('touchstart click', $.proxy(function(event) {
	                event.stopPropagation();

	                var $target = $(event.target);
	                
	                if (event.shiftKey && this.options.multiple) {
	                    if($target.is("label")){ // Handles checkbox selection manually (see https://github.com/davidstutz/bootstrap-multiselect/issues/431)
	                        event.preventDefault();
	                        $target = $target.find("input");
	                        $target.prop("checked", !$target.prop("checked"));
	                    }
	                    var checked = $target.prop('checked') || false;

	                    if (this.lastToggledInput !== null && this.lastToggledInput !== $target) { // Make sure we actually have a range
	                        var from = $target.closest("li").index();
	                        var to = this.lastToggledInput.closest("li").index();
	                        
	                        if (from > to) { // Swap the indices
	                            var tmp = to;
	                            to = from;
	                            from = tmp;
	                        }
	                        
	                        // Make sure we grab all elements since slice excludes the last index
	                        ++to;
	                        
	                        // Change the checkboxes and underlying options
	                        var range = this.$ul.find("li").slice(from, to).find("input");
	                        
	                        range.prop('checked', checked);
	                        
	                        if (this.options.selectedClass) {
	                            range.closest('li')
	                                .toggleClass(this.options.selectedClass, checked);
	                        }
	                        
	                        for (var i = 0, j = range.length; i < j; i++) {
	                            var $checkbox = $(range[i]);

	                            var $option = this.getOptionByValue($checkbox.val());

	                            $option.prop('selected', checked);
	                        }                   
	                    }
	                    
	                    // Trigger the select "change" event
	                    $target.trigger("change");
	                }
	                
	                // Remembers last clicked option
	                if($target.is("input") && !$target.closest("li").is(".multiselect-item")){
	                    this.lastToggledInput = $target;
	                }

	                $target.blur();
	            }, this));

	            // Keyboard support.
	            this.$container.off('keydown.multiselect').on('keydown.multiselect', $.proxy(function(event) {
	                if ($('input[type="text"]', this.$container).is(':focus')) {
	                    return;
	                }

	                if (event.keyCode === 9 && this.$container.hasClass('open')) {
	                    this.$button.click();
	                }
	                else {
	                    var $items = $(this.$container).find("li:not(.divider):not(.disabled) a").filter(":visible");

	                    if (!$items.length) {
	                        return;
	                    }

	                    var index = $items.index($items.filter(':focus'));

	                    // Navigation up.
	                    if (event.keyCode === 38 && index > 0) {
	                        index--;
	                    }
	                    // Navigate down.
	                    else if (event.keyCode === 40 && index < $items.length - 1) {
	                        index++;
	                    }
	                    else if (!~index) {
	                        index = 0;
	                    }

	                    var $current = $items.eq(index);
	                    $current.focus();

	                    if (event.keyCode === 32 || event.keyCode === 13) {
	                        var $checkbox = $current.find('input');

	                        $checkbox.prop("checked", !$checkbox.prop("checked"));
	                        $checkbox.change();
	                    }

	                    event.stopPropagation();
	                    event.preventDefault();
	                }
	            }, this));

	            if(this.options.enableClickableOptGroups && this.options.multiple) {
	                $('li.multiselect-group', this.$ul).on('click', $.proxy(function(event) {
	                    event.stopPropagation();
	                    console.log('test');
	                    var group = $(event.target).parent();

	                    // Search all option in optgroup
	                    var $options = group.nextUntil('li.multiselect-group');
	                    var $visibleOptions = $options.filter(":visible:not(.disabled)");

	                    // check or uncheck items
	                    var allChecked = true;
	                    var optionInputs = $visibleOptions.find('input');
	                    var values = [];
	                    
	                    optionInputs.each(function() {
	                        allChecked = allChecked && $(this).prop('checked');
	                        values.push($(this).val());
	                    });

	                    if (!allChecked) {
	                        this.select(values, false);
	                    }
	                    else {
	                        this.deselect(values, false);
	                    }
	                    
	                    this.options.onChange(optionInputs, !allChecked);
	               }, this));
	            }

	            if (this.options.enableCollapsibleOptGroups && this.options.multiple) {
	                $("li.multiselect-group input", this.$ul).off();
	                $("li.multiselect-group", this.$ul).siblings().not("li.multiselect-group, li.multiselect-all", this.$ul).each( function () {
	                    $(this).toggleClass('hidden', true);
	                });
	                
	                $("li.multiselect-group", this.$ul).on("click", $.proxy(function(group) {
	                    group.stopPropagation();
	                }, this));
	                
	                $("li.multiselect-group > a > b", this.$ul).on("click", $.proxy(function(t) {
	                    t.stopPropagation();
	                    var n = $(t.target).closest('li');
	                    var r = n.nextUntil("li.multiselect-group");
	                    var i = true;
	                    
	                    r.each(function() {
	                        i = i && $(this).hasClass('hidden');
	                    });
	                    
	                    r.toggleClass('hidden', !i);
	                }, this));
	                
	                $("li.multiselect-group > a > input", this.$ul).on("change", $.proxy(function(t) {
	                    t.stopPropagation();
	                    var n = $(t.target).closest('li');
	                    var r = n.nextUntil("li.multiselect-group", ':not(.disabled)');
	                    var s = r.find("input");
	                    
	                    var i = true;
	                    s.each(function() {
	                        i = i && $(this).prop("checked");
	                    });
	                    
	                    s.prop("checked", !i).trigger("change");
	                }, this));
	                
	                // Set the initial selection state of the groups.
	                $('li.multiselect-group', this.$ul).each(function() {
	                    var r = $(this).nextUntil("li.multiselect-group", ':not(.disabled)');
	                    var s = r.find("input");
	                    
	                    var i = true;
	                    s.each(function() {
	                        i = i && $(this).prop("checked");
	                    });
	                    
	                    $(this).find('input').prop("checked", i);
	                });
	                
	                // Update the group checkbox based on new selections among the
	                // corresponding children.
	                $("li input", this.$ul).on("change", $.proxy(function(t) {
	                    t.stopPropagation();
	                    var n = $(t.target).closest('li');
	                    var r1 = n.prevUntil("li.multiselect-group", ':not(.disabled)');
	                    var r2 = n.nextUntil("li.multiselect-group", ':not(.disabled)');
	                    var s1 = r1.find("input");
	                    var s2 = r2.find("input");
	                    
	                    var i = $(t.target).prop('checked');
	                    s1.each(function() {
	                        i = i && $(this).prop("checked");
	                    });
	                    
	                    s2.each(function() {
	                        i = i && $(this).prop("checked");
	                    });
	                    
	                    n.prevAll('.multiselect-group').find('input').prop('checked', i);
	                }, this));
	                
	                $("li.multiselect-all", this.$ul).css('background', '#f3f3f3').css('border-bottom', '1px solid #eaeaea');
	                $("li.multiselect-group > a, li.multiselect-all > a > label.checkbox", this.$ul).css('padding', '3px 20px 3px 35px');
	                $("li.multiselect-group > a > input", this.$ul).css('margin', '4px 0px 5px -20px');
	            }
	        },

	        /**
	         * Create an option using the given select option.
	         *
	         * @param {jQuery} element
	         */
	        createOptionValue: function(element) {
	            var $element = $(element);
	            if ($element.is(':selected')) {
	                $element.prop('selected', true);
	            }

	            // Support the label attribute on options.
	            var label = this.options.optionLabel(element);
	            var classes = this.options.optionClass(element);
	            var value = $element.val();
	            var inputType = this.options.multiple ? "checkbox" : "radio";

	            var $li = $(this.options.templates.li);
	            var $label = $('label', $li);
	            $label.addClass(inputType);
	            $li.addClass(classes);

	            if (this.options.enableHTML) {
	                $label.html(" " + label);
	            }
	            else {
	                $label.text(" " + label);
	            }
	        
	            var $checkbox = $('<input/>').attr('type', inputType);

	            if (this.options.checkboxName) {
	                $checkbox.attr('name', this.options.checkboxName);
	            }
	            $label.prepend($checkbox);

	            var selected = $element.prop('selected') || false;
	            $checkbox.val(value);

	            if (value === this.options.selectAllValue) {
	                $li.addClass("multiselect-item multiselect-all");
	                $checkbox.parent().parent()
	                    .addClass('multiselect-all');
	            }

	            $label.attr('title', $element.attr('title'));

	            this.$ul.append($li);

	            if ($element.is(':disabled')) {
	                $checkbox.attr('disabled', 'disabled')
	                    .prop('disabled', true)
	                    .closest('a')
	                    .attr("tabindex", "-1")
	                    .closest('li')
	                    .addClass('disabled');
	            }

	            $checkbox.prop('checked', selected);

	            if (selected && this.options.selectedClass) {
	                $checkbox.closest('li')
	                    .addClass(this.options.selectedClass);
	            }
	        },

	        /**
	         * Creates a divider using the given select option.
	         *
	         * @param {jQuery} element
	         */
	        createDivider: function(element) {
	            var $divider = $(this.options.templates.divider);
	            this.$ul.append($divider);
	        },

	        /**
	         * Creates an optgroup.
	         *
	         * @param {jQuery} group
	         */
	        createOptgroup: function(group) {            
	            if (this.options.enableCollapsibleOptGroups && this.options.multiple) {
	                var label = $(group).attr("label");
	                var value = $(group).attr("value");
	                var r = $('<li class="multiselect-item multiselect-group"><a href="javascript:void(0);"><input type="checkbox" value="' + value + '"/><b> ' + label + '<b class="caret"></b></b></a></li>');

	                if (this.options.enableClickableOptGroups) {
	                    r.addClass("multiselect-group-clickable")
	                }
	                this.$ul.append(r);
	                if ($(group).is(":disabled")) {
	                    r.addClass("disabled")
	                }
	                $("option", group).each($.proxy(function($, group) {
	                    this.createOptionValue(group)
	                }, this))
	            }
	            else {
	                var groupName = $(group).prop('label');

	                // Add a header for the group.
	                var $li = $(this.options.templates.liGroup);

	                if (this.options.enableHTML) {
	                    $('label', $li).html(groupName);
	                }
	                else {
	                    $('label', $li).text(groupName);
	                }

	                if (this.options.enableClickableOptGroups) {
	                    $li.addClass('multiselect-group-clickable');
	                }

	                this.$ul.append($li);

	                if ($(group).is(':disabled')) {
	                    $li.addClass('disabled');
	                }

	                // Add the options of the group.
	                $('option', group).each($.proxy(function(index, element) {
	                    this.createOptionValue(element);
	                }, this));
	            }
	        },

	        /**
	         * Build the select all.
	         * 
	         * Checks if a select all has already been created.
	         */
	        buildSelectAll: function() {
	            if (typeof this.options.selectAllValue === 'number') {
	                this.options.selectAllValue = this.options.selectAllValue.toString();
	            }
	            
	            var alreadyHasSelectAll = this.hasSelectAll();

	            if (!alreadyHasSelectAll && this.options.includeSelectAllOption && this.options.multiple
	                    && $('option', this.$select).length > this.options.includeSelectAllIfMoreThan) {

	                // Check whether to add a divider after the select all.
	                if (this.options.includeSelectAllDivider) {
	                    this.$ul.prepend($(this.options.templates.divider));
	                }

	                var $li = $(this.options.templates.li);
	                $('label', $li).addClass("checkbox");
	                
	                if (this.options.enableHTML) {
	                    $('label', $li).html(" " + this.options.selectAllText);
	                }
	                else {
	                    $('label', $li).text(" " + this.options.selectAllText);
	                }
	                
	                if (this.options.selectAllName) {
	                    $('label', $li).prepend('<input type="checkbox" name="' + this.options.selectAllName + '" />');
	                }
	                else {
	                    $('label', $li).prepend('<input type="checkbox" />');
	                }
	                
	                var $checkbox = $('input', $li);
	                $checkbox.val(this.options.selectAllValue);

	                $li.addClass("multiselect-item multiselect-all");
	                $checkbox.parent().parent()
	                    .addClass('multiselect-all');

	                this.$ul.prepend($li);

	                $checkbox.prop('checked', false);
	            }
	        },

	        /**
	         * Builds the filter.
	         */
	        buildFilter: function() {

	            // Build filter if filtering OR case insensitive filtering is enabled and the number of options exceeds (or equals) enableFilterLength.
	            if (this.options.enableFiltering || this.options.enableCaseInsensitiveFiltering) {
	                var enableFilterLength = Math.max(this.options.enableFiltering, this.options.enableCaseInsensitiveFiltering);

	                if (this.$select.find('option').length >= enableFilterLength) {

	                    this.$filter = $(this.options.templates.filter);
	                    $('input', this.$filter).attr('placeholder', this.options.filterPlaceholder);
	                    
	                    // Adds optional filter clear button
	                    if(this.options.includeFilterClearBtn){
	                        var clearBtn = $(this.options.templates.filterClearBtn);
	                        clearBtn.on('click', $.proxy(function(event){
	                            clearTimeout(this.searchTimeout);
	                            this.$filter.find('.multiselect-search').val('');
	                            $('li', this.$ul).show().removeClass("filter-hidden");
	                            this.updateSelectAll();
	                        }, this));
	                        this.$filter.find('.input-group').append(clearBtn);
	                    }
	                    
	                    this.$ul.prepend(this.$filter);

	                    this.$filter.val(this.query).on('click', function(event) {
	                        event.stopPropagation();
	                    }).on('input keydown', $.proxy(function(event) {
	                        // Cancel enter key default behaviour
	                        if (event.which === 13) {
	                          event.preventDefault();
	                        }
	                        
	                        // This is useful to catch "keydown" events after the browser has updated the control.
	                        clearTimeout(this.searchTimeout);

	                        this.searchTimeout = this.asyncFunction($.proxy(function() {

	                            if (this.query !== event.target.value) {
	                                this.query = event.target.value;

	                                var currentGroup, currentGroupVisible;
	                                $.each($('li', this.$ul), $.proxy(function(index, element) {
	                                    var value = $('input', element).length > 0 ? $('input', element).val() : "";
	                                    var text = $('label', element).text();

	                                    var filterCandidate = '';
	                                    if ((this.options.filterBehavior === 'text')) {
	                                        filterCandidate = text;
	                                    }
	                                    else if ((this.options.filterBehavior === 'value')) {
	                                        filterCandidate = value;
	                                    }
	                                    else if (this.options.filterBehavior === 'both') {
	                                        filterCandidate = text + '\n' + value;
	                                    }

	                                    if (value !== this.options.selectAllValue && text) {

	                                        // By default lets assume that element is not
	                                        // interesting for this search.
	                                        var showElement = false;

	                                        if (this.options.enableCaseInsensitiveFiltering) {
	                                            filterCandidate = filterCandidate.toLowerCase();
	                                            this.query = this.query.toLowerCase();
	                                        }

	                                        if (this.options.enableFullValueFiltering && this.options.filterBehavior !== 'both') {
	                                            var valueToMatch = filterCandidate.trim().substring(0, this.query.length);
	                                            if (this.query.indexOf(valueToMatch) > -1) {
	                                                showElement = true;
	                                            }
	                                        }
	                                        else if (filterCandidate.indexOf(this.query) > -1) {
	                                            showElement = true;
	                                        }

	                                        // Toggle current element (group or group item) according to showElement boolean.
	                                        $(element).toggle(showElement).toggleClass('filter-hidden', !showElement);
	                                        
	                                        // Differentiate groups and group items.
	                                        if ($(element).hasClass('multiselect-group')) {
	                                            // Remember group status.
	                                            currentGroup = element;
	                                            currentGroupVisible = showElement;
	                                        }
	                                        else {
	                                            // Show group name when at least one of its items is visible.
	                                            if (showElement) {
	                                                $(currentGroup).show().removeClass('filter-hidden');
	                                            }
	                                            
	                                            // Show all group items when group name satisfies filter.
	                                            if (!showElement && currentGroupVisible) {
	                                                $(element).show().removeClass('filter-hidden');
	                                            }
	                                        }
	                                    }
	                                }, this));
	                            }

	                            this.updateSelectAll();
	                        }, this), 300, this);
	                    }, this));
	                }
	            }
	        },

	        /**
	         * Unbinds the whole plugin.
	         */
	        destroy: function() {
	            this.$container.remove();
	            this.$select.show();
	            this.$select.data('multiselect', null);
	        },

	        /**
	         * Refreshs the multiselect based on the selected options of the select.
	         */
	        refresh: function () {
	            var inputs = $.map($('li input', this.$ul), $);
	            
	            $('option', this.$select).each($.proxy(function (index, element) {
	                var $elem = $(element);
	                var value = $elem.val();
	                var $input;
	                for (var i = inputs.length; 0 < i--; /**/) {
	                    if (value !== ($input = inputs[i]).val())
	                        continue; // wrong li

	                    if ($elem.is(':selected')) {
	                        $input.prop('checked', true);

	                        if (this.options.selectedClass) {
	                            $input.closest('li')
	                                .addClass(this.options.selectedClass);
	                        }
	                    }
	                    else {
	                        $input.prop('checked', false);

	                        if (this.options.selectedClass) {
	                            $input.closest('li')
	                                .removeClass(this.options.selectedClass);
	                        }
	                    }

	                    if ($elem.is(":disabled")) {
	                        $input.attr('disabled', 'disabled')
	                            .prop('disabled', true)
	                            .closest('li')
	                            .addClass('disabled');
	                    }
	                    else {
	                        $input.prop('disabled', false)
	                            .closest('li')
	                            .removeClass('disabled');
	                    }
	                    break; // assumes unique values
	                }
	            }, this));

	            this.updateButtonText();
	            this.updateSelectAll();
	        },

	        /**
	         * Select all options of the given values.
	         * 
	         * If triggerOnChange is set to true, the on change event is triggered if
	         * and only if one value is passed.
	         * 
	         * @param {Array} selectValues
	         * @param {Boolean} triggerOnChange
	         */
	        select: function(selectValues, triggerOnChange) {
	            if(!$.isArray(selectValues)) {
	                selectValues = [selectValues];
	            }

	            for (var i = 0; i < selectValues.length; i++) {
	                var value = selectValues[i];

	                if (value === null || value === undefined) {
	                    continue;
	                }

	                var $option = this.getOptionByValue(value);
	                var $checkbox = this.getInputByValue(value);

	                if($option === undefined || $checkbox === undefined) {
	                    continue;
	                }
	                
	                if (!this.options.multiple) {
	                    this.deselectAll(false);
	                }
	                
	                if (this.options.selectedClass) {
	                    $checkbox.closest('li')
	                        .addClass(this.options.selectedClass);
	                }

	                $checkbox.prop('checked', true);
	                $option.prop('selected', true);
	                
	                if (triggerOnChange) {
	                    this.options.onChange($option, true);
	                }
	            }

	            this.updateButtonText();
	            this.updateSelectAll();
	        },

	        /**
	         * Clears all selected items.
	         */
	        clearSelection: function () {
	            this.deselectAll(false);
	            this.updateButtonText();
	            this.updateSelectAll();
	        },

	        /**
	         * Deselects all options of the given values.
	         * 
	         * If triggerOnChange is set to true, the on change event is triggered, if
	         * and only if one value is passed.
	         * 
	         * @param {Array} deselectValues
	         * @param {Boolean} triggerOnChange
	         */
	        deselect: function(deselectValues, triggerOnChange) {
	            if(!$.isArray(deselectValues)) {
	                deselectValues = [deselectValues];
	            }

	            for (var i = 0; i < deselectValues.length; i++) {
	                var value = deselectValues[i];

	                if (value === null || value === undefined) {
	                    continue;
	                }

	                var $option = this.getOptionByValue(value);
	                var $checkbox = this.getInputByValue(value);

	                if($option === undefined || $checkbox === undefined) {
	                    continue;
	                }

	                if (this.options.selectedClass) {
	                    $checkbox.closest('li')
	                        .removeClass(this.options.selectedClass);
	                }

	                $checkbox.prop('checked', false);
	                $option.prop('selected', false);
	                
	                if (triggerOnChange) {
	                    this.options.onChange($option, false);
	                }
	            }

	            this.updateButtonText();
	            this.updateSelectAll();
	        },
	        
	        /**
	         * Selects all enabled & visible options.
	         *
	         * If justVisible is true or not specified, only visible options are selected.
	         *
	         * @param {Boolean} justVisible
	         * @param {Boolean} triggerOnSelectAll
	         */
	        selectAll: function (justVisible, triggerOnSelectAll) {
	            justVisible = (this.options.enableCollapsibleOptGroups && this.options.multiple) ? false : justVisible;
	            
	            var justVisible = typeof justVisible === 'undefined' ? true : justVisible;
	            var allCheckboxes = $("li input[type='checkbox']:enabled", this.$ul);
	            var visibleCheckboxes = allCheckboxes.filter(":visible");
	            var allCheckboxesCount = allCheckboxes.length;
	            var visibleCheckboxesCount = visibleCheckboxes.length;
	            
	            if(justVisible) {
	                visibleCheckboxes.prop('checked', true);
	                $("li:not(.divider):not(.disabled)", this.$ul).filter(":visible").addClass(this.options.selectedClass);
	            }
	            else {
	                allCheckboxes.prop('checked', true);
	                $("li:not(.divider):not(.disabled)", this.$ul).addClass(this.options.selectedClass);
	            }
	                
	            if (allCheckboxesCount === visibleCheckboxesCount || justVisible === false) {
	                $("option:not([data-role='divider']):enabled", this.$select).prop('selected', true);
	            }
	            else {
	                var values = visibleCheckboxes.map(function() {
	                    return $(this).val();
	                }).get();
	                
	                $("option:enabled", this.$select).filter(function(index) {
	                    return $.inArray($(this).val(), values) !== -1;
	                }).prop('selected', true);
	            }
	            
	            if (triggerOnSelectAll) {
	                this.options.onSelectAll();
	            }
	        },

	        /**
	         * Deselects all options.
	         * 
	         * If justVisible is true or not specified, only visible options are deselected.
	         * 
	         * @param {Boolean} justVisible
	         */
	        deselectAll: function (justVisible) {
	            justVisible = (this.options.enableCollapsibleOptGroups && this.options.multiple) ? false : justVisible;
	            justVisible = typeof justVisible === 'undefined' ? true : justVisible;
	            
	            if(justVisible) {              
	                var visibleCheckboxes = $("li input[type='checkbox']:not(:disabled)", this.$ul).filter(":visible");
	                visibleCheckboxes.prop('checked', false);
	                
	                var values = visibleCheckboxes.map(function() {
	                    return $(this).val();
	                }).get();
	                
	                $("option:enabled", this.$select).filter(function(index) {
	                    return $.inArray($(this).val(), values) !== -1;
	                }).prop('selected', false);
	                
	                if (this.options.selectedClass) {
	                    $("li:not(.divider):not(.disabled)", this.$ul).filter(":visible").removeClass(this.options.selectedClass);
	                }
	            }
	            else {
	                $("li input[type='checkbox']:enabled", this.$ul).prop('checked', false);
	                $("option:enabled", this.$select).prop('selected', false);
	                
	                if (this.options.selectedClass) {
	                    $("li:not(.divider):not(.disabled)", this.$ul).removeClass(this.options.selectedClass);
	                }
	            }
	        },

	        /**
	         * Rebuild the plugin.
	         * 
	         * Rebuilds the dropdown, the filter and the select all option.
	         */
	        rebuild: function() {
	            this.$ul.html('');

	            // Important to distinguish between radios and checkboxes.
	            this.options.multiple = this.$select.attr('multiple') === "multiple";

	            this.buildSelectAll();
	            this.buildDropdownOptions();
	            this.buildFilter();

	            this.updateButtonText();
	            this.updateSelectAll(true);
	            
	            if (this.options.disableIfEmpty && $('option', this.$select).length <= 0) {
	                this.disable();
	            }
	            else {
	                this.enable();
	            }
	            
	            if (this.options.dropRight) {
	                this.$ul.addClass('pull-right');
	            }
	        },

	        /**
	         * The provided data will be used to build the dropdown.
	         */
	        dataprovider: function(dataprovider) {
	            
	            var groupCounter = 0;
	            var $select = this.$select.empty();
	            
	            $.each(dataprovider, function (index, option) {
	                var $tag;
	                
	                if ($.isArray(option.children)) { // create optiongroup tag
	                    groupCounter++;
	                    
	                    $tag = $('<optgroup/>').attr({
	                        label: option.label || 'Group ' + groupCounter,
	                        disabled: !!option.disabled
	                    });
	                    
	                    forEach(option.children, function(subOption) { // add children option tags
	                        $tag.append($('<option/>').attr({
	                            value: subOption.value,
	                            label: subOption.label || subOption.value,
	                            title: subOption.title,
	                            selected: !!subOption.selected,
	                            disabled: !!subOption.disabled
	                        }));
	                    });
	                }
	                else {
	                    $tag = $('<option/>').attr({
	                        value: option.value,
	                        label: option.label || option.value,
	                        title: option.title,
	                        class: option.class,
	                        selected: !!option.selected,
	                        disabled: !!option.disabled
	                    });
	                    $tag.text(option.label || option.value);
	                }
	                
	                $select.append($tag);
	            });
	            
	            this.rebuild();
	        },

	        /**
	         * Enable the multiselect.
	         */
	        enable: function() {
	            this.$select.prop('disabled', false);
	            this.$button.prop('disabled', false)
	                .removeClass('disabled');
	        },

	        /**
	         * Disable the multiselect.
	         */
	        disable: function() {
	            this.$select.prop('disabled', true);
	            this.$button.prop('disabled', true)
	                .addClass('disabled');
	        },

	        /**
	         * Set the options.
	         *
	         * @param {Array} options
	         */
	        setOptions: function(options) {
	            this.options = this.mergeOptions(options);
	        },

	        /**
	         * Merges the given options with the default options.
	         *
	         * @param {Array} options
	         * @returns {Array}
	         */
	        mergeOptions: function(options) {
	            return $.extend(true, {}, this.defaults, this.options, options);
	        },

	        /**
	         * Checks whether a select all checkbox is present.
	         *
	         * @returns {Boolean}
	         */
	        hasSelectAll: function() {
	            return $('li.multiselect-all', this.$ul).length > 0;
	        },

	        /**
	         * Updates the select all checkbox based on the currently displayed and selected checkboxes.
	         */
	        updateSelectAll: function(notTriggerOnSelectAll) {
	            if (this.hasSelectAll()) {
	                var allBoxes = $("li:not(.multiselect-item):not(.filter-hidden) input:enabled", this.$ul);
	                var allBoxesLength = allBoxes.length;
	                var checkedBoxesLength = allBoxes.filter(":checked").length;
	                var selectAllLi  = $("li.multiselect-all", this.$ul);
	                var selectAllInput = selectAllLi.find("input");
	                
	                if (checkedBoxesLength > 0 && checkedBoxesLength === allBoxesLength) {
	                    selectAllInput.prop("checked", true);
	                    selectAllLi.addClass(this.options.selectedClass);
	                    this.options.onSelectAll(true);
	                }
	                else {
	                    selectAllInput.prop("checked", false);
	                    selectAllLi.removeClass(this.options.selectedClass);
	                    if (checkedBoxesLength === 0) {
	                        if (!notTriggerOnSelectAll) {
	                            this.options.onSelectAll(false);
	                        }
	                    }
	                }
	            }
	        },

	        /**
	         * Update the button text and its title based on the currently selected options.
	         */
	        updateButtonText: function() {
	            var options = this.getSelected();
	            
	            // First update the displayed button text.
	            if (this.options.enableHTML) {
	                $('.multiselect .multiselect-selected-text', this.$container).html(this.options.buttonText(options, this.$select));
	            }
	            else {
	                $('.multiselect .multiselect-selected-text', this.$container).text(this.options.buttonText(options, this.$select));
	            }
	            
	            // Now update the title attribute of the button.
	            $('.multiselect', this.$container).attr('title', this.options.buttonTitle(options, this.$select));
	        },

	        /**
	         * Get all selected options.
	         *
	         * @returns {jQUery}
	         */
	        getSelected: function() {
	            return $('option', this.$select).filter(":selected");
	        },

	        /**
	         * Gets a select option by its value.
	         *
	         * @param {String} value
	         * @returns {jQuery}
	         */
	        getOptionByValue: function (value) {

	            var options = $('option', this.$select);
	            var valueToCompare = value.toString();

	            for (var i = 0; i < options.length; i = i + 1) {
	                var option = options[i];
	                if (option.value === valueToCompare) {
	                    return $(option);
	                }
	            }
	        },

	        /**
	         * Get the input (radio/checkbox) by its value.
	         *
	         * @param {String} value
	         * @returns {jQuery}
	         */
	        getInputByValue: function (value) {

	            var checkboxes = $('li input', this.$ul);
	            var valueToCompare = value.toString();

	            for (var i = 0; i < checkboxes.length; i = i + 1) {
	                var checkbox = checkboxes[i];
	                if (checkbox.value === valueToCompare) {
	                    return $(checkbox);
	                }
	            }
	        },

	        /**
	         * Used for knockout integration.
	         */
	        updateOriginalOptions: function() {
	            this.originalOptions = this.$select.clone()[0].options;
	        },

	        asyncFunction: function(callback, timeout, self) {
	            var args = Array.prototype.slice.call(arguments, 3);
	            return setTimeout(function() {
	                callback.apply(self || window, args);
	            }, timeout);
	        },

	        setAllSelectedText: function(allSelectedText) {
	            this.options.allSelectedText = allSelectedText;
	            this.updateButtonText();
	        }
	    };

	    $.fn.multiselect = function(option, parameter, extraOptions) {
	        return this.each(function() {
	            var data = $(this).data('multiselect');
	            var options = typeof option === 'object' && option;

	            // Initialize the multiselect.
	            if (!data) {
	                data = new Multiselect(this, options);
	                $(this).data('multiselect', data);
	            }

	            // Call multiselect method.
	            if (typeof option === 'string') {
	                data[option](parameter, extraOptions);
	                
	                if (option === 'destroy') {
	                    $(this).data('multiselect', false);
	                }
	            }
	        });
	    };

	    $.fn.multiselect.Constructor = Multiselect;

	    $(function() {
	        $("select[data-role=multiselect]").multiselect();
	    });

	}(jQuery);




/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Data, ItemView, Marionette, View, _, itemTemplate, moment, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	_ = __webpack_require__(3);

	moment = __webpack_require__(44);

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	Data = __webpack_require__(40);

	itemTemplate = __webpack_require__(45);

	viewTemplate = __webpack_require__(46);

	__webpack_require__(19);

	ItemView = (function(superClass) {
	  extend(ItemView, superClass);

	  ItemView.prototype.tagName = 'tr';

	  ItemView.prototype.template = itemTemplate;

	  ItemView.prototype.bindings = {
	    '.exercise-table-td-name': 'name',
	    '.exercise-table-td-date': {
	      observe: 'date',
	      onGet: function(value) {
	        return moment(value).format('dddd MM/DD/YY hh:mm:ss');
	      }
	    },
	    '.exercise-table-td-type': 'type'
	  };

	  ItemView.prototype.events = {
	    click: function() {
	      var label, type;
	      type = this.model.get('type');
	      label = _.find(Data.Types, {
	        value: type
	      }).label;
	      this.rootChannel.request('exercise:detail', label.toLowerCase(), this.model.get('name'));
	    }
	  };

	  function ItemView() {
	    ItemView.__super__.constructor.apply(this, arguments);
	    this.rootChannel = Backbone.Radio.channel('root');
	  }

	  ItemView.prototype.onRender = function() {
	    this.stickit();
	  };

	  ItemView.prototype.onBeforeDestroy = function() {
	    this.unstickit();
	  };

	  return ItemView;

	})(Marionette.CompositeView);

	View = (function(superClass) {
	  extend(View, superClass);

	  function View() {
	    return View.__super__.constructor.apply(this, arguments);
	  }

	  View.prototype.childViewContainer = 'tbody';

	  View.prototype.childView = ItemView;

	  View.prototype.template = viewTemplate;

	  View.prototype.ui = {
	    first: '#exercise-table-first',
	    prev: '#exercise-table-prev',
	    next: '#exercise-table-next',
	    last: '#exercise-table-last',
	    currentPage: '#exercise-table-currentpage',
	    lastPage: '#exercise-table-lastpage'
	  };

	  View.prototype.collectionEvents = {
	    'reset': function() {
	      this.setPage();
	    },
	    'sync update': function() {
	      this.collection.getFirstPage();
	      this.setPage();
	    }
	  };

	  View.prototype.events = {
	    'click @ui.first': function() {
	      this.collection.getFirstPage();
	    },
	    'click @ui.prev': function() {
	      if (this.collection.hasPreviousPage()) {
	        this.collection.getPreviousPage();
	      }
	    },
	    'click @ui.next': function() {
	      if (this.collection.hasNextPage()) {
	        this.collection.getNextPage();
	      }
	    },
	    'click @ui.last': function() {
	      this.collection.getLastPage();
	    }
	  };

	  View.prototype.onRender = function() {
	    this.collection.getFirstPage();
	    this.setPage();
	  };

	  View.prototype.setPage = function() {
	    var state;
	    state = this.collection.state;
	    $(this.ui.currentPage).text(state.currentPage);
	    $(this.ui.lastPage).text(state.lastPage);
	  };

	  return View;

	})(Marionette.CompositeView);

	module.exports = View;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, module) {//! moment.js
	//! version : 2.9.0
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com

	(function (undefined) {
	    /************************************
	     Constants
	     ************************************/

	    var moment,
	        VERSION = '2.9.0',
	    // the global-scope this is NOT the global object in Node.js
	        globalScope = (typeof global !== 'undefined' && (typeof window === 'undefined' || window === global.window)) ? global : this,
	        oldGlobalMoment,
	        round = Math.round,
	        hasOwnProperty = Object.prototype.hasOwnProperty,
	        i,

	        YEAR = 0,
	        MONTH = 1,
	        DATE = 2,
	        HOUR = 3,
	        MINUTE = 4,
	        SECOND = 5,
	        MILLISECOND = 6,

	    // internal storage for locale config files
	        locales = {},

	    // extra moment internal properties (plugins register props here)
	        momentProperties = [],

	    // check for nodeJS
	        hasModule = (typeof module !== 'undefined' && module && module.exports),

	    // ASP.NET json date format regex
	        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
	        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

	    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

	    // format tokens
	        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,
	        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,

	    // parsing token regexes
	        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
	        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
	        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
	        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
	        parseTokenDigits = /\d+/, // nonzero number of digits
	        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
	        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
	        parseTokenT = /T/i, // T (ISO separator)
	        parseTokenOffsetMs = /[\+\-]?\d+/, // 1234567890123
	        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

	    //strict parsing regexes
	        parseTokenOneDigit = /\d/, // 0 - 9
	        parseTokenTwoDigits = /\d\d/, // 00 - 99
	        parseTokenThreeDigits = /\d{3}/, // 000 - 999
	        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
	        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
	        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

	    // iso 8601 regex
	    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

	        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

	        isoDates = [
	            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
	            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
	            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
	            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
	            ['YYYY-DDD', /\d{4}-\d{3}/]
	        ],

	    // iso time formats and regexes
	        isoTimes = [
	            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
	            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
	            ['HH:mm', /(T| )\d\d:\d\d/],
	            ['HH', /(T| )\d\d/]
	        ],

	    // timezone chunker '+10:00' > ['10', '00'] or '-1530' > ['-', '15', '30']
	        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

	    // getter and setter names
	        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
	        unitMillisecondFactors = {
	            'Milliseconds' : 1,
	            'Seconds' : 1e3,
	            'Minutes' : 6e4,
	            'Hours' : 36e5,
	            'Days' : 864e5,
	            'Months' : 2592e6,
	            'Years' : 31536e6
	        },

	        unitAliases = {
	            ms : 'millisecond',
	            s : 'second',
	            m : 'minute',
	            h : 'hour',
	            d : 'day',
	            D : 'date',
	            w : 'week',
	            W : 'isoWeek',
	            M : 'month',
	            Q : 'quarter',
	            y : 'year',
	            DDD : 'dayOfYear',
	            e : 'weekday',
	            E : 'isoWeekday',
	            gg: 'weekYear',
	            GG: 'isoWeekYear'
	        },

	        camelFunctions = {
	            dayofyear : 'dayOfYear',
	            isoweekday : 'isoWeekday',
	            isoweek : 'isoWeek',
	            weekyear : 'weekYear',
	            isoweekyear : 'isoWeekYear'
	        },

	    // format function strings
	        formatFunctions = {},

	    // default relative time thresholds
	        relativeTimeThresholds = {
	            s: 45,  // seconds to minute
	            m: 45,  // minutes to hour
	            h: 22,  // hours to day
	            d: 26,  // days to month
	            M: 11   // months to year
	        },

	    // tokens to ordinalize and pad
	        ordinalizeTokens = 'DDD w W M D d'.split(' '),
	        paddedTokens = 'M D H h m s w W'.split(' '),

	        formatTokenFunctions = {
	            M    : function () {
	                return this.month() + 1;
	            },
	            MMM  : function (format) {
	                return this.localeData().monthsShort(this, format);
	            },
	            MMMM : function (format) {
	                return this.localeData().months(this, format);
	            },
	            D    : function () {
	                return this.date();
	            },
	            DDD  : function () {
	                return this.dayOfYear();
	            },
	            d    : function () {
	                return this.day();
	            },
	            dd   : function (format) {
	                return this.localeData().weekdaysMin(this, format);
	            },
	            ddd  : function (format) {
	                return this.localeData().weekdaysShort(this, format);
	            },
	            dddd : function (format) {
	                return this.localeData().weekdays(this, format);
	            },
	            w    : function () {
	                return this.week();
	            },
	            W    : function () {
	                return this.isoWeek();
	            },
	            YY   : function () {
	                return leftZeroFill(this.year() % 100, 2);
	            },
	            YYYY : function () {
	                return leftZeroFill(this.year(), 4);
	            },
	            YYYYY : function () {
	                return leftZeroFill(this.year(), 5);
	            },
	            YYYYYY : function () {
	                var y = this.year(), sign = y >= 0 ? '+' : '-';
	                return sign + leftZeroFill(Math.abs(y), 6);
	            },
	            gg   : function () {
	                return leftZeroFill(this.weekYear() % 100, 2);
	            },
	            gggg : function () {
	                return leftZeroFill(this.weekYear(), 4);
	            },
	            ggggg : function () {
	                return leftZeroFill(this.weekYear(), 5);
	            },
	            GG   : function () {
	                return leftZeroFill(this.isoWeekYear() % 100, 2);
	            },
	            GGGG : function () {
	                return leftZeroFill(this.isoWeekYear(), 4);
	            },
	            GGGGG : function () {
	                return leftZeroFill(this.isoWeekYear(), 5);
	            },
	            e : function () {
	                return this.weekday();
	            },
	            E : function () {
	                return this.isoWeekday();
	            },
	            a    : function () {
	                return this.localeData().meridiem(this.hours(), this.minutes(), true);
	            },
	            A    : function () {
	                return this.localeData().meridiem(this.hours(), this.minutes(), false);
	            },
	            H    : function () {
	                return this.hours();
	            },
	            h    : function () {
	                return this.hours() % 12 || 12;
	            },
	            m    : function () {
	                return this.minutes();
	            },
	            s    : function () {
	                return this.seconds();
	            },
	            S    : function () {
	                return toInt(this.milliseconds() / 100);
	            },
	            SS   : function () {
	                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
	            },
	            SSS  : function () {
	                return leftZeroFill(this.milliseconds(), 3);
	            },
	            SSSS : function () {
	                return leftZeroFill(this.milliseconds(), 3);
	            },
	            Z    : function () {
	                var a = this.utcOffset(),
	                    b = '+';
	                if (a < 0) {
	                    a = -a;
	                    b = '-';
	                }
	                return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);
	            },
	            ZZ   : function () {
	                var a = this.utcOffset(),
	                    b = '+';
	                if (a < 0) {
	                    a = -a;
	                    b = '-';
	                }
	                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
	            },
	            z : function () {
	                return this.zoneAbbr();
	            },
	            zz : function () {
	                return this.zoneName();
	            },
	            x    : function () {
	                return this.valueOf();
	            },
	            X    : function () {
	                return this.unix();
	            },
	            Q : function () {
	                return this.quarter();
	            }
	        },

	        deprecations = {},

	        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'],

	        updateInProgress = false;

	    // Pick the first defined of two or three arguments. dfl comes from
	    // default.
	    function dfl(a, b, c) {
	        switch (arguments.length) {
	            case 2: return a != null ? a : b;
	            case 3: return a != null ? a : b != null ? b : c;
	            default: throw new Error('Implement me');
	        }
	    }

	    function hasOwnProp(a, b) {
	        return hasOwnProperty.call(a, b);
	    }

	    function defaultParsingFlags() {
	        // We need to deep clone this object, and es5 standard is not very
	        // helpful.
	        return {
	            empty : false,
	            unusedTokens : [],
	            unusedInput : [],
	            overflow : -2,
	            charsLeftOver : 0,
	            nullInput : false,
	            invalidMonth : null,
	            invalidFormat : false,
	            userInvalidated : false,
	            iso: false
	        };
	    }

	    function printMsg(msg) {
	        if (moment.suppressDeprecationWarnings === false &&
	            typeof console !== 'undefined' && console.warn) {
	            console.warn('Deprecation warning: ' + msg);
	        }
	    }

	    function deprecate(msg, fn) {
	        var firstTime = true;
	        return extend(function () {
	            if (firstTime) {
	                printMsg(msg);
	                firstTime = false;
	            }
	            return fn.apply(this, arguments);
	        }, fn);
	    }

	    function deprecateSimple(name, msg) {
	        if (!deprecations[name]) {
	            printMsg(msg);
	            deprecations[name] = true;
	        }
	    }

	    function padToken(func, count) {
	        return function (a) {
	            return leftZeroFill(func.call(this, a), count);
	        };
	    }
	    function ordinalizeToken(func, period) {
	        return function (a) {
	            return this.localeData().ordinal(func.call(this, a), period);
	        };
	    }

	    function monthDiff(a, b) {
	        // difference in months
	        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	        // b is in (anchor - 1 month, anchor + 1 month)
	            anchor = a.clone().add(wholeMonthDiff, 'months'),
	            anchor2, adjust;

	        if (b - anchor < 0) {
	            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor - anchor2);
	        } else {
	            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor2 - anchor);
	        }

	        return -(wholeMonthDiff + adjust);
	    }

	    while (ordinalizeTokens.length) {
	        i = ordinalizeTokens.pop();
	        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
	    }
	    while (paddedTokens.length) {
	        i = paddedTokens.pop();
	        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
	    }
	    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


	    function meridiemFixWrap(locale, hour, meridiem) {
	        var isPm;

	        if (meridiem == null) {
	            // nothing to do
	            return hour;
	        }
	        if (locale.meridiemHour != null) {
	            return locale.meridiemHour(hour, meridiem);
	        } else if (locale.isPM != null) {
	            // Fallback
	            isPm = locale.isPM(meridiem);
	            if (isPm && hour < 12) {
	                hour += 12;
	            }
	            if (!isPm && hour === 12) {
	                hour = 0;
	            }
	            return hour;
	        } else {
	            // thie is not supposed to happen
	            return hour;
	        }
	    }

	    /************************************
	     Constructors
	     ************************************/

	    function Locale() {
	    }

	    // Moment prototype object
	    function Moment(config, skipOverflow) {
	        if (skipOverflow !== false) {
	            checkOverflow(config);
	        }
	        copyConfig(this, config);
	        this._d = new Date(+config._d);
	        // Prevent infinite loop in case updateOffset creates new moment
	        // objects.
	        if (updateInProgress === false) {
	            updateInProgress = true;
	            moment.updateOffset(this);
	            updateInProgress = false;
	        }
	    }

	    // Duration Constructor
	    function Duration(duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            quarters = normalizedInput.quarter || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;

	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	        seconds * 1e3 + // 1000
	        minutes * 6e4 + // 1000 * 60
	        hours * 36e5; // 1000 * 60 * 60
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	        weeks * 7;
	        // It is impossible translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	        quarters * 3 +
	        years * 12;

	        this._data = {};

	        this._locale = moment.localeData();

	        this._bubble();
	    }

	    /************************************
	     Helpers
	     ************************************/


	    function extend(a, b) {
	        for (var i in b) {
	            if (hasOwnProp(b, i)) {
	                a[i] = b[i];
	            }
	        }

	        if (hasOwnProp(b, 'toString')) {
	            a.toString = b.toString;
	        }

	        if (hasOwnProp(b, 'valueOf')) {
	            a.valueOf = b.valueOf;
	        }

	        return a;
	    }

	    function copyConfig(to, from) {
	        var i, prop, val;

	        if (typeof from._isAMomentObject !== 'undefined') {
	            to._isAMomentObject = from._isAMomentObject;
	        }
	        if (typeof from._i !== 'undefined') {
	            to._i = from._i;
	        }
	        if (typeof from._f !== 'undefined') {
	            to._f = from._f;
	        }
	        if (typeof from._l !== 'undefined') {
	            to._l = from._l;
	        }
	        if (typeof from._strict !== 'undefined') {
	            to._strict = from._strict;
	        }
	        if (typeof from._tzm !== 'undefined') {
	            to._tzm = from._tzm;
	        }
	        if (typeof from._isUTC !== 'undefined') {
	            to._isUTC = from._isUTC;
	        }
	        if (typeof from._offset !== 'undefined') {
	            to._offset = from._offset;
	        }
	        if (typeof from._pf !== 'undefined') {
	            to._pf = from._pf;
	        }
	        if (typeof from._locale !== 'undefined') {
	            to._locale = from._locale;
	        }

	        if (momentProperties.length > 0) {
	            for (i in momentProperties) {
	                prop = momentProperties[i];
	                val = from[prop];
	                if (typeof val !== 'undefined') {
	                    to[prop] = val;
	                }
	            }
	        }

	        return to;
	    }

	    function absRound(number) {
	        if (number < 0) {
	            return Math.ceil(number);
	        } else {
	            return Math.floor(number);
	        }
	    }

	    // left zero fill a number
	    // see http://jsperf.com/left-zero-filling for performance comparison
	    function leftZeroFill(number, targetLength, forceSign) {
	        var output = '' + Math.abs(number),
	            sign = number >= 0;

	        while (output.length < targetLength) {
	            output = '0' + output;
	        }
	        return (sign ? (forceSign ? '+' : '') : '-') + output;
	    }

	    function positiveMomentsDifference(base, other) {
	        var res = {milliseconds: 0, months: 0};

	        res.months = other.month() - base.month() +
	        (other.year() - base.year()) * 12;
	        if (base.clone().add(res.months, 'M').isAfter(other)) {
	            --res.months;
	        }

	        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

	        return res;
	    }

	    function momentsDifference(base, other) {
	        var res;
	        other = makeAs(other, base);
	        if (base.isBefore(other)) {
	            res = positiveMomentsDifference(base, other);
	        } else {
	            res = positiveMomentsDifference(other, base);
	            res.milliseconds = -res.milliseconds;
	            res.months = -res.months;
	        }

	        return res;
	    }

	    // TODO: remove 'name' arg after deprecation is removed
	    function createAdder(direction, name) {
	        return function (val, period) {
	            var dur, tmp;
	            //invert the arguments, but complain about it
	            if (period !== null && !isNaN(+period)) {
	                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
	                tmp = val; val = period; period = tmp;
	            }

	            val = typeof val === 'string' ? +val : val;
	            dur = moment.duration(val, period);
	            addOrSubtractDurationFromMoment(this, dur, direction);
	            return this;
	        };
	    }

	    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = duration._days,
	            months = duration._months;
	        updateOffset = updateOffset == null ? true : updateOffset;

	        if (milliseconds) {
	            mom._d.setTime(+mom._d + milliseconds * isAdding);
	        }
	        if (days) {
	            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
	        }
	        if (months) {
	            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
	        }
	        if (updateOffset) {
	            moment.updateOffset(mom, days || months);
	        }
	    }

	    // check if is an array
	    function isArray(input) {
	        return Object.prototype.toString.call(input) === '[object Array]';
	    }

	    function isDate(input) {
	        return Object.prototype.toString.call(input) === '[object Date]' ||
	            input instanceof Date;
	    }

	    // compare two arrays, return the number of differences
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }

	    function normalizeUnits(units) {
	        if (units) {
	            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
	            units = unitAliases[units] || camelFunctions[lowered] || lowered;
	        }
	        return units;
	    }

	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;

	        for (prop in inputObject) {
	            if (hasOwnProp(inputObject, prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }

	        return normalizedInput;
	    }

	    function makeList(field) {
	        var count, setter;

	        if (field.indexOf('week') === 0) {
	            count = 7;
	            setter = 'day';
	        }
	        else if (field.indexOf('month') === 0) {
	            count = 12;
	            setter = 'month';
	        }
	        else {
	            return;
	        }

	        moment[field] = function (format, index) {
	            var i, getter,
	                method = moment._locale[field],
	                results = [];

	            if (typeof format === 'number') {
	                index = format;
	                format = undefined;
	            }

	            getter = function (i) {
	                var m = moment().utc().set(setter, i);
	                return method.call(moment._locale, m, format || '');
	            };

	            if (index != null) {
	                return getter(index);
	            }
	            else {
	                for (i = 0; i < count; i++) {
	                    results.push(getter(i));
	                }
	                return results;
	            }
	        };
	    }

	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;

	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            if (coercedNumber >= 0) {
	                value = Math.floor(coercedNumber);
	            } else {
	                value = Math.ceil(coercedNumber);
	            }
	        }

	        return value;
	    }

	    function daysInMonth(year, month) {
	        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	    }

	    function weeksInYear(year, dow, doy) {
	        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
	    }

	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }

	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }

	    function checkOverflow(m) {
	        var overflow;
	        if (m._a && m._pf.overflow === -2) {
	            overflow =
	                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
	                    m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
	                        m._a[HOUR] < 0 || m._a[HOUR] > 24 ||
	                        (m._a[HOUR] === 24 && (m._a[MINUTE] !== 0 ||
	                        m._a[SECOND] !== 0 ||
	                        m._a[MILLISECOND] !== 0)) ? HOUR :
	                            m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
	                                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
	                                    m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
	                                        -1;

	            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }

	            m._pf.overflow = overflow;
	        }
	    }

	    function isValid(m) {
	        if (m._isValid == null) {
	            m._isValid = !isNaN(m._d.getTime()) &&
	            m._pf.overflow < 0 &&
	            !m._pf.empty &&
	            !m._pf.invalidMonth &&
	            !m._pf.nullInput &&
	            !m._pf.invalidFormat &&
	            !m._pf.userInvalidated;

	            if (m._strict) {
	                m._isValid = m._isValid &&
	                m._pf.charsLeftOver === 0 &&
	                m._pf.unusedTokens.length === 0 &&
	                m._pf.bigHour === undefined;
	            }
	        }
	        return m._isValid;
	    }

	    function normalizeLocale(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }

	    // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	    function chooseLocale(names) {
	        var i = 0, j, next, locale, split;

	        while (i < names.length) {
	            split = normalizeLocale(names[i]).split('-');
	            j = split.length;
	            next = normalizeLocale(names[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                locale = loadLocale(split.slice(0, j).join('-'));
	                if (locale) {
	                    return locale;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return null;
	    }

	    function loadLocale(name) {
	        var oldLocale = null;
	        if (!locales[name] && hasModule) {
	            try {
	                oldLocale = moment.locale();
	                !(function webpackMissingModule() { var e = new Error("Cannot find module \"./locale\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());
	                // because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales
	                moment.locale(oldLocale);
	            } catch (e) { }
	        }
	        return locales[name];
	    }

	    // Return a moment from input, that is local/utc/utcOffset equivalent to
	    // model.
	    function makeAs(input, model) {
	        var res, diff;
	        if (model._isUTC) {
	            res = model.clone();
	            diff = (moment.isMoment(input) || isDate(input) ?
	                +input : +moment(input)) - (+res);
	            // Use low-level api, because this fn is low-level api.
	            res._d.setTime(+res._d + diff);
	            moment.updateOffset(res, false);
	            return res;
	        } else {
	            return moment(input).local();
	        }
	    }

	    /************************************
	     Locale
	     ************************************/


	    extend(Locale.prototype, {

	        set : function (config) {
	            var prop, i;
	            for (i in config) {
	                prop = config[i];
	                if (typeof prop === 'function') {
	                    this[i] = prop;
	                } else {
	                    this['_' + i] = prop;
	                }
	            }
	            // Lenient ordinal parsing accepts just a number in addition to
	            // number + (possibly) stuff coming from _ordinalParseLenient.
	            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\d{1,2}/.source);
	        },

	        _months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        months : function (m) {
	            return this._months[m.month()];
	        },

	        _monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        monthsShort : function (m) {
	            return this._monthsShort[m.month()];
	        },

	        monthsParse : function (monthName, format, strict) {
	            var i, mom, regex;

	            if (!this._monthsParse) {
	                this._monthsParse = [];
	                this._longMonthsParse = [];
	                this._shortMonthsParse = [];
	            }

	            for (i = 0; i < 12; i++) {
	                // make the regex if we don't have it already
	                mom = moment.utc([2000, i]);
	                if (strict && !this._longMonthsParse[i]) {
	                    this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	                    this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	                }
	                if (!strict && !this._monthsParse[i]) {
	                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	                }
	                // test the regex
	                if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	                    return i;
	                } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	                    return i;
	                } else if (!strict && this._monthsParse[i].test(monthName)) {
	                    return i;
	                }
	            }
	        },

	        _weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdays : function (m) {
	            return this._weekdays[m.day()];
	        },

	        _weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysShort : function (m) {
	            return this._weekdaysShort[m.day()];
	        },

	        _weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        weekdaysMin : function (m) {
	            return this._weekdaysMin[m.day()];
	        },

	        weekdaysParse : function (weekdayName) {
	            var i, mom, regex;

	            if (!this._weekdaysParse) {
	                this._weekdaysParse = [];
	            }

	            for (i = 0; i < 7; i++) {
	                // make the regex if we don't have it already
	                if (!this._weekdaysParse[i]) {
	                    mom = moment([2000, 1]).day(i);
	                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	                }
	                // test the regex
	                if (this._weekdaysParse[i].test(weekdayName)) {
	                    return i;
	                }
	            }
	        },

	        _longDateFormat : {
	            LTS : 'h:mm:ss A',
	            LT : 'h:mm A',
	            L : 'MM/DD/YYYY',
	            LL : 'MMMM D, YYYY',
	            LLL : 'MMMM D, YYYY LT',
	            LLLL : 'dddd, MMMM D, YYYY LT'
	        },
	        longDateFormat : function (key) {
	            var output = this._longDateFormat[key];
	            if (!output && this._longDateFormat[key.toUpperCase()]) {
	                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
	                    return val.slice(1);
	                });
	                this._longDateFormat[key] = output;
	            }
	            return output;
	        },

	        isPM : function (input) {
	            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	            // Using charAt should be more compatible.
	            return ((input + '').toLowerCase().charAt(0) === 'p');
	        },

	        _meridiemParse : /[ap]\.?m?\.?/i,
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'pm' : 'PM';
	            } else {
	                return isLower ? 'am' : 'AM';
	            }
	        },


	        _calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        calendar : function (key, mom, now) {
	            var output = this._calendar[key];
	            return typeof output === 'function' ? output.apply(mom, [now]) : output;
	        },

	        _relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },

	        relativeTime : function (number, withoutSuffix, string, isFuture) {
	            var output = this._relativeTime[string];
	            return (typeof output === 'function') ?
	                output(number, withoutSuffix, string, isFuture) :
	                output.replace(/%d/i, number);
	        },

	        pastFuture : function (diff, output) {
	            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
	        },

	        ordinal : function (number) {
	            return this._ordinal.replace('%d', number);
	        },
	        _ordinal : '%d',
	        _ordinalParse : /\d{1,2}/,

	        preparse : function (string) {
	            return string;
	        },

	        postformat : function (string) {
	            return string;
	        },

	        week : function (mom) {
	            return weekOfYear(mom, this._week.dow, this._week.doy).week;
	        },

	        _week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        },

	        firstDayOfWeek : function () {
	            return this._week.dow;
	        },

	        firstDayOfYear : function () {
	            return this._week.doy;
	        },

	        _invalidDate: 'Invalid date',
	        invalidDate: function () {
	            return this._invalidDate;
	        }
	    });

	    /************************************
	     Formatting
	     ************************************/


	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, '');
	        }
	        return input.replace(/\\/g, '');
	    }

	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;

	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }

	        return function (mom) {
	            var output = '';
	            for (i = 0; i < length; i++) {
	                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }

	    // format date using native date object
	    function formatMoment(m, format) {
	        if (!m.isValid()) {
	            return m.localeData().invalidDate();
	        }

	        format = expandFormat(format, m.localeData());

	        if (!formatFunctions[format]) {
	            formatFunctions[format] = makeFormatFunction(format);
	        }

	        return formatFunctions[format](m);
	    }

	    function expandFormat(format, locale) {
	        var i = 5;

	        function replaceLongDateFormatTokens(input) {
	            return locale.longDateFormat(input) || input;
	        }

	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }

	        return format;
	    }


	    /************************************
	     Parsing
	     ************************************/


	    // get the regex to find the next token
	    function getParseRegexForToken(token, config) {
	        var a, strict = config._strict;
	        switch (token) {
	            case 'Q':
	                return parseTokenOneDigit;
	            case 'DDDD':
	                return parseTokenThreeDigits;
	            case 'YYYY':
	            case 'GGGG':
	            case 'gggg':
	                return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
	            case 'Y':
	            case 'G':
	            case 'g':
	                return parseTokenSignedNumber;
	            case 'YYYYYY':
	            case 'YYYYY':
	            case 'GGGGG':
	            case 'ggggg':
	                return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
	            case 'S':
	                if (strict) {
	                    return parseTokenOneDigit;
	                }
	            /* falls through */
	            case 'SS':
	                if (strict) {
	                    return parseTokenTwoDigits;
	                }
	            /* falls through */
	            case 'SSS':
	                if (strict) {
	                    return parseTokenThreeDigits;
	                }
	            /* falls through */
	            case 'DDD':
	                return parseTokenOneToThreeDigits;
	            case 'MMM':
	            case 'MMMM':
	            case 'dd':
	            case 'ddd':
	            case 'dddd':
	                return parseTokenWord;
	            case 'a':
	            case 'A':
	                return config._locale._meridiemParse;
	            case 'x':
	                return parseTokenOffsetMs;
	            case 'X':
	                return parseTokenTimestampMs;
	            case 'Z':
	            case 'ZZ':
	                return parseTokenTimezone;
	            case 'T':
	                return parseTokenT;
	            case 'SSSS':
	                return parseTokenDigits;
	            case 'MM':
	            case 'DD':
	            case 'YY':
	            case 'GG':
	            case 'gg':
	            case 'HH':
	            case 'hh':
	            case 'mm':
	            case 'ss':
	            case 'ww':
	            case 'WW':
	                return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
	            case 'M':
	            case 'D':
	            case 'd':
	            case 'H':
	            case 'h':
	            case 'm':
	            case 's':
	            case 'w':
	            case 'W':
	            case 'e':
	            case 'E':
	                return parseTokenOneOrTwoDigits;
	            case 'Do':
	                return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;
	            default :
	                a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), 'i'));
	                return a;
	        }
	    }

	    function utcOffsetFromString(string) {
	        string = string || '';
	        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
	            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
	            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
	            minutes = +(parts[1] * 60) + toInt(parts[2]);

	        return parts[0] === '+' ? minutes : -minutes;
	    }

	    // function to convert string input to date
	    function addTimeToArrayFromToken(token, input, config) {
	        var a, datePartArray = config._a;

	        switch (token) {
	            // QUARTER
	            case 'Q':
	                if (input != null) {
	                    datePartArray[MONTH] = (toInt(input) - 1) * 3;
	                }
	                break;
	            // MONTH
	            case 'M' : // fall through to MM
	            case 'MM' :
	                if (input != null) {
	                    datePartArray[MONTH] = toInt(input) - 1;
	                }
	                break;
	            case 'MMM' : // fall through to MMMM
	            case 'MMMM' :
	                a = config._locale.monthsParse(input, token, config._strict);
	                // if we didn't find a month name, mark the date as invalid.
	                if (a != null) {
	                    datePartArray[MONTH] = a;
	                } else {
	                    config._pf.invalidMonth = input;
	                }
	                break;
	            // DAY OF MONTH
	            case 'D' : // fall through to DD
	            case 'DD' :
	                if (input != null) {
	                    datePartArray[DATE] = toInt(input);
	                }
	                break;
	            case 'Do' :
	                if (input != null) {
	                    datePartArray[DATE] = toInt(parseInt(
	                        input.match(/\d{1,2}/)[0], 10));
	                }
	                break;
	            // DAY OF YEAR
	            case 'DDD' : // fall through to DDDD
	            case 'DDDD' :
	                if (input != null) {
	                    config._dayOfYear = toInt(input);
	                }

	                break;
	            // YEAR
	            case 'YY' :
	                datePartArray[YEAR] = moment.parseTwoDigitYear(input);
	                break;
	            case 'YYYY' :
	            case 'YYYYY' :
	            case 'YYYYYY' :
	                datePartArray[YEAR] = toInt(input);
	                break;
	            // AM / PM
	            case 'a' : // fall through to A
	            case 'A' :
	                config._meridiem = input;
	                // config._isPm = config._locale.isPM(input);
	                break;
	            // HOUR
	            case 'h' : // fall through to hh
	            case 'hh' :
	                config._pf.bigHour = true;
	            /* falls through */
	            case 'H' : // fall through to HH
	            case 'HH' :
	                datePartArray[HOUR] = toInt(input);
	                break;
	            // MINUTE
	            case 'm' : // fall through to mm
	            case 'mm' :
	                datePartArray[MINUTE] = toInt(input);
	                break;
	            // SECOND
	            case 's' : // fall through to ss
	            case 'ss' :
	                datePartArray[SECOND] = toInt(input);
	                break;
	            // MILLISECOND
	            case 'S' :
	            case 'SS' :
	            case 'SSS' :
	            case 'SSSS' :
	                datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
	                break;
	            // UNIX OFFSET (MILLISECONDS)
	            case 'x':
	                config._d = new Date(toInt(input));
	                break;
	            // UNIX TIMESTAMP WITH MS
	            case 'X':
	                config._d = new Date(parseFloat(input) * 1000);
	                break;
	            // TIMEZONE
	            case 'Z' : // fall through to ZZ
	            case 'ZZ' :
	                config._useUTC = true;
	                config._tzm = utcOffsetFromString(input);
	                break;
	            // WEEKDAY - human
	            case 'dd':
	            case 'ddd':
	            case 'dddd':
	                a = config._locale.weekdaysParse(input);
	                // if we didn't get a weekday name, mark the date as invalid
	                if (a != null) {
	                    config._w = config._w || {};
	                    config._w['d'] = a;
	                } else {
	                    config._pf.invalidWeekday = input;
	                }
	                break;
	            // WEEK, WEEK DAY - numeric
	            case 'w':
	            case 'ww':
	            case 'W':
	            case 'WW':
	            case 'd':
	            case 'e':
	            case 'E':
	                token = token.substr(0, 1);
	            /* falls through */
	            case 'gggg':
	            case 'GGGG':
	            case 'GGGGG':
	                token = token.substr(0, 2);
	                if (input) {
	                    config._w = config._w || {};
	                    config._w[token] = toInt(input);
	                }
	                break;
	            case 'gg':
	            case 'GG':
	                config._w = config._w || {};
	                config._w[token] = moment.parseTwoDigitYear(input);
	        }
	    }

	    function dayOfYearFromWeekInfo(config) {
	        var w, weekYear, week, weekday, dow, doy, temp;

	        w = config._w;
	        if (w.GG != null || w.W != null || w.E != null) {
	            dow = 1;
	            doy = 4;

	            // TODO: We need to take the current isoWeekYear, but that depends on
	            // how we interpret now (local, utc, fixed offset). So create
	            // a now version of current config (take local/utc/offset flags, and
	            // create now).
	            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
	            week = dfl(w.W, 1);
	            weekday = dfl(w.E, 1);
	        } else {
	            dow = config._locale._week.dow;
	            doy = config._locale._week.doy;

	            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
	            week = dfl(w.w, 1);

	            if (w.d != null) {
	                // weekday -- low day numbers are considered next week
	                weekday = w.d;
	                if (weekday < dow) {
	                    ++week;
	                }
	            } else if (w.e != null) {
	                // local weekday -- counting starts from begining of week
	                weekday = w.e + dow;
	            } else {
	                // default to begining of week
	                weekday = dow;
	            }
	        }
	        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

	        config._a[YEAR] = temp.year;
	        config._dayOfYear = temp.dayOfYear;
	    }

	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function dateFromConfig(config) {
	        var i, date, input = [], currentDate, yearToUse;

	        if (config._d) {
	            return;
	        }

	        currentDate = currentDateArray(config);

	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            dayOfYearFromWeekInfo(config);
	        }

	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear) {
	            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);

	            if (config._dayOfYear > daysInYear(yearToUse)) {
	                config._pf._overflowDayOfYear = true;
	            }

	            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }

	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }

	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }

	        // Check for 24:00:00.000
	        if (config._a[HOUR] === 24 &&
	            config._a[MINUTE] === 0 &&
	            config._a[SECOND] === 0 &&
	            config._a[MILLISECOND] === 0) {
	            config._nextDay = true;
	            config._a[HOUR] = 0;
	        }

	        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
	        // Apply timezone offset from input. The actual utcOffset can be changed
	        // with parseZone.
	        if (config._tzm != null) {
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	        }

	        if (config._nextDay) {
	            config._a[HOUR] = 24;
	        }
	    }

	    function dateFromObject(config) {
	        var normalizedInput;

	        if (config._d) {
	            return;
	        }

	        normalizedInput = normalizeObjectUnits(config._i);
	        config._a = [
	            normalizedInput.year,
	            normalizedInput.month,
	            normalizedInput.day || normalizedInput.date,
	            normalizedInput.hour,
	            normalizedInput.minute,
	            normalizedInput.second,
	            normalizedInput.millisecond
	        ];

	        dateFromConfig(config);
	    }

	    function currentDateArray(config) {
	        var now = new Date();
	        if (config._useUTC) {
	            return [
	                now.getUTCFullYear(),
	                now.getUTCMonth(),
	                now.getUTCDate()
	            ];
	        } else {
	            return [now.getFullYear(), now.getMonth(), now.getDate()];
	        }
	    }

	    // date from string and format string
	    function makeDateFromStringAndFormat(config) {
	        if (config._f === moment.ISO_8601) {
	            parseISO(config);
	            return;
	        }

	        config._a = [];
	        config._pf.empty = true;

	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;

	        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    config._pf.unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    config._pf.empty = false;
	                }
	                else {
	                    config._pf.unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                config._pf.unusedTokens.push(token);
	            }
	        }

	        // add remaining unparsed input length to the string
	        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            config._pf.unusedInput.push(string);
	        }

	        // clear _12h flag if hour is <= 12
	        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {
	            config._pf.bigHour = undefined;
	        }
	        // handle meridiem
	        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR],
	            config._meridiem);
	        dateFromConfig(config);
	        checkOverflow(config);
	    }

	    function unescapeFormat(s) {
	        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        });
	    }

	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function regexpEscape(s) {
	        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }

	    // date from string and array of format strings
	    function makeDateFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,

	            scoreToBeat,
	            i,
	            currentScore;

	        if (config._f.length === 0) {
	            config._pf.invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }

	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = copyConfig({}, config);
	            if (config._useUTC != null) {
	                tempConfig._useUTC = config._useUTC;
	            }
	            tempConfig._pf = defaultParsingFlags();
	            tempConfig._f = config._f[i];
	            makeDateFromStringAndFormat(tempConfig);

	            if (!isValid(tempConfig)) {
	                continue;
	            }

	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += tempConfig._pf.charsLeftOver;

	            //or tokens
	            currentScore += tempConfig._pf.unusedTokens.length * 10;

	            tempConfig._pf.score = currentScore;

	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }

	        extend(config, bestMoment || tempConfig);
	    }

	    // date from iso format
	    function parseISO(config) {
	        var i, l,
	            string = config._i,
	            match = isoRegex.exec(string);

	        if (match) {
	            config._pf.iso = true;
	            for (i = 0, l = isoDates.length; i < l; i++) {
	                if (isoDates[i][1].exec(string)) {
	                    // match[5] should be 'T' or undefined
	                    config._f = isoDates[i][0] + (match[6] || ' ');
	                    break;
	                }
	            }
	            for (i = 0, l = isoTimes.length; i < l; i++) {
	                if (isoTimes[i][1].exec(string)) {
	                    config._f += isoTimes[i][0];
	                    break;
	                }
	            }
	            if (string.match(parseTokenTimezone)) {
	                config._f += 'Z';
	            }
	            makeDateFromStringAndFormat(config);
	        } else {
	            config._isValid = false;
	        }
	    }

	    // date from iso format or fallback
	    function makeDateFromString(config) {
	        parseISO(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	            moment.createFromInputFallback(config);
	        }
	    }

	    function map(arr, fn) {
	        var res = [], i;
	        for (i = 0; i < arr.length; ++i) {
	            res.push(fn(arr[i], i));
	        }
	        return res;
	    }

	    function makeDateFromInput(config) {
	        var input = config._i, matched;
	        if (input === undefined) {
	            config._d = new Date();
	        } else if (isDate(input)) {
	            config._d = new Date(+input);
	        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
	            config._d = new Date(+matched[1]);
	        } else if (typeof input === 'string') {
	            makeDateFromString(config);
	        } else if (isArray(input)) {
	            config._a = map(input.slice(0), function (obj) {
	                return parseInt(obj, 10);
	            });
	            dateFromConfig(config);
	        } else if (typeof(input) === 'object') {
	            dateFromObject(config);
	        } else if (typeof(input) === 'number') {
	            // from milliseconds
	            config._d = new Date(input);
	        } else {
	            moment.createFromInputFallback(config);
	        }
	    }

	    function makeDate(y, m, d, h, M, s, ms) {
	        //can't just apply() to create a date:
	        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	        var date = new Date(y, m, d, h, M, s, ms);

	        //the date constructor doesn't accept years < 1970
	        if (y < 1970) {
	            date.setFullYear(y);
	        }
	        return date;
	    }

	    function makeUTCDate(y) {
	        var date = new Date(Date.UTC.apply(null, arguments));
	        if (y < 1970) {
	            date.setUTCFullYear(y);
	        }
	        return date;
	    }

	    function parseWeekday(input, locale) {
	        if (typeof input === 'string') {
	            if (!isNaN(input)) {
	                input = parseInt(input, 10);
	            }
	            else {
	                input = locale.weekdaysParse(input);
	                if (typeof input !== 'number') {
	                    return null;
	                }
	            }
	        }
	        return input;
	    }

	    /************************************
	     Relative Time
	     ************************************/


	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }

	    function relativeTime(posNegDuration, withoutSuffix, locale) {
	        var duration = moment.duration(posNegDuration).abs(),
	            seconds = round(duration.as('s')),
	            minutes = round(duration.as('m')),
	            hours = round(duration.as('h')),
	            days = round(duration.as('d')),
	            months = round(duration.as('M')),
	            years = round(duration.as('y')),

	            args = seconds < relativeTimeThresholds.s && ['s', seconds] ||
	                minutes === 1 && ['m'] ||
	                minutes < relativeTimeThresholds.m && ['mm', minutes] ||
	                hours === 1 && ['h'] ||
	                hours < relativeTimeThresholds.h && ['hh', hours] ||
	                days === 1 && ['d'] ||
	                days < relativeTimeThresholds.d && ['dd', days] ||
	                months === 1 && ['M'] ||
	                months < relativeTimeThresholds.M && ['MM', months] ||
	                years === 1 && ['y'] || ['yy', years];

	        args[2] = withoutSuffix;
	        args[3] = +posNegDuration > 0;
	        args[4] = locale;
	        return substituteTimeAgo.apply({}, args);
	    }


	    /************************************
	     Week of Year
	     ************************************/


	    // firstDayOfWeek       0 = sun, 6 = sat
	    //                      the day of the week that starts the week
	    //                      (usually sunday or monday)
	    // firstDayOfWeekOfYear 0 = sun, 6 = sat
	    //                      the first week is the week that contains the first
	    //                      of this day of the week
	    //                      (eg. ISO weeks use thursday (4))
	    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
	        var end = firstDayOfWeekOfYear - firstDayOfWeek,
	            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
	            adjustedMoment;


	        if (daysToDayOfWeek > end) {
	            daysToDayOfWeek -= 7;
	        }

	        if (daysToDayOfWeek < end - 7) {
	            daysToDayOfWeek += 7;
	        }

	        adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');
	        return {
	            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
	            year: adjustedMoment.year()
	        };
	    }

	    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
	        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

	        d = d === 0 ? 7 : d;
	        weekday = weekday != null ? weekday : firstDayOfWeek;
	        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
	        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

	        return {
	            year: dayOfYear > 0 ? year : year - 1,
	            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
	        };
	    }

	    /************************************
	     Top Level Functions
	     ************************************/

	    function makeMoment(config) {
	        var input = config._i,
	            format = config._f,
	            res;

	        config._locale = config._locale || moment.localeData(config._l);

	        if (input === null || (format === undefined && input === '')) {
	            return moment.invalid({nullInput: true});
	        }

	        if (typeof input === 'string') {
	            config._i = input = config._locale.preparse(input);
	        }

	        if (moment.isMoment(input)) {
	            return new Moment(input, true);
	        } else if (format) {
	            if (isArray(format)) {
	                makeDateFromStringAndArray(config);
	            } else {
	                makeDateFromStringAndFormat(config);
	            }
	        } else {
	            makeDateFromInput(config);
	        }

	        res = new Moment(config);
	        if (res._nextDay) {
	            // Adding is smart enough around DST
	            res.add(1, 'd');
	            res._nextDay = undefined;
	        }

	        return res;
	    }

	    moment = function (input, format, locale, strict) {
	        var c;

	        if (typeof(locale) === 'boolean') {
	            strict = locale;
	            locale = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c = {};
	        c._isAMomentObject = true;
	        c._i = input;
	        c._f = format;
	        c._l = locale;
	        c._strict = strict;
	        c._isUTC = false;
	        c._pf = defaultParsingFlags();

	        return makeMoment(c);
	    };

	    moment.suppressDeprecationWarnings = false;

	    moment.createFromInputFallback = deprecate(
	        'moment construction falls back to js Date. This is ' +
	        'discouraged and will be removed in upcoming major ' +
	        'release. Please refer to ' +
	        'https://github.com/moment/moment/issues/1407 for more info.',
	        function (config) {
	            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	        }
	    );

	    // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.
	    function pickBy(fn, moments) {
	        var res, i;
	        if (moments.length === 1 && isArray(moments[0])) {
	            moments = moments[0];
	        }
	        if (!moments.length) {
	            return moment();
	        }
	        res = moments[0];
	        for (i = 1; i < moments.length; ++i) {
	            if (moments[i][fn](res)) {
	                res = moments[i];
	            }
	        }
	        return res;
	    }

	    moment.min = function () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isBefore', args);
	    };

	    moment.max = function () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isAfter', args);
	    };

	    // creating with utc
	    moment.utc = function (input, format, locale, strict) {
	        var c;

	        if (typeof(locale) === 'boolean') {
	            strict = locale;
	            locale = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c = {};
	        c._isAMomentObject = true;
	        c._useUTC = true;
	        c._isUTC = true;
	        c._l = locale;
	        c._i = input;
	        c._f = format;
	        c._strict = strict;
	        c._pf = defaultParsingFlags();

	        return makeMoment(c).utc();
	    };

	    // creating with unix timestamp (in seconds)
	    moment.unix = function (input) {
	        return moment(input * 1000);
	    };

	    // duration
	    moment.duration = function (input, key) {
	        var duration = input,
	        // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            parseIso,
	            diffRes;

	        if (moment.isDuration(input)) {
	            duration = {
	                ms: input._milliseconds,
	                d: input._days,
	                M: input._months
	            };
	        } else if (typeof input === 'number') {
	            duration = {};
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y: 0,
	                d: toInt(match[DATE]) * sign,
	                h: toInt(match[HOUR]) * sign,
	                m: toInt(match[MINUTE]) * sign,
	                s: toInt(match[SECOND]) * sign,
	                ms: toInt(match[MILLISECOND]) * sign
	            };
	        } else if (!!(match = isoDurationRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            parseIso = function (inp) {
	                // We'd normally use ~~inp for this, but unfortunately it also
	                // converts floats to ints.
	                // inp may be undefined, so careful calling replace on it.
	                var res = inp && parseFloat(inp.replace(',', '.'));
	                // apply sign while we're at it
	                return (isNaN(res) ? 0 : res) * sign;
	            };
	            duration = {
	                y: parseIso(match[2]),
	                M: parseIso(match[3]),
	                d: parseIso(match[4]),
	                h: parseIso(match[5]),
	                m: parseIso(match[6]),
	                s: parseIso(match[7]),
	                w: parseIso(match[8])
	            };
	        } else if (duration == null) {// checks for null or undefined
	            duration = {};
	        } else if (typeof duration === 'object' &&
	            ('from' in duration || 'to' in duration)) {
	            diffRes = momentsDifference(moment(duration.from), moment(duration.to));

	            duration = {};
	            duration.ms = diffRes.milliseconds;
	            duration.M = diffRes.months;
	        }

	        ret = new Duration(duration);

	        if (moment.isDuration(input) && hasOwnProp(input, '_locale')) {
	            ret._locale = input._locale;
	        }

	        return ret;
	    };

	    // version number
	    moment.version = VERSION;

	    // default format
	    moment.defaultFormat = isoFormat;

	    // constant that refers to the ISO standard
	    moment.ISO_8601 = function () {};

	    // Plugins that add properties should also add the key here (null value),
	    // so we can properly clone ourselves.
	    moment.momentProperties = momentProperties;

	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    moment.updateOffset = function () {};

	    // This function allows you to set a threshold for relative time strings
	    moment.relativeTimeThreshold = function (threshold, limit) {
	        if (relativeTimeThresholds[threshold] === undefined) {
	            return false;
	        }
	        if (limit === undefined) {
	            return relativeTimeThresholds[threshold];
	        }
	        relativeTimeThresholds[threshold] = limit;
	        return true;
	    };

	    moment.lang = deprecate(
	        'moment.lang is deprecated. Use moment.locale instead.',
	        function (key, value) {
	            return moment.locale(key, value);
	        }
	    );

	    // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    moment.locale = function (key, values) {
	        var data;
	        if (key) {
	            if (typeof(values) !== 'undefined') {
	                data = moment.defineLocale(key, values);
	            }
	            else {
	                data = moment.localeData(key);
	            }

	            if (data) {
	                moment.duration._locale = moment._locale = data;
	            }
	        }

	        return moment._locale._abbr;
	    };

	    moment.defineLocale = function (name, values) {
	        if (values !== null) {
	            values.abbr = name;
	            if (!locales[name]) {
	                locales[name] = new Locale();
	            }
	            locales[name].set(values);

	            // backwards compat for now: also set the locale
	            moment.locale(name);

	            return locales[name];
	        } else {
	            // useful for testing
	            delete locales[name];
	            return null;
	        }
	    };

	    moment.langData = deprecate(
	        'moment.langData is deprecated. Use moment.localeData instead.',
	        function (key) {
	            return moment.localeData(key);
	        }
	    );

	    // returns locale data
	    moment.localeData = function (key) {
	        var locale;

	        if (key && key._locale && key._locale._abbr) {
	            key = key._locale._abbr;
	        }

	        if (!key) {
	            return moment._locale;
	        }

	        if (!isArray(key)) {
	            //short-circuit everything else
	            locale = loadLocale(key);
	            if (locale) {
	                return locale;
	            }
	            key = [key];
	        }

	        return chooseLocale(key);
	    };

	    // compare moment object
	    moment.isMoment = function (obj) {
	        return obj instanceof Moment ||
	            (obj != null && hasOwnProp(obj, '_isAMomentObject'));
	    };

	    // for typechecking Duration objects
	    moment.isDuration = function (obj) {
	        return obj instanceof Duration;
	    };

	    for (i = lists.length - 1; i >= 0; --i) {
	        makeList(lists[i]);
	    }

	    moment.normalizeUnits = function (units) {
	        return normalizeUnits(units);
	    };

	    moment.invalid = function (flags) {
	        var m = moment.utc(NaN);
	        if (flags != null) {
	            extend(m._pf, flags);
	        }
	        else {
	            m._pf.userInvalidated = true;
	        }

	        return m;
	    };

	    moment.parseZone = function () {
	        return moment.apply(null, arguments).parseZone();
	    };

	    moment.parseTwoDigitYear = function (input) {
	        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    };

	    moment.isDate = isDate;

	    /************************************
	     Moment Prototype
	     ************************************/


	    extend(moment.fn = Moment.prototype, {

	        clone : function () {
	            return moment(this);
	        },

	        valueOf : function () {
	            return +this._d - ((this._offset || 0) * 60000);
	        },

	        unix : function () {
	            return Math.floor(+this / 1000);
	        },

	        toString : function () {
	            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	        },

	        toDate : function () {
	            return this._offset ? new Date(+this) : this._d;
	        },

	        toISOString : function () {
	            var m = moment(this).utc();
	            if (0 < m.year() && m.year() <= 9999) {
	                if ('function' === typeof Date.prototype.toISOString) {
	                    // native implementation is ~50x faster, use it when we can
	                    return this.toDate().toISOString();
	                } else {
	                    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	                }
	            } else {
	                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            }
	        },

	        toArray : function () {
	            var m = this;
	            return [
	                m.year(),
	                m.month(),
	                m.date(),
	                m.hours(),
	                m.minutes(),
	                m.seconds(),
	                m.milliseconds()
	            ];
	        },

	        isValid : function () {
	            return isValid(this);
	        },

	        isDSTShifted : function () {
	            if (this._a) {
	                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
	            }

	            return false;
	        },

	        parsingFlags : function () {
	            return extend({}, this._pf);
	        },

	        invalidAt: function () {
	            return this._pf.overflow;
	        },

	        utc : function (keepLocalTime) {
	            return this.utcOffset(0, keepLocalTime);
	        },

	        local : function (keepLocalTime) {
	            if (this._isUTC) {
	                this.utcOffset(0, keepLocalTime);
	                this._isUTC = false;

	                if (keepLocalTime) {
	                    this.subtract(this._dateUtcOffset(), 'm');
	                }
	            }
	            return this;
	        },

	        format : function (inputString) {
	            var output = formatMoment(this, inputString || moment.defaultFormat);
	            return this.localeData().postformat(output);
	        },

	        add : createAdder(1, 'add'),

	        subtract : createAdder(-1, 'subtract'),

	        diff : function (input, units, asFloat) {
	            var that = makeAs(input, this),
	                zoneDiff = (that.utcOffset() - this.utcOffset()) * 6e4,
	                anchor, diff, output, daysAdjust;

	            units = normalizeUnits(units);

	            if (units === 'year' || units === 'month' || units === 'quarter') {
	                output = monthDiff(this, that);
	                if (units === 'quarter') {
	                    output = output / 3;
	                } else if (units === 'year') {
	                    output = output / 12;
	                }
	            } else {
	                diff = this - that;
	                output = units === 'second' ? diff / 1e3 : // 1000
	                    units === 'minute' ? diff / 6e4 : // 1000 * 60
	                        units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
	                            units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	                                units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	                                    diff;
	            }
	            return asFloat ? output : absRound(output);
	        },

	        from : function (time, withoutSuffix) {
	            return moment.duration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	        },

	        fromNow : function (withoutSuffix) {
	            return this.from(moment(), withoutSuffix);
	        },

	        calendar : function (time) {
	            // We want to compare the start of today, vs this.
	            // Getting start-of-today depends on whether we're locat/utc/offset
	            // or not.
	            var now = time || moment(),
	                sod = makeAs(now, this).startOf('day'),
	                diff = this.diff(sod, 'days', true),
	                format = diff < -6 ? 'sameElse' :
	                    diff < -1 ? 'lastWeek' :
	                        diff < 0 ? 'lastDay' :
	                            diff < 1 ? 'sameDay' :
	                                diff < 2 ? 'nextDay' :
	                                    diff < 7 ? 'nextWeek' : 'sameElse';
	            return this.format(this.localeData().calendar(format, this, moment(now)));
	        },

	        isLeapYear : function () {
	            return isLeapYear(this.year());
	        },

	        isDST : function () {
	            return (this.utcOffset() > this.clone().month(0).utcOffset() ||
	            this.utcOffset() > this.clone().month(5).utcOffset());
	        },

	        day : function (input) {
	            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	            if (input != null) {
	                input = parseWeekday(input, this.localeData());
	                return this.add(input - day, 'd');
	            } else {
	                return day;
	            }
	        },

	        month : makeAccessor('Month', true),

	        startOf : function (units) {
	            units = normalizeUnits(units);
	            // the following switch intentionally omits break keywords
	            // to utilize falling through the cases.
	            switch (units) {
	                case 'year':
	                    this.month(0);
	                /* falls through */
	                case 'quarter':
	                case 'month':
	                    this.date(1);
	                /* falls through */
	                case 'week':
	                case 'isoWeek':
	                case 'day':
	                    this.hours(0);
	                /* falls through */
	                case 'hour':
	                    this.minutes(0);
	                /* falls through */
	                case 'minute':
	                    this.seconds(0);
	                /* falls through */
	                case 'second':
	                    this.milliseconds(0);
	                /* falls through */
	            }

	            // weeks are a special case
	            if (units === 'week') {
	                this.weekday(0);
	            } else if (units === 'isoWeek') {
	                this.isoWeekday(1);
	            }

	            // quarters are also special
	            if (units === 'quarter') {
	                this.month(Math.floor(this.month() / 3) * 3);
	            }

	            return this;
	        },

	        endOf: function (units) {
	            units = normalizeUnits(units);
	            if (units === undefined || units === 'millisecond') {
	                return this;
	            }
	            return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	        },

	        isAfter: function (input, units) {
	            var inputMs;
	            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
	            if (units === 'millisecond') {
	                input = moment.isMoment(input) ? input : moment(input);
	                return +this > +input;
	            } else {
	                inputMs = moment.isMoment(input) ? +input : +moment(input);
	                return inputMs < +this.clone().startOf(units);
	            }
	        },

	        isBefore: function (input, units) {
	            var inputMs;
	            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
	            if (units === 'millisecond') {
	                input = moment.isMoment(input) ? input : moment(input);
	                return +this < +input;
	            } else {
	                inputMs = moment.isMoment(input) ? +input : +moment(input);
	                return +this.clone().endOf(units) < inputMs;
	            }
	        },

	        isBetween: function (from, to, units) {
	            return this.isAfter(from, units) && this.isBefore(to, units);
	        },

	        isSame: function (input, units) {
	            var inputMs;
	            units = normalizeUnits(units || 'millisecond');
	            if (units === 'millisecond') {
	                input = moment.isMoment(input) ? input : moment(input);
	                return +this === +input;
	            } else {
	                inputMs = +moment(input);
	                return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
	            }
	        },

	        min: deprecate(
	            'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
	            function (other) {
	                other = moment.apply(null, arguments);
	                return other < this ? this : other;
	            }
	        ),

	        max: deprecate(
	            'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
	            function (other) {
	                other = moment.apply(null, arguments);
	                return other > this ? this : other;
	            }
	        ),

	        zone : deprecate(
	            'moment().zone is deprecated, use moment().utcOffset instead. ' +
	            'https://github.com/moment/moment/issues/1779',
	            function (input, keepLocalTime) {
	                if (input != null) {
	                    if (typeof input !== 'string') {
	                        input = -input;
	                    }

	                    this.utcOffset(input, keepLocalTime);

	                    return this;
	                } else {
	                    return -this.utcOffset();
	                }
	            }
	        ),

	        // keepLocalTime = true means only change the timezone, without
	        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	        // +0200, so we adjust the time as needed, to be valid.
	        //
	        // Keeping the time actually adds/subtracts (one hour)
	        // from the actual represented time. That is why we call updateOffset
	        // a second time. In case it wants us to change the offset again
	        // _changeInProgress == true case, then we have to adjust, because
	        // there is no such time in the given timezone.
	        utcOffset : function (input, keepLocalTime) {
	            var offset = this._offset || 0,
	                localAdjust;
	            if (input != null) {
	                if (typeof input === 'string') {
	                    input = utcOffsetFromString(input);
	                }
	                if (Math.abs(input) < 16) {
	                    input = input * 60;
	                }
	                if (!this._isUTC && keepLocalTime) {
	                    localAdjust = this._dateUtcOffset();
	                }
	                this._offset = input;
	                this._isUTC = true;
	                if (localAdjust != null) {
	                    this.add(localAdjust, 'm');
	                }
	                if (offset !== input) {
	                    if (!keepLocalTime || this._changeInProgress) {
	                        addOrSubtractDurationFromMoment(this,
	                            moment.duration(input - offset, 'm'), 1, false);
	                    } else if (!this._changeInProgress) {
	                        this._changeInProgress = true;
	                        moment.updateOffset(this, true);
	                        this._changeInProgress = null;
	                    }
	                }

	                return this;
	            } else {
	                return this._isUTC ? offset : this._dateUtcOffset();
	            }
	        },

	        isLocal : function () {
	            return !this._isUTC;
	        },

	        isUtcOffset : function () {
	            return this._isUTC;
	        },

	        isUtc : function () {
	            return this._isUTC && this._offset === 0;
	        },

	        zoneAbbr : function () {
	            return this._isUTC ? 'UTC' : '';
	        },

	        zoneName : function () {
	            return this._isUTC ? 'Coordinated Universal Time' : '';
	        },

	        parseZone : function () {
	            if (this._tzm) {
	                this.utcOffset(this._tzm);
	            } else if (typeof this._i === 'string') {
	                this.utcOffset(utcOffsetFromString(this._i));
	            }
	            return this;
	        },

	        hasAlignedHourOffset : function (input) {
	            if (!input) {
	                input = 0;
	            }
	            else {
	                input = moment(input).utcOffset();
	            }

	            return (this.utcOffset() - input) % 60 === 0;
	        },

	        daysInMonth : function () {
	            return daysInMonth(this.year(), this.month());
	        },

	        dayOfYear : function (input) {
	            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
	            return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	        },

	        quarter : function (input) {
	            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	        },

	        weekYear : function (input) {
	            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
	            return input == null ? year : this.add((input - year), 'y');
	        },

	        isoWeekYear : function (input) {
	            var year = weekOfYear(this, 1, 4).year;
	            return input == null ? year : this.add((input - year), 'y');
	        },

	        week : function (input) {
	            var week = this.localeData().week(this);
	            return input == null ? week : this.add((input - week) * 7, 'd');
	        },

	        isoWeek : function (input) {
	            var week = weekOfYear(this, 1, 4).week;
	            return input == null ? week : this.add((input - week) * 7, 'd');
	        },

	        weekday : function (input) {
	            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	            return input == null ? weekday : this.add(input - weekday, 'd');
	        },

	        isoWeekday : function (input) {
	            // behaves the same as moment#day except
	            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	            // as a setter, sunday should belong to the previous week.
	            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
	        },

	        isoWeeksInYear : function () {
	            return weeksInYear(this.year(), 1, 4);
	        },

	        weeksInYear : function () {
	            var weekInfo = this.localeData()._week;
	            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	        },

	        get : function (units) {
	            units = normalizeUnits(units);
	            return this[units]();
	        },

	        set : function (units, value) {
	            var unit;
	            if (typeof units === 'object') {
	                for (unit in units) {
	                    this.set(unit, units[unit]);
	                }
	            }
	            else {
	                units = normalizeUnits(units);
	                if (typeof this[units] === 'function') {
	                    this[units](value);
	                }
	            }
	            return this;
	        },

	        // If passed a locale key, it will set the locale for this
	        // instance.  Otherwise, it will return the locale configuration
	        // variables for this instance.
	        locale : function (key) {
	            var newLocaleData;

	            if (key === undefined) {
	                return this._locale._abbr;
	            } else {
	                newLocaleData = moment.localeData(key);
	                if (newLocaleData != null) {
	                    this._locale = newLocaleData;
	                }
	                return this;
	            }
	        },

	        lang : deprecate(
	            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	            function (key) {
	                if (key === undefined) {
	                    return this.localeData();
	                } else {
	                    return this.locale(key);
	                }
	            }
	        ),

	        localeData : function () {
	            return this._locale;
	        },

	        _dateUtcOffset : function () {
	            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	            // https://github.com/moment/moment/pull/1871
	            return -Math.round(this._d.getTimezoneOffset() / 15) * 15;
	        }

	    });

	    function rawMonthSetter(mom, value) {
	        var dayOfMonth;

	        // TODO: Move this out of here!
	        if (typeof value === 'string') {
	            value = mom.localeData().monthsParse(value);
	            // TODO: Another silent failure?
	            if (typeof value !== 'number') {
	                return mom;
	            }
	        }

	        dayOfMonth = Math.min(mom.date(),
	            daysInMonth(mom.year(), value));
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	        return mom;
	    }

	    function rawGetter(mom, unit) {
	        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
	    }

	    function rawSetter(mom, unit, value) {
	        if (unit === 'Month') {
	            return rawMonthSetter(mom, value);
	        } else {
	            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	        }
	    }

	    function makeAccessor(unit, keepTime) {
	        return function (value) {
	            if (value != null) {
	                rawSetter(this, unit, value);
	                moment.updateOffset(this, keepTime);
	                return this;
	            } else {
	                return rawGetter(this, unit);
	            }
	        };
	    }

	    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
	    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
	    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
	    // Setting the hour should keep the time, because the user explicitly
	    // specified which hour he wants. So trying to maintain the same hour (in
	    // a new timezone) makes sense. Adding/subtracting hours does not follow
	    // this rule.
	    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
	    // moment.fn.month is defined separately
	    moment.fn.date = makeAccessor('Date', true);
	    moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));
	    moment.fn.year = makeAccessor('FullYear', true);
	    moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));

	    // add plural methods
	    moment.fn.days = moment.fn.day;
	    moment.fn.months = moment.fn.month;
	    moment.fn.weeks = moment.fn.week;
	    moment.fn.isoWeeks = moment.fn.isoWeek;
	    moment.fn.quarters = moment.fn.quarter;

	    // add aliased format methods
	    moment.fn.toJSON = moment.fn.toISOString;

	    // alias isUtc for dev-friendliness
	    moment.fn.isUTC = moment.fn.isUtc;

	    /************************************
	     Duration Prototype
	     ************************************/


	    function daysToYears (days) {
	        // 400 years have 146097 days (taking into account leap year rules)
	        return days * 400 / 146097;
	    }

	    function yearsToDays (years) {
	        // years * 365 + absRound(years / 4) -
	        //     absRound(years / 100) + absRound(years / 400);
	        return years * 146097 / 400;
	    }

	    extend(moment.duration.fn = Duration.prototype, {

	        _bubble : function () {
	            var milliseconds = this._milliseconds,
	                days = this._days,
	                months = this._months,
	                data = this._data,
	                seconds, minutes, hours, years = 0;

	            // The following code bubbles up values, see the tests for
	            // examples of what that means.
	            data.milliseconds = milliseconds % 1000;

	            seconds = absRound(milliseconds / 1000);
	            data.seconds = seconds % 60;

	            minutes = absRound(seconds / 60);
	            data.minutes = minutes % 60;

	            hours = absRound(minutes / 60);
	            data.hours = hours % 24;

	            days += absRound(hours / 24);

	            // Accurately convert days to years, assume start from year 0.
	            years = absRound(daysToYears(days));
	            days -= absRound(yearsToDays(years));

	            // 30 days to a month
	            // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
	            months += absRound(days / 30);
	            days %= 30;

	            // 12 months -> 1 year
	            years += absRound(months / 12);
	            months %= 12;

	            data.days = days;
	            data.months = months;
	            data.years = years;
	        },

	        abs : function () {
	            this._milliseconds = Math.abs(this._milliseconds);
	            this._days = Math.abs(this._days);
	            this._months = Math.abs(this._months);

	            this._data.milliseconds = Math.abs(this._data.milliseconds);
	            this._data.seconds = Math.abs(this._data.seconds);
	            this._data.minutes = Math.abs(this._data.minutes);
	            this._data.hours = Math.abs(this._data.hours);
	            this._data.months = Math.abs(this._data.months);
	            this._data.years = Math.abs(this._data.years);

	            return this;
	        },

	        weeks : function () {
	            return absRound(this.days() / 7);
	        },

	        valueOf : function () {
	            return this._milliseconds +
	                this._days * 864e5 +
	                (this._months % 12) * 2592e6 +
	                toInt(this._months / 12) * 31536e6;
	        },

	        humanize : function (withSuffix) {
	            var output = relativeTime(this, !withSuffix, this.localeData());

	            if (withSuffix) {
	                output = this.localeData().pastFuture(+this, output);
	            }

	            return this.localeData().postformat(output);
	        },

	        add : function (input, val) {
	            // supports only 2.0-style add(1, 's') or add(moment)
	            var dur = moment.duration(input, val);

	            this._milliseconds += dur._milliseconds;
	            this._days += dur._days;
	            this._months += dur._months;

	            this._bubble();

	            return this;
	        },

	        subtract : function (input, val) {
	            var dur = moment.duration(input, val);

	            this._milliseconds -= dur._milliseconds;
	            this._days -= dur._days;
	            this._months -= dur._months;

	            this._bubble();

	            return this;
	        },

	        get : function (units) {
	            units = normalizeUnits(units);
	            return this[units.toLowerCase() + 's']();
	        },

	        as : function (units) {
	            var days, months;
	            units = normalizeUnits(units);

	            if (units === 'month' || units === 'year') {
	                days = this._days + this._milliseconds / 864e5;
	                months = this._months + daysToYears(days) * 12;
	                return units === 'month' ? months : months / 12;
	            } else {
	                // handle milliseconds separately because of floating point math errors (issue #1867)
	                days = this._days + Math.round(yearsToDays(this._months / 12));
	                switch (units) {
	                    case 'week': return days / 7 + this._milliseconds / 6048e5;
	                    case 'day': return days + this._milliseconds / 864e5;
	                    case 'hour': return days * 24 + this._milliseconds / 36e5;
	                    case 'minute': return days * 24 * 60 + this._milliseconds / 6e4;
	                    case 'second': return days * 24 * 60 * 60 + this._milliseconds / 1000;
	                    // Math.floor prevents floating point math errors here
	                    case 'millisecond': return Math.floor(days * 24 * 60 * 60 * 1000) + this._milliseconds;
	                    default: throw new Error('Unknown unit ' + units);
	                }
	            }
	        },

	        lang : moment.fn.lang,
	        locale : moment.fn.locale,

	        toIsoString : deprecate(
	            'toIsoString() is deprecated. Please use toISOString() instead ' +
	            '(notice the capitals)',
	            function () {
	                return this.toISOString();
	            }
	        ),

	        toISOString : function () {
	            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	            var years = Math.abs(this.years()),
	                months = Math.abs(this.months()),
	                days = Math.abs(this.days()),
	                hours = Math.abs(this.hours()),
	                minutes = Math.abs(this.minutes()),
	                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

	            if (!this.asSeconds()) {
	                // this is the same as C#'s (Noda) and python (isodate)...
	                // but not other JS (goog.date)
	                return 'P0D';
	            }

	            return (this.asSeconds() < 0 ? '-' : '') +
	                'P' +
	                (years ? years + 'Y' : '') +
	                (months ? months + 'M' : '') +
	                (days ? days + 'D' : '') +
	                ((hours || minutes || seconds) ? 'T' : '') +
	                (hours ? hours + 'H' : '') +
	                (minutes ? minutes + 'M' : '') +
	                (seconds ? seconds + 'S' : '');
	        },

	        localeData : function () {
	            return this._locale;
	        },

	        toJSON : function () {
	            return this.toISOString();
	        }
	    });

	    moment.duration.fn.toString = moment.duration.fn.toISOString;

	    function makeDurationGetter(name) {
	        moment.duration.fn[name] = function () {
	            return this._data[name];
	        };
	    }

	    for (i in unitMillisecondFactors) {
	        if (hasOwnProp(unitMillisecondFactors, i)) {
	            makeDurationGetter(i.toLowerCase());
	        }
	    }

	    moment.duration.fn.asMilliseconds = function () {
	        return this.as('ms');
	    };
	    moment.duration.fn.asSeconds = function () {
	        return this.as('s');
	    };
	    moment.duration.fn.asMinutes = function () {
	        return this.as('m');
	    };
	    moment.duration.fn.asHours = function () {
	        return this.as('h');
	    };
	    moment.duration.fn.asDays = function () {
	        return this.as('d');
	    };
	    moment.duration.fn.asWeeks = function () {
	        return this.as('weeks');
	    };
	    moment.duration.fn.asMonths = function () {
	        return this.as('M');
	    };
	    moment.duration.fn.asYears = function () {
	        return this.as('y');
	    };

	    /************************************
	     Default Locale
	     ************************************/


	        // Set default locale, other locale will inherit from English.
	    moment.locale('en', {
	        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                    (b === 1) ? 'st' :
	                        (b === 2) ? 'nd' :
	                            (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });

	    /* EMBED_LOCALES */

	    /************************************
	     Exposing Moment
	     ************************************/

	    function makeGlobal(shouldDeprecate) {
	        /*global ender:false */
	        if (typeof ender !== 'undefined') {
	            return;
	        }
	        oldGlobalMoment = globalScope.moment;
	        if (shouldDeprecate) {
	            globalScope.moment = deprecate(
	                'Accessing Moment through the global scope is ' +
	                'deprecated, and will be removed in an upcoming ' +
	                'release.',
	                moment);
	        } else {
	            globalScope.moment = moment;
	        }
	    }

	    // CommonJS module is defined
	    if (hasModule) {
	        module.exports = moment;
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	            if (module.config && module.config() && module.config().noGlobal === true) {
	                // release the global variable
	                globalScope.moment = oldGlobalMoment;
	            }

	            return moment;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	        makeGlobal(true);
	    } else {
	        makeGlobal();
	    }
	}).call(this);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(4)(module)))

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<td class=\"exercise-table-td-name\"></td><td class=\"exercise-table-td-date\"></td><td class=\"exercise-table-td-type\"></td>");;return buf.join("");
	}

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-sm-12\"><span><b>List of exercises</b></span></div></div><br><div class=\"row\"><div class=\"col-sm-8\"><div class=\"btn-group\"><button id=\"exercise-table-first\" class=\"btn btn-default\"><i class=\"fa fa-chevron-left\"></i><i class=\"fa fa-chevron-left\"></i></button><button id=\"exercise-table-prev\" class=\"btn btn-default\"><i class=\"fa fa-chevron-left\"></i></button><button id=\"exercise-table-next\" class=\"btn btn-default\"><i class=\"fa fa-chevron-right\"></i></button><button id=\"exercise-table-last\" class=\"btn btn-default\"><i class=\"fa fa-chevron-right\"></i><i class=\"fa fa-chevron-right\"></i></button></div></div><div class=\"col-sm-4\"><div class=\"pull-right\"><span><b id=\"exercise-table-currentpage\"></b>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "</span><span><b>/</b>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "</span><span><b id=\"exercise-table-lastpage\"></b></span></div></div></div><br><div class=\"row\"><div class=\"col-sm-12\"><table class=\"table table-condensed table-bordered table-hover\"><thead><tr><td><b>Name</b></td><td><b>Date</b></td><td><b>Type</b></td></tr></thead><tbody></tbody></table></div></div>");;return buf.join("");
	}

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-sm-12\"><button id=\"exercise-back-home\" class=\"btn btn-default\"><i class=\"fa fa-lg fa-arrow-left\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "<i class=\"fa fa-lg fa-home\"></i></button></div></div><br><div class=\"row\"><div class=\"col-sm-12\"><span class=\"lead\"><i class=\"fa fa-fw fa-lg fa-heartbeat\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Exercise</span></div></div><br><div class=\"row\"><div class=\"col-sm-6\"><div id=\"exercise-input-view\"></div></div><div class=\"col-sm-6\"><div id=\"exercise-table-view\"></div></div></div>");;return buf.join("");
	}

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var Backbone = __webpack_require__(8);

	/*
	  backbone.paginator 2.0.0
	  http://github.com/backbone-paginator/backbone.paginator

	  Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
	  Licensed under the MIT @license.
	*/

	(function (factory) {

	  // CommonJS
	  if (true) {
	    module.exports = factory(__webpack_require__(9), __webpack_require__(8));
	  }
	  // AMD
	  else if (typeof define == "function" && define.amd) {
	    define(["underscore", "backbone"], factory);
	  }
	  // Browser
	  else if (typeof _ !== "undefined" && typeof Backbone !== "undefined") {
	    var oldPageableCollection = Backbone.PageableCollection;
	    var PageableCollection = factory(_, Backbone);

	    /**
	       __BROWSER ONLY__

	       If you already have an object named `PageableCollection` attached to the
	       `Backbone` module, you can use this to return a local reference to this
	       Backbone.PageableCollection class and reset the name
	       Backbone.PageableCollection to its previous definition.

	           // The left hand side gives you a reference to this
	           // Backbone.PageableCollection implementation, the right hand side
	           // resets Backbone.PageableCollection to your other
	           // Backbone.PageableCollection.
	           var PageableCollection = Backbone.PageableCollection.noConflict();

	       @static
	       @member Backbone.PageableCollection
	       @return {Backbone.PageableCollection}
	    */
	    Backbone.PageableCollection.noConflict = function () {
	      Backbone.PageableCollection = oldPageableCollection;
	      return PageableCollection;
	    };
	  }

	}(function (_, Backbone) {

	  "use strict";

	  var _extend = _.extend;
	  var _omit = _.omit;
	  var _clone = _.clone;
	  var _each = _.each;
	  var _pick = _.pick;
	  var _contains = _.contains;
	  var _isEmpty = _.isEmpty;
	  var _pairs = _.pairs;
	  var _invert = _.invert;
	  var _isArray = _.isArray;
	  var _isFunction = _.isFunction;
	  var _isObject = _.isObject;
	  var _keys = _.keys;
	  var _isUndefined = _.isUndefined;
	  var ceil = Math.ceil;
	  var floor = Math.floor;
	  var max = Math.max;

	  var BBColProto = Backbone.Collection.prototype;

	  function finiteInt (val, name) {
	    if (!_.isNumber(val) || _.isNaN(val) || !_.isFinite(val) || ~~val !== val) {
	      throw new TypeError("`" + name + "` must be a finite integer");
	    }
	    return val;
	  }

	  function queryStringToParams (qs) {
	    var kvp, k, v, ls, params = {}, decode = decodeURIComponent;
	    var kvps = qs.split('&');
	    for (var i = 0, l = kvps.length; i < l; i++) {
	      var param = kvps[i];
	      kvp = param.split('='), k = kvp[0], v = kvp[1] || true;
	      k = decode(k), v = decode(v), ls = params[k];
	      if (_isArray(ls)) ls.push(v);
	      else if (ls) params[k] = [ls, v];
	      else params[k] = v;
	    }
	    return params;
	  }

	  // hack to make sure the whatever event handlers for this event is run
	  // before func is, and the event handlers that func will trigger.
	  function runOnceAtLastHandler (col, event, func) {
	    var eventHandlers = col._events[event];
	    if (eventHandlers && eventHandlers.length) {
	      var lastHandler = eventHandlers[eventHandlers.length - 1];
	      var oldCallback = lastHandler.callback;
	      lastHandler.callback = function () {
	        try {
	          oldCallback.apply(this, arguments);
	          func();
	        }
	        catch (e) {
	          throw e;
	        }
	        finally {
	          lastHandler.callback = oldCallback;
	        }
	      };
	    }
	    else func();
	  }

	  var PARAM_TRIM_RE = /[\s'"]/g;
	  var URL_TRIM_RE = /[<>\s'"]/g;

	  /**
	     Drop-in replacement for Backbone.Collection. Supports server-side and
	     client-side pagination and sorting. Client-side mode also support fully
	     multi-directional synchronization of changes between pages.

	     @class Backbone.PageableCollection
	     @extends Backbone.Collection
	  */
	  var PageableCollection = Backbone.PageableCollection = Backbone.Collection.extend({

	    /**
	       The container object to store all pagination states.

	       You can override the default state by extending this class or specifying
	       them in an `options` hash to the constructor.

	       @property {Object} state

	       @property {0|1} [state.firstPage=1] The first page index. Set to 0 if
	       your server API uses 0-based indices. You should only override this value
	       during extension, initialization or reset by the server after
	       fetching. This value should be read only at other times.

	       @property {number} [state.lastPage=null] The last page index. This value
	       is __read only__ and it's calculated based on whether `firstPage` is 0 or
	       1, during bootstrapping, fetching and resetting. Please don't change this
	       value under any circumstances.

	       @property {number} [state.currentPage=null] The current page index. You
	       should only override this value during extension, initialization or reset
	       by the server after fetching. This value should be read only at other
	       times. Can be a 0-based or 1-based index, depending on whether
	       `firstPage` is 0 or 1. If left as default, it will be set to `firstPage`
	       on initialization.

	       @property {number} [state.pageSize=25] How many records to show per
	       page. This value is __read only__ after initialization, if you want to
	       change the page size after initialization, you must call #setPageSize.

	       @property {number} [state.totalPages=null] How many pages there are. This
	       value is __read only__ and it is calculated from `totalRecords`.

	       @property {number} [state.totalRecords=null] How many records there
	       are. This value is __required__ under server mode. This value is optional
	       for client mode as the number will be the same as the number of models
	       during bootstrapping and during fetching, either supplied by the server
	       in the metadata, or calculated from the size of the response.

	       @property {string} [state.sortKey=null] The model attribute to use for
	       sorting.

	       @property {-1|0|1} [state.order=-1] The order to use for sorting. Specify
	       -1 for ascending order or 1 for descending order. If 0, no client side
	       sorting will be done and the order query parameter will not be sent to
	       the server during a fetch.
	    */
	    state: {
	      firstPage: 1,
	      lastPage: null,
	      currentPage: null,
	      pageSize: 25,
	      totalPages: null,
	      totalRecords: null,
	      sortKey: null,
	      order: -1
	    },

	    /**
	       @property {"server"|"client"|"infinite"} [mode="server"] The mode of
	       operations for this collection. `"server"` paginates on the server-side,
	       `"client"` paginates on the client-side and `"infinite"` paginates on the
	       server-side for APIs that do not support `totalRecords`.
	    */
	    mode: "server",

	    /**
	       A translation map to convert Backbone.PageableCollection state attributes
	       to the query parameters accepted by your server API.

	       You can override the default state by extending this class or specifying
	       them in `options.queryParams` object hash to the constructor.

	       @property {Object} queryParams
	       @property {string} [queryParams.currentPage="page"]
	       @property {string} [queryParams.pageSize="per_page"]
	       @property {string} [queryParams.totalPages="total_pages"]
	       @property {string} [queryParams.totalRecords="total_entries"]
	       @property {string} [queryParams.sortKey="sort_by"]
	       @property {string} [queryParams.order="order"]
	       @property {string} [queryParams.directions={"-1": "asc", "1": "desc"}] A
	       map for translating a Backbone.PageableCollection#state.order constant to
	       the ones your server API accepts.
	    */
	    queryParams: {
	      currentPage: "page",
	      pageSize: "per_page",
	      totalPages: "total_pages",
	      totalRecords: "total_entries",
	      sortKey: "sort_by",
	      order: "order",
	      directions: {
	        "-1": "asc",
	        "1": "desc"
	      }
	    },

	    /**
	       __CLIENT MODE ONLY__

	       This collection is the internal storage for the bootstrapped or fetched
	       models. You can use this if you want to operate on all the pages.

	       @property {Backbone.Collection} fullCollection
	    */

	    /**
	       Given a list of models or model attributues, bootstraps the full
	       collection in client mode or infinite mode, or just the page you want in
	       server mode.

	       If you want to initialize a collection to a different state than the
	       default, you can specify them in `options.state`. Any state parameters
	       supplied will be merged with the default. If you want to change the
	       default mapping from #state keys to your server API's query parameter
	       names, you can specifiy an object hash in `option.queryParams`. Likewise,
	       any mapping provided will be merged with the default. Lastly, all
	       Backbone.Collection constructor options are also accepted.

	       See:

	       - Backbone.PageableCollection#state
	       - Backbone.PageableCollection#queryParams
	       - [Backbone.Collection#initialize](http://backbonejs.org/#Collection-constructor)

	       @param {Array.<Object>} [models]

	       @param {Object} [options]

	       @param {function(*, *): number} [options.comparator] If specified, this
	       comparator is set to the current page under server mode, or the #fullCollection
	       otherwise.

	       @param {boolean} [options.full] If `false` and either a
	       `options.comparator` or `sortKey` is defined, the comparator is attached
	       to the current page. Default is `true` under client or infinite mode and
	       the comparator will be attached to the #fullCollection.

	       @param {Object} [options.state] The state attributes overriding the defaults.

	       @param {string} [options.state.sortKey] The model attribute to use for
	       sorting. If specified instead of `options.comparator`, a comparator will
	       be automatically created using this value, and optionally a sorting order
	       specified in `options.state.order`. The comparator is then attached to
	       the new collection instance.

	       @param {-1|1} [options.state.order] The order to use for sorting. Specify
	       -1 for ascending order and 1 for descending order.

	       @param {Object} [options.queryParam]
	    */
	    constructor: function (models, options) {

	      BBColProto.constructor.apply(this, arguments);

	      options = options || {};

	      var mode = this.mode = options.mode || this.mode || PageableProto.mode;

	      var queryParams = _extend({}, PageableProto.queryParams, this.queryParams,
	                                options.queryParams || {});

	      queryParams.directions = _extend({},
	                                       PageableProto.queryParams.directions,
	                                       this.queryParams.directions,
	                                       queryParams.directions || {});

	      this.queryParams = queryParams;

	      var state = this.state = _extend({}, PageableProto.state, this.state,
	                                       options.state || {});

	      state.currentPage = state.currentPage == null ?
	        state.firstPage :
	        state.currentPage;

	      if (!_isArray(models)) models = models ? [models] : [];
	      models = models.slice();

	      if (mode != "server" && state.totalRecords == null && !_isEmpty(models)) {
	        state.totalRecords = models.length;
	      }

	      this.switchMode(mode, _extend({fetch: false,
	                                     resetState: false,
	                                     models: models}, options));

	      var comparator = options.comparator;

	      if (state.sortKey && !comparator) {
	        this.setSorting(state.sortKey, state.order, options);
	      }

	      if (mode != "server") {
	        var fullCollection = this.fullCollection;

	        if (comparator && options.full) {
	          this.comparator = null;
	          fullCollection.comparator = comparator;
	        }

	        if (options.full) fullCollection.sort();

	        // make sure the models in the current page and full collection have the
	        // same references
	        if (models && !_isEmpty(models)) {
	          this.reset(models, _extend({silent: true}, options));
	          this.getPage(state.currentPage);
	          models.splice.apply(models, [0, models.length].concat(this.models));
	        }
	      }

	      this._initState = _clone(this.state);
	    },

	    /**
	       Makes a Backbone.Collection that contains all the pages.

	       @private
	       @param {Array.<Object|Backbone.Model>} models
	       @param {Object} options Options for Backbone.Collection constructor.
	       @return {Backbone.Collection}
	    */
	    _makeFullCollection: function (models, options) {

	      var properties = ["url", "model", "sync", "comparator"];
	      var thisProto = this.constructor.prototype;
	      var i, length, prop;

	      var proto = {};
	      for (i = 0, length = properties.length; i < length; i++) {
	        prop = properties[i];
	        if (!_isUndefined(thisProto[prop])) {
	          proto[prop] = thisProto[prop];
	        }
	      }

	      var fullCollection = new (Backbone.Collection.extend(proto))(models, options);

	      for (i = 0, length = properties.length; i < length; i++) {
	        prop = properties[i];
	        if (this[prop] !== thisProto[prop]) {
	          fullCollection[prop] = this[prop];
	        }
	      }

	      return fullCollection;
	    },

	    /**
	       Factory method that returns a Backbone event handler that responses to
	       the `add`, `remove`, `reset`, and the `sort` events. The returned event
	       handler will synchronize the current page collection and the full
	       collection's models.

	       @private

	       @param {Backbone.PageableCollection} pageCol
	       @param {Backbone.Collection} fullCol

	       @return {function(string, Backbone.Model, Backbone.Collection, Object)}
	       Collection event handler
	    */
	    _makeCollectionEventHandler: function (pageCol, fullCol) {

	      return function collectionEventHandler (event, model, collection, options) {

	        var handlers = pageCol._handlers;
	        _each(_keys(handlers), function (event) {
	          var handler = handlers[event];
	          pageCol.off(event, handler);
	          fullCol.off(event, handler);
	        });

	        var state = _clone(pageCol.state);
	        var firstPage = state.firstPage;
	        var currentPage = firstPage === 0 ?
	          state.currentPage :
	          state.currentPage - 1;
	        var pageSize = state.pageSize;
	        var pageStart = currentPage * pageSize, pageEnd = pageStart + pageSize;

	        if (event == "add") {
	          var pageIndex, fullIndex, addAt, colToAdd, options = options || {};
	          if (collection == fullCol) {
	            fullIndex = fullCol.indexOf(model);
	            if (fullIndex >= pageStart && fullIndex < pageEnd) {
	              colToAdd = pageCol;
	              pageIndex = addAt = fullIndex - pageStart;
	            }
	          }
	          else {
	            pageIndex = pageCol.indexOf(model);
	            fullIndex = pageStart + pageIndex;
	            colToAdd = fullCol;
	            var addAt = !_isUndefined(options.at) ?
	              options.at + pageStart :
	              fullIndex;
	          }

	          if (!options.onRemove) {
	            ++state.totalRecords;
	            delete options.onRemove;
	          }

	          pageCol.state = pageCol._checkState(state);

	          if (colToAdd) {
	            colToAdd.add(model, _extend({}, options || {}, {at: addAt}));
	            var modelToRemove = pageIndex >= pageSize ?
	              model :
	              !_isUndefined(options.at) && addAt < pageEnd && pageCol.length > pageSize ?
	              pageCol.at(pageSize) :
	              null;
	            if (modelToRemove) {
	              runOnceAtLastHandler(collection, event, function () {
	                pageCol.remove(modelToRemove, {onAdd: true});
	              });
	            }
	          }
	        }

	        // remove the model from the other collection as well
	        if (event == "remove") {
	          if (!options.onAdd) {
	            // decrement totalRecords and update totalPages and lastPage
	            if (!--state.totalRecords) {
	              state.totalRecords = null;
	              state.totalPages = null;
	            }
	            else {
	              var totalPages = state.totalPages = ceil(state.totalRecords / pageSize);
	              state.lastPage = firstPage === 0 ? totalPages - 1 : totalPages || firstPage;
	              if (state.currentPage > totalPages) state.currentPage = state.lastPage;
	            }
	            pageCol.state = pageCol._checkState(state);

	            var nextModel, removedIndex = options.index;
	            if (collection == pageCol) {
	              if (nextModel = fullCol.at(pageEnd)) {
	                runOnceAtLastHandler(pageCol, event, function () {
	                  pageCol.push(nextModel, {onRemove: true});
	                });
	              }
	              else if (!pageCol.length && state.totalRecords) {
	                pageCol.reset(fullCol.models.slice(pageStart - pageSize, pageEnd - pageSize),
	                              _extend({}, options, {parse: false}));
	              }
	              fullCol.remove(model);
	            }
	            else if (removedIndex >= pageStart && removedIndex < pageEnd) {
	              if (nextModel = fullCol.at(pageEnd - 1)) {
	                runOnceAtLastHandler(pageCol, event, function() {
	                  pageCol.push(nextModel, {onRemove: true});
	                });
	              }
	              pageCol.remove(model);
	              if (!pageCol.length && state.totalRecords) {
	                pageCol.reset(fullCol.models.slice(pageStart - pageSize, pageEnd - pageSize),
	                              _extend({}, options, {parse: false}));
	              }
	            }
	          }
	          else delete options.onAdd;
	        }

	        if (event == "reset") {
	          options = collection;
	          collection = model;

	          // Reset that's not a result of getPage
	          if (collection == pageCol && options.from == null &&
	              options.to == null) {
	            var head = fullCol.models.slice(0, pageStart);
	            var tail = fullCol.models.slice(pageStart + pageCol.models.length);
	            fullCol.reset(head.concat(pageCol.models).concat(tail), options);
	          }
	          else if (collection == fullCol) {
	            if (!(state.totalRecords = fullCol.models.length)) {
	              state.totalRecords = null;
	              state.totalPages = null;
	            }
	            if (pageCol.mode == "client") {
	              state.lastPage = state.currentPage = state.firstPage;
	            }
	            pageCol.state = pageCol._checkState(state);
	            pageCol.reset(fullCol.models.slice(pageStart, pageEnd),
	                          _extend({}, options, {parse: false}));
	          }
	        }

	        if (event == "sort") {
	          options = collection;
	          collection = model;
	          if (collection === fullCol) {
	            pageCol.reset(fullCol.models.slice(pageStart, pageEnd),
	                          _extend({}, options, {parse: false}));
	          }
	        }

	        _each(_keys(handlers), function (event) {
	          var handler = handlers[event];
	          _each([pageCol, fullCol], function (col) {
	            col.on(event, handler);
	            var callbacks = col._events[event] || [];
	            callbacks.unshift(callbacks.pop());
	          });
	        });
	      };
	    },

	    /**
	       Sanity check this collection's pagination states. Only perform checks
	       when all the required pagination state values are defined and not null.
	       If `totalPages` is undefined or null, it is set to `totalRecords` /
	       `pageSize`. `lastPage` is set according to whether `firstPage` is 0 or 1
	       when no error occurs.

	       @private

	       @throws {TypeError} If `totalRecords`, `pageSize`, `currentPage` or
	       `firstPage` is not a finite integer.

	       @throws {RangeError} If `pageSize`, `currentPage` or `firstPage` is out
	       of bounds.

	       @return {Object} Returns the `state` object if no error was found.
	    */
	    _checkState: function (state) {

	      var mode = this.mode;
	      var links = this.links;
	      var totalRecords = state.totalRecords;
	      var pageSize = state.pageSize;
	      var currentPage = state.currentPage;
	      var firstPage = state.firstPage;
	      var totalPages = state.totalPages;

	      if (totalRecords != null && pageSize != null && currentPage != null &&
	          firstPage != null && (mode == "infinite" ? links : true)) {

	        totalRecords = finiteInt(totalRecords, "totalRecords");
	        pageSize = finiteInt(pageSize, "pageSize");
	        currentPage = finiteInt(currentPage, "currentPage");
	        firstPage = finiteInt(firstPage, "firstPage");

	        if (pageSize < 1) {
	          throw new RangeError("`pageSize` must be >= 1");
	        }

	        totalPages = state.totalPages = ceil(totalRecords / pageSize);

	        if (firstPage < 0 || firstPage > 1) {
	          throw new RangeError("`firstPage must be 0 or 1`");
	        }

	        state.lastPage = firstPage === 0 ? max(0, totalPages - 1) : totalPages || firstPage;

	        if (mode == "infinite") {
	          if (!links[currentPage + '']) {
	            throw new RangeError("No link found for page " + currentPage);
	          }
	        }
	        else if (currentPage < firstPage ||
	                 (totalPages > 0 &&
	                  (firstPage ? currentPage > totalPages : currentPage >= totalPages))) {
	          throw new RangeError("`currentPage` must be firstPage <= currentPage " +
	                               (firstPage ? ">" : ">=") +
	                               " totalPages if " + firstPage + "-based. Got " +
	                               currentPage + '.');
	        }
	      }

	      return state;
	    },

	    /**
	       Change the page size of this collection.

	       Under most if not all circumstances, you should call this method to
	       change the page size of a pageable collection because it will keep the
	       pagination state sane. By default, the method will recalculate the
	       current page number to one that will retain the current page's models
	       when increasing the page size. When decreasing the page size, this method
	       will retain the last models to the current page that will fit into the
	       smaller page size.

	       If `options.first` is true, changing the page size will also reset the
	       current page back to the first page instead of trying to be smart.

	       For server mode operations, changing the page size will trigger a #fetch
	       and subsequently a `reset` event.

	       For client mode operations, changing the page size will `reset` the
	       current page by recalculating the current page boundary on the client
	       side.

	       If `options.fetch` is true, a fetch can be forced if the collection is in
	       client mode.

	       @param {number} pageSize The new page size to set to #state.
	       @param {Object} [options] {@link #fetch} options.
	       @param {boolean} [options.first=false] Reset the current page number to
	       the first page if `true`.
	       @param {boolean} [options.fetch] If `true`, force a fetch in client mode.

	       @throws {TypeError} If `pageSize` is not a finite integer.
	       @throws {RangeError} If `pageSize` is less than 1.

	       @chainable
	       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
	       from fetch or this.
	    */
	    setPageSize: function (pageSize, options) {
	      pageSize = finiteInt(pageSize, "pageSize");

	      options = options || {first: false};

	      var state = this.state;
	      var totalPages = ceil(state.totalRecords / pageSize);
	      var currentPage = totalPages ?
	          max(state.firstPage, floor(totalPages * state.currentPage / state.totalPages)) :
	        state.firstPage;

	      state = this.state = this._checkState(_extend({}, state, {
	        pageSize: pageSize,
	        currentPage: options.first ? state.firstPage : currentPage,
	        totalPages: totalPages
	      }));

	      return this.getPage(state.currentPage, _omit(options, ["first"]));
	    },

	    /**
	       Switching between client, server and infinite mode.

	       If switching from client to server mode, the #fullCollection is emptied
	       first and then deleted and a fetch is immediately issued for the current
	       page from the server. Pass `false` to `options.fetch` to skip fetching.

	       If switching to infinite mode, and if `options.models` is given for an
	       array of models, #links will be populated with a URL per page, using the
	       default URL for this collection.

	       If switching from server to client mode, all of the pages are immediately
	       refetched. If you have too many pages, you can pass `false` to
	       `options.fetch` to skip fetching.

	       If switching to any mode from infinite mode, the #links will be deleted.

	       @param {"server"|"client"|"infinite"} [mode] The mode to switch to.

	       @param {Object} [options]

	       @param {boolean} [options.fetch=true] If `false`, no fetching is done.

	       @param {boolean} [options.resetState=true] If 'false', the state is not
	       reset, but checked for sanity instead.

	       @chainable
	       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
	       from fetch or this if `options.fetch` is `false`.
	    */
	    switchMode: function (mode, options) {

	      if (!_contains(["server", "client", "infinite"], mode)) {
	        throw new TypeError('`mode` must be one of "server", "client" or "infinite"');
	      }

	      options = options || {fetch: true, resetState: true};

	      var state = this.state = options.resetState ?
	        _clone(this._initState) :
	        this._checkState(_extend({}, this.state));

	      this.mode = mode;

	      var self = this;
	      var fullCollection = this.fullCollection;
	      var handlers = this._handlers = this._handlers || {}, handler;
	      if (mode != "server" && !fullCollection) {
	        fullCollection = this._makeFullCollection(options.models || [], options);
	        fullCollection.pageableCollection = this;
	        this.fullCollection = fullCollection;
	        var allHandler = this._makeCollectionEventHandler(this, fullCollection);
	        _each(["add", "remove", "reset", "sort"], function (event) {
	          handlers[event] = handler = _.bind(allHandler, {}, event);
	          self.on(event, handler);
	          fullCollection.on(event, handler);
	        });
	        fullCollection.comparator = this._fullComparator;
	      }
	      else if (mode == "server" && fullCollection) {
	        _each(_keys(handlers), function (event) {
	          handler = handlers[event];
	          self.off(event, handler);
	          fullCollection.off(event, handler);
	        });
	        delete this._handlers;
	        this._fullComparator = fullCollection.comparator;
	        delete this.fullCollection;
	      }

	      if (mode == "infinite") {
	        var links = this.links = {};
	        var firstPage = state.firstPage;
	        var totalPages = ceil(state.totalRecords / state.pageSize);
	        var lastPage = firstPage === 0 ? max(0, totalPages - 1) : totalPages || firstPage;
	        for (var i = state.firstPage; i <= lastPage; i++) {
	          links[i] = this.url;
	        }
	      }
	      else if (this.links) delete this.links;

	      return options.fetch ?
	        this.fetch(_omit(options, "fetch", "resetState")) :
	        this;
	    },

	    /**
	       @return {boolean} `true` if this collection can page backward, `false`
	       otherwise.
	    */
	    hasPreviousPage: function () {
	      var state = this.state;
	      var currentPage = state.currentPage;
	      if (this.mode != "infinite") return currentPage > state.firstPage;
	      return !!this.links[currentPage - 1];
	    },

	    /**
	       @return {boolean} `true` if this collection can page forward, `false`
	       otherwise.
	    */
	    hasNextPage: function () {
	      var state = this.state;
	      var currentPage = this.state.currentPage;
	      if (this.mode != "infinite") return currentPage < state.lastPage;
	      return !!this.links[currentPage + 1];
	    },

	    /**
	       Fetch the first page in server mode, or reset the current page of this
	       collection to the first page in client or infinite mode.

	       @param {Object} options {@link #getPage} options.

	       @chainable
	       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
	       from fetch or this.
	    */
	    getFirstPage: function (options) {
	      return this.getPage("first", options);
	    },

	    /**
	       Fetch the previous page in server mode, or reset the current page of this
	       collection to the previous page in client or infinite mode.

	       @param {Object} options {@link #getPage} options.

	       @chainable
	       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
	       from fetch or this.
	    */
	    getPreviousPage: function (options) {
	      return this.getPage("prev", options);
	    },

	    /**
	       Fetch the next page in server mode, or reset the current page of this
	       collection to the next page in client mode.

	       @param {Object} options {@link #getPage} options.

	       @chainable
	       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
	       from fetch or this.
	    */
	    getNextPage: function (options) {
	      return this.getPage("next", options);
	    },

	    /**
	       Fetch the last page in server mode, or reset the current page of this
	       collection to the last page in client mode.

	       @param {Object} options {@link #getPage} options.

	       @chainable
	       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
	       from fetch or this.
	    */
	    getLastPage: function (options) {
	      return this.getPage("last", options);
	    },

	    /**
	       Given a page index, set #state.currentPage to that index. If this
	       collection is in server mode, fetch the page using the updated state,
	       otherwise, reset the current page of this collection to the page
	       specified by `index` in client mode. If `options.fetch` is true, a fetch
	       can be forced in client mode before resetting the current page. Under
	       infinite mode, if the index is less than the current page, a reset is
	       done as in client mode. If the index is greater than the current page
	       number, a fetch is made with the results **appended** to #fullCollection.
	       The current page will then be reset after fetching.

	       @param {number|string} index The page index to go to, or the page name to
	       look up from #links in infinite mode.
	       @param {Object} [options] {@link #fetch} options or
	       [reset](http://backbonejs.org/#Collection-reset) options for client mode
	       when `options.fetch` is `false`.
	       @param {boolean} [options.fetch=false] If true, force a {@link #fetch} in
	       client mode.

	       @throws {TypeError} If `index` is not a finite integer under server or
	       client mode, or does not yield a URL from #links under infinite mode.

	       @throws {RangeError} If `index` is out of bounds.

	       @chainable
	       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
	       from fetch or this.
	    */
	    getPage: function (index, options) {

	      var mode = this.mode, fullCollection = this.fullCollection;

	      options = options || {fetch: false};

	      var state = this.state,
	      firstPage = state.firstPage,
	      currentPage = state.currentPage,
	      lastPage = state.lastPage,
	      pageSize = state.pageSize;

	      var pageNum = index;
	      switch (index) {
	        case "first": pageNum = firstPage; break;
	        case "prev": pageNum = currentPage - 1; break;
	        case "next": pageNum = currentPage + 1; break;
	        case "last": pageNum = lastPage; break;
	        default: pageNum = finiteInt(index, "index");
	      }

	      this.state = this._checkState(_extend({}, state, {currentPage: pageNum}));

	      options.from = currentPage, options.to = pageNum;

	      var pageStart = (firstPage === 0 ? pageNum : pageNum - 1) * pageSize;
	      var pageModels = fullCollection && fullCollection.length ?
	        fullCollection.models.slice(pageStart, pageStart + pageSize) :
	        [];
	      if ((mode == "client" || (mode == "infinite" && !_isEmpty(pageModels))) &&
	          !options.fetch) {
	        this.reset(pageModels, _omit(options, "fetch"));
	        return this;
	      }

	      if (mode == "infinite") options.url = this.links[pageNum];

	      return this.fetch(_omit(options, "fetch"));
	    },

	    /**
	       Fetch the page for the provided item offset in server mode, or reset the current page of this
	       collection to the page for the provided item offset in client mode.

	       @param {Object} options {@link #getPage} options.

	       @chainable
	       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
	       from fetch or this.
	    */
	    getPageByOffset: function (offset, options) {
	      if (offset < 0) {
	        throw new RangeError("`offset must be > 0`");
	      }
	      offset = finiteInt(offset);

	      var page = floor(offset / this.state.pageSize);
	      if (this.state.firstPage !== 0) page++;
	      if (page > this.state.lastPage) page = this.state.lastPage;
	      return this.getPage(page, options);
	    },

	    /**
	       Overidden to make `getPage` compatible with Zepto.

	       @param {string} method
	       @param {Backbone.Model|Backbone.Collection} model
	       @param {Object} [options]

	       @return {XMLHttpRequest}
	    */
	    sync: function (method, model, options) {
	      var self = this;
	      if (self.mode == "infinite") {
	        var success = options.success;
	        var currentPage = self.state.currentPage;
	        options.success = function (resp, status, xhr) {
	          var links = self.links;
	          var newLinks = self.parseLinks(resp, _extend({xhr: xhr}, options));
	          if (newLinks.first) links[self.state.firstPage] = newLinks.first;
	          if (newLinks.prev) links[currentPage - 1] = newLinks.prev;
	          if (newLinks.next) links[currentPage + 1] = newLinks.next;
	          if (success) success(resp, status, xhr);
	        };
	      }

	      return (BBColProto.sync || Backbone.sync).call(self, method, model, options);
	    },

	    /**
	       Parse pagination links from the server response. Only valid under
	       infinite mode.

	       Given a response body and a XMLHttpRequest object, extract pagination
	       links from them for infinite paging.

	       This default implementation parses the RFC 5988 `Link` header and extract
	       3 links from it - `first`, `prev`, `next`. Any subclasses overriding this
	       method __must__ return an object hash having only the keys
	       above. However, simply returning a `next` link or an empty hash if there
	       are no more links should be enough for most implementations.

	       @param {*} resp The deserialized response body.
	       @param {Object} [options]
	       @param {XMLHttpRequest} [options.xhr] The XMLHttpRequest object for this
	       response.
	       @return {Object}
	    */
	    parseLinks: function (resp, options) {
	      var links = {};
	      var linkHeader = options.xhr.getResponseHeader("Link");
	      if (linkHeader) {
	        var relations = ["first", "prev", "next"];
	        _each(linkHeader.split(","), function (linkValue) {
	          var linkParts = linkValue.split(";");
	          var url = linkParts[0].replace(URL_TRIM_RE, '');
	          var params = linkParts.slice(1);
	          _each(params, function (param) {
	            var paramParts = param.split("=");
	            var key = paramParts[0].replace(PARAM_TRIM_RE, '');
	            var value = paramParts[1].replace(PARAM_TRIM_RE, '');
	            if (key == "rel" && _contains(relations, value)) links[value] = url;
	          });
	        });
	      }

	      return links;
	    },

	    /**
	       Parse server response data.

	       This default implementation assumes the response data is in one of two
	       structures:

	           [
	             {}, // Your new pagination state
	             [{}, ...] // An array of JSON objects
	           ]

	       Or,

	           [{}] // An array of JSON objects

	       The first structure is the preferred form because the pagination states
	       may have been updated on the server side, sending them down again allows
	       this collection to update its states. If the response has a pagination
	       state object, it is checked for errors.

	       The second structure is the
	       [Backbone.Collection#parse](http://backbonejs.org/#Collection-parse)
	       default.

	       **Note:** this method has been further simplified since 1.1.7. While
	       existing #parse implementations will continue to work, new code is
	       encouraged to override #parseState and #parseRecords instead.

	       @param {Object} resp The deserialized response data from the server.
	       @param {Object} the options for the ajax request

	       @return {Array.<Object>} An array of model objects
	    */
	    parse: function (resp, options) {
	      var newState = this.parseState(resp, _clone(this.queryParams), _clone(this.state), options);
	      if (newState) this.state = this._checkState(_extend({}, this.state, newState));
	      return this.parseRecords(resp, options);
	    },

	    /**
	       Parse server response for server pagination state updates. Not applicable
	       under infinite mode.

	       This default implementation first checks whether the response has any
	       state object as documented in #parse. If it exists, a state object is
	       returned by mapping the server state keys to this pageable collection
	       instance's query parameter keys using `queryParams`.

	       It is __NOT__ neccessary to return a full state object complete with all
	       the mappings defined in #queryParams. Any state object resulted is merged
	       with a copy of the current pageable collection state and checked for
	       sanity before actually updating. Most of the time, simply providing a new
	       `totalRecords` value is enough to trigger a full pagination state
	       recalculation.

	           parseState: function (resp, queryParams, state, options) {
	             return {totalRecords: resp.total_entries};
	           }

	       If you want to use header fields use:

	           parseState: function (resp, queryParams, state, options) {
	               return {totalRecords: options.xhr.getResponseHeader("X-total")};
	           }

	       This method __MUST__ return a new state object instead of directly
	       modifying the #state object. The behavior of directly modifying #state is
	       undefined.

	       @param {Object} resp The deserialized response data from the server.
	       @param {Object} queryParams A copy of #queryParams.
	       @param {Object} state A copy of #state.
	       @param {Object} [options] The options passed through from
	       `parse`. (backbone >= 0.9.10 only)

	       @return {Object} A new (partial) state object.
	     */
	    parseState: function (resp, queryParams, state, options) {
	      if (resp && resp.length === 2 && _isObject(resp[0]) && _isArray(resp[1])) {

	        var newState = _clone(state);
	        var serverState = resp[0];

	        _each(_pairs(_omit(queryParams, "directions")), function (kvp) {
	          var k = kvp[0], v = kvp[1];
	          var serverVal = serverState[v];
	          if (!_isUndefined(serverVal) && !_.isNull(serverVal)) newState[k] = serverState[v];
	        });

	        if (serverState.order) {
	          newState.order = _invert(queryParams.directions)[serverState.order] * 1;
	        }

	        return newState;
	      }
	    },

	    /**
	       Parse server response for an array of model objects.

	       This default implementation first checks whether the response has any
	       state object as documented in #parse. If it exists, the array of model
	       objects is assumed to be the second element, otherwise the entire
	       response is returned directly.

	       @param {Object} resp The deserialized response data from the server.
	       @param {Object} [options] The options passed through from the
	       `parse`. (backbone >= 0.9.10 only)

	       @return {Array.<Object>} An array of model objects
	     */
	    parseRecords: function (resp, options) {
	      if (resp && resp.length === 2 && _isObject(resp[0]) && _isArray(resp[1])) {
	        return resp[1];
	      }

	      return resp;
	    },

	    /**
	       Fetch a page from the server in server mode, or all the pages in client
	       mode. Under infinite mode, the current page is refetched by default and
	       then reset.

	       The query string is constructed by translating the current pagination
	       state to your server API query parameter using #queryParams. The current
	       page will reset after fetch.

	       @param {Object} [options] Accepts all
	       [Backbone.Collection#fetch](http://backbonejs.org/#Collection-fetch)
	       options.

	       @return {XMLHttpRequest}
	    */
	    fetch: function (options) {

	      options = options || {};

	      var state = this._checkState(this.state);

	      var mode = this.mode;

	      if (mode == "infinite" && !options.url) {
	        options.url = this.links[state.currentPage];
	      }

	      var data = options.data || {};

	      // dedup query params
	      var url = options.url || this.url || "";
	      if (_isFunction(url)) url = url.call(this);
	      var qsi = url.indexOf('?');
	      if (qsi != -1) {
	        _extend(data, queryStringToParams(url.slice(qsi + 1)));
	        url = url.slice(0, qsi);
	      }

	      options.url = url;
	      options.data = data;

	      // map params except directions
	      var queryParams = this.mode == "client" ?
	        _pick(this.queryParams, "sortKey", "order") :
	        _omit(_pick(this.queryParams, _keys(PageableProto.queryParams)),
	              "directions");

	      var i, kvp, k, v, kvps = _pairs(queryParams), thisCopy = _clone(this);
	      for (i = 0; i < kvps.length; i++) {
	        kvp = kvps[i], k = kvp[0], v = kvp[1];
	        v = _isFunction(v) ? v.call(thisCopy) : v;
	        if (state[k] != null && v != null) {
	          data[v] = state[k];
	        }
	      }

	      // fix up sorting parameters
	      if (state.sortKey && state.order) {
	        var o = _isFunction(queryParams.order) ?
	          queryParams.order.call(thisCopy) :
	          queryParams.order;
	        data[o] = this.queryParams.directions[state.order + ""];
	      }
	      else if (!state.sortKey) delete data[queryParams.order];

	      // map extra query parameters
	      var extraKvps = _pairs(_omit(this.queryParams,
	                                   _keys(PageableProto.queryParams)));
	      for (i = 0; i < extraKvps.length; i++) {
	        kvp = extraKvps[i];
	        v = kvp[1];
	        v = _isFunction(v) ? v.call(thisCopy) : v;
	        if (v != null) data[kvp[0]] = v;
	      }

	      if (mode != "server") {
	        var self = this, fullCol = this.fullCollection;
	        var success = options.success;
	        options.success = function (col, resp, opts) {

	          // make sure the caller's intent is obeyed
	          opts = opts || {};
	          if (_isUndefined(options.silent)) delete opts.silent;
	          else opts.silent = options.silent;

	          var models = col.models;
	          if (mode == "client") fullCol.reset(models, opts);
	          else {
	            fullCol.add(models, _extend({at: fullCol.length},
	                                        _extend(opts, {parse: false})));
	            self.trigger("reset", self, opts);
	          }

	          if (success) success(col, resp, opts);
	        };

	        // silent the first reset from backbone
	        return BBColProto.fetch.call(this, _extend({}, options, {silent: true}));
	      }

	      return BBColProto.fetch.call(this, options);
	    },

	    /**
	       Convenient method for making a `comparator` sorted by a model attribute
	       identified by `sortKey` and ordered by `order`.

	       Like a Backbone.Collection, a Backbone.PageableCollection will maintain
	       the __current page__ in sorted order on the client side if a `comparator`
	       is attached to it. If the collection is in client mode, you can attach a
	       comparator to #fullCollection to have all the pages reflect the global
	       sorting order by specifying an option `full` to `true`. You __must__ call
	       `sort` manually or #fullCollection.sort after calling this method to
	       force a resort.

	       While you can use this method to sort the current page in server mode,
	       the sorting order may not reflect the global sorting order due to the
	       additions or removals of the records on the server since the last
	       fetch. If you want the most updated page in a global sorting order, it is
	       recommended that you set #state.sortKey and optionally #state.order, and
	       then call #fetch.

	       @protected

	       @param {string} [sortKey=this.state.sortKey] See `state.sortKey`.
	       @param {number} [order=this.state.order] See `state.order`.
	       @param {(function(Backbone.Model, string): Object) | string} [sortValue] See #setSorting.

	       See [Backbone.Collection.comparator](http://backbonejs.org/#Collection-comparator).
	    */
	    _makeComparator: function (sortKey, order, sortValue) {
	      var state = this.state;

	      sortKey = sortKey || state.sortKey;
	      order = order || state.order;

	      if (!sortKey || !order) return;

	      if (!sortValue) sortValue = function (model, attr) {
	        return model.get(attr);
	      };

	      return function (left, right) {
	        var l = sortValue(left, sortKey), r = sortValue(right, sortKey), t;
	        if (order === 1) t = l, l = r, r = t;
	        if (l === r) return 0;
	        else if (l < r) return -1;
	        return 1;
	      };
	    },

	    /**
	       Adjusts the sorting for this pageable collection.

	       Given a `sortKey` and an `order`, sets `state.sortKey` and
	       `state.order`. A comparator can be applied on the client side to sort in
	       the order defined if `options.side` is `"client"`. By default the
	       comparator is applied to the #fullCollection. Set `options.full` to
	       `false` to apply a comparator to the current page under any mode. Setting
	       `sortKey` to `null` removes the comparator from both the current page and
	       the full collection.

	       If a `sortValue` function is given, it will be passed the `(model,
	       sortKey)` arguments and is used to extract a value from the model during
	       comparison sorts. If `sortValue` is not given, `model.get(sortKey)` is
	       used for sorting.

	       @chainable

	       @param {string} sortKey See `state.sortKey`.
	       @param {number} [order=this.state.order] See `state.order`.
	       @param {Object} [options]
	       @param {"server"|"client"} [options.side] By default, `"client"` if
	       `mode` is `"client"`, `"server"` otherwise.
	       @param {boolean} [options.full=true]
	       @param {(function(Backbone.Model, string): Object) | string} [options.sortValue]
	    */
	    setSorting: function (sortKey, order, options) {

	      var state = this.state;

	      state.sortKey = sortKey;
	      state.order = order = order || state.order;

	      var fullCollection = this.fullCollection;

	      var delComp = false, delFullComp = false;

	      if (!sortKey) delComp = delFullComp = true;

	      var mode = this.mode;
	      options = _extend({side: mode == "client" ? mode : "server", full: true},
	                        options);

	      var comparator = this._makeComparator(sortKey, order, options.sortValue);

	      var full = options.full, side = options.side;

	      if (side == "client") {
	        if (full) {
	          if (fullCollection) fullCollection.comparator = comparator;
	          delComp = true;
	        }
	        else {
	          this.comparator = comparator;
	          delFullComp = true;
	        }
	      }
	      else if (side == "server" && !full) {
	        this.comparator = comparator;
	      }

	      if (delComp) this.comparator = null;
	      if (delFullComp && fullCollection) fullCollection.comparator = null;

	      return this;
	    }

	  });

	  var PageableProto = PageableCollection.prototype;

	  return PageableCollection;

	}));



/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	module.exports.Master = __webpack_require__(50);

	module.exports.Detail = __webpack_require__(63);

	module.exports.Log = __webpack_require__(72);


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Collection, InputView, Marionette, Model, PageableCollection, TableView, View, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	InputView = __webpack_require__(51);

	TableView = __webpack_require__(58);

	viewTemplate = __webpack_require__(62);

	__webpack_require__(48);

	Model = (function(superClass) {
	  extend(Model, superClass);

	  function Model() {
	    return Model.__super__.constructor.apply(this, arguments);
	  }

	  Model.prototype.idAttribute = '_id';

	  Model.prototype.defaults = {
	    date: new Date(),
	    name: '',
	    muscle: 0,
	    note: ''
	  };

	  return Model;

	})(Backbone.Model);

	Collection = (function(superClass) {
	  extend(Collection, superClass);

	  function Collection() {
	    return Collection.__super__.constructor.apply(this, arguments);
	  }

	  Collection.prototype.url = '/api/exercise';

	  Collection.prototype.model = Model;

	  Collection.prototype.comparator = function(item) {
	    return -item.get('date');
	  };

	  Collection.prototype.parse = function(response) {
	    return response.strength;
	  };

	  return Collection;

	})(Backbone.Collection);

	PageableCollection = (function(superClass) {
	  extend(PageableCollection, superClass);

	  function PageableCollection() {
	    return PageableCollection.__super__.constructor.apply(this, arguments);
	  }

	  PageableCollection.prototype.url = '/api/exercise';

	  PageableCollection.prototype.model = Model;

	  PageableCollection.prototype.mode = 'client';

	  PageableCollection.prototype.state = {
	    currentPage: 1,
	    pageSize: 10
	  };

	  PageableCollection.prototype.comparator = function(item) {
	    return -item.get('date');
	  };

	  PageableCollection.prototype.parseRecords = function(response) {
	    return response[0].strength;
	  };

	  return PageableCollection;

	})(Backbone.PageableCollection);

	View = (function(superClass) {
	  extend(View, superClass);

	  View.prototype.template = viewTemplate;

	  View.prototype.regions = {
	    input: '#strength-input-view',
	    table: '#strength-table-view'
	  };

	  View.prototype.events = {
	    'click #strength-back': function() {
	      this.rootChannel.request('exercise');
	    }
	  };

	  View.prototype.collectionEvents = {
	    sync: function() {
	      this.filterCollection(this.model.get('muscle'));
	    }
	  };

	  View.prototype.modelEvents = {
	    'change:muscle': function(model, value) {
	      this.filterCollection(value);
	    }
	  };

	  function View() {
	    View.__super__.constructor.apply(this, arguments);
	    this.rootChannel = Backbone.Radio.channel('root');
	    this.pageableCollection = new PageableCollection(this.collection.models);
	  }

	  View.prototype.onShow = function() {
	    this.filterCollection(this.model.get('muscle'));
	    this.showChildView('input', new InputView({
	      collection: this.collection,
	      model: this.model
	    }));
	    this.showChildView('table', new TableView({
	      collection: this.pageableCollection
	    }));
	  };

	  View.prototype.filterCollection = function(muscle) {
	    var models;
	    models = this.collection.filter(function(model) {
	      return model.get('muscle') === muscle;
	    });
	    this.pageableCollection.fullCollection.reset(models);
	  };

	  return View;

	})(Marionette.LayoutView);

	module.exports.Model = Model;

	module.exports.Collection = Collection;

	module.exports.View = View;


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Data, Marionette, Validation, View, _, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	_ = __webpack_require__(3);

	Backbone = __webpack_require__(8);

	Validation = __webpack_require__(27);

	Marionette = __webpack_require__(10);

	Data = __webpack_require__(52);

	viewTemplate = __webpack_require__(53);

	__webpack_require__(54);

	__webpack_require__(55);

	__webpack_require__(56);

	__webpack_require__(19);

	__webpack_require__(57);

	View = (function(superClass) {
	  extend(View, superClass);

	  View.prototype.template = viewTemplate;

	  View.prototype.ui = {
	    back: '#strength-exercise',
	    name: '#strength-name',
	    muscle: '#strength-muscle',
	    submit: '#strength-submit',
	    addset: '#strength-addset',
	    date: '#strength-date',
	    time: '#strength-time',
	    form: '#strength-form'
	  };

	  View.prototype.bindings = {
	    '#strength-name': 'name',
	    '#strength-note': 'note',
	    '#strength-muscle': {
	      observe: 'muscle',
	      onSet: function(value) {
	        return parseInt(value);
	      }
	    }
	  };

	  View.prototype.events = {
	    'click @ui.back': function() {
	      this.rootChannel.request('exercise');
	    },
	    'click @ui.time': function() {
	      this.ui.time.timepicker('showWidget');
	    },
	    'click @ui.submit': function() {
	      this.ui.form.validator('validate');
	      this.collection.create(this.model.attributes, {
	        wait: true,
	        at: 0,
	        success: (function(_this) {
	          return function() {
	            _this.ui.name.val('');
	          };
	        })(this)
	      });
	    }
	  };

	  function View() {
	    View.__super__.constructor.apply(this, arguments);
	    this.rootChannel = Backbone.Radio.channel('root');
	  }

	  View.prototype.onRender = function() {
	    this.ui.muscle.multiselect({
	      enableFiltering: true,
	      maxHeight: 200,
	      buttonWidth: '100%',
	      buttonClass: 'btn btn-info'
	    }).multiselect('dataprovider', Data.Muscles);
	    this.ui.addset.TouchSpin({
	      buttondown_class: 'btn btn-info',
	      buttonup_class: 'btn btn-info',
	      min: 1,
	      max: 20
	    });
	    this.ui.date.datepicker({
	      todayBtn: 'linked',
	      todayHighlight: true
	    }).on('changeDate', (function(_this) {
	      return function() {
	        _this.model.set('date', new Date(_this.ui.date.val()));
	      };
	    })(this)).datepicker('setDate', new Date());
	    this.ui.time.timepicker({
	      template: 'dropdown'
	    }).timepicker('setTime', '12:45 AM');
	    this.stickit();
	  };

	  View.prototype.onShow = function() {
	    this.ui.name.focus();
	  };

	  View.prototype.onBeforeDestroy = function() {
	    this.ui.form.validator('destroy');
	    this.ui.date.datepicker('destroy');
	    this.ui.addset.TouchSpin('destroy');
	  };

	  return View;

	})(Marionette.LayoutView);

	module.exports = View;


/***/ },
/* 52 */
/***/ function(module, exports) {

	var Muscles;

	Muscles = [
	  {
	    value: 0,
	    label: 'Abdominals'
	  }, {
	    value: 1,
	    label: 'Arms'
	  }, {
	    value: 2,
	    label: 'Back'
	  }, {
	    value: 3,
	    label: 'Biceps'
	  }, {
	    value: 4,
	    label: 'Calves'
	  }, {
	    value: 5,
	    label: 'Chest'
	  }, {
	    value: 6,
	    label: 'Forearms'
	  }, {
	    value: 7,
	    label: 'Glutes'
	  }, {
	    value: 8,
	    label: 'Hamstrings'
	  }, {
	    value: 9,
	    label: 'Lats'
	  }, {
	    value: 10,
	    label: 'Legs'
	  }, {
	    value: 11,
	    label: 'Neck'
	  }, {
	    value: 12,
	    label: 'Quadriceps'
	  }, {
	    value: 13,
	    label: 'Shoulders'
	  }, {
	    value: 14,
	    label: 'Traps'
	  }, {
	    value: 15,
	    label: 'Triceps'
	  }
	];

	exports.Muscles = Muscles;


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-sm-12\"><span><b>CREATE A NEW WORKOUT</b></span></div></div><br><div class=\"row\"><div class=\"col-sm-12\"><form id=\"strength-form\" class=\"form-horizontal\"><!-- Nav tabs--><ul role=\"tablist\" class=\"nav nav-tabs\"><li role=\"presentation\" class=\"active\"><a href=\"#strength-basic\" aria-controls=\"basic\" role=\"tab\" data-toggle=\"tab\"><i class=\"fa fa-fw fa-lg fa-pencil\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Basic</a></li><li role=\"presentation\"><a href=\"#strength-advance\" aria-controls=\"advance\" role=\"tab\" data-toggle=\"tab\"><i class=\"fa fa-fw fa-lg fa-cogs\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Advance</a></li></ul><br><!-- Tab panes--><div class=\"tab-content\"><!-- Basic--><div id=\"strength-basic\" role=\"tabpanel\" class=\"tab-pane active\"><div class=\"form-group\"><label for=\"strength-muscle\" class=\"col-sm-2 control-label\">Muscle</label><div class=\"col-sm-10\"><select id=\"strength-muscle\" class=\"form-control\"></select></div></div><div class=\"form-group\"><label for=\"strength-name\" class=\"col-sm-2 control-label\">Name</label><div class=\"col-sm-10\"><input id=\"strength-name\" required class=\"form-control\"><div class=\"help-block with-errors\"></div></div></div></div><!-- Advance--><div id=\"strength-advance\" role=\"tabpanel\" class=\"tab-pane\"><div class=\"form-group\"><label for=\"strength-date\" class=\"col-sm-2 control-label\">Date</label><div class=\"col-sm-10\"><div class=\"input-group date\"><input id=\"strength-date\" muscle=\"text\" readonly class=\"form-control input-readonly\"><div class=\"input-group-addon\"><span class=\"fa fa-fw fa-lg fa-calendar\"></span></div></div></div></div><div class=\"form-group\"><label for=\"strength-time\" class=\"col-sm-2 control-label\">Time</label><div class=\"col-sm-10\"><div class=\"input-group bootstrap-timepicker timepicker\"><input id=\"strength-time\" readonly class=\"form-control input-readonly\"><div class=\"input-group-addon\"><span class=\"fa fa-fw fa-lg fa-clock-o\"></span></div></div></div></div><div class=\"form-group\"><label for=\"strength-note\" class=\"col-sm-2 control-label\">Note</label><div class=\"col-sm-10\"><input id=\"strength-note\" class=\"form-control\"></div></div></div></div></form></div></div><div class=\"row\"><div class=\"col-sm-12\"><button id=\"strength-submit\" class=\"btn btn-success pull-right\"><i class=\"fa fa-lg fa-plus-circle\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Add Workout</button></div></div>");;return buf.join("");
	}

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var jQuery = __webpack_require__(2);

	/*** IMPORTS FROM imports-loader ***/
	var jQuery = __webpack_require__(2);

	(function($) {
	  'use strict';

	  var _currentSpinnerId = 0;

	  function _scopedEventName(name, id) {
	    return name + '.touchspin_' + id;
	  }

	  function _scopeEventNames(names, id) {
	    return $.map(names, function(name) {
	      return _scopedEventName(name, id);
	    });
	  }

	  $.fn.TouchSpin = function(options) {

	    if (options === 'destroy') {
	      this.each(function() {
	        var originalinput = $(this),
	            originalinput_data = originalinput.data();
	        $(document).off(_scopeEventNames([
	          'mouseup',
	          'touchend',
	          'touchcancel',
	          'mousemove',
	          'touchmove',
	          'scroll',
	          'scrollstart'], originalinput_data.spinnerid).join(' '));
	      });
	      return;
	    }

	    var defaults = {
	      min: 0,
	      max: 100,
	      initval: '',
	      replacementval: '',
	      step: 1,
	      decimals: 0,
	      stepinterval: 100,
	      forcestepdivisibility: 'round', // none | floor | round | ceil
	      stepintervaldelay: 500,
	      verticalbuttons: false,
	      verticalupclass: 'glyphicon glyphicon-chevron-up',
	      verticaldownclass: 'glyphicon glyphicon-chevron-down',
	      prefix: '',
	      postfix: '',
	      prefix_extraclass: '',
	      postfix_extraclass: '',
	      booster: true,
	      boostat: 10,
	      maxboostedstep: false,
	      mousewheel: true,
	      buttondown_class: 'btn btn-default',
	      buttonup_class: 'btn btn-default',
		  buttondown_txt: '-',
		  buttonup_txt: '+'
	    };

	    var attributeMap = {
	      min: 'min',
	      max: 'max',
	      initval: 'init-val',
	      replacementval: 'replacement-val',
	      step: 'step',
	      decimals: 'decimals',
	      stepinterval: 'step-interval',
	      verticalbuttons: 'vertical-buttons',
	      verticalupclass: 'vertical-up-class',
	      verticaldownclass: 'vertical-down-class',
	      forcestepdivisibility: 'force-step-divisibility',
	      stepintervaldelay: 'step-interval-delay',
	      prefix: 'prefix',
	      postfix: 'postfix',
	      prefix_extraclass: 'prefix-extra-class',
	      postfix_extraclass: 'postfix-extra-class',
	      booster: 'booster',
	      boostat: 'boostat',
	      maxboostedstep: 'max-boosted-step',
	      mousewheel: 'mouse-wheel',
	      buttondown_class: 'button-down-class',
	      buttonup_class: 'button-up-class',
		  buttondown_txt: 'button-down-txt',
		  buttonup_txt: 'button-up-txt'
	    };

	    return this.each(function() {

	      var settings,
	          originalinput = $(this),
	          originalinput_data = originalinput.data(),
	          container,
	          elements,
	          value,
	          downSpinTimer,
	          upSpinTimer,
	          downDelayTimeout,
	          upDelayTimeout,
	          spincount = 0,
	          spinning = false;

	      init();


	      function init() {
	        if (originalinput.data('alreadyinitialized')) {
	          return;
	        }

	        originalinput.data('alreadyinitialized', true);
	        _currentSpinnerId += 1;
	        originalinput.data('spinnerid', _currentSpinnerId);


	        if (!originalinput.is('input')) {
	          console.log('Must be an input.');
	          return;
	        }

	        _initSettings();
	        _setInitval();
	        _checkValue();
	        _buildHtml();
	        _initElements();
	        _hideEmptyPrefixPostfix();
	        _bindEvents();
	        _bindEventsInterface();
	        elements.input.css('display', 'block');
	      }

	      function _setInitval() {
	        if (settings.initval !== '' && originalinput.val() === '') {
	          originalinput.val(settings.initval);
	        }
	      }

	      function changeSettings(newsettings) {
	        _updateSettings(newsettings);
	        _checkValue();

	        var value = elements.input.val();

	        if (value !== '') {
	          value = Number(elements.input.val());
	          elements.input.val(value.toFixed(settings.decimals));
	        }
	      }

	      function _initSettings() {
	        settings = $.extend({}, defaults, originalinput_data, _parseAttributes(), options);
	      }

	      function _parseAttributes() {
	        var data = {};
	        $.each(attributeMap, function(key, value) {
	          var attrName = 'bts-' + value + '';
	          if (originalinput.is('[data-' + attrName + ']')) {
	            data[key] = originalinput.data(attrName);
	          }
	        });
	        return data;
	      }

	      function _updateSettings(newsettings) {
	        settings = $.extend({}, settings, newsettings);
	      }

	      function _buildHtml() {
	        var initval = originalinput.val(),
	            parentelement = originalinput.parent();

	        if (initval !== '') {
	          initval = Number(initval).toFixed(settings.decimals);
	        }

	        originalinput.data('initvalue', initval).val(initval);
	        originalinput.addClass('form-control');

	        if (parentelement.hasClass('input-group')) {
	          _advanceInputGroup(parentelement);
	        }
	        else {
	          _buildInputGroup();
	        }
	      }

	      function _advanceInputGroup(parentelement) {
	        parentelement.addClass('bootstrap-touchspin');

	        var prev = originalinput.prev(),
	            next = originalinput.next();

	        var downhtml,
	            uphtml,
	            prefixhtml = '<span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span>',
	            postfixhtml = '<span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span>';

	        if (prev.hasClass('input-group-btn')) {
	          downhtml = '<button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button>';
	          prev.append(downhtml);
	        }
	        else {
	          downhtml = '<span class="input-group-btn"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button></span>';
	          $(downhtml).insertBefore(originalinput);
	        }

	        if (next.hasClass('input-group-btn')) {
	          uphtml = '<button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button>';
	          next.prepend(uphtml);
	        }
	        else {
	          uphtml = '<span class="input-group-btn"><button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button></span>';
	          $(uphtml).insertAfter(originalinput);
	        }

	        $(prefixhtml).insertBefore(originalinput);
	        $(postfixhtml).insertAfter(originalinput);

	        container = parentelement;
	      }

	      function _buildInputGroup() {
	        var html;

	        if (settings.verticalbuttons) {
	          html = '<div class="input-group bootstrap-touchspin"><span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span><span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span><span class="input-group-btn-vertical"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-up" type="button"><i class="' + settings.verticalupclass + '"></i></button><button class="' + settings.buttonup_class + ' bootstrap-touchspin-down" type="button"><i class="' + settings.verticaldownclass + '"></i></button></span></div>';
	        }
	        else {
	          html = '<div class="input-group bootstrap-touchspin"><span class="input-group-btn"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button></span><span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span><span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span><span class="input-group-btn"><button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button></span></div>';
	        }

	        container = $(html).insertBefore(originalinput);

	        $('.bootstrap-touchspin-prefix', container).after(originalinput);

	        if (originalinput.hasClass('input-sm')) {
	          container.addClass('input-group-sm');
	        }
	        else if (originalinput.hasClass('input-lg')) {
	          container.addClass('input-group-lg');
	        }
	      }

	      function _initElements() {
	        elements = {
	          down: $('.bootstrap-touchspin-down', container),
	          up: $('.bootstrap-touchspin-up', container),
	          input: $('input', container),
	          prefix: $('.bootstrap-touchspin-prefix', container).addClass(settings.prefix_extraclass),
	          postfix: $('.bootstrap-touchspin-postfix', container).addClass(settings.postfix_extraclass)
	        };
	      }

	      function _hideEmptyPrefixPostfix() {
	        if (settings.prefix === '') {
	          elements.prefix.hide();
	        }

	        if (settings.postfix === '') {
	          elements.postfix.hide();
	        }
	      }

	      function _bindEvents() {
	        originalinput.on('keydown', function(ev) {
	          var code = ev.keyCode || ev.which;

	          if (code === 38) {
	            if (spinning !== 'up') {
	              upOnce();
	              startUpSpin();
	            }
	            ev.preventDefault();
	          }
	          else if (code === 40) {
	            if (spinning !== 'down') {
	              downOnce();
	              startDownSpin();
	            }
	            ev.preventDefault();
	          }
	        });

	        originalinput.on('keyup', function(ev) {
	          var code = ev.keyCode || ev.which;

	          if (code === 38) {
	            stopSpin();
	          }
	          else if (code === 40) {
	            stopSpin();
	          }
	        });

	        originalinput.on('blur', function() {
	          _checkValue();
	        });

	        elements.down.on('keydown', function(ev) {
	          var code = ev.keyCode || ev.which;

	          if (code === 32 || code === 13) {
	            if (spinning !== 'down') {
	              downOnce();
	              startDownSpin();
	            }
	            ev.preventDefault();
	          }
	        });

	        elements.down.on('keyup', function(ev) {
	          var code = ev.keyCode || ev.which;

	          if (code === 32 || code === 13) {
	            stopSpin();
	          }
	        });

	        elements.up.on('keydown', function(ev) {
	          var code = ev.keyCode || ev.which;

	          if (code === 32 || code === 13) {
	            if (spinning !== 'up') {
	              upOnce();
	              startUpSpin();
	            }
	            ev.preventDefault();
	          }
	        });

	        elements.up.on('keyup', function(ev) {
	          var code = ev.keyCode || ev.which;

	          if (code === 32 || code === 13) {
	            stopSpin();
	          }
	        });

	        elements.down.on('mousedown.touchspin', function(ev) {
	          elements.down.off('touchstart.touchspin');  // android 4 workaround

	          if (originalinput.is(':disabled')) {
	            return;
	          }

	          downOnce();
	          startDownSpin();

	          ev.preventDefault();
	          ev.stopPropagation();
	        });

	        elements.down.on('touchstart.touchspin', function(ev) {
	          elements.down.off('mousedown.touchspin');  // android 4 workaround

	          if (originalinput.is(':disabled')) {
	            return;
	          }

	          downOnce();
	          startDownSpin();

	          ev.preventDefault();
	          ev.stopPropagation();
	        });

	        elements.up.on('mousedown.touchspin', function(ev) {
	          elements.up.off('touchstart.touchspin');  // android 4 workaround

	          if (originalinput.is(':disabled')) {
	            return;
	          }

	          upOnce();
	          startUpSpin();

	          ev.preventDefault();
	          ev.stopPropagation();
	        });

	        elements.up.on('touchstart.touchspin', function(ev) {
	          elements.up.off('mousedown.touchspin');  // android 4 workaround

	          if (originalinput.is(':disabled')) {
	            return;
	          }

	          upOnce();
	          startUpSpin();

	          ev.preventDefault();
	          ev.stopPropagation();
	        });

	        elements.up.on('mouseout touchleave touchend touchcancel', function(ev) {
	          if (!spinning) {
	            return;
	          }

	          ev.stopPropagation();
	          stopSpin();
	        });

	        elements.down.on('mouseout touchleave touchend touchcancel', function(ev) {
	          if (!spinning) {
	            return;
	          }

	          ev.stopPropagation();
	          stopSpin();
	        });

	        elements.down.on('mousemove touchmove', function(ev) {
	          if (!spinning) {
	            return;
	          }

	          ev.stopPropagation();
	          ev.preventDefault();
	        });

	        elements.up.on('mousemove touchmove', function(ev) {
	          if (!spinning) {
	            return;
	          }

	          ev.stopPropagation();
	          ev.preventDefault();
	        });

	        $(document).on(_scopeEventNames(['mouseup', 'touchend', 'touchcancel'], _currentSpinnerId).join(' '), function(ev) {
	          if (!spinning) {
	            return;
	          }

	          ev.preventDefault();
	          stopSpin();
	        });

	        $(document).on(_scopeEventNames(['mousemove', 'touchmove', 'scroll', 'scrollstart'], _currentSpinnerId).join(' '), function(ev) {
	          if (!spinning) {
	            return;
	          }

	          ev.preventDefault();
	          stopSpin();
	        });

	        originalinput.on('mousewheel DOMMouseScroll', function(ev) {
	          if (!settings.mousewheel || !originalinput.is(':focus')) {
	            return;
	          }

	          var delta = ev.originalEvent.wheelDelta || -ev.originalEvent.deltaY || -ev.originalEvent.detail;

	          ev.stopPropagation();
	          ev.preventDefault();

	          if (delta < 0) {
	            downOnce();
	          }
	          else {
	            upOnce();
	          }
	        });
	      }

	      function _bindEventsInterface() {
	        originalinput.on('touchspin.uponce', function() {
	          stopSpin();
	          upOnce();
	        });

	        originalinput.on('touchspin.downonce', function() {
	          stopSpin();
	          downOnce();
	        });

	        originalinput.on('touchspin.startupspin', function() {
	          startUpSpin();
	        });

	        originalinput.on('touchspin.startdownspin', function() {
	          startDownSpin();
	        });

	        originalinput.on('touchspin.stopspin', function() {
	          stopSpin();
	        });

	        originalinput.on('touchspin.updatesettings', function(e, newsettings) {
	          changeSettings(newsettings);
	        });
	      }

	      function _forcestepdivisibility(value) {
	        switch (settings.forcestepdivisibility) {
	          case 'round':
	            return (Math.round(value / settings.step) * settings.step).toFixed(settings.decimals);
	          case 'floor':
	            return (Math.floor(value / settings.step) * settings.step).toFixed(settings.decimals);
	          case 'ceil':
	            return (Math.ceil(value / settings.step) * settings.step).toFixed(settings.decimals);
	          default:
	            return value;
	        }
	      }

	      function _checkValue() {
	        var val, parsedval, returnval;

	        val = originalinput.val();

	        if (val === '') {
	          if (settings.replacementval !== '') {
	            originalinput.val(settings.replacementval);
	            originalinput.trigger('change');
	          }
	          return;
	        }

	        if (settings.decimals > 0 && val === '.') {
	          return;
	        }

	        parsedval = parseFloat(val);

	        if (isNaN(parsedval)) {
	          if (settings.replacementval !== '') {
	            parsedval = settings.replacementval;
	          }
	          else {
	            parsedval = 0;
	          }
	        }

	        returnval = parsedval;

	        if (parsedval.toString() !== val) {
	          returnval = parsedval;
	        }

	        if (parsedval < settings.min) {
	          returnval = settings.min;
	        }

	        if (parsedval > settings.max) {
	          returnval = settings.max;
	        }

	        returnval = _forcestepdivisibility(returnval);

	        if (Number(val).toString() !== returnval.toString()) {
	          originalinput.val(returnval);
	          originalinput.trigger('change');
	        }
	      }

	      function _getBoostedStep() {
	        if (!settings.booster) {
	          return settings.step;
	        }
	        else {
	          var boosted = Math.pow(2, Math.floor(spincount / settings.boostat)) * settings.step;

	          if (settings.maxboostedstep) {
	            if (boosted > settings.maxboostedstep) {
	              boosted = settings.maxboostedstep;
	              value = Math.round((value / boosted)) * boosted;
	            }
	          }

	          return Math.max(settings.step, boosted);
	        }
	      }

	      function upOnce() {
	        _checkValue();

	        value = parseFloat(elements.input.val());
	        if (isNaN(value)) {
	          value = 0;
	        }

	        var initvalue = value,
	            boostedstep = _getBoostedStep();

	        value = value + boostedstep;

	        if (value > settings.max) {
	          value = settings.max;
	          originalinput.trigger('touchspin.on.max');
	          stopSpin();
	        }

	        elements.input.val(Number(value).toFixed(settings.decimals));

	        if (initvalue !== value) {
	          originalinput.trigger('change');
	        }
	      }

	      function downOnce() {
	        _checkValue();

	        value = parseFloat(elements.input.val());
	        if (isNaN(value)) {
	          value = 0;
	        }

	        var initvalue = value,
	            boostedstep = _getBoostedStep();

	        value = value - boostedstep;

	        if (value < settings.min) {
	          value = settings.min;
	          originalinput.trigger('touchspin.on.min');
	          stopSpin();
	        }

	        elements.input.val(value.toFixed(settings.decimals));

	        if (initvalue !== value) {
	          originalinput.trigger('change');
	        }
	      }

	      function startDownSpin() {
	        stopSpin();

	        spincount = 0;
	        spinning = 'down';

	        originalinput.trigger('touchspin.on.startspin');
	        originalinput.trigger('touchspin.on.startdownspin');

	        downDelayTimeout = setTimeout(function() {
	          downSpinTimer = setInterval(function() {
	            spincount++;
	            downOnce();
	          }, settings.stepinterval);
	        }, settings.stepintervaldelay);
	      }

	      function startUpSpin() {
	        stopSpin();

	        spincount = 0;
	        spinning = 'up';

	        originalinput.trigger('touchspin.on.startspin');
	        originalinput.trigger('touchspin.on.startupspin');

	        upDelayTimeout = setTimeout(function() {
	          upSpinTimer = setInterval(function() {
	            spincount++;
	            upOnce();
	          }, settings.stepinterval);
	        }, settings.stepintervaldelay);
	      }

	      function stopSpin() {
	        clearTimeout(downDelayTimeout);
	        clearTimeout(upDelayTimeout);
	        clearInterval(downSpinTimer);
	        clearInterval(upSpinTimer);

	        switch (spinning) {
	          case 'up':
	            originalinput.trigger('touchspin.on.stopupspin');
	            originalinput.trigger('touchspin.on.stopspin');
	            break;
	          case 'down':
	            originalinput.trigger('touchspin.on.stopdownspin');
	            originalinput.trigger('touchspin.on.stopspin');
	            break;
	        }

	        spincount = 0;
	        spinning = false;
	      }

	    });

	  };

	})(jQuery);




/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/
	var jQuery = __webpack_require__(2);

	/*** IMPORTS FROM imports-loader ***/
	var jQuery = __webpack_require__(2);

	/* =========================================================
	 * bootstrap-datepicker.js
	 * Repo: https://github.com/eternicode/bootstrap-datepicker/
	 * Demo: http://eternicode.github.io/bootstrap-datepicker/
	 * Docs: http://bootstrap-datepicker.readthedocs.org/
	 * Forked from http://www.eyecon.ro/bootstrap-datepicker
	 * =========================================================
	 * Started by Stefan Petre; improvements by Andrew Rowls + contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================= */

	(function(factory){
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        factory(require('jquery'));
	    } else {
	        factory(jQuery);
	    }
	}(function($, undefined){

		function UTCDate(){
			return new Date(Date.UTC.apply(Date, arguments));
		}
		function UTCToday(){
			var today = new Date();
			return UTCDate(today.getFullYear(), today.getMonth(), today.getDate());
		}
		function isUTCEquals(date1, date2) {
			return (
				date1.getUTCFullYear() === date2.getUTCFullYear() &&
				date1.getUTCMonth() === date2.getUTCMonth() &&
				date1.getUTCDate() === date2.getUTCDate()
			);
		}
		function alias(method){
			return function(){
				return this[method].apply(this, arguments);
			};
		}
		function isValidDate(d) {
			return d && !isNaN(d.getTime());
		}

		var DateArray = (function(){
			var extras = {
				get: function(i){
					return this.slice(i)[0];
				},
				contains: function(d){
					// Array.indexOf is not cross-browser;
					// $.inArray doesn't work with Dates
					var val = d && d.valueOf();
					for (var i=0, l=this.length; i < l; i++)
						if (this[i].valueOf() === val)
							return i;
					return -1;
				},
				remove: function(i){
					this.splice(i,1);
				},
				replace: function(new_array){
					if (!new_array)
						return;
					if (!$.isArray(new_array))
						new_array = [new_array];
					this.clear();
					this.push.apply(this, new_array);
				},
				clear: function(){
					this.length = 0;
				},
				copy: function(){
					var a = new DateArray();
					a.replace(this);
					return a;
				}
			};

			return function(){
				var a = [];
				a.push.apply(a, arguments);
				$.extend(a, extras);
				return a;
			};
		})();


		// Picker object

		var Datepicker = function(element, options){
			$(element).data('datepicker', this);
			this._process_options(options);

			this.dates = new DateArray();
			this.viewDate = this.o.defaultViewDate;
			this.focusDate = null;

			this.element = $(element);
			this.isInline = false;
			this.isInput = this.element.is('input');
			this.component = this.element.hasClass('date') ? this.element.find('.add-on, .input-group-addon, .btn') : false;
			this.hasInput = this.component && this.element.find('input').length;
			if (this.component && this.component.length === 0)
				this.component = false;

			this.picker = $(DPGlobal.template);

			// Checking templates and inserting
			if (this._check_template(this.o.templates.leftArrow)) {
				this.picker.find('.prev').html(this.o.templates.leftArrow);
			}
			if (this._check_template(this.o.templates.rightArrow)) {
				this.picker.find('.next').html(this.o.templates.rightArrow);
			}

			this._buildEvents();
			this._attachEvents();

			if (this.isInline){
				this.picker.addClass('datepicker-inline').appendTo(this.element);
			}
			else {
				this.picker.addClass('datepicker-dropdown dropdown-menu');
			}

			if (this.o.rtl){
				this.picker.addClass('datepicker-rtl');
			}

			this.viewMode = this.o.startView;

			if (this.o.calendarWeeks)
				this.picker.find('thead .datepicker-title, tfoot .today, tfoot .clear')
							.attr('colspan', function(i, val){
								return parseInt(val) + 1;
							});

			this._allow_update = false;

			this.setStartDate(this._o.startDate);
			this.setEndDate(this._o.endDate);
			this.setDaysOfWeekDisabled(this.o.daysOfWeekDisabled);
			this.setDaysOfWeekHighlighted(this.o.daysOfWeekHighlighted);
			this.setDatesDisabled(this.o.datesDisabled);

			this.fillDow();
			this.fillMonths();

			this._allow_update = true;

			this.update();
			this.showMode();

			if (this.isInline){
				this.show();
			}
		};

		Datepicker.prototype = {
			constructor: Datepicker,

			_resolveViewName: function(view, default_value){
				if (view === 0 || view === 'days' || view === 'month') {
					return 0;
				}
				if (view === 1 || view === 'months' || view === 'year') {
					return 1;
				}
				if (view === 2 || view === 'years' || view === 'decade') {
					return 2;
				}
				if (view === 3 || view === 'decades' || view === 'century') {
					return 3;
				}
				if (view === 4 || view === 'centuries' || view === 'millennium') {
					return 4;
				}
				return default_value === undefined ? false : default_value;
			},

			_check_template: function(tmp){
				try {
					// If empty
					if (tmp === undefined || tmp === "") {
						return false;
					}
					// If no html, everything ok
					if ((tmp.match(/[<>]/g) || []).length <= 0) {
						return true;
					}
					// Checking if html is fine
					var jDom = $(tmp);
					return jDom.length > 0;
				}
				catch (ex) {
					return false;
				}
			},

			_process_options: function(opts){
				// Store raw options for reference
				this._o = $.extend({}, this._o, opts);
				// Processed options
				var o = this.o = $.extend({}, this._o);

				// Check if "de-DE" style date is available, if not language should
				// fallback to 2 letter code eg "de"
				var lang = o.language;
				if (!dates[lang]){
					lang = lang.split('-')[0];
					if (!dates[lang])
						lang = defaults.language;
				}
				o.language = lang;

				// Retrieve view index from any aliases
				o.startView = this._resolveViewName(o.startView, 0);
				o.minViewMode = this._resolveViewName(o.minViewMode, 0);
				o.maxViewMode = this._resolveViewName(o.maxViewMode, 4);

				// Check that the start view is between min and max
				o.startView = Math.min(o.startView, o.maxViewMode);
				o.startView = Math.max(o.startView, o.minViewMode);

				// true, false, or Number > 0
				if (o.multidate !== true){
					o.multidate = Number(o.multidate) || false;
					if (o.multidate !== false)
						o.multidate = Math.max(0, o.multidate);
				}
				o.multidateSeparator = String(o.multidateSeparator);

				o.weekStart %= 7;
				o.weekEnd = (o.weekStart + 6) % 7;

				var format = DPGlobal.parseFormat(o.format);
				if (o.startDate !== -Infinity){
					if (!!o.startDate){
						if (o.startDate instanceof Date)
							o.startDate = this._local_to_utc(this._zero_time(o.startDate));
						else
							o.startDate = DPGlobal.parseDate(o.startDate, format, o.language, o.assumeNearbyYear);
					}
					else {
						o.startDate = -Infinity;
					}
				}
				if (o.endDate !== Infinity){
					if (!!o.endDate){
						if (o.endDate instanceof Date)
							o.endDate = this._local_to_utc(this._zero_time(o.endDate));
						else
							o.endDate = DPGlobal.parseDate(o.endDate, format, o.language, o.assumeNearbyYear);
					}
					else {
						o.endDate = Infinity;
					}
				}

				o.daysOfWeekDisabled = o.daysOfWeekDisabled||[];
				if (!$.isArray(o.daysOfWeekDisabled))
					o.daysOfWeekDisabled = o.daysOfWeekDisabled.split(/[,\s]*/);
				o.daysOfWeekDisabled = $.map(o.daysOfWeekDisabled, function(d){
					return parseInt(d, 10);
				});

				o.daysOfWeekHighlighted = o.daysOfWeekHighlighted||[];
				if (!$.isArray(o.daysOfWeekHighlighted))
					o.daysOfWeekHighlighted = o.daysOfWeekHighlighted.split(/[,\s]*/);
				o.daysOfWeekHighlighted = $.map(o.daysOfWeekHighlighted, function(d){
					return parseInt(d, 10);
				});

				o.datesDisabled = o.datesDisabled||[];
				if (!$.isArray(o.datesDisabled)) {
					var datesDisabled = [];
					datesDisabled.push(DPGlobal.parseDate(o.datesDisabled, format, o.language, o.assumeNearbyYear));
					o.datesDisabled = datesDisabled;
				}
				o.datesDisabled = $.map(o.datesDisabled,function(d){
					return DPGlobal.parseDate(d, format, o.language, o.assumeNearbyYear);
				});

				var plc = String(o.orientation).toLowerCase().split(/\s+/g),
					_plc = o.orientation.toLowerCase();
				plc = $.grep(plc, function(word){
					return /^auto|left|right|top|bottom$/.test(word);
				});
				o.orientation = {x: 'auto', y: 'auto'};
				if (!_plc || _plc === 'auto')
					; // no action
				else if (plc.length === 1){
					switch (plc[0]){
						case 'top':
						case 'bottom':
							o.orientation.y = plc[0];
							break;
						case 'left':
						case 'right':
							o.orientation.x = plc[0];
							break;
					}
				}
				else {
					_plc = $.grep(plc, function(word){
						return /^left|right$/.test(word);
					});
					o.orientation.x = _plc[0] || 'auto';

					_plc = $.grep(plc, function(word){
						return /^top|bottom$/.test(word);
					});
					o.orientation.y = _plc[0] || 'auto';
				}
				if (o.defaultViewDate) {
					var year = o.defaultViewDate.year || new Date().getFullYear();
					var month = o.defaultViewDate.month || 0;
					var day = o.defaultViewDate.day || 1;
					o.defaultViewDate = UTCDate(year, month, day);
				} else {
					o.defaultViewDate = UTCToday();
				}
			},
			_events: [],
			_secondaryEvents: [],
			_applyEvents: function(evs){
				for (var i=0, el, ch, ev; i < evs.length; i++){
					el = evs[i][0];
					if (evs[i].length === 2){
						ch = undefined;
						ev = evs[i][1];
					}
					else if (evs[i].length === 3){
						ch = evs[i][1];
						ev = evs[i][2];
					}
					el.on(ev, ch);
				}
			},
			_unapplyEvents: function(evs){
				for (var i=0, el, ev, ch; i < evs.length; i++){
					el = evs[i][0];
					if (evs[i].length === 2){
						ch = undefined;
						ev = evs[i][1];
					}
					else if (evs[i].length === 3){
						ch = evs[i][1];
						ev = evs[i][2];
					}
					el.off(ev, ch);
				}
			},
			_buildEvents: function(){
	            var events = {
	                keyup: $.proxy(function(e){
	                    if ($.inArray(e.keyCode, [27, 37, 39, 38, 40, 32, 13, 9]) === -1)
	                        this.update();
	                }, this),
	                keydown: $.proxy(this.keydown, this),
	                paste: $.proxy(this.paste, this)
	            };

	            if (this.o.showOnFocus === true) {
	                events.focus = $.proxy(this.show, this);
	            }

	            if (this.isInput) { // single input
	                this._events = [
	                    [this.element, events]
	                ];
	            }
	            else if (this.component && this.hasInput) { // component: input + button
	                this._events = [
	                    // For components that are not readonly, allow keyboard nav
	                    [this.element.find('input'), events],
	                    [this.component, {
	                        click: $.proxy(this.show, this)
	                    }]
	                ];
	            }
				else if (this.element.is('div')){  // inline datepicker
					this.isInline = true;
				}
				else {
					this._events = [
						[this.element, {
							click: $.proxy(this.show, this)
						}]
					];
				}
				this._events.push(
					// Component: listen for blur on element descendants
					[this.element, '*', {
						blur: $.proxy(function(e){
							this._focused_from = e.target;
						}, this)
					}],
					// Input: listen for blur on element
					[this.element, {
						blur: $.proxy(function(e){
							this._focused_from = e.target;
						}, this)
					}]
				);

				if (this.o.immediateUpdates) {
					// Trigger input updates immediately on changed year/month
					this._events.push([this.element, {
						'changeYear changeMonth': $.proxy(function(e){
							this.update(e.date);
						}, this)
					}]);
				}

				this._secondaryEvents = [
					[this.picker, {
						click: $.proxy(this.click, this)
					}],
					[$(window), {
						resize: $.proxy(this.place, this)
					}],
					[$(document), {
						mousedown: $.proxy(function(e){
							// Clicked outside the datepicker, hide it
							if (!(
								this.element.is(e.target) ||
								this.element.find(e.target).length ||
								this.picker.is(e.target) ||
								this.picker.find(e.target).length ||
								this.picker.hasClass('datepicker-inline')
							)){
								this.hide();
							}
						}, this)
					}]
				];
			},
			_attachEvents: function(){
				this._detachEvents();
				this._applyEvents(this._events);
			},
			_detachEvents: function(){
				this._unapplyEvents(this._events);
			},
			_attachSecondaryEvents: function(){
				this._detachSecondaryEvents();
				this._applyEvents(this._secondaryEvents);
			},
			_detachSecondaryEvents: function(){
				this._unapplyEvents(this._secondaryEvents);
			},
			_trigger: function(event, altdate){
				var date = altdate || this.dates.get(-1),
					local_date = this._utc_to_local(date);

				this.element.trigger({
					type: event,
					date: local_date,
					dates: $.map(this.dates, this._utc_to_local),
					format: $.proxy(function(ix, format){
						if (arguments.length === 0){
							ix = this.dates.length - 1;
							format = this.o.format;
						}
						else if (typeof ix === 'string'){
							format = ix;
							ix = this.dates.length - 1;
						}
						format = format || this.o.format;
						var date = this.dates.get(ix);
						return DPGlobal.formatDate(date, format, this.o.language);
					}, this)
				});
			},

			show: function(){
	      var element = this.component ? this.element.find('input') : this.element;
				if (element.attr('readonly') && this.o.enableOnReadonly === false)
					return;
				if (!this.isInline)
					this.picker.appendTo(this.o.container);
				this.place();
				this.picker.show();
				this._attachSecondaryEvents();
				this._trigger('show');
				if ((window.navigator.msMaxTouchPoints || 'ontouchstart' in document) && this.o.disableTouchKeyboard) {
					$(this.element).blur();
				}
				return this;
			},

			hide: function(){
				if (this.isInline)
					return this;
				if (!this.picker.is(':visible'))
					return this;
				this.focusDate = null;
				this.picker.hide().detach();
				this._detachSecondaryEvents();
				this.viewMode = this.o.startView;
				this.showMode();

				if (
					this.o.forceParse &&
					(
						this.isInput && this.element.val() ||
						this.hasInput && this.element.find('input').val()
					)
				)
					this.setValue();
				this._trigger('hide');
				return this;
			},

			destroy: function(){
				this.hide();
				this._detachEvents();
				this._detachSecondaryEvents();
				this.picker.remove();
				delete this.element.data().datepicker;
				if (!this.isInput){
					delete this.element.data().date;
				}
				return this;
			},

			paste: function(evt){
				var dateString;
				if (evt.originalEvent.clipboardData && evt.originalEvent.clipboardData.types
					&& $.inArray('text/plain', evt.originalEvent.clipboardData.types) !== -1) {
					dateString = evt.originalEvent.clipboardData.getData('text/plain');
				}
				else if (window.clipboardData) {
					dateString = window.clipboardData.getData('Text');
				}
				else {
					return;
				}
				this.setDate(dateString);
				this.update();
				evt.preventDefault();
			},

			_utc_to_local: function(utc){
				return utc && new Date(utc.getTime() + (utc.getTimezoneOffset()*60000));
			},
			_local_to_utc: function(local){
				return local && new Date(local.getTime() - (local.getTimezoneOffset()*60000));
			},
			_zero_time: function(local){
				return local && new Date(local.getFullYear(), local.getMonth(), local.getDate());
			},
			_zero_utc_time: function(utc){
				return utc && new Date(Date.UTC(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate()));
			},

			getDates: function(){
				return $.map(this.dates, this._utc_to_local);
			},

			getUTCDates: function(){
				return $.map(this.dates, function(d){
					return new Date(d);
				});
			},

			getDate: function(){
				return this._utc_to_local(this.getUTCDate());
			},

			getUTCDate: function(){
				var selected_date = this.dates.get(-1);
				if (typeof selected_date !== 'undefined') {
					return new Date(selected_date);
				} else {
					return null;
				}
			},

			clearDates: function(){
				var element;
				if (this.isInput) {
					element = this.element;
				} else if (this.component) {
					element = this.element.find('input');
				}

				if (element) {
					element.val('');
				}

				this.update();
				this._trigger('changeDate');

				if (this.o.autoclose) {
					this.hide();
				}
			},
			setDates: function(){
				var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
				this.update.apply(this, args);
				this._trigger('changeDate');
				this.setValue();
				return this;
			},

			setUTCDates: function(){
				var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
				this.update.apply(this, $.map(args, this._utc_to_local));
				this._trigger('changeDate');
				this.setValue();
				return this;
			},

			setDate: alias('setDates'),
			setUTCDate: alias('setUTCDates'),
			remove: alias('destroy'),

			setValue: function(){
				var formatted = this.getFormattedDate();
				if (!this.isInput){
					if (this.component){
						this.element.find('input').val(formatted);
					}
				}
				else {
					this.element.val(formatted);
				}
				return this;
			},

			getFormattedDate: function(format){
				if (format === undefined)
					format = this.o.format;

				var lang = this.o.language;
				return $.map(this.dates, function(d){
					return DPGlobal.formatDate(d, format, lang);
				}).join(this.o.multidateSeparator);
			},

			getStartDate: function(){
				return this.o.startDate;
			},

			setStartDate: function(startDate){
				this._process_options({startDate: startDate});
				this.update();
				this.updateNavArrows();
				return this;
			},

			getEndDate: function(){
				return this.o.endDate;
			},

			setEndDate: function(endDate){
				this._process_options({endDate: endDate});
				this.update();
				this.updateNavArrows();
				return this;
			},

			setDaysOfWeekDisabled: function(daysOfWeekDisabled){
				this._process_options({daysOfWeekDisabled: daysOfWeekDisabled});
				this.update();
				this.updateNavArrows();
				return this;
			},

			setDaysOfWeekHighlighted: function(daysOfWeekHighlighted){
				this._process_options({daysOfWeekHighlighted: daysOfWeekHighlighted});
				this.update();
				return this;
			},

			setDatesDisabled: function(datesDisabled){
				this._process_options({datesDisabled: datesDisabled});
				this.update();
				this.updateNavArrows();
			},

			place: function(){
				if (this.isInline)
					return this;
				var calendarWidth = this.picker.outerWidth(),
					calendarHeight = this.picker.outerHeight(),
					visualPadding = 10,
					container = $(this.o.container),
					windowWidth = container.width(),
					scrollTop = this.o.container === 'body' ? $(document).scrollTop() : container.scrollTop(),
					appendOffset = container.offset();

				var parentsZindex = [];
				this.element.parents().each(function(){
					var itemZIndex = $(this).css('z-index');
					if (itemZIndex !== 'auto' && itemZIndex !== 0) parentsZindex.push(parseInt(itemZIndex));
				});
				var zIndex = Math.max.apply(Math, parentsZindex) + this.o.zIndexOffset;
				var offset = this.component ? this.component.parent().offset() : this.element.offset();
				var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(false);
				var width = this.component ? this.component.outerWidth(true) : this.element.outerWidth(false);
				var left = offset.left - appendOffset.left,
					top = offset.top - appendOffset.top;

				if (this.o.container !== 'body') {
					top += scrollTop;
				}

				this.picker.removeClass(
					'datepicker-orient-top datepicker-orient-bottom '+
					'datepicker-orient-right datepicker-orient-left'
				);

				if (this.o.orientation.x !== 'auto'){
					this.picker.addClass('datepicker-orient-' + this.o.orientation.x);
					if (this.o.orientation.x === 'right')
						left -= calendarWidth - width;
				}
				// auto x orientation is best-placement: if it crosses a window
				// edge, fudge it sideways
				else {
					if (offset.left < 0) {
						// component is outside the window on the left side. Move it into visible range
						this.picker.addClass('datepicker-orient-left');
						left -= offset.left - visualPadding;
					} else if (left + calendarWidth > windowWidth) {
						// the calendar passes the widow right edge. Align it to component right side
						this.picker.addClass('datepicker-orient-right');
						left += width - calendarWidth;
					} else {
						// Default to left
						this.picker.addClass('datepicker-orient-left');
					}
				}

				// auto y orientation is best-situation: top or bottom, no fudging,
				// decision based on which shows more of the calendar
				var yorient = this.o.orientation.y,
					top_overflow;
				if (yorient === 'auto'){
					top_overflow = -scrollTop + top - calendarHeight;
					yorient = top_overflow < 0 ? 'bottom' : 'top';
				}

				this.picker.addClass('datepicker-orient-' + yorient);
				if (yorient === 'top')
					top -= calendarHeight + parseInt(this.picker.css('padding-top'));
				else
					top += height;

				if (this.o.rtl) {
					var right = windowWidth - (left + width);
					this.picker.css({
						top: top,
						right: right,
						zIndex: zIndex
					});
				} else {
					this.picker.css({
						top: top,
						left: left,
						zIndex: zIndex
					});
				}
				return this;
			},

			_allow_update: true,
			update: function(){
				if (!this._allow_update)
					return this;

				var oldDates = this.dates.copy(),
					dates = [],
					fromArgs = false;
				if (arguments.length){
					$.each(arguments, $.proxy(function(i, date){
						if (date instanceof Date)
							date = this._local_to_utc(date);
						dates.push(date);
					}, this));
					fromArgs = true;
				}
				else {
					dates = this.isInput
							? this.element.val()
							: this.element.data('date') || this.element.find('input').val();
					if (dates && this.o.multidate)
						dates = dates.split(this.o.multidateSeparator);
					else
						dates = [dates];
					delete this.element.data().date;
				}

				dates = $.map(dates, $.proxy(function(date){
					return DPGlobal.parseDate(date, this.o.format, this.o.language, this.o.assumeNearbyYear);
				}, this));
				dates = $.grep(dates, $.proxy(function(date){
					return (
						!this.dateWithinRange(date) ||
						!date
					);
				}, this), true);
				this.dates.replace(dates);

				if (this.dates.length)
					this.viewDate = new Date(this.dates.get(-1));
				else if (this.viewDate < this.o.startDate)
					this.viewDate = new Date(this.o.startDate);
				else if (this.viewDate > this.o.endDate)
					this.viewDate = new Date(this.o.endDate);
				else
					this.viewDate = this.o.defaultViewDate;

				if (fromArgs){
					// setting date by clicking
					this.setValue();
				}
				else if (dates.length){
					// setting date by typing
					if (String(oldDates) !== String(this.dates))
						this._trigger('changeDate');
				}
				if (!this.dates.length && oldDates.length)
					this._trigger('clearDate');

				this.fill();
				this.element.change();
				return this;
			},

			fillDow: function(){
				var dowCnt = this.o.weekStart,
					html = '<tr>';
				if (this.o.calendarWeeks){
					this.picker.find('.datepicker-days .datepicker-switch')
						.attr('colspan', function(i, val){
							return parseInt(val) + 1;
						});
					html += '<th class="cw">&#160;</th>';
				}
				while (dowCnt < this.o.weekStart + 7){
					html += '<th class="dow';
	        if ($.inArray(dowCnt, this.o.daysOfWeekDisabled) > -1)
	          html += ' disabled';
	        html += '">'+dates[this.o.language].daysMin[(dowCnt++)%7]+'</th>';
				}
				html += '</tr>';
				this.picker.find('.datepicker-days thead').append(html);
			},

			fillMonths: function(){
	      var localDate = this._utc_to_local(this.viewDate);
				var html = '',
				i = 0;
				while (i < 12){
	        var focused = localDate && localDate.getMonth() === i ? ' focused' : '';
					html += '<span class="month' + focused + '">' + dates[this.o.language].monthsShort[i++]+'</span>';
				}
				this.picker.find('.datepicker-months td').html(html);
			},

			setRange: function(range){
				if (!range || !range.length)
					delete this.range;
				else
					this.range = $.map(range, function(d){
						return d.valueOf();
					});
				this.fill();
			},

			getClassNames: function(date){
				var cls = [],
					year = this.viewDate.getUTCFullYear(),
					month = this.viewDate.getUTCMonth(),
					today = new Date();
				if (date.getUTCFullYear() < year || (date.getUTCFullYear() === year && date.getUTCMonth() < month)){
					cls.push('old');
				}
				else if (date.getUTCFullYear() > year || (date.getUTCFullYear() === year && date.getUTCMonth() > month)){
					cls.push('new');
				}
				if (this.focusDate && date.valueOf() === this.focusDate.valueOf())
					cls.push('focused');
				// Compare internal UTC date with local today, not UTC today
				if (this.o.todayHighlight &&
					date.getUTCFullYear() === today.getFullYear() &&
					date.getUTCMonth() === today.getMonth() &&
					date.getUTCDate() === today.getDate()){
					cls.push('today');
				}
				if (this.dates.contains(date) !== -1)
					cls.push('active');
				if (!this.dateWithinRange(date)){
					cls.push('disabled');
				}
				if (this.dateIsDisabled(date)){
					cls.push('disabled', 'disabled-date');
				}
				if ($.inArray(date.getUTCDay(), this.o.daysOfWeekHighlighted) !== -1){
					cls.push('highlighted');
				}

				if (this.range){
					if (date > this.range[0] && date < this.range[this.range.length-1]){
						cls.push('range');
					}
					if ($.inArray(date.valueOf(), this.range) !== -1){
						cls.push('selected');
					}
					if (date.valueOf() === this.range[0]){
	          cls.push('range-start');
	        }
	        if (date.valueOf() === this.range[this.range.length-1]){
	          cls.push('range-end');
	        }
				}
				return cls;
			},

			_fill_yearsView: function(selector, cssClass, factor, step, currentYear, startYear, endYear, callback){
				var html, view, year, steps, startStep, endStep, thisYear, i, classes, tooltip, before;

				html      = '';
				view      = this.picker.find(selector);
				year      = parseInt(currentYear / factor, 10) * factor;
				startStep = parseInt(startYear / step, 10) * step;
				endStep   = parseInt(endYear / step, 10) * step;
				steps     = $.map(this.dates, function(d){
					return parseInt(d.getUTCFullYear() / step, 10) * step;
				});

				view.find('.datepicker-switch').text(year + '-' + (year + step * 9));

				thisYear = year - step;
				for (i = -1; i < 11; i += 1) {
					classes = [cssClass];
					tooltip = null;

					if (i === -1) {
						classes.push('old');
					} else if (i === 10) {
						classes.push('new');
					}
					if ($.inArray(thisYear, steps) !== -1) {
						classes.push('active');
					}
					if (thisYear < startStep || thisYear > endStep) {
						classes.push('disabled');
					}
	        if (thisYear === this.viewDate.getFullYear()) {
					  classes.push('focused');
	        }

					if (callback !== $.noop) {
						before = callback(new Date(thisYear, 0, 1));
						if (before === undefined) {
							before = {};
						} else if (typeof(before) === 'boolean') {
							before = {enabled: before};
						} else if (typeof(before) === 'string') {
							before = {classes: before};
						}
						if (before.enabled === false) {
							classes.push('disabled');
						}
						if (before.classes) {
							classes = classes.concat(before.classes.split(/\s+/));
						}
						if (before.tooltip) {
							tooltip = before.tooltip;
						}
					}

					html += '<span class="' + classes.join(' ') + '"' + (tooltip ? ' title="' + tooltip + '"' : '') + '>' + thisYear + '</span>';
					thisYear += step;
				}
				view.find('td').html(html);
			},

			fill: function(){
				var d = new Date(this.viewDate),
					year = d.getUTCFullYear(),
					month = d.getUTCMonth(),
					startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
					startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
					endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
					endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
					todaytxt = dates[this.o.language].today || dates['en'].today || '',
					cleartxt = dates[this.o.language].clear || dates['en'].clear || '',
					titleFormat = dates[this.o.language].titleFormat || dates['en'].titleFormat,
					tooltip,
					before;
				if (isNaN(year) || isNaN(month))
					return;
				this.picker.find('.datepicker-days .datepicker-switch')
							.text(DPGlobal.formatDate(d, titleFormat, this.o.language));
				this.picker.find('tfoot .today')
							.text(todaytxt)
							.toggle(this.o.todayBtn !== false);
				this.picker.find('tfoot .clear')
							.text(cleartxt)
							.toggle(this.o.clearBtn !== false);
				this.picker.find('thead .datepicker-title')
							.text(this.o.title)
							.toggle(this.o.title !== '');
				this.updateNavArrows();
				this.fillMonths();
				var prevMonth = UTCDate(year, month-1, 28),
					day = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());
				prevMonth.setUTCDate(day);
				prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7)%7);
				var nextMonth = new Date(prevMonth);
				if (prevMonth.getUTCFullYear() < 100){
	        nextMonth.setUTCFullYear(prevMonth.getUTCFullYear());
	      }
				nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
				nextMonth = nextMonth.valueOf();
				var html = [];
				var clsName;
				while (prevMonth.valueOf() < nextMonth){
					if (prevMonth.getUTCDay() === this.o.weekStart){
						html.push('<tr>');
						if (this.o.calendarWeeks){
							// ISO 8601: First week contains first thursday.
							// ISO also states week starts on Monday, but we can be more abstract here.
							var
								// Start of current week: based on weekstart/current date
								ws = new Date(+prevMonth + (this.o.weekStart - prevMonth.getUTCDay() - 7) % 7 * 864e5),
								// Thursday of this week
								th = new Date(Number(ws) + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),
								// First Thursday of year, year from thursday
								yth = new Date(Number(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay())%7*864e5),
								// Calendar week: ms between thursdays, div ms per day, div 7 days
								calWeek =  (th - yth) / 864e5 / 7 + 1;
							html.push('<td class="cw">'+ calWeek +'</td>');

						}
					}
					clsName = this.getClassNames(prevMonth);
					clsName.push('day');

					if (this.o.beforeShowDay !== $.noop){
						before = this.o.beforeShowDay(this._utc_to_local(prevMonth));
						if (before === undefined)
							before = {};
						else if (typeof(before) === 'boolean')
							before = {enabled: before};
						else if (typeof(before) === 'string')
							before = {classes: before};
						if (before.enabled === false)
							clsName.push('disabled');
						if (before.classes)
							clsName = clsName.concat(before.classes.split(/\s+/));
						if (before.tooltip)
							tooltip = before.tooltip;
					}

					clsName = $.unique(clsName);
					html.push('<td class="'+clsName.join(' ')+'"' + (tooltip ? ' title="'+tooltip+'"' : '') + '>'+prevMonth.getUTCDate() + '</td>');
					tooltip = null;
					if (prevMonth.getUTCDay() === this.o.weekEnd){
						html.push('</tr>');
					}
					prevMonth.setUTCDate(prevMonth.getUTCDate()+1);
				}
				this.picker.find('.datepicker-days tbody').empty().append(html.join(''));

				var monthsTitle = dates[this.o.language].monthsTitle || dates['en'].monthsTitle || 'Months';
				var months = this.picker.find('.datepicker-months')
							.find('.datepicker-switch')
								.text(this.o.maxViewMode < 2 ? monthsTitle : year)
								.end()
							.find('span').removeClass('active');

				$.each(this.dates, function(i, d){
					if (d.getUTCFullYear() === year)
						months.eq(d.getUTCMonth()).addClass('active');
				});

				if (year < startYear || year > endYear){
					months.addClass('disabled');
				}
				if (year === startYear){
					months.slice(0, startMonth).addClass('disabled');
				}
				if (year === endYear){
					months.slice(endMonth+1).addClass('disabled');
				}

				if (this.o.beforeShowMonth !== $.noop){
					var that = this;
					$.each(months, function(i, month){
	          var moDate = new Date(year, i, 1);
	          var before = that.o.beforeShowMonth(moDate);
						if (before === undefined)
							before = {};
						else if (typeof(before) === 'boolean')
							before = {enabled: before};
						else if (typeof(before) === 'string')
							before = {classes: before};
						if (before.enabled === false && !$(month).hasClass('disabled'))
						    $(month).addClass('disabled');
						if (before.classes)
						    $(month).addClass(before.classes);
						if (before.tooltip)
						    $(month).prop('title', before.tooltip);
					});
				}

				// Generating decade/years picker
				this._fill_yearsView(
					'.datepicker-years',
					'year',
					10,
					1,
					year,
					startYear,
					endYear,
					this.o.beforeShowYear
				);

				// Generating century/decades picker
				this._fill_yearsView(
					'.datepicker-decades',
					'decade',
					100,
					10,
					year,
					startYear,
					endYear,
					this.o.beforeShowDecade
				);

				// Generating millennium/centuries picker
				this._fill_yearsView(
					'.datepicker-centuries',
					'century',
					1000,
					100,
					year,
					startYear,
					endYear,
					this.o.beforeShowCentury
				);
			},

			updateNavArrows: function(){
				if (!this._allow_update)
					return;

				var d = new Date(this.viewDate),
					year = d.getUTCFullYear(),
					month = d.getUTCMonth();
				switch (this.viewMode){
					case 0:
						if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear() && month <= this.o.startDate.getUTCMonth()){
							this.picker.find('.prev').css({visibility: 'hidden'});
						}
						else {
							this.picker.find('.prev').css({visibility: 'visible'});
						}
						if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear() && month >= this.o.endDate.getUTCMonth()){
							this.picker.find('.next').css({visibility: 'hidden'});
						}
						else {
							this.picker.find('.next').css({visibility: 'visible'});
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
						if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear() || this.o.maxViewMode < 2){
							this.picker.find('.prev').css({visibility: 'hidden'});
						}
						else {
							this.picker.find('.prev').css({visibility: 'visible'});
						}
						if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear() || this.o.maxViewMode < 2){
							this.picker.find('.next').css({visibility: 'hidden'});
						}
						else {
							this.picker.find('.next').css({visibility: 'visible'});
						}
						break;
				}
			},

			click: function(e){
				e.preventDefault();
				e.stopPropagation();

				var target, dir, day, year, month, monthChanged, yearChanged;
				target = $(e.target);

				// Clicked on the switch
				if (target.hasClass('datepicker-switch')){
					this.showMode(1);
				}

				// Clicked on prev or next
				var navArrow = target.closest('.prev, .next');
				if (navArrow.length > 0) {
					dir = DPGlobal.modes[this.viewMode].navStep * (navArrow.hasClass('prev') ? -1 : 1);
					if (this.viewMode === 0){
						this.viewDate = this.moveMonth(this.viewDate, dir);
						this._trigger('changeMonth', this.viewDate);
					} else {
						this.viewDate = this.moveYear(this.viewDate, dir);
						if (this.viewMode === 1){
							this._trigger('changeYear', this.viewDate);
						}
					}
					this.fill();
				}

				// Clicked on today button
				if (target.hasClass('today')){
					this.showMode(-2);
					this._setDate(UTCToday(), this.o.todayBtn === 'linked' ? null : 'view');
				}

				// Clicked on clear button
				if (target.hasClass('clear')){
					this.clearDates();
				}

				if (!target.hasClass('disabled')){
					// Clicked on a day
					if (target.hasClass('day')){
						day = parseInt(target.text(), 10) || 1;
						year = this.viewDate.getUTCFullYear();
						month = this.viewDate.getUTCMonth();

						// From last month
						if (target.hasClass('old')){
							if (month === 0) {
								month = 11;
								year = year - 1;
								monthChanged = true;
								yearChanged = true;
							} else {
								month = month - 1;
								monthChanged = true;
	 						}
	 					}

						// From next month
						if (target.hasClass('new')) {
							if (month === 11){
								month = 0;
								year = year + 1;
								monthChanged = true;
								yearChanged = true;
	 						} else {
								month = month + 1;
								monthChanged = true;
	 						}
						}
						this._setDate(UTCDate(year, month, day));
						if (yearChanged) {
							this._trigger('changeYear', this.viewDate);
						}
						if (monthChanged) {
							this._trigger('changeMonth', this.viewDate);
						}
					}

					// Clicked on a month
					if (target.hasClass('month')) {
						this.viewDate.setUTCDate(1);
						day = 1;
						month = target.parent().find('span').index(target);
						year = this.viewDate.getUTCFullYear();
						this.viewDate.setUTCMonth(month);
						this._trigger('changeMonth', this.viewDate);
						if (this.o.minViewMode === 1){
							this._setDate(UTCDate(year, month, day));
							this.showMode();
						} else {
							this.showMode(-1);
						}
						this.fill();
					}

					// Clicked on a year
					if (target.hasClass('year')
							|| target.hasClass('decade')
							|| target.hasClass('century')) {
						this.viewDate.setUTCDate(1);

						day = 1;
						month = 0;
						year = parseInt(target.text(), 10)||0;
						this.viewDate.setUTCFullYear(year);

						if (target.hasClass('year')){
							this._trigger('changeYear', this.viewDate);
							if (this.o.minViewMode === 2){
								this._setDate(UTCDate(year, month, day));
							}
						}
						if (target.hasClass('decade')){
							this._trigger('changeDecade', this.viewDate);
							if (this.o.minViewMode === 3){
								this._setDate(UTCDate(year, month, day));
							}
						}
						if (target.hasClass('century')){
							this._trigger('changeCentury', this.viewDate);
							if (this.o.minViewMode === 4){
								this._setDate(UTCDate(year, month, day));
							}
						}

						this.showMode(-1);
						this.fill();
					}
				}

				if (this.picker.is(':visible') && this._focused_from){
					$(this._focused_from).focus();
				}
				delete this._focused_from;
			},

			_toggle_multidate: function(date){
				var ix = this.dates.contains(date);
				if (!date){
					this.dates.clear();
				}

				if (ix !== -1){
					if (this.o.multidate === true || this.o.multidate > 1 || this.o.toggleActive){
						this.dates.remove(ix);
					}
				} else if (this.o.multidate === false) {
					this.dates.clear();
					this.dates.push(date);
				}
				else {
					this.dates.push(date);
				}

				if (typeof this.o.multidate === 'number')
					while (this.dates.length > this.o.multidate)
						this.dates.remove(0);
			},

			_setDate: function(date, which){
				if (!which || which === 'date')
					this._toggle_multidate(date && new Date(date));
				if (!which || which === 'view')
					this.viewDate = date && new Date(date);

				this.fill();
				this.setValue();
				if (!which || which !== 'view') {
					this._trigger('changeDate');
				}
				var element;
				if (this.isInput){
					element = this.element;
				}
				else if (this.component){
					element = this.element.find('input');
				}
				if (element){
					element.change();
				}
				if (this.o.autoclose && (!which || which === 'date')){
					this.hide();
				}
			},

			moveDay: function(date, dir){
				var newDate = new Date(date);
				newDate.setUTCDate(date.getUTCDate() + dir);

				return newDate;
			},

			moveWeek: function(date, dir){
				return this.moveDay(date, dir * 7);
			},

			moveMonth: function(date, dir){
				if (!isValidDate(date))
					return this.o.defaultViewDate;
				if (!dir)
					return date;
				var new_date = new Date(date.valueOf()),
					day = new_date.getUTCDate(),
					month = new_date.getUTCMonth(),
					mag = Math.abs(dir),
					new_month, test;
				dir = dir > 0 ? 1 : -1;
				if (mag === 1){
					test = dir === -1
						// If going back one month, make sure month is not current month
						// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
						? function(){
							return new_date.getUTCMonth() === month;
						}
						// If going forward one month, make sure month is as expected
						// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
						: function(){
							return new_date.getUTCMonth() !== new_month;
						};
					new_month = month + dir;
					new_date.setUTCMonth(new_month);
					// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
					if (new_month < 0 || new_month > 11)
						new_month = (new_month + 12) % 12;
				}
				else {
					// For magnitudes >1, move one month at a time...
					for (var i=0; i < mag; i++)
						// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
						new_date = this.moveMonth(new_date, dir);
					// ...then reset the day, keeping it in the new month
					new_month = new_date.getUTCMonth();
					new_date.setUTCDate(day);
					test = function(){
						return new_month !== new_date.getUTCMonth();
					};
				}
				// Common date-resetting loop -- if date is beyond end of month, make it
				// end of month
				while (test()){
					new_date.setUTCDate(--day);
					new_date.setUTCMonth(new_month);
				}
				return new_date;
			},

			moveYear: function(date, dir){
				return this.moveMonth(date, dir*12);
			},

			moveAvailableDate: function(date, dir, fn){
				do {
					date = this[fn](date, dir);

					if (!this.dateWithinRange(date))
						return false;

					fn = 'moveDay';
				}
				while (this.dateIsDisabled(date));

				return date;
			},

			weekOfDateIsDisabled: function(date){
				return $.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1;
			},

			dateIsDisabled: function(date){
				return (
					this.weekOfDateIsDisabled(date) ||
					$.grep(this.o.datesDisabled, function(d){
						return isUTCEquals(date, d);
					}).length > 0
				);
			},

			dateWithinRange: function(date){
				return date >= this.o.startDate && date <= this.o.endDate;
			},

			keydown: function(e){
				if (!this.picker.is(':visible')){
					if (e.keyCode === 40 || e.keyCode === 27) { // allow down to re-show picker
						this.show();
						e.stopPropagation();
	        }
					return;
				}
				var dateChanged = false,
					dir, newViewDate,
					focusDate = this.focusDate || this.viewDate;
				switch (e.keyCode){
					case 27: // escape
						if (this.focusDate){
							this.focusDate = null;
							this.viewDate = this.dates.get(-1) || this.viewDate;
							this.fill();
						}
						else
							this.hide();
						e.preventDefault();
						e.stopPropagation();
						break;
					case 37: // left
					case 38: // up
					case 39: // right
					case 40: // down
						if (!this.o.keyboardNavigation || this.o.daysOfWeekDisabled.length === 7)
							break;
						dir = e.keyCode === 37 || e.keyCode === 38 ? -1 : 1;
	          if (this.viewMode === 0) {
	  					if (e.ctrlKey){
	  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');

	  						if (newViewDate)
	  							this._trigger('changeYear', this.viewDate);
	  					}
	  					else if (e.shiftKey){
	  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');

	  						if (newViewDate)
	  							this._trigger('changeMonth', this.viewDate);
	  					}
	  					else if (e.keyCode === 37 || e.keyCode === 39){
	  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveDay');
	  					}
	  					else if (!this.weekOfDateIsDisabled(focusDate)){
	  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveWeek');
	  					}
	          } else if (this.viewMode === 1) {
	            if (e.keyCode === 38 || e.keyCode === 40) {
	              dir = dir * 4;
	            }
	            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');
	          } else if (this.viewMode === 2) {
	            if (e.keyCode === 38 || e.keyCode === 40) {
	              dir = dir * 4;
	            }
	            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');
	          }
						if (newViewDate){
							this.focusDate = this.viewDate = newViewDate;
							this.setValue();
							this.fill();
							e.preventDefault();
						}
						break;
					case 13: // enter
						if (!this.o.forceParse)
							break;
						focusDate = this.focusDate || this.dates.get(-1) || this.viewDate;
						if (this.o.keyboardNavigation) {
							this._toggle_multidate(focusDate);
							dateChanged = true;
						}
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.setValue();
						this.fill();
						if (this.picker.is(':visible')){
							e.preventDefault();
							e.stopPropagation();
							if (this.o.autoclose)
								this.hide();
						}
						break;
					case 9: // tab
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.fill();
						this.hide();
						break;
				}
				if (dateChanged){
					if (this.dates.length)
						this._trigger('changeDate');
					else
						this._trigger('clearDate');
					var element;
					if (this.isInput){
						element = this.element;
					}
					else if (this.component){
						element = this.element.find('input');
					}
					if (element){
						element.change();
					}
				}
			},

			showMode: function(dir){
				if (dir){
					this.viewMode = Math.max(this.o.minViewMode, Math.min(this.o.maxViewMode, this.viewMode + dir));
				}
				this.picker
					.children('div')
					.hide()
					.filter('.datepicker-' + DPGlobal.modes[this.viewMode].clsName)
						.show();
				this.updateNavArrows();
			}
		};

		var DateRangePicker = function(element, options){
			$(element).data('datepicker', this);
			this.element = $(element);
			this.inputs = $.map(options.inputs, function(i){
				return i.jquery ? i[0] : i;
			});
			delete options.inputs;

			datepickerPlugin.call($(this.inputs), options)
				.on('changeDate', $.proxy(this.dateUpdated, this));

			this.pickers = $.map(this.inputs, function(i){
				return $(i).data('datepicker');
			});
			this.updateDates();
		};
		DateRangePicker.prototype = {
			updateDates: function(){
				this.dates = $.map(this.pickers, function(i){
					return i.getUTCDate();
				});
				this.updateRanges();
			},
			updateRanges: function(){
				var range = $.map(this.dates, function(d){
					return d.valueOf();
				});
				$.each(this.pickers, function(i, p){
					p.setRange(range);
				});
			},
			dateUpdated: function(e){
				// `this.updating` is a workaround for preventing infinite recursion
				// between `changeDate` triggering and `setUTCDate` calling.  Until
				// there is a better mechanism.
				if (this.updating)
					return;
				this.updating = true;

				var dp = $(e.target).data('datepicker');

				if (typeof(dp) === "undefined") {
					return;
				}

				var new_date = dp.getUTCDate(),
					i = $.inArray(e.target, this.inputs),
					j = i - 1,
					k = i + 1,
					l = this.inputs.length;
				if (i === -1)
					return;

				$.each(this.pickers, function(i, p){
					if (!p.getUTCDate())
						p.setUTCDate(new_date);
				});

				if (new_date < this.dates[j]){
					// Date being moved earlier/left
					while (j >= 0 && new_date < this.dates[j]){
						this.pickers[j--].setUTCDate(new_date);
					}
				}
				else if (new_date > this.dates[k]){
					// Date being moved later/right
					while (k < l && new_date > this.dates[k]){
						this.pickers[k++].setUTCDate(new_date);
					}
				}
				this.updateDates();

				delete this.updating;
			},
			remove: function(){
				$.map(this.pickers, function(p){ p.remove(); });
				delete this.element.data().datepicker;
			}
		};

		function opts_from_el(el, prefix){
			// Derive options from element data-attrs
			var data = $(el).data(),
				out = {}, inkey,
				replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])');
			prefix = new RegExp('^' + prefix.toLowerCase());
			function re_lower(_,a){
				return a.toLowerCase();
			}
			for (var key in data)
				if (prefix.test(key)){
					inkey = key.replace(replace, re_lower);
					out[inkey] = data[key];
				}
			return out;
		}

		function opts_from_locale(lang){
			// Derive options from locale plugins
			var out = {};
			// Check if "de-DE" style date is available, if not language should
			// fallback to 2 letter code eg "de"
			if (!dates[lang]){
				lang = lang.split('-')[0];
				if (!dates[lang])
					return;
			}
			var d = dates[lang];
			$.each(locale_opts, function(i,k){
				if (k in d)
					out[k] = d[k];
			});
			return out;
		}

		var old = $.fn.datepicker;
		var datepickerPlugin = function(option){
			var args = Array.apply(null, arguments);
			args.shift();
			var internal_return;
			this.each(function(){
				var $this = $(this),
					data = $this.data('datepicker'),
					options = typeof option === 'object' && option;
				if (!data){
					var elopts = opts_from_el(this, 'date'),
						// Preliminary otions
						xopts = $.extend({}, defaults, elopts, options),
						locopts = opts_from_locale(xopts.language),
						// Options priority: js args, data-attrs, locales, defaults
						opts = $.extend({}, defaults, locopts, elopts, options);
					if ($this.hasClass('input-daterange') || opts.inputs){
						$.extend(opts, {
							inputs: opts.inputs || $this.find('input').toArray()
						});
						data = new DateRangePicker(this, opts);
					}
					else {
						data = new Datepicker(this, opts);
					}
					$this.data('datepicker', data);
				}
				if (typeof option === 'string' && typeof data[option] === 'function'){
					internal_return = data[option].apply(data, args);
				}
			});

			if (
				internal_return === undefined ||
				internal_return instanceof Datepicker ||
				internal_return instanceof DateRangePicker
			)
				return this;

			if (this.length > 1)
				throw new Error('Using only allowed for the collection of a single element (' + option + ' function)');
			else
				return internal_return;
		};
		$.fn.datepicker = datepickerPlugin;

		var defaults = $.fn.datepicker.defaults = {
			assumeNearbyYear: false,
			autoclose: false,
			beforeShowDay: $.noop,
			beforeShowMonth: $.noop,
			beforeShowYear: $.noop,
			beforeShowDecade: $.noop,
			beforeShowCentury: $.noop,
			calendarWeeks: false,
			clearBtn: false,
			toggleActive: false,
			daysOfWeekDisabled: [],
			daysOfWeekHighlighted: [],
			datesDisabled: [],
			endDate: Infinity,
			forceParse: true,
			format: 'mm/dd/yyyy',
			keyboardNavigation: true,
			language: 'en',
			minViewMode: 0,
			maxViewMode: 4,
			multidate: false,
			multidateSeparator: ',',
			orientation: "auto",
			rtl: false,
			startDate: -Infinity,
			startView: 0,
			todayBtn: false,
			todayHighlight: false,
			weekStart: 0,
			disableTouchKeyboard: false,
			enableOnReadonly: true,
			showOnFocus: true,
			zIndexOffset: 10,
			container: 'body',
			immediateUpdates: false,
			title: '',
			templates: {
				leftArrow: '&laquo;',
				rightArrow: '&raquo;'
			}
		};
		var locale_opts = $.fn.datepicker.locale_opts = [
			'format',
			'rtl',
			'weekStart'
		];
		$.fn.datepicker.Constructor = Datepicker;
		var dates = $.fn.datepicker.dates = {
			en: {
				days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
				daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
				daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
				months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
				monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
				today: "Today",
				clear: "Clear",
				titleFormat: "MM yyyy"
			}
		};

		var DPGlobal = {
			modes: [
				{
					clsName: 'days',
					navFnc: 'Month',
					navStep: 1
				},
				{
					clsName: 'months',
					navFnc: 'FullYear',
					navStep: 1
				},
				{
					clsName: 'years',
					navFnc: 'FullYear',
					navStep: 10
				},
				{
					clsName: 'decades',
					navFnc: 'FullDecade',
					navStep: 100
				},
				{
					clsName: 'centuries',
					navFnc: 'FullCentury',
					navStep: 1000
			}],
			isLeapYear: function(year){
				return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));
			},
			getDaysInMonth: function(year, month){
				return [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
			},
			validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
			nonpunctuation: /[^ -\/:-@\u5e74\u6708\u65e5\[-`{-~\t\n\r]+/g,
			parseFormat: function(format){
				if (typeof format.toValue === 'function' && typeof format.toDisplay === 'function')
	                return format;
	            // IE treats \0 as a string end in inputs (truncating the value),
				// so it's a bad format delimiter, anyway
				var separators = format.replace(this.validParts, '\0').split('\0'),
					parts = format.match(this.validParts);
				if (!separators || !separators.length || !parts || parts.length === 0){
					throw new Error("Invalid date format.");
				}
				return {separators: separators, parts: parts};
			},
			parseDate: function(date, format, language, assumeNearby){
				if (!date)
					return undefined;
				if (date instanceof Date)
					return date;
				if (typeof format === 'string')
					format = DPGlobal.parseFormat(format);
				if (format.toValue)
	                return format.toValue(date, format, language);
	            var part_re = /([\-+]\d+)([dmwy])/,
					parts = date.match(/([\-+]\d+)([dmwy])/g),
					fn_map = {
						d: 'moveDay',
						m: 'moveMonth',
						w: 'moveWeek',
						y: 'moveYear'
					},
					dateAliases = {
						yesterday: '-1d',
						today: '+0d',
						tomorrow: '+1d'
					},
					part, dir, i, fn;
				if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/.test(date)){
					date = new Date();
					for (i=0; i < parts.length; i++){
						part = part_re.exec(parts[i]);
						dir = parseInt(part[1]);
						fn = fn_map[part[2]];
						date = Datepicker.prototype[fn](date, dir);
					}
					return UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
				}

				if (typeof dateAliases[date] !== 'undefined') {
					date = dateAliases[date];
					parts = date.match(/([\-+]\d+)([dmwy])/g);

					if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/.test(date)){
						date = new Date();
					  	for (i=0; i < parts.length; i++){
							part = part_re.exec(parts[i]);
							dir = parseInt(part[1]);
							fn = fn_map[part[2]];
							date = Datepicker.prototype[fn](date, dir);
					  	}

				  		return UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
					}
				}

				parts = date && date.match(this.nonpunctuation) || [];
				date = new Date();

				function applyNearbyYear(year, threshold){
					if (threshold === true)
						threshold = 10;

					// if year is 2 digits or less, than the user most likely is trying to get a recent century
					if (year < 100){
						year += 2000;
						// if the new year is more than threshold years in advance, use last century
						if (year > ((new Date()).getFullYear()+threshold)){
							year -= 100;
						}
					}

					return year;
				}

				var parsed = {},
					setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
					setters_map = {
						yyyy: function(d,v){
							return d.setUTCFullYear(assumeNearby ? applyNearbyYear(v, assumeNearby) : v);
						},
						yy: function(d,v){
							return d.setUTCFullYear(assumeNearby ? applyNearbyYear(v, assumeNearby) : v);
						},
						m: function(d,v){
							if (isNaN(d))
								return d;
							v -= 1;
							while (v < 0) v += 12;
							v %= 12;
							d.setUTCMonth(v);
							while (d.getUTCMonth() !== v)
								d.setUTCDate(d.getUTCDate()-1);
							return d;
						},
						d: function(d,v){
							return d.setUTCDate(v);
						}
					},
					val, filtered;
				setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
				setters_map['dd'] = setters_map['d'];
				date = UTCToday();
				var fparts = format.parts.slice();
				// Remove noop parts
				if (parts.length !== fparts.length){
					fparts = $(fparts).filter(function(i,p){
						return $.inArray(p, setters_order) !== -1;
					}).toArray();
				}
				// Process remainder
				function match_part(){
					var m = this.slice(0, parts[i].length),
						p = parts[i].slice(0, m.length);
					return m.toLowerCase() === p.toLowerCase();
				}
				if (parts.length === fparts.length){
					var cnt;
					for (i=0, cnt = fparts.length; i < cnt; i++){
						val = parseInt(parts[i], 10);
						part = fparts[i];
						if (isNaN(val)){
							switch (part){
								case 'MM':
									filtered = $(dates[language].months).filter(match_part);
									val = $.inArray(filtered[0], dates[language].months) + 1;
									break;
								case 'M':
									filtered = $(dates[language].monthsShort).filter(match_part);
									val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
									break;
							}
						}
						parsed[part] = val;
					}
					var _date, s;
					for (i=0; i < setters_order.length; i++){
						s = setters_order[i];
						if (s in parsed && !isNaN(parsed[s])){
							_date = new Date(date);
							setters_map[s](_date, parsed[s]);
							if (!isNaN(_date))
								date = _date;
						}
					}
				}
				return date;
			},
			formatDate: function(date, format, language){
				if (!date)
					return '';
				if (typeof format === 'string')
					format = DPGlobal.parseFormat(format);
				if (format.toDisplay)
	                return format.toDisplay(date, format, language);
	            var val = {
					d: date.getUTCDate(),
					D: dates[language].daysShort[date.getUTCDay()],
					DD: dates[language].days[date.getUTCDay()],
					m: date.getUTCMonth() + 1,
					M: dates[language].monthsShort[date.getUTCMonth()],
					MM: dates[language].months[date.getUTCMonth()],
					yy: date.getUTCFullYear().toString().substring(2),
					yyyy: date.getUTCFullYear()
				};
				val.dd = (val.d < 10 ? '0' : '') + val.d;
				val.mm = (val.m < 10 ? '0' : '') + val.m;
				date = [];
				var seps = $.extend([], format.separators);
				for (var i=0, cnt = format.parts.length; i <= cnt; i++){
					if (seps.length)
						date.push(seps.shift());
					date.push(val[format.parts[i]]);
				}
				return date.join('');
			},
			headTemplate: '<thead>'+
				              '<tr>'+
				                '<th colspan="7" class="datepicker-title"></th>'+
				              '</tr>'+
								'<tr>'+
									'<th class="prev">&laquo;</th>'+
									'<th colspan="5" class="datepicker-switch"></th>'+
									'<th class="next">&raquo;</th>'+
								'</tr>'+
							'</thead>',
			contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
			footTemplate: '<tfoot>'+
								'<tr>'+
									'<th colspan="7" class="today"></th>'+
								'</tr>'+
								'<tr>'+
									'<th colspan="7" class="clear"></th>'+
								'</tr>'+
							'</tfoot>'
		};
		DPGlobal.template = '<div class="datepicker">'+
								'<div class="datepicker-days">'+
									'<table class=" table-condensed">'+
										DPGlobal.headTemplate+
										'<tbody></tbody>'+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
								'<div class="datepicker-months">'+
									'<table class="table-condensed">'+
										DPGlobal.headTemplate+
										DPGlobal.contTemplate+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
								'<div class="datepicker-years">'+
									'<table class="table-condensed">'+
										DPGlobal.headTemplate+
										DPGlobal.contTemplate+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
								'<div class="datepicker-decades">'+
									'<table class="table-condensed">'+
										DPGlobal.headTemplate+
										DPGlobal.contTemplate+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
								'<div class="datepicker-centuries">'+
									'<table class="table-condensed">'+
										DPGlobal.headTemplate+
										DPGlobal.contTemplate+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
							'</div>';

		$.fn.datepicker.DPGlobal = DPGlobal;


		/* DATEPICKER NO CONFLICT
		* =================== */

		$.fn.datepicker.noConflict = function(){
			$.fn.datepicker = old;
			return this;
		};

		/* DATEPICKER VERSION
		 * =================== */
		$.fn.datepicker.version = '1.7.0-dev';

		/* DATEPICKER DATA-API
		* ================== */

		$(document).on(
			'focus.datepicker.data-api click.datepicker.data-api',
			'[data-provide="datepicker"]',
			function(e){
				var $this = $(this);
				if ($this.data('datepicker'))
					return;
				e.preventDefault();
				// component click requires us to explicitly show it
				datepickerPlugin.call($this, 'show');
			}
		);
		$(function(){
			datepickerPlugin.call($('[data-provide="datepicker-inline"]'));
		});

	}));




/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var jQuery = __webpack_require__(2);

	/*** IMPORTS FROM imports-loader ***/
	var jQuery = __webpack_require__(2);

	/*!
	 * Timepicker Component for Twitter Bootstrap
	 *
	 * Copyright 2013 Joris de Wit and bootstrap-timepicker contributors
	 *
	 * Contributors https://github.com/jdewit/bootstrap-timepicker/graphs/contributors
	 *
	 * For the full copyright and license information, please view the LICENSE
	 * file that was distributed with this source code.
	 */
	(function($, window, document) {
	  'use strict';

	  // TIMEPICKER PUBLIC CLASS DEFINITION
	  var Timepicker = function(element, options) {
	    this.widget = '';
	    this.$element = $(element);
	    this.defaultTime = options.defaultTime;
	    this.disableFocus = options.disableFocus;
	    this.disableMousewheel = options.disableMousewheel;
	    this.isOpen = options.isOpen;
	    this.minuteStep = options.minuteStep;
	    this.modalBackdrop = options.modalBackdrop;
	    this.orientation = options.orientation;
	    this.secondStep = options.secondStep;
	    this.snapToStep = options.snapToStep;
	    this.showInputs = options.showInputs;
	    this.showMeridian = options.showMeridian;
	    this.showSeconds = options.showSeconds;
	    this.template = options.template;
	    this.appendWidgetTo = options.appendWidgetTo;
	    this.showWidgetOnAddonClick = options.showWidgetOnAddonClick;
	    this.icons = options.icons;
	    this.maxHours = options.maxHours;
	    this.explicitMode = options.explicitMode; // If true 123 = 1:23, 12345 = 1:23:45, else invalid.

	    this.handleDocumentClick = function (e) {
	      var self = e.data.scope;
	      // This condition was inspired by bootstrap-datepicker.
	      // The element the timepicker is invoked on is the input but it has a sibling for addon/button.
	      if (!(self.$element.parent().find(e.target).length ||
	          self.$widget.is(e.target) ||
	          self.$widget.find(e.target).length)) {
	        self.hideWidget();
	      }
	    };

	    this._init();
	  };

	  Timepicker.prototype = {

	    constructor: Timepicker,
	    _init: function() {
	      var self = this;

	      if (this.showWidgetOnAddonClick && (this.$element.parent().hasClass('input-group') && this.$element.parent().hasClass('bootstrap-timepicker'))) {
	        this.$element.parent('.input-group.bootstrap-timepicker').find('.input-group-addon').on({
	          'click.timepicker': $.proxy(this.showWidget, this)
	        });
	        this.$element.on({
	          'focus.timepicker': $.proxy(this.highlightUnit, this),
	          'click.timepicker': $.proxy(this.highlightUnit, this),
	          'keydown.timepicker': $.proxy(this.elementKeydown, this),
	          'blur.timepicker': $.proxy(this.blurElement, this),
	          'mousewheel.timepicker DOMMouseScroll.timepicker': $.proxy(this.mousewheel, this)
	        });
	      } else {
	        if (this.template) {
	          this.$element.on({
	            'focus.timepicker': $.proxy(this.showWidget, this),
	            'click.timepicker': $.proxy(this.showWidget, this),
	            'blur.timepicker': $.proxy(this.blurElement, this),
	            'mousewheel.timepicker DOMMouseScroll.timepicker': $.proxy(this.mousewheel, this)
	          });
	        } else {
	          this.$element.on({
	            'focus.timepicker': $.proxy(this.highlightUnit, this),
	            'click.timepicker': $.proxy(this.highlightUnit, this),
	            'keydown.timepicker': $.proxy(this.elementKeydown, this),
	            'blur.timepicker': $.proxy(this.blurElement, this),
	            'mousewheel.timepicker DOMMouseScroll.timepicker': $.proxy(this.mousewheel, this)
	          });
	        }
	      }

	      if (this.template !== false) {
	        this.$widget = $(this.getTemplate()).on('click', $.proxy(this.widgetClick, this));
	      } else {
	        this.$widget = false;
	      }

	      if (this.showInputs && this.$widget !== false) {
	        this.$widget.find('input').each(function() {
	          $(this).on({
	            'click.timepicker': function() { $(this).select(); },
	            'keydown.timepicker': $.proxy(self.widgetKeydown, self),
	            'keyup.timepicker': $.proxy(self.widgetKeyup, self)
	          });
	        });
	      }

	      this.setDefaultTime(this.defaultTime);
	    },

	    blurElement: function() {
	      this.highlightedUnit = null;
	      this.updateFromElementVal();
	    },

	    clear: function() {
	      this.hour = '';
	      this.minute = '';
	      this.second = '';
	      this.meridian = '';

	      this.$element.val('');
	    },

	    decrementHour: function() {
	      if (this.showMeridian) {
	        if (this.hour === 1) {
	          this.hour = 12;
	        } else if (this.hour === 12) {
	          this.hour--;

	          return this.toggleMeridian();
	        } else if (this.hour === 0) {
	          this.hour = 11;

	          return this.toggleMeridian();
	        } else {
	          this.hour--;
	        }
	      } else {
	        if (this.hour <= 0) {
	          this.hour = this.maxHours - 1;
	        } else {
	          this.hour--;
	        }
	      }
	    },

	    decrementMinute: function(step) {
	      var newVal;

	      if (step) {
	        newVal = this.minute - step;
	      } else {
	        newVal = this.minute - this.minuteStep;
	      }

	      if (newVal < 0) {
	        this.decrementHour();
	        this.minute = newVal + 60;
	      } else {
	        this.minute = newVal;
	      }
	    },

	    decrementSecond: function() {
	      var newVal = this.second - this.secondStep;

	      if (newVal < 0) {
	        this.decrementMinute(true);
	        this.second = newVal + 60;
	      } else {
	        this.second = newVal;
	      }
	    },

	    elementKeydown: function(e) {
	      switch (e.which) {
	      case 9: //tab
	        if (e.shiftKey) {
	          if (this.highlightedUnit === 'hour') {
	            this.hideWidget();
	            break;
	          }
	          this.highlightPrevUnit();
	        } else if ((this.showMeridian && this.highlightedUnit === 'meridian') || (this.showSeconds && this.highlightedUnit === 'second') || (!this.showMeridian && !this.showSeconds && this.highlightedUnit ==='minute')) {
	          this.hideWidget();
	          break;
	        } else {
	          this.highlightNextUnit();
	        }
	        e.preventDefault();
	        this.updateFromElementVal();
	        break;
	      case 27: // escape
	        this.updateFromElementVal();
	        break;
	      case 37: // left arrow
	        e.preventDefault();
	        this.highlightPrevUnit();
	        this.updateFromElementVal();
	        break;
	      case 38: // up arrow
	        e.preventDefault();
	        switch (this.highlightedUnit) {
	        case 'hour':
	          this.incrementHour();
	          this.highlightHour();
	          break;
	        case 'minute':
	          this.incrementMinute();
	          this.highlightMinute();
	          break;
	        case 'second':
	          this.incrementSecond();
	          this.highlightSecond();
	          break;
	        case 'meridian':
	          this.toggleMeridian();
	          this.highlightMeridian();
	          break;
	        }
	        this.update();
	        break;
	      case 39: // right arrow
	        e.preventDefault();
	        this.highlightNextUnit();
	        this.updateFromElementVal();
	        break;
	      case 40: // down arrow
	        e.preventDefault();
	        switch (this.highlightedUnit) {
	        case 'hour':
	          this.decrementHour();
	          this.highlightHour();
	          break;
	        case 'minute':
	          this.decrementMinute();
	          this.highlightMinute();
	          break;
	        case 'second':
	          this.decrementSecond();
	          this.highlightSecond();
	          break;
	        case 'meridian':
	          this.toggleMeridian();
	          this.highlightMeridian();
	          break;
	        }

	        this.update();
	        break;
	      }
	    },

	    getCursorPosition: function() {
	      var input = this.$element.get(0);

	      if ('selectionStart' in input) {// Standard-compliant browsers

	        return input.selectionStart;
	      } else if (document.selection) {// IE fix
	        input.focus();
	        var sel = document.selection.createRange(),
	          selLen = document.selection.createRange().text.length;

	        sel.moveStart('character', - input.value.length);

	        return sel.text.length - selLen;
	      }
	    },

	    getTemplate: function() {
	      var template,
	        hourTemplate,
	        minuteTemplate,
	        secondTemplate,
	        meridianTemplate,
	        templateContent;

	      if (this.showInputs) {
	        hourTemplate = '<input type="text" class="bootstrap-timepicker-hour" maxlength="2"/>';
	        minuteTemplate = '<input type="text" class="bootstrap-timepicker-minute" maxlength="2"/>';
	        secondTemplate = '<input type="text" class="bootstrap-timepicker-second" maxlength="2"/>';
	        meridianTemplate = '<input type="text" class="bootstrap-timepicker-meridian" maxlength="2"/>';
	      } else {
	        hourTemplate = '<span class="bootstrap-timepicker-hour"></span>';
	        minuteTemplate = '<span class="bootstrap-timepicker-minute"></span>';
	        secondTemplate = '<span class="bootstrap-timepicker-second"></span>';
	        meridianTemplate = '<span class="bootstrap-timepicker-meridian"></span>';
	      }

	      templateContent = '<table>'+
	         '<tr>'+
	           '<td><a href="#" data-action="incrementHour"><span class="'+ this.icons.up +'"></span></a></td>'+
	           '<td class="separator">&nbsp;</td>'+
	           '<td><a href="#" data-action="incrementMinute"><span class="'+ this.icons.up +'"></span></a></td>'+
	           (this.showSeconds ?
	             '<td class="separator">&nbsp;</td>'+
	             '<td><a href="#" data-action="incrementSecond"><span class="'+ this.icons.up +'"></span></a></td>'
	           : '') +
	           (this.showMeridian ?
	             '<td class="separator">&nbsp;</td>'+
	             '<td class="meridian-column"><a href="#" data-action="toggleMeridian"><span class="'+ this.icons.up +'"></span></a></td>'
	           : '') +
	         '</tr>'+
	         '<tr>'+
	           '<td>'+ hourTemplate +'</td> '+
	           '<td class="separator">:</td>'+
	           '<td>'+ minuteTemplate +'</td> '+
	           (this.showSeconds ?
	            '<td class="separator">:</td>'+
	            '<td>'+ secondTemplate +'</td>'
	           : '') +
	           (this.showMeridian ?
	            '<td class="separator">&nbsp;</td>'+
	            '<td>'+ meridianTemplate +'</td>'
	           : '') +
	         '</tr>'+
	         '<tr>'+
	           '<td><a href="#" data-action="decrementHour"><span class="'+ this.icons.down +'"></span></a></td>'+
	           '<td class="separator"></td>'+
	           '<td><a href="#" data-action="decrementMinute"><span class="'+ this.icons.down +'"></span></a></td>'+
	           (this.showSeconds ?
	            '<td class="separator">&nbsp;</td>'+
	            '<td><a href="#" data-action="decrementSecond"><span class="'+ this.icons.down +'"></span></a></td>'
	           : '') +
	           (this.showMeridian ?
	            '<td class="separator">&nbsp;</td>'+
	            '<td><a href="#" data-action="toggleMeridian"><span class="'+ this.icons.down +'"></span></a></td>'
	           : '') +
	         '</tr>'+
	       '</table>';

	      switch(this.template) {
	      case 'modal':
	        template = '<div class="bootstrap-timepicker-widget modal hide fade in" data-backdrop="'+ (this.modalBackdrop ? 'true' : 'false') +'">'+
	          '<div class="modal-header">'+
	            '<a href="#" class="close" data-dismiss="modal">&times;</a>'+
	            '<h3>Pick a Time</h3>'+
	          '</div>'+
	          '<div class="modal-content">'+
	            templateContent +
	          '</div>'+
	          '<div class="modal-footer">'+
	            '<a href="#" class="btn btn-primary" data-dismiss="modal">OK</a>'+
	          '</div>'+
	        '</div>';
	        break;
	      case 'dropdown':
	        template = '<div class="bootstrap-timepicker-widget dropdown-menu">'+ templateContent +'</div>';
	        break;
	      }

	      return template;
	    },

	    getTime: function() {
	      if (this.hour === '') {
	        return '';
	      }

	      return this.hour + ':' + (this.minute.toString().length === 1 ? '0' + this.minute : this.minute) + (this.showSeconds ? ':' + (this.second.toString().length === 1 ? '0' + this.second : this.second) : '') + (this.showMeridian ? ' ' + this.meridian : '');
	    },

	    hideWidget: function() {
	      if (this.isOpen === false) {
	        return;
	      }

	      this.$element.trigger({
	        'type': 'hide.timepicker',
	        'time': {
	          'value': this.getTime(),
	          'hours': this.hour,
	          'minutes': this.minute,
	          'seconds': this.second,
	          'meridian': this.meridian
	        }
	      });

	      if (this.template === 'modal' && this.$widget.modal) {
	        this.$widget.modal('hide');
	      } else {
	        this.$widget.removeClass('open');
	      }

	      $(document).off('mousedown.timepicker, touchend.timepicker', this.handleDocumentClick);

	      this.isOpen = false;
	      // show/hide approach taken by datepicker
	      this.$widget.detach();
	    },

	    highlightUnit: function() {
	      this.position = this.getCursorPosition();
	      if (this.position >= 0 && this.position <= 2) {
	        this.highlightHour();
	      } else if (this.position >= 3 && this.position <= 5) {
	        this.highlightMinute();
	      } else if (this.position >= 6 && this.position <= 8) {
	        if (this.showSeconds) {
	          this.highlightSecond();
	        } else {
	          this.highlightMeridian();
	        }
	      } else if (this.position >= 9 && this.position <= 11) {
	        this.highlightMeridian();
	      }
	    },

	    highlightNextUnit: function() {
	      switch (this.highlightedUnit) {
	      case 'hour':
	        this.highlightMinute();
	        break;
	      case 'minute':
	        if (this.showSeconds) {
	          this.highlightSecond();
	        } else if (this.showMeridian){
	          this.highlightMeridian();
	        } else {
	          this.highlightHour();
	        }
	        break;
	      case 'second':
	        if (this.showMeridian) {
	          this.highlightMeridian();
	        } else {
	          this.highlightHour();
	        }
	        break;
	      case 'meridian':
	        this.highlightHour();
	        break;
	      }
	    },

	    highlightPrevUnit: function() {
	      switch (this.highlightedUnit) {
	      case 'hour':
	        if(this.showMeridian){
	          this.highlightMeridian();
	        } else if (this.showSeconds) {
	          this.highlightSecond();
	        } else {
	          this.highlightMinute();
	        }
	        break;
	      case 'minute':
	        this.highlightHour();
	        break;
	      case 'second':
	        this.highlightMinute();
	        break;
	      case 'meridian':
	        if (this.showSeconds) {
	          this.highlightSecond();
	        } else {
	          this.highlightMinute();
	        }
	        break;
	      }
	    },

	    highlightHour: function() {
	      var $element = this.$element.get(0),
	          self = this;

	      this.highlightedUnit = 'hour';

	      if ($element.setSelectionRange) {
	        setTimeout(function() {
	          if (self.hour < 10) {
	            $element.setSelectionRange(0,1);
	          } else {
	            $element.setSelectionRange(0,2);
	          }
	        }, 0);
	      }
	    },

	    highlightMinute: function() {
	      var $element = this.$element.get(0),
	          self = this;

	      this.highlightedUnit = 'minute';

	      if ($element.setSelectionRange) {
	        setTimeout(function() {
	          if (self.hour < 10) {
	            $element.setSelectionRange(2,4);
	          } else {
	            $element.setSelectionRange(3,5);
	          }
	        }, 0);
	      }
	    },

	    highlightSecond: function() {
	      var $element = this.$element.get(0),
	          self = this;

	      this.highlightedUnit = 'second';

	      if ($element.setSelectionRange) {
	        setTimeout(function() {
	          if (self.hour < 10) {
	            $element.setSelectionRange(5,7);
	          } else {
	            $element.setSelectionRange(6,8);
	          }
	        }, 0);
	      }
	    },

	    highlightMeridian: function() {
	      var $element = this.$element.get(0),
	          self = this;

	      this.highlightedUnit = 'meridian';

	      if ($element.setSelectionRange) {
	        if (this.showSeconds) {
	          setTimeout(function() {
	            if (self.hour < 10) {
	              $element.setSelectionRange(8,10);
	            } else {
	              $element.setSelectionRange(9,11);
	            }
	          }, 0);
	        } else {
	          setTimeout(function() {
	            if (self.hour < 10) {
	              $element.setSelectionRange(5,7);
	            } else {
	              $element.setSelectionRange(6,8);
	            }
	          }, 0);
	        }
	      }
	    },

	    incrementHour: function() {
	      if (this.showMeridian) {
	        if (this.hour === 11) {
	          this.hour++;
	          return this.toggleMeridian();
	        } else if (this.hour === 12) {
	          this.hour = 0;
	        }
	      }
	      if (this.hour === this.maxHours - 1) {
	        this.hour = 0;

	        return;
	      }
	      this.hour++;
	    },

	    incrementMinute: function(step) {
	      var newVal;

	      if (step) {
	        newVal = this.minute + step;
	      } else {
	        newVal = this.minute + this.minuteStep - (this.minute % this.minuteStep);
	      }

	      if (newVal > 59) {
	        this.incrementHour();
	        this.minute = newVal - 60;
	      } else {
	        this.minute = newVal;
	      }
	    },

	    incrementSecond: function() {
	      var newVal = this.second + this.secondStep - (this.second % this.secondStep);

	      if (newVal > 59) {
	        this.incrementMinute(true);
	        this.second = newVal - 60;
	      } else {
	        this.second = newVal;
	      }
	    },

	    mousewheel: function(e) {
	      if (this.disableMousewheel) {
	        return;
	      }

	      e.preventDefault();
	      e.stopPropagation();

	      var delta = e.originalEvent.wheelDelta || -e.originalEvent.detail,
	          scrollTo = null;

	      if (e.type === 'mousewheel') {
	        scrollTo = (e.originalEvent.wheelDelta * -1);
	      }
	      else if (e.type === 'DOMMouseScroll') {
	        scrollTo = 40 * e.originalEvent.detail;
	      }

	      if (scrollTo) {
	        e.preventDefault();
	        $(this).scrollTop(scrollTo + $(this).scrollTop());
	      }

	      switch (this.highlightedUnit) {
	      case 'minute':
	        if (delta > 0) {
	          this.incrementMinute();
	        } else {
	          this.decrementMinute();
	        }
	        this.highlightMinute();
	        break;
	      case 'second':
	        if (delta > 0) {
	          this.incrementSecond();
	        } else {
	          this.decrementSecond();
	        }
	        this.highlightSecond();
	        break;
	      case 'meridian':
	        this.toggleMeridian();
	        this.highlightMeridian();
	        break;
	      default:
	        if (delta > 0) {
	          this.incrementHour();
	        } else {
	          this.decrementHour();
	        }
	        this.highlightHour();
	        break;
	      }

	      return false;
	    },

	    /**
	     * Given a segment value like 43, will round and snap the segment
	     * to the nearest "step", like 45 if step is 15. Segment will
	     * "overflow" to 0 if it's larger than 59 or would otherwise
	     * round up to 60.
	     */
	    changeToNearestStep: function (segment, step) {
	      if (segment % step === 0) {
	        return segment;
	      }
	      if (Math.round((segment % step) / step)) {
	        return (segment + (step - segment % step)) % 60;
	      } else {
	        return segment - segment % step;
	      }
	    },

	    // This method was adapted from bootstrap-datepicker.
	    place : function() {
	      if (this.isInline) {
	        return;
	      }
	      var widgetWidth = this.$widget.outerWidth(), widgetHeight = this.$widget.outerHeight(), visualPadding = 10, windowWidth =
	        $(window).width(), windowHeight = $(window).height(), scrollTop = $(window).scrollTop();

	      var zIndex = parseInt(this.$element.parents().filter(function() { return $(this).css('z-index') !== 'auto'; }).first().css('z-index'), 10) + 10;
	      var offset = this.component ? this.component.parent().offset() : this.$element.offset();
	      var height = this.component ? this.component.outerHeight(true) : this.$element.outerHeight(false);
	      var width = this.component ? this.component.outerWidth(true) : this.$element.outerWidth(false);
	      var left = offset.left, top = offset.top;

	      this.$widget.removeClass('timepicker-orient-top timepicker-orient-bottom timepicker-orient-right timepicker-orient-left');

	      if (this.orientation.x !== 'auto') {
	        this.$widget.addClass('timepicker-orient-' + this.orientation.x);
	        if (this.orientation.x === 'right') {
	          left -= widgetWidth - width;
	        }
	      } else{
	        // auto x orientation is best-placement: if it crosses a window edge, fudge it sideways
	        // Default to left
	        this.$widget.addClass('timepicker-orient-left');
	        if (offset.left < 0) {
	          left -= offset.left - visualPadding;
	        } else if (offset.left + widgetWidth > windowWidth) {
	          left = windowWidth - widgetWidth - visualPadding;
	        }
	      }
	      // auto y orientation is best-situation: top or bottom, no fudging, decision based on which shows more of the widget
	      var yorient = this.orientation.y, topOverflow, bottomOverflow;
	      if (yorient === 'auto') {
	        topOverflow = -scrollTop + offset.top - widgetHeight;
	        bottomOverflow = scrollTop + windowHeight - (offset.top + height + widgetHeight);
	        if (Math.max(topOverflow, bottomOverflow) === bottomOverflow) {
	          yorient = 'top';
	        } else {
	          yorient = 'bottom';
	        }
	      }
	      this.$widget.addClass('timepicker-orient-' + yorient);
	      if (yorient === 'top'){
	        top += height;
	      } else{
	        top -= widgetHeight + parseInt(this.$widget.css('padding-top'), 10);
	      }

	      this.$widget.css({
	        top : top,
	        left : left,
	        zIndex : zIndex
	      });
	    },

	    remove: function() {
	      $('document').off('.timepicker');
	      if (this.$widget) {
	        this.$widget.remove();
	      }
	      delete this.$element.data().timepicker;
	    },

	    setDefaultTime: function(defaultTime) {
	      if (!this.$element.val()) {
	        if (defaultTime === 'current') {
	          var dTime = new Date(),
	            hours = dTime.getHours(),
	            minutes = dTime.getMinutes(),
	            seconds = dTime.getSeconds(),
	            meridian = 'AM';

	          if (seconds !== 0) {
	            seconds = Math.ceil(dTime.getSeconds() / this.secondStep) * this.secondStep;
	            if (seconds === 60) {
	              minutes += 1;
	              seconds = 0;
	            }
	          }

	          if (minutes !== 0) {
	            minutes = Math.ceil(dTime.getMinutes() / this.minuteStep) * this.minuteStep;
	            if (minutes === 60) {
	              hours += 1;
	              minutes = 0;
	            }
	          }

	          if (this.showMeridian) {
	            if (hours === 0) {
	              hours = 12;
	            } else if (hours >= 12) {
	              if (hours > 12) {
	                hours = hours - 12;
	              }
	              meridian = 'PM';
	            } else {
	              meridian = 'AM';
	            }
	          }

	          this.hour = hours;
	          this.minute = minutes;
	          this.second = seconds;
	          this.meridian = meridian;

	          this.update();

	        } else if (defaultTime === false) {
	          this.hour = 0;
	          this.minute = 0;
	          this.second = 0;
	          this.meridian = 'AM';
	        } else {
	          this.setTime(defaultTime);
	        }
	      } else {
	        this.updateFromElementVal();
	      }
	    },

	    setTime: function(time, ignoreWidget) {
	      if (!time) {
	        this.clear();
	        return;
	      }

	      var timeMode,
	          timeArray,
	          hour,
	          minute,
	          second,
	          meridian;

	      if (typeof time === 'object' && time.getMonth){
	        // this is a date object
	        hour    = time.getHours();
	        minute  = time.getMinutes();
	        second  = time.getSeconds();

	        if (this.showMeridian){
	          meridian = 'AM';
	          if (hour > 12){
	            meridian = 'PM';
	            hour = hour % 12;
	          }

	          if (hour === 12){
	            meridian = 'PM';
	          }
	        }
	      } else {
	        timeMode = ((/a/i).test(time) ? 1 : 0) + ((/p/i).test(time) ? 2 : 0); // 0 = none, 1 = AM, 2 = PM, 3 = BOTH.
	        if (timeMode > 2) { // If both are present, fail.
	          this.clear();
	          return;
	        }

	        timeArray = time.replace(/[^0-9\:]/g, '').split(':');

	        hour = timeArray[0] ? timeArray[0].toString() : timeArray.toString();

	        if(this.explicitMode && hour.length > 2 && (hour.length % 2) !== 0 ) {
	          this.clear();
	          return;
	        }

	        minute = timeArray[1] ? timeArray[1].toString() : '';
	        second = timeArray[2] ? timeArray[2].toString() : '';

	        // adaptive time parsing
	        if (hour.length > 4) {
	          second = hour.slice(-2);
	          hour = hour.slice(0, -2);
	        }

	        if (hour.length > 2) {
	          minute = hour.slice(-2);
	          hour = hour.slice(0, -2);
	        }

	        if (minute.length > 2) {
	          second = minute.slice(-2);
	          minute = minute.slice(0, -2);
	        }

	        hour = parseInt(hour, 10);
	        minute = parseInt(minute, 10);
	        second = parseInt(second, 10);

	        if (isNaN(hour)) {
	          hour = 0;
	        }
	        if (isNaN(minute)) {
	          minute = 0;
	        }
	        if (isNaN(second)) {
	          second = 0;
	        }

	        // Adjust the time based upon unit boundary.
	        // NOTE: Negatives will never occur due to time.replace() above.
	        if (second > 59) {
	          second = 59;
	        }

	        if (minute > 59) {
	          minute = 59;
	        }

	        if (hour >= this.maxHours) {
	          // No day/date handling.
	          hour = this.maxHours - 1;
	        }

	        if (this.showMeridian) {
	          if (hour > 12) {
	            // Force PM.
	            timeMode = 2;
	            hour -= 12;
	          }
	          if (!timeMode) {
	            timeMode = 1;
	          }
	          if (hour === 0) {
	            hour = 12; // AM or PM, reset to 12.  0 AM = 12 AM.  0 PM = 12 PM, etc.
	          }
	          meridian = timeMode === 1 ? 'AM' : 'PM';
	        } else if (hour < 12 && timeMode === 2) {
	          hour += 12;
	        } else {
	          if (hour >= this.maxHours) {
	            hour = this.maxHours - 1;
	          } else if ((hour < 0) || (hour === 12 && timeMode === 1)){
	            hour = 0;
	          }
	        }
	      }

	      this.hour = hour;
	      if (this.snapToStep) {
	        this.minute = this.changeToNearestStep(minute, this.minuteStep);
	        this.second = this.changeToNearestStep(second, this.secondStep);
	      } else {
	        this.minute = minute;
	        this.second = second;
	      }
	      this.meridian = meridian;

	      this.update(ignoreWidget);
	    },

	    showWidget: function() {
	      if (this.isOpen) {
	        return;
	      }

	      if (this.$element.is(':disabled')) {
	        return;
	      }

	      // show/hide approach taken by datepicker
	      this.$widget.appendTo(this.appendWidgetTo);
	      $(document).on('mousedown.timepicker, touchend.timepicker', {scope: this}, this.handleDocumentClick);

	      this.$element.trigger({
	        'type': 'show.timepicker',
	        'time': {
	          'value': this.getTime(),
	          'hours': this.hour,
	          'minutes': this.minute,
	          'seconds': this.second,
	          'meridian': this.meridian
	        }
	      });

	      this.place();
	      if (this.disableFocus) {
	        this.$element.blur();
	      }

	      // widget shouldn't be empty on open
	      if (this.hour === '') {
	        if (this.defaultTime) {
	          this.setDefaultTime(this.defaultTime);
	        } else {
	          this.setTime('0:0:0');
	        }
	      }

	      if (this.template === 'modal' && this.$widget.modal) {
	        this.$widget.modal('show').on('hidden', $.proxy(this.hideWidget, this));
	      } else {
	        if (this.isOpen === false) {
	          this.$widget.addClass('open');
	        }
	      }

	      this.isOpen = true;
	    },

	    toggleMeridian: function() {
	      this.meridian = this.meridian === 'AM' ? 'PM' : 'AM';
	    },

	    update: function(ignoreWidget) {
	      this.updateElement();
	      if (!ignoreWidget) {
	        this.updateWidget();
	      }

	      this.$element.trigger({
	        'type': 'changeTime.timepicker',
	        'time': {
	          'value': this.getTime(),
	          'hours': this.hour,
	          'minutes': this.minute,
	          'seconds': this.second,
	          'meridian': this.meridian
	        }
	      });
	    },

	    updateElement: function() {
	      this.$element.val(this.getTime()).change();
	    },

	    updateFromElementVal: function() {
	      this.setTime(this.$element.val());
	    },

	    updateWidget: function() {
	      if (this.$widget === false) {
	        return;
	      }

	      var hour = this.hour,
	          minute = this.minute.toString().length === 1 ? '0' + this.minute : this.minute,
	          second = this.second.toString().length === 1 ? '0' + this.second : this.second;

	      if (this.showInputs) {
	        this.$widget.find('input.bootstrap-timepicker-hour').val(hour);
	        this.$widget.find('input.bootstrap-timepicker-minute').val(minute);

	        if (this.showSeconds) {
	          this.$widget.find('input.bootstrap-timepicker-second').val(second);
	        }
	        if (this.showMeridian) {
	          this.$widget.find('input.bootstrap-timepicker-meridian').val(this.meridian);
	        }
	      } else {
	        this.$widget.find('span.bootstrap-timepicker-hour').text(hour);
	        this.$widget.find('span.bootstrap-timepicker-minute').text(minute);

	        if (this.showSeconds) {
	          this.$widget.find('span.bootstrap-timepicker-second').text(second);
	        }
	        if (this.showMeridian) {
	          this.$widget.find('span.bootstrap-timepicker-meridian').text(this.meridian);
	        }
	      }
	    },

	    updateFromWidgetInputs: function() {
	      if (this.$widget === false) {
	        return;
	      }

	      var t = this.$widget.find('input.bootstrap-timepicker-hour').val() + ':' +
	              this.$widget.find('input.bootstrap-timepicker-minute').val() +
	              (this.showSeconds ? ':' + this.$widget.find('input.bootstrap-timepicker-second').val() : '') +
	              (this.showMeridian ? this.$widget.find('input.bootstrap-timepicker-meridian').val() : '')
	      ;

	      this.setTime(t, true);
	    },

	    widgetClick: function(e) {
	      e.stopPropagation();
	      e.preventDefault();

	      var $input = $(e.target),
	          action = $input.closest('a').data('action');

	      if (action) {
	        this[action]();
	      }
	      this.update();

	      if ($input.is('input')) {
	        $input.get(0).setSelectionRange(0,2);
	      }
	    },

	    widgetKeydown: function(e) {
	      var $input = $(e.target),
	          name = $input.attr('class').replace('bootstrap-timepicker-', '');

	      switch (e.which) {
	      case 9: //tab
	        if (e.shiftKey) {
	          if (name === 'hour') {
	            return this.hideWidget();
	          }
	        } else if ((this.showMeridian && name === 'meridian') || (this.showSeconds && name === 'second') || (!this.showMeridian && !this.showSeconds && name === 'minute')) {
	          return this.hideWidget();
	        }
	        break;
	      case 27: // escape
	        this.hideWidget();
	        break;
	      case 38: // up arrow
	        e.preventDefault();
	        switch (name) {
	        case 'hour':
	          this.incrementHour();
	          break;
	        case 'minute':
	          this.incrementMinute();
	          break;
	        case 'second':
	          this.incrementSecond();
	          break;
	        case 'meridian':
	          this.toggleMeridian();
	          break;
	        }
	        this.setTime(this.getTime());
	        $input.get(0).setSelectionRange(0,2);
	        break;
	      case 40: // down arrow
	        e.preventDefault();
	        switch (name) {
	        case 'hour':
	          this.decrementHour();
	          break;
	        case 'minute':
	          this.decrementMinute();
	          break;
	        case 'second':
	          this.decrementSecond();
	          break;
	        case 'meridian':
	          this.toggleMeridian();
	          break;
	        }
	        this.setTime(this.getTime());
	        $input.get(0).setSelectionRange(0,2);
	        break;
	      }
	    },

	    widgetKeyup: function(e) {
	      if ((e.which === 65) || (e.which === 77) || (e.which === 80) || (e.which === 46) || (e.which === 8) || (e.which >= 48 && e.which <= 57) || (e.which >= 96 && e.which <= 105)) {
	        this.updateFromWidgetInputs();
	      }
	    }
	  };

	  //TIMEPICKER PLUGIN DEFINITION
	  $.fn.timepicker = function(option) {
	    var args = Array.apply(null, arguments);
	    args.shift();
	    return this.each(function() {
	      var $this = $(this),
	        data = $this.data('timepicker'),
	        options = typeof option === 'object' && option;

	      if (!data) {
	        $this.data('timepicker', (data = new Timepicker(this, $.extend({}, $.fn.timepicker.defaults, options, $(this).data()))));
	      }

	      if (typeof option === 'string') {
	        data[option].apply(data, args);
	      }
	    });
	  };

	  $.fn.timepicker.defaults = {
	    defaultTime: 'current',
	    disableFocus: false,
	    disableMousewheel: false,
	    isOpen: false,
	    minuteStep: 15,
	    modalBackdrop: false,
	    orientation: { x: 'auto', y: 'auto'},
	    secondStep: 15,
	    snapToStep: false,
	    showSeconds: false,
	    showInputs: true,
	    showMeridian: true,
	    template: 'dropdown',
	    appendWidgetTo: 'body',
	    showWidgetOnAddonClick: true,
	    icons: {
	      up: 'glyphicon glyphicon-chevron-up',
	      down: 'glyphicon glyphicon-chevron-down'
	    },
	    maxHours: 24,
	    explicitMode: false
	  };

	  $.fn.timepicker.Constructor = Timepicker;

	  $(document).on(
	    'focus.timepicker.data-api click.timepicker.data-api',
	    '[data-provide="timepicker"]',
	    function(e){
	      var $this = $(this);
	      if ($this.data('timepicker')) {
	        return;
	      }
	      e.preventDefault();
	      // component click requires us to explicitly show it
	      $this.timepicker();
	    }
	  );

	})(jQuery, window, document);




/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var jQuery = __webpack_require__(2);

	/*!
	 * Validator v0.10.1 for Bootstrap 3, by @1000hz
	 * Copyright 2016 Cina Saffary
	 * Licensed under http://opensource.org/licenses/MIT
	 *
	 * https://github.com/1000hz/bootstrap-validator
	 */

	+function ($) {
	  'use strict';

	  // VALIDATOR CLASS DEFINITION
	  // ==========================

	  function getValue($el) {
	    return $el.is('[type="checkbox"]') ? $el.prop('checked')                                     :
	           $el.is('[type="radio"]')    ? !!$('[name="' + $el.attr('name') + '"]:checked').length :
	                                         $.trim($el.val())
	  }

	  var Validator = function (element, options) {
	    this.options  = options
	    this.$element = $(element)
	    this.$inputs  = this.$element.find(Validator.INPUT_SELECTOR)
	    this.$btn     = $('button[type="submit"], input[type="submit"]')
	                      .filter('[form="' + this.$element.attr('id') + '"]')
	                      .add(this.$element.find('input[type="submit"], button[type="submit"]'))

	    options.errors = $.extend({}, Validator.DEFAULTS.errors, options.errors)

	    for (var custom in options.custom) {
	      if (!options.errors[custom]) throw new Error('Missing default error message for custom validator: ' + custom)
	    }

	    $.extend(Validator.VALIDATORS, options.custom)

	    this.$element.attr('novalidate', true) // disable automatic native validation
	    this.toggleSubmit()

	    this.$element.on('input.bs.validator change.bs.validator focusout.bs.validator', Validator.INPUT_SELECTOR, $.proxy(this.onInput, this))
	    this.$element.on('submit.bs.validator', $.proxy(this.onSubmit, this))

	    this.$element.find('[data-match]').each(function () {
	      var $this  = $(this)
	      var target = $this.data('match')

	      $(target).on('input.bs.validator', function (e) {
	        getValue($this) && $this.trigger('input.bs.validator')
	      })
	    })
	  }

	  Validator.INPUT_SELECTOR = ':input:not([type="submit"], button):enabled:visible'

	  Validator.FOCUS_OFFSET = 20

	  Validator.DEFAULTS = {
	    delay: 500,
	    html: false,
	    disable: true,
	    focus: true,
	    custom: {},
	    errors: {
	      match: 'Does not match',
	      minlength: 'Not long enough'
	    },
	    feedback: {
	      success: 'glyphicon-ok',
	      error: 'glyphicon-remove'
	    }
	  }

	  Validator.VALIDATORS = {
	    'native': function ($el) {
	      var el = $el[0]
	      return el.checkValidity ? el.checkValidity() : true
	    },
	    'match': function ($el) {
	      var target = $el.data('match')
	      return !$el.val() || $el.val() === $(target).val()
	    },
	    'minlength': function ($el) {
	      var minlength = $el.data('minlength')
	      return !$el.val() || $el.val().length >= minlength
	    }
	  }

	  Validator.prototype.onInput = function (e) {
	    var self        = this
	    var $el         = $(e.target)
	    var deferErrors = e.type !== 'focusout'
	    this.validateInput($el, deferErrors).done(function () {
	      self.toggleSubmit()
	    })
	  }

	  Validator.prototype.validateInput = function ($el, deferErrors) {
	    var value      = getValue($el)
	    var prevValue  = $el.data('bs.validator.previous')
	    var prevErrors = $el.data('bs.validator.errors')
	    var errors

	    if (prevValue === value) return $.Deferred().resolve()
	    else $el.data('bs.validator.previous', value)

	    if ($el.is('[type="radio"]')) $el = this.$element.find('input[name="' + $el.attr('name') + '"]')

	    var e = $.Event('validate.bs.validator', {relatedTarget: $el[0]})
	    this.$element.trigger(e)
	    if (e.isDefaultPrevented()) return

	    var self = this

	    return this.runValidators($el).done(function (errors) {
	      $el.data('bs.validator.errors', errors)

	      errors.length
	        ? deferErrors ? self.defer($el, self.showErrors) : self.showErrors($el)
	        : self.clearErrors($el)

	      if (!prevErrors || errors.toString() !== prevErrors.toString()) {
	        e = errors.length
	          ? $.Event('invalid.bs.validator', {relatedTarget: $el[0], detail: errors})
	          : $.Event('valid.bs.validator', {relatedTarget: $el[0], detail: prevErrors})

	        self.$element.trigger(e)
	      }

	      self.toggleSubmit()

	      self.$element.trigger($.Event('validated.bs.validator', {relatedTarget: $el[0]}))
	    })
	  }


	  Validator.prototype.runValidators = function ($el) {
	    var errors   = []
	    var deferred = $.Deferred()
	    var options  = this.options

	    $el.data('bs.validator.deferred') && $el.data('bs.validator.deferred').reject()
	    $el.data('bs.validator.deferred', deferred)

	    function getErrorMessage(key) {
	      return $el.data(key + '-error')
	        || $el.data('error')
	        || key == 'native' && $el[0].validationMessage
	        || options.errors[key]
	    }

	    $.each(Validator.VALIDATORS, $.proxy(function (key, validator) {
	      if ((getValue($el) || $el.attr('required')) &&
	          ($el.data(key) || key == 'native') &&
	          !validator.call(this, $el)) {
	        var error = getErrorMessage(key)
	        !~errors.indexOf(error) && errors.push(error)
	      }
	    }, this))

	    if (!errors.length && getValue($el) && $el.data('remote')) {
	      this.defer($el, function () {
	        var data = {}
	        data[$el.attr('name')] = getValue($el)
	        $.get($el.data('remote'), data)
	          .fail(function (jqXHR, textStatus, error) { errors.push(getErrorMessage('remote') || error) })
	          .always(function () { deferred.resolve(errors)})
	      })
	    } else deferred.resolve(errors)

	    return deferred.promise()
	  }

	  Validator.prototype.validate = function () {
	    var self = this

	    $.when(this.$inputs.map(function (el) {
	      return self.validateInput($(this), false)
	    })).then(function () {
	      self.toggleSubmit()
	      if (self.$btn.hasClass('disabled')) self.focusError()
	    })

	    return this
	  }

	  Validator.prototype.focusError = function () {
	    if (!this.options.focus) return

	    var $input = $(".has-error:first :input")

	    $(document.body).animate({scrollTop: $input.offset().top - Validator.FOCUS_OFFSET}, 250)
	    $input.focus()
	  }

	  Validator.prototype.showErrors = function ($el) {
	    var method = this.options.html ? 'html' : 'text'
	    var errors = $el.data('bs.validator.errors')
	    var $group = $el.closest('.form-group')
	    var $block = $group.find('.help-block.with-errors')
	    var $feedback = $group.find('.form-control-feedback')

	    if (!errors.length) return

	    errors = $('<ul/>')
	      .addClass('list-unstyled')
	      .append($.map(errors, function (error) { return $('<li/>')[method](error) }))

	    $block.data('bs.validator.originalContent') === undefined && $block.data('bs.validator.originalContent', $block.html())
	    $block.empty().append(errors)
	    $group.addClass('has-error has-danger')

	    $group.hasClass('has-feedback')
	      && $feedback.removeClass(this.options.feedback.success)
	      && $feedback.addClass(this.options.feedback.error)
	      && $group.removeClass('has-success')
	  }

	  Validator.prototype.clearErrors = function ($el) {
	    var $group = $el.closest('.form-group')
	    var $block = $group.find('.help-block.with-errors')
	    var $feedback = $group.find('.form-control-feedback')

	    $block.html($block.data('bs.validator.originalContent'))
	    $group.removeClass('has-error has-danger')

	    $group.hasClass('has-feedback')
	      && $feedback.removeClass(this.options.feedback.error)
	      && getValue($el)
	      && $feedback.addClass(this.options.feedback.success)
	      && $group.addClass('has-success')
	  }

	  Validator.prototype.hasErrors = function () {
	    function fieldErrors() {
	      return !!($(this).data('bs.validator.errors') || []).length
	    }

	    return !!this.$inputs.filter(fieldErrors).length
	  }

	  Validator.prototype.isIncomplete = function () {
	    function fieldIncomplete() {
	      return !getValue($(this))
	    }

	    return !!this.$inputs.filter('[required]').filter(fieldIncomplete).length
	  }

	  Validator.prototype.onSubmit = function (e) {
	    this.validate()
	    if (this.$btn.hasClass('disabled')) e.preventDefault()
	  }

	  Validator.prototype.toggleSubmit = function () {
	    if(!this.options.disable) return
	    this.$btn.toggleClass('disabled', this.isIncomplete() || this.hasErrors())
	  }

	  Validator.prototype.defer = function ($el, callback) {
	    callback = $.proxy(callback, this, $el)
	    if (!this.options.delay) return callback()
	    window.clearTimeout($el.data('bs.validator.timeout'))
	    $el.data('bs.validator.timeout', window.setTimeout(callback, this.options.delay))
	  }

	  Validator.prototype.destroy = function () {
	    this.$element
	      .removeAttr('novalidate')
	      .removeData('bs.validator')
	      .off('.bs.validator')
	      .find('.form-control-feedback')
	        .removeClass([this.options.feedback.error, this.options.feedback.success].join(' '))

	    this.$inputs
	      .off('.bs.validator')
	      .removeData(['bs.validator.errors', 'bs.validator.deferred', 'bs.validator.previous'])
	      .each(function () {
	        var $this = $(this)
	        var timeout = $this.data('bs.validator.timeout')
	        window.clearTimeout(timeout) && $this.removeData('bs.validator.timeout')
	      })

	    this.$element.find('.help-block.with-errors').each(function () {
	      var $this = $(this)
	      var originalContent = $this.data('bs.validator.originalContent')

	      $this
	        .removeData('bs.validator.originalContent')
	        .html(originalContent)
	    })

	    this.$element.find('input[type="submit"], button[type="submit"]').removeClass('disabled')

	    this.$element.find('.has-error, .has-danger').removeClass('has-error has-danger')

	    return this
	  }

	  // VALIDATOR PLUGIN DEFINITION
	  // ===========================


	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var options = $.extend({}, Validator.DEFAULTS, $this.data(), typeof option == 'object' && option)
	      var data    = $this.data('bs.validator')

	      if (!data && option == 'destroy') return
	      if (!data) $this.data('bs.validator', (data = new Validator(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.validator

	  $.fn.validator             = Plugin
	  $.fn.validator.Constructor = Validator


	  // VALIDATOR NO CONFLICT
	  // =====================

	  $.fn.validator.noConflict = function () {
	    $.fn.validator = old
	    return this
	  }


	  // VALIDATOR DATA-API
	  // ==================

	  $(window).on('load', function () {
	    $('form[data-toggle="validator"]').each(function () {
	      var $form = $(this)
	      Plugin.call($form, $form.data())
	    })
	  })

	}(jQuery);



/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, ItemView, Marionette, Pageable, View, _, itemTemplate, moment, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	_ = __webpack_require__(3);

	moment = __webpack_require__(44);

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	Pageable = __webpack_require__(59);

	itemTemplate = __webpack_require__(60);

	viewTemplate = __webpack_require__(61);

	__webpack_require__(42);

	__webpack_require__(19);

	ItemView = (function(superClass) {
	  extend(ItemView, superClass);

	  ItemView.prototype.tagName = 'tr';

	  ItemView.prototype.template = itemTemplate;

	  ItemView.prototype.bindings = {
	    '.strength-table-td-name': 'name',
	    '.strength-table-td-date': {
	      observe: 'date',
	      onGet: function(value) {
	        return moment(value).format('dddd MM/DD/YY hh:mm');
	      }
	    },
	    '.strength-table-td-muscle': 'muscle'
	  };

	  ItemView.prototype.events = {
	    click: function() {
	      this.rootChannel.request('strength:detail', this.model.id);
	    }
	  };

	  function ItemView() {
	    ItemView.__super__.constructor.apply(this, arguments);
	    this.rootChannel = Backbone.Radio.channel('root');
	  }

	  ItemView.prototype.onRender = function() {
	    this.stickit();
	  };

	  ItemView.prototype.onBeforeDestroy = function() {
	    this.unstickit();
	  };

	  return ItemView;

	})(Marionette.ItemView);

	View = (function(superClass) {
	  extend(View, superClass);

	  View.prototype.childViewContainer = 'tbody';

	  View.prototype.childView = ItemView;

	  View.prototype.template = viewTemplate;

	  View.prototype.ui = {
	    name: '#strength-name',
	    muscle: '#strength-muscle',
	    first: '#strength-table-first',
	    prev: '#strength-table-prev',
	    next: '#strength-table-next',
	    last: '#strength-table-last',
	    currentPage: '#strength-table-currentpage',
	    lastPage: '#strength-table-lastpage'
	  };

	  View.prototype.behaviors = {
	    Pageable: {
	      behaviorClass: Pageable
	    }
	  };

	  function View() {
	    View.__super__.constructor.apply(this, arguments);
	    this.rootChannel = Backbone.Radio.channel('root');
	  }

	  return View;

	})(Marionette.CompositeView);

	module.exports = View;


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var Behavior, Marionette,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Marionette = __webpack_require__(10);

	Behavior = (function(superClass) {
	  extend(Behavior, superClass);

	  function Behavior() {
	    return Behavior.__super__.constructor.apply(this, arguments);
	  }

	  Behavior.prototype.collectionEvents = {
	    'reset': function() {
	      this.setPage();
	    },
	    'sync update': function() {
	      this.view.collection.getFirstPage();
	      this.setPage();
	    }
	  };

	  Behavior.prototype.events = {
	    'click @ui.first': function() {
	      this.view.collection.getFirstPage();
	    },
	    'click @ui.prev': function() {
	      if (this.view.collection.hasPreviousPage()) {
	        this.view.collection.getPreviousPage();
	      }
	    },
	    'click @ui.next': function() {
	      if (this.view.collection.hasNextPage()) {
	        this.view.collection.getNextPage();
	      }
	    },
	    'click @ui.last': function() {
	      this.view.collection.getLastPage();
	    }
	  };

	  Behavior.prototype.onRender = function() {
	    this.view.collection.getFirstPage();
	    this.setPage();
	  };

	  Behavior.prototype.setPage = function() {
	    var state;
	    state = this.view.collection.state;
	    $(this.view.ui.currentPage).text(state.currentPage);
	    $(this.view.ui.lastPage).text(state.lastPage);
	  };

	  return Behavior;

	})(Marionette.Behavior);

	module.exports = Behavior;


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<td class=\"strength-table-td-muscle\"></td><td class=\"strength-table-td-name\"></td><td class=\"strength-table-td-date\"></td>");;return buf.join("");
	}

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-sm-12\"><span><b>CHOOSE A WORKOUT</b></span></div></div><br><div class=\"row\"><div class=\"col-sm-8\"><div class=\"btn-group\"><button id=\"strength-table-first\" class=\"btn btn-default\"><i class=\"fa fa-chevron-left\"></i><i class=\"fa fa-chevron-left\"></i></button><button id=\"strength-table-prev\" class=\"btn btn-default\"><i class=\"fa fa-chevron-left\"></i></button><button id=\"strength-table-next\" class=\"btn btn-default\"><i class=\"fa fa-chevron-right\"></i></button><button id=\"strength-table-last\" class=\"btn btn-default\"><i class=\"fa fa-chevron-right\"></i><i class=\"fa fa-chevron-right\"></i></button></div></div><div class=\"col-sm-4\"><div class=\"pull-right\"><span><b id=\"strength-table-currentpage\"></b>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "</span><span><b>/</b>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "</span><span><b id=\"strength-table-lastpage\"></b></span></div></div></div><br><div class=\"row\"><div class=\"col-sm-12\"><table class=\"table table-condensed table-hover\"><thead><tr><td><b>Muscle</b></td><td><b>Name</b></td><td><b>Date</b></td></tr></thead><tbody></tbody></table></div></div>");;return buf.join("");
	}

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-xs-12\"><button id=\"strength-back\" class=\"btn btn-default\"><i class=\"fa fa-lg fa-arrow-left\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "<i class=\"fa fa-lg fa-heartbeat\"></i></button></div></div><br><div class=\"row\"><div class=\"col-sm-12\"><span class=\"lead\"><i class=\"fa fa-fw fa-lg fa-shield\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "STRENGTH</span></div></div><br><div class=\"row\"><div class=\"col-sm-6\"><div class=\"row\"><div class=\"col-sm-12\"><div id=\"strength-input-view\"></div></div></div></div><div class=\"col-sm-6\"><div class=\"row\"><div class=\"col-sm-12\"><div id=\"strength-table-view\"></div></div></div></div></div>");;return buf.join("");
	}

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Collection, InputView, Marionette, Model, TableView, View, moment, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	moment = __webpack_require__(44);

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	InputView = __webpack_require__(64);

	TableView = __webpack_require__(68);

	viewTemplate = __webpack_require__(71);

	__webpack_require__(48);

	Model = (function(superClass) {
	  extend(Model, superClass);

	  Model.prototype.idAttribute = '_id';

	  function Model(attributes, options) {
	    Model.__super__.constructor.apply(this, arguments);
	    if (options != null ? options.id : void 0) {
	      this.url = "/api/strength/" + options.id;
	    } else {
	      this.url = '/api/strength';
	    }
	  }

	  Model.prototype.defaults = {
	    count: 1,
	    session: []
	  };

	  Model.prototype.parse = function(response) {
	    return response;
	  };

	  return Model;

	})(Backbone.Model);

	Collection = (function(superClass) {
	  extend(Collection, superClass);

	  function Collection() {
	    return Collection.__super__.constructor.apply(this, arguments);
	  }

	  Collection.prototype.url = '/api/strength';

	  Collection.prototype.model = Model;

	  Collection.prototype.mode = 'client';

	  Collection.prototype.state = {
	    currentPage: 1,
	    pageSize: 10
	  };

	  return Collection;

	})(Backbone.PageableCollection);

	View = (function(superClass) {
	  extend(View, superClass);

	  View.prototype.template = viewTemplate;

	  View.prototype.regions = {
	    input: '#strength-input-view',
	    table: '#strength-table-view'
	  };

	  View.prototype.events = {
	    'click #strength-back': function() {
	      this.rootChannel.request('strength');
	    },
	    'click #strength-log': function() {
	      this.rootChannel.request('strength:log', this.strengthID);
	    }
	  };

	  View.prototype.bindings = {
	    '#strength-header': 'name'
	  };

	  function View(options) {
	    var attributes;
	    View.__super__.constructor.apply(this, arguments);
	    this.rootChannel = Backbone.Radio.channel('root');
	    this.mergeOptions(options, 'strengthID');
	    attributes = _.chain(this.model.attributes).extend({
	      date: new Date(),
	      exercise: this.model.get('_id')
	    }).omit('_id').value();
	    this.model = new Model(attributes);
	  }

	  View.prototype.onRender = function() {
	    this.stickit();
	  };

	  View.prototype.onShow = function() {
	    this.showChildView('input', new InputView({
	      model: this.model,
	      collection: this.collection
	    }));

	    /*
	    @showChildView 'table', new TableView
	      #collection: @collection
	      collection: new Backbone.Collection()
	      model: @model
	     */
	  };

	  return View;

	})(Marionette.LayoutView);

	module.exports.Model = Model;

	module.exports.Collection = Collection;

	module.exports.View = View;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Marionette, Model, SetView, View, _, moment, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	_ = __webpack_require__(3);

	moment = __webpack_require__(44);

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	SetView = __webpack_require__(65);

	viewTemplate = __webpack_require__(67);

	__webpack_require__(54);

	__webpack_require__(55);

	__webpack_require__(56);

	__webpack_require__(19);

	__webpack_require__(57);

	Model = (function(superClass) {
	  extend(Model, superClass);

	  function Model() {
	    return Model.__super__.constructor.apply(this, arguments);
	  }

	  Model.prototype.idAttribute = '_id';

	  Model.prototype.defaults = {
	    index: 1,
	    weight: 0,
	    rep: 1
	  };

	  return Model;

	})(Backbone.Model);

	View = (function(superClass) {
	  extend(View, superClass);

	  View.prototype.template = viewTemplate;

	  View.prototype.regions = {
	    set: '#strength-set-view'
	  };

	  View.prototype.ui = {
	    name: '#strength-name',
	    type: '#strength-type',
	    submit: '#strength-submit',
	    addset: '#strength-addset',
	    date: '#strength-date',
	    time: '#strength-time',
	    form: '#strength-form'
	  };

	  View.prototype.bindings = {
	    '#strength-name': 'name',
	    '#strength-note': 'note',
	    '#strength-addset': {
	      observe: 'count',
	      onSet: function(value) {
	        if (value > this.sessionCollection.length) {
	          this.sessionCollection.add(new Model({
	            index: parseInt(value)
	          }));
	        } else {
	          this.sessionCollection.remove(this.sessionCollection.last());
	        }
	      }
	    }
	  };

	  View.prototype.events = {
	    'click #strength-exercise': function() {
	      this.rootChannel.request('exercise');
	    },
	    'click #strength-time': function() {
	      this.ui.time.timepicker('showWidget');
	    },
	    'click @ui.submit': function() {
	      var date, time;
	      date = moment(new Date(this.ui.date.val())).format('YYYY-MM-DD');
	      time = this.ui.time.val();
	      this.model.set({
	        date: moment(new Date(date + " " + time)).format()
	      });
	      this.ui.form.validator('validate');
	      this.model.set('session', this.sessionCollection.toJSON());
	      this.ui.form.validator('validate');
	      this.model.save({}, {
	        error: function() {
	          console.log('fail');
	        }
	      });
	    }
	  };

	  function View() {
	    var model;
	    View.__super__.constructor.apply(this, arguments);
	    this.rootChannel = Backbone.Radio.channel('root');
	    model = new Model({}, {
	      id: this.model.id
	    });
	    this.sessionCollection = new Backbone.Collection(model);
	  }

	  View.prototype.onRender = function() {
	    this.ui.addset.TouchSpin({
	      buttondown_class: 'btn btn-info',
	      buttonup_class: 'btn btn-info',
	      min: 1,
	      max: 20
	    });
	    this.ui.date.datepicker({
	      todayBtn: 'linked',
	      todayHighlight: true
	    }).on('changeDate', (function(_this) {
	      return function() {
	        _this.model.set('date', new Date(_this.ui.date.val()));
	      };
	    })(this)).datepicker('setDate', new Date());
	    this.ui.time.timepicker({
	      template: 'dropdown'
	    }).timepicker('setTime', moment().format('HH:mm:ss'));
	    this.stickit();
	  };

	  View.prototype.onShow = function() {
	    this.showChildView('set', new SetView({
	      collection: this.sessionCollection
	    }));
	  };

	  View.prototype.onBeforeDestroy = function() {
	    this.ui.form.validator('destroy');
	    this.ui.date.datepicker('destroy');
	    this.ui.addset.TouchSpin('destroy');
	    this.unstickit();
	  };

	  return View;

	})(Marionette.LayoutView);

	module.exports = View;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, ItemView, Marionette, View, _, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	_ = __webpack_require__(3);

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	viewTemplate = __webpack_require__(66);

	ItemView = (function(superClass) {
	  extend(ItemView, superClass);

	  function ItemView() {
	    return ItemView.__super__.constructor.apply(this, arguments);
	  }

	  ItemView.prototype.template = viewTemplate;

	  ItemView.prototype.ui = {
	    rep: '.strength-rep',
	    weight: '.strength-weight'
	  };

	  ItemView.prototype.bindings = {
	    '.strength-rep': {
	      observe: 'rep',
	      onSet: function(value) {
	        return parseInt(value);
	      }
	    },
	    '.strength-weight': {
	      observe: 'weight',
	      onSet: function(value) {
	        return parseInt(value);
	      }
	    },
	    '.strength-set-label': {
	      observe: 'index',
	      onGet: function(value) {
	        return "Set #" + value;
	      }
	    }
	  };

	  ItemView.prototype.onRender = function() {
	    this.ui.rep.TouchSpin();
	    this.ui.weight.TouchSpin();
	    this.stickit();
	  };

	  ItemView.prototype.onBeforeDestroy = function() {
	    this.ui.rep.TouchSpin('destroy');
	    this.ui.weight.TouchSpin('destroy');
	  };

	  return ItemView;

	})(Marionette.ItemView);

	View = (function(superClass) {
	  extend(View, superClass);

	  function View() {
	    return View.__super__.constructor.apply(this, arguments);
	  }

	  View.prototype.template = false;

	  View.prototype.childView = ItemView;

	  return View;

	})(Marionette.CollectionView);

	module.exports = View;


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<hr><div class=\"form-group\"><div class=\"col-sm-12\"><label class=\"strength-set-label\">Set #</label></div></div><div class=\"form-group\"><div class=\"col-sm-2 control-label\"><label>Weight</label></div><div class=\"col-sm-10\"><input placeholder=\"0\" class=\"form-control strength-weight\"></div></div><div class=\"form-group\"><div class=\"col-sm-2 control-label\"><label>Reps</label></div><div class=\"col-sm-10\"><input placeholder=\"0\" class=\"form-control strength-rep\"></div></div>");;return buf.join("");
	}

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-sm-12\"><span><b>Add a new workout session</b></span></div></div><br><div class=\"row\"><div class=\"col-sm-12\"><form id=\"strength-form\" class=\"form-horizontal\"><!-- Nav tabs--><ul role=\"tablist\" class=\"nav nav-tabs\"><li role=\"presentation\" class=\"active\"><a href=\"#strength-basic\" aria-controls=\"basic\" role=\"tab\" data-toggle=\"tab\"><i class=\"fa fa-fw fa-lg fa-pencil\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Basic</a></li><li role=\"presentation\"><a href=\"#strength-advance\" aria-controls=\"advance\" role=\"tab\" data-toggle=\"tab\"><i class=\"fa fa-fw fa-lg fa-cogs\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Advance</a></li></ul><br><!-- Tab panes--><div class=\"tab-content\"><!-- Basic--><div id=\"strength-basic\" role=\"tabpanel\" class=\"tab-pane active\"><div class=\"form-group\"><label for=\"strength-name\" class=\"col-sm-2 control-label\">Name</label><div class=\"col-sm-10\"><input id=\"strength-name\" readonly class=\"form-control\"><div class=\"help-block with-errors\"></div></div></div><div id=\"strength-set-view\"></div><hr><div class=\"form-group\"><label for=\"strength-addset\" class=\"col-sm-2 control-label\">Sets</label><div class=\"col-sm-10\"><input id=\"strength-addset\" placeholder=\"0\" class=\"form-control\"></div></div></div><!-- Advance--><div id=\"strength-advance\" role=\"tabpanel\" class=\"tab-pane\"><div class=\"form-group\"><label for=\"strength-date\" class=\"col-sm-2 control-label\">Date</label><div class=\"col-sm-10\"><div class=\"input-group date\"><input id=\"strength-date\" type=\"text\" readonly class=\"form-control input-readonly\"><div style=\"color:white;\" class=\"input-group-addon btn-info\"><span class=\"fa fa-fw fa-lg fa-calendar\"></span></div></div></div></div><div class=\"form-group\"><label for=\"strength-time\" class=\"col-sm-2 control-label\">Time</label><div class=\"col-sm-10\"><div class=\"input-group bootstrap-timepicker timepicker\"><input id=\"strength-time\" readonly class=\"form-control input-readonly\"><div style=\"color:white;\" class=\"input-group-addon btn-info\"><span class=\"fa fa-fw fa-lg fa-clock-o\"></span></div></div></div></div><div class=\"form-group\"><label for=\"strength-note\" class=\"col-sm-2 control-label\">Note</label><div class=\"col-sm-10\"><input id=\"strength-note\" class=\"form-control\"></div></div></div></div></form></div></div><div class=\"row\"><div class=\"col-sm-12\"><button id=\"strength-submit\" class=\"btn btn-success pull-right\"><i class=\"fa fa-plus\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "Add Session</button></div></div>");;return buf.join("");
	}

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var $, Backbone, ItemView, Marionette, View, _, itemTemplate, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	$ = __webpack_require__(2);

	_ = __webpack_require__(3);

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	itemTemplate = __webpack_require__(69);

	viewTemplate = __webpack_require__(70);

	__webpack_require__(42);

	__webpack_require__(19);

	ItemView = (function(superClass) {
	  extend(ItemView, superClass);

	  function ItemView() {
	    return ItemView.__super__.constructor.apply(this, arguments);
	  }

	  ItemView.prototype.tagName = 'tr';

	  ItemView.prototype.template = itemTemplate;

	  ItemView.prototype.bindings = {
	    '.strength-table-td-name': 'name'
	  };

	  ItemView.prototype.onRender = function() {
	    this.stickit();
	  };

	  return ItemView;

	})(Marionette.CompositeView);

	View = (function(superClass) {
	  extend(View, superClass);

	  View.prototype.childViewContainer = 'tbody';

	  View.prototype.childView = ItemView;

	  View.prototype.template = viewTemplate;

	  View.prototype.ui = {
	    name: '#strength-name',
	    type: '#strength-type'
	  };

	  function View() {
	    View.__super__.constructor.apply(this, arguments);
	    this.rootChannel = Backbone.Radio.channel('root');
	  }

	  return View;

	})(Marionette.CompositeView);

	module.exports = View;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<td class=\"strength-table-td-name\"></td>");;return buf.join("");
	}

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-sm-12\"><span><b>Table of past sets</b></span></div></div><br><div class=\"row\"><div class=\"col-sm-12\"><table class=\"table table-condensed table-bordered table-hover\"><thead><tr><td><b>Name</b></td></tr></thead><tbody></tbody></table></div></div>");;return buf.join("");
	}

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-xs-12\"><button id=\"strength-back\" class=\"btn btn-default\"><i class=\"fa fa-lg fa-arrow-left\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "<i class=\"fa fa-lg fa-shield\"></i></button><div class=\"pull-right\"><button id=\"strength-log\" class=\"btn btn-default\"><i class=\"fa fa-lg fa-area-chart\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "<i class=\"fa fa-lg fa-arrow-right\"></i></button></div></div></div><br><div class=\"row\"><div class=\"col-sm-12\"><span class=\"lead\"><i class=\"fa fa-fw fa-lg fa-child\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "<span id=\"strength-header\"></span></span></div></div><br><div class=\"row\"><div class=\"col-sm-6\"><div class=\"row\"><div class=\"col-sm-12\"><div id=\"strength-input-view\"></div></div></div></div><div class=\"col-sm-6\"><div class=\"row\"><div class=\"col-sm-12\"><div id=\"strength-table-view\"></div></div></div></div></div>");;return buf.join("");
	}

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, GraphView, Marionette, Model, TableView, View, moment, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	moment = __webpack_require__(44);

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	GraphView = __webpack_require__(73);

	TableView = __webpack_require__(75);

	viewTemplate = __webpack_require__(77);

	Model = (function(superClass) {
	  extend(Model, superClass);

	  function Model(attributes, options) {
	    Model.__super__.constructor.apply(this, arguments);
	    this.url = "/api/strength/" + options.id + "/log";
	  }

	  Model.prototype.parse = function(response) {
	    var i, key, len, record, ref, result, serie, series;
	    series = {};
	    ref = response.log;
	    for (i = 0, len = ref.length; i < len; i++) {
	      record = ref[i];
	      _.each(record.session, function(session, index) {
	        if (series[session.index] === void 0) {
	          series[session.index] = [];
	        }
	        series[session.index].push({
	          x: moment(record.date).valueOf(),
	          y: session.weight
	        });
	      });
	    }
	    result = [];
	    for (key in series) {
	      serie = series[key];
	      result.push({
	        index: key,
	        name: "SET" + key,
	        data: serie || []
	      });
	    }
	    response.log = result;
	    return response;
	  };

	  return Model;

	})(Backbone.Model);

	View = (function(superClass) {
	  extend(View, superClass);

	  View.prototype.template = viewTemplate;

	  View.prototype.regions = {
	    graph: '#strength-log-graph-view',
	    table: '#strength-log-table-view'
	  };

	  View.prototype.events = {
	    'click #strength-log-back': function() {
	      this.rootChannel.request('strength:detail', this.strengthID);
	    }
	  };

	  function View(options) {
	    View.__super__.constructor.apply(this, arguments);
	    this.rootChannel = Backbone.Radio.channel('root');
	    this.mergeOptions(options, 'strengthID');
	  }

	  View.prototype.onRender = function() {
	    this.stickit();
	  };

	  View.prototype.onShow = function() {
	    this.showChildView('graph', new GraphView({
	      collection: new Backbone.Collection(this.model.get('log')),
	      model: this.model
	    }));
	    this.showChildView('table', new TableView({
	      model: this.model
	    }));
	  };

	  return View;

	})(Marionette.LayoutView);

	module.exports.Model = Model;

	module.exports.View = View;


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var $, Backbone, Highstock, Marionette, View, seriesData, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	$ = __webpack_require__(2);

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	Highstock = __webpack_require__(5);

	viewTemplate = __webpack_require__(74);

	seriesData = function(models) {
	  var i, len, model, series;
	  series = [];
	  for (i = 0, len = models.length; i < len; i++) {
	    model = models[i];
	    series.push(model);
	  }
	  return series;
	};

	View = (function(superClass) {
	  extend(View, superClass);

	  View.prototype.template = viewTemplate;

	  View.prototype.ui = {
	    chart: '#strength-log-graph-ui'
	  };

	  function View(options) {
	    View.__super__.constructor.apply(this, arguments);
	    this.rootChannel = Backbone.Radio.channel('root');
	  }

	  View.prototype.onRender = function() {
	    this.chart = new Highstock.StockChart({
	      chart: {
	        type: 'areaspline',
	        renderTo: this.ui.chart[0]
	      },
	      title: {
	        text: this.model.get('name').toUpperCase(),
	        style: {
	          fontWeight: 'bold'
	        }
	      },
	      plotOptions: {
	        areaspline: {
	          fillOpacity: 0.3,
	          lineWidth: 3
	        },
	        series: {
	          marker: {
	            radius: 2,
	            enabled: true
	          }
	        }
	      },
	      xAxis: {
	        lineWidth: 2,
	        title: {
	          text: 'Time',
	          style: {
	            fontWeight: 600,
	            fontSize: '12px'
	          }
	        }
	      },
	      yAxis: [
	        {
	          lineWidth: 2,
	          opposite: false,
	          title: {
	            text: 'Weight',
	            style: {
	              fontWeight: 600,
	              fontSize: '12px'
	            }
	          }
	        }
	      ],
	      series: seriesData(this.model.get('log')),
	      legend: {
	        enabled: true,
	        borderWidth: 2
	      },
	      credits: {
	        enabled: false
	      }
	    });
	  };

	  View.prototype.onShow = function() {
	    this.model.set('max', this.chart.yAxis[0].dataMax);
	    this.model.set('min', this.chart.yAxis[0].dataMin);
	    this.chart.reflow();
	  };

	  return View;

	})(Marionette.ItemView);

	module.exports = View;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div id=\"strength-log-graph-ui\"></div>");;return buf.join("");
	}

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Data, Marionette, View, moment, viewTemplate,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	moment = __webpack_require__(44);

	Backbone = __webpack_require__(8);

	Marionette = __webpack_require__(10);

	Data = __webpack_require__(52);

	viewTemplate = __webpack_require__(76);

	View = (function(superClass) {
	  extend(View, superClass);

	  View.prototype.template = viewTemplate;

	  View.prototype.bindings = {
	    '#strength-log-table-name': 'name',
	    '#strength-log-table-max': {
	      observe: 'max',
	      onGet: function(value) {
	        return value + ' lb';
	      }
	    },
	    '#strength-log-table-min': {
	      observe: 'min',
	      onGet: function(value) {
	        return value + ' lb';
	      }
	    },
	    '#strength-log-table-avg': 'avg',
	    '#strength-log-table-target': {
	      observe: 'muscle',
	      onGet: function(value) {
	        return _.find(Data.Muscles, {
	          value: value
	        }).label;
	      }
	    },
	    '#strength-log-table-date': {
	      observe: 'date',
	      onGet: function(value) {
	        return moment(value).format('YYYY-MM-DD');
	      }
	    }
	  };

	  function View(options) {
	    View.__super__.constructor.apply(this, arguments);
	    this.rootChannel = Backbone.Radio.channel('root');
	    this.mergeOptions(options, 'title');
	  }

	  View.prototype.onRender = function() {
	    this.stickit();
	  };

	  return View;

	})(Marionette.ItemView);

	module.exports = View;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-sm-12\"><table class=\"table table-condensed table-hover\"><thead><tr><td colspan=\"2\"><b>Summary</b></td></tr></thead><tbody><tr><td>Name</td><td id=\"strength-log-table-name\"></td></tr><tr><td>Max</td><td id=\"strength-log-table-max\"></td></tr><tr><td>Min</td><td id=\"strength-log-table-min\"></td></tr><tr><td>Target</td><td id=\"strength-log-table-target\"></td></tr><tr><td>Started</td><td id=\"strength-log-table-date\"></td></tr></tbody></table></div></div>");;return buf.join("");
	}

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(14);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"row\"><div class=\"col-xs-12\"><button id=\"strength-log-back\" class=\"btn btn-default\"><i class=\"fa fa-lg fa-arrow-left\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "<i class=\"fa fa-lg fa-file-text-o\"></i></button></div></div><br><div class=\"row\"><div class=\"col-xs-12\"><span class=\"lead\"><i class=\"fa fa-fw fa-lg fa-area-chart\"></i>" + (jade.escape(null == (jade_interp = ' ') ? "" : jade_interp)) + "LOG</span></div></div><br><div class=\"row\"><div class=\"col-xs-12\"><div id=\"strength-log-graph-view\"></div></div></div><hr><br><div class=\"row\"><div class=\"col-sm-12\"><div id=\"strength-log-table-view\"></div></div></div>");;return buf.join("");
	}

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var jQuery = __webpack_require__(2);

	/*	
	 * jQuery mmenu v4.7.5
	 * @requires jQuery 1.7.0 or later
	 *
	 * mmenu.frebsite.nl
	 *	
	 * Copyright (c) Fred Heusschen
	 * www.frebsite.nl
	 *
	 * Licensed under the MIT license:
	 * http://en.wikipedia.org/wiki/MIT_License
	 */
	!function(e){function n(){l=!0,d.$wndw=e(window),d.$html=e("html"),d.$body=e("body"),e.each([i,a,o],function(e,n){n.add=function(e){e=e.split(" ");for(var t in e)n[e[t]]=n.mm(e[t])}}),i.mm=function(e){return"mm-"+e},i.add("wrapper menu inline panel nopanel list nolist subtitle selected label spacer current highest hidden opened subopened subopen fullsubopen subclose"),i.umm=function(e){return"mm-"==e.slice(0,3)&&(e=e.slice(3)),e},a.mm=function(e){return"mm-"+e},a.add("parent"),o.mm=function(e){return e+".mm"},o.add("toggle open close setSelected transitionend webkitTransitionEnd mousedown mouseup touchstart touchmove touchend scroll resize click keydown keyup"),e[t]._c=i,e[t]._d=a,e[t]._e=o,e[t].glbl=d}var t="mmenu",s="4.7.5";if(!e[t]){var i={},a={},o={},l=!1,d={$wndw:null,$html:null,$body:null};e[t]=function(n,s,i){this.$menu=n,this.opts=s,this.conf=i,this.vars={},"function"==typeof this.___deprecated&&this.___deprecated(),this._initMenu(),this._initAnchors(),this._initEvents();var a=this.$menu.children(this.conf.panelNodetype);for(var o in e[t].addons)e[t].addons[o]._add.call(this),e[t].addons[o]._add=function(){},e[t].addons[o]._setup.call(this);return this._init(a),"function"==typeof this.___debug&&this.___debug(),this},e[t].version=s,e[t].addons={},e[t].uniqueId=0,e[t].defaults={classes:"",slidingSubmenus:!0,onClick:{setSelected:!0}},e[t].configuration={panelNodetype:"ul, ol, div",transitionDuration:400,openingInterval:25,classNames:{panel:"Panel",selected:"Selected",label:"Label",spacer:"Spacer"}},e[t].prototype={_init:function(n){n=n.not("."+i.nopanel),n=this._initPanels(n);for(var s in e[t].addons)e[t].addons[s]._init.call(this,n);this._update()},_initMenu:function(){this.opts.offCanvas&&this.conf.clone&&(this.$menu=this.$menu.clone(!0),this.$menu.add(this.$menu.find("*")).filter("[id]").each(function(){e(this).attr("id",i.mm(e(this).attr("id")))})),this.$menu.contents().each(function(){3==e(this)[0].nodeType&&e(this).remove()}),this.$menu.parent().addClass(i.wrapper);var n=[i.menu];n.push(i.mm(this.opts.slidingSubmenus?"horizontal":"vertical")),this.opts.classes&&n.push(this.opts.classes),this.$menu.addClass(n.join(" "))},_initPanels:function(n){var t=this;this.__findAddBack(n,"ul, ol").not("."+i.nolist).addClass(i.list);var s=this.__findAddBack(n,"."+i.list).find("> li");this.__refactorClass(s,this.conf.classNames.selected,"selected"),this.__refactorClass(s,this.conf.classNames.label,"label"),this.__refactorClass(s,this.conf.classNames.spacer,"spacer"),s.off(o.setSelected).on(o.setSelected,function(n,t){n.stopPropagation(),s.removeClass(i.selected),"boolean"!=typeof t&&(t=!0),t&&e(this).addClass(i.selected)}),this.__refactorClass(this.__findAddBack(n,"."+this.conf.classNames.panel),this.conf.classNames.panel,"panel"),n.add(this.__findAddBack(n,"."+i.list).children().children().filter(this.conf.panelNodetype).not("."+i.nopanel)).addClass(i.panel);var l=this.__findAddBack(n,"."+i.panel),d=e("."+i.panel,this.$menu);if(l.each(function(){var n=e(this),s=n.attr("id")||t.__getUniqueId();n.attr("id",s)}),l.each(function(){var n=e(this),s=n.is("ul, ol")?n:n.find("ul ,ol").first(),o=n.parent(),l=o.children("a, span"),d=o.closest("."+i.panel);if(o.parent().is("."+i.list)&&!n.data(a.parent)){n.data(a.parent,o);var r=e('<a class="'+i.subopen+'" href="#'+n.attr("id")+'" />').insertBefore(l);l.is("a")||r.addClass(i.fullsubopen),t.opts.slidingSubmenus&&s.prepend('<li class="'+i.subtitle+'"><a class="'+i.subclose+'" href="#'+d.attr("id")+'">'+l.text()+"</a></li>")}}),this.opts.slidingSubmenus){var r=this.__findAddBack(n,"."+i.list).find("> li."+i.selected);r.parents("li").removeClass(i.selected).end().add(r.parents("li")).each(function(){var n=e(this),t=n.find("> ."+i.panel);t.length&&(n.parents("."+i.panel).addClass(i.subopened),t.addClass(i.opened))}).closest("."+i.panel).addClass(i.opened).parents("."+i.panel).addClass(i.subopened)}else{var r=e("li."+i.selected,d);r.parents("li").removeClass(i.selected).end().add(r.parents("li")).addClass(i.opened)}var u=d.filter("."+i.opened);return u.length||(u=l.first()),u.addClass(i.opened).last().addClass(i.current),this.opts.slidingSubmenus&&l.not(u.last()).addClass(i.hidden).end().appendTo(this.$menu),l},_initAnchors:function(){var n=this;d.$body.on(o.click,"a",function(s){var a=e(this),l=!1,r=n.$menu.find(a).length;for(var u in e[t].addons)if(e[t].addons[u]._clickAnchor&&(l=e[t].addons[u]._clickAnchor.call(n,a,r)))break;if(!l&&r){var c=a.attr("href")||"";if("#"==c.slice(0,1))try{e(c,n.$menu).is("."+i.panel)&&(l=!0,e(c).trigger(n.opts.slidingSubmenus?o.open:o.toggle))}catch(p){}}if(l&&s.preventDefault(),!l&&r&&a.is("."+i.list+" > li > a")&&!a.is('[rel="external"]')&&!a.is('[target="_blank"]')){n.__valueOrFn(n.opts.onClick.setSelected,a)&&a.parent().trigger(o.setSelected);var h=n.__valueOrFn(n.opts.onClick.preventDefault,a,"#"==c.slice(0,1));h&&s.preventDefault(),n.__valueOrFn(n.opts.onClick.blockUI,a,!h)&&d.$html.addClass(i.blocking),n.__valueOrFn(n.opts.onClick.close,a,h)&&n.$menu.trigger(o.close)}})},_initEvents:function(){var n=this;this.$menu.on(o.toggle+" "+o.open+" "+o.close,"."+i.panel,function(e){e.stopPropagation()}),this.opts.slidingSubmenus?this.$menu.on(o.open,"."+i.panel,function(){return n._openSubmenuHorizontal(e(this))}):this.$menu.on(o.toggle,"."+i.panel,function(){var n=e(this);n.trigger(n.parent().hasClass(i.opened)?o.close:o.open)}).on(o.open,"."+i.panel,function(){e(this).parent().addClass(i.opened)}).on(o.close,"."+i.panel,function(){e(this).parent().removeClass(i.opened)})},_openSubmenuHorizontal:function(n){if(n.hasClass(i.current))return!1;var t=e("."+i.panel,this.$menu),s=t.filter("."+i.current);return t.removeClass(i.highest).removeClass(i.current).not(n).not(s).addClass(i.hidden),n.hasClass(i.opened)?s.addClass(i.highest).removeClass(i.opened).removeClass(i.subopened):(n.addClass(i.highest),s.addClass(i.subopened)),n.removeClass(i.hidden).addClass(i.current),setTimeout(function(){n.removeClass(i.subopened).addClass(i.opened)},this.conf.openingInterval),"open"},_update:function(e){if(this.updates||(this.updates=[]),"function"==typeof e)this.updates.push(e);else for(var n=0,t=this.updates.length;t>n;n++)this.updates[n].call(this,e)},__valueOrFn:function(e,n,t){return"function"==typeof e?e.call(n[0]):"undefined"==typeof e&&"undefined"!=typeof t?t:e},__refactorClass:function(e,n,t){return e.filter("."+n).removeClass(n).addClass(i[t])},__findAddBack:function(e,n){return e.find(n).add(e.filter(n))},__transitionend:function(e,n,t){var s=!1,i=function(){s||n.call(e[0]),s=!0};e.one(o.transitionend,i),e.one(o.webkitTransitionEnd,i),setTimeout(i,1.1*t)},__getUniqueId:function(){return i.mm(e[t].uniqueId++)}},e.fn[t]=function(s,i){return l||n(),s=e.extend(!0,{},e[t].defaults,s),i=e.extend(!0,{},e[t].configuration,i),this.each(function(){var n=e(this);n.data(t)||n.data(t,new e[t](n,s,i))})},e[t].support={touch:"ontouchstart"in window||navigator.msMaxTouchPoints}}}(jQuery);
	/*	
	 * jQuery mmenu offCanvas addon
	 * mmenu.frebsite.nl
	 *
	 * Copyright (c) Fred Heusschen
	 */
	!function(e){var t="mmenu",o="offCanvas";e[t].addons[o]={_init:function(){},_setup:function(){if(this.opts[o]){var t=this,s=this.opts[o],p=this.conf[o];"string"!=typeof p.pageSelector&&(p.pageSelector="> "+p.pageNodetype),a.$allMenus=(a.$allMenus||e()).add(this.$menu),this.vars.opened=!1;var r=[n.offcanvas];"left"!=s.position&&r.push(n.mm(s.position)),"back"!=s.zposition&&r.push(n.mm(s.zposition)),this.$menu.addClass(r.join(" ")).parent().removeClass(n.wrapper),this.setPage(a.$page),this[o+"_initBlocker"](),this[o+"_initWindow"](),this.$menu.on(i.open+" "+i.opening+" "+i.opened+" "+i.close+" "+i.closing+" "+i.closed+" "+i.setPage,function(e){e.stopPropagation()}).on(i.open+" "+i.close+" "+i.setPage,function(e){t[e.type]()}),this.$menu[p.menuInjectMethod+"To"](p.menuWrapperSelector)}},_add:function(){n=e[t]._c,s=e[t]._d,i=e[t]._e,n.add("offcanvas slideout modal background opening blocker page"),s.add("style"),i.add("opening opened closing closed setPage"),a=e[t].glbl},_clickAnchor:function(e){if(!this.opts[o])return!1;var t=this.$menu.attr("id");if(t&&t.length&&(this.conf.clone&&(t=n.umm(t)),e.is('[href="#'+t+'"]')))return this.open(),!0;if(a.$page){var t=a.$page.attr("id");return t&&t.length&&e.is('[href="#'+t+'"]')?(this.close(),!0):!1}}},e[t].defaults[o]={position:"left",zposition:"back",modal:!1,moveBackground:!0},e[t].configuration[o]={pageNodetype:"div",pageSelector:null,menuWrapperSelector:"body",menuInjectMethod:"prepend"},e[t].prototype.open=function(){if(this.vars.opened)return!1;var e=this;return this._openSetup(),setTimeout(function(){e._openFinish()},this.conf.openingInterval),"open"},e[t].prototype._openSetup=function(){var e=this;a.$allMenus.not(this.$menu).trigger(i.close),a.$page.data(s.style,a.$page.attr("style")||""),a.$wndw.trigger(i.resize,[!0]);var t=[n.opened];this.opts[o].modal&&t.push(n.modal),this.opts[o].moveBackground&&t.push(n.background),"left"!=this.opts[o].position&&t.push(n.mm(this.opts[o].position)),"back"!=this.opts[o].zposition&&t.push(n.mm(this.opts[o].zposition)),this.opts.classes&&t.push(this.opts.classes),a.$html.addClass(t.join(" ")),setTimeout(function(){e.vars.opened=!0},this.conf.openingInterval),this.$menu.addClass(n.current+" "+n.opened)},e[t].prototype._openFinish=function(){var e=this;this.__transitionend(a.$page,function(){e.$menu.trigger(i.opened)},this.conf.transitionDuration),a.$html.addClass(n.opening),this.$menu.trigger(i.opening)},e[t].prototype.close=function(){if(!this.vars.opened)return!1;var e=this;return this.__transitionend(a.$page,function(){e.$menu.removeClass(n.current).removeClass(n.opened),a.$html.removeClass(n.opened).removeClass(n.modal).removeClass(n.background).removeClass(n.mm(e.opts[o].position)).removeClass(n.mm(e.opts[o].zposition)),e.opts.classes&&a.$html.removeClass(e.opts.classes),a.$page.attr("style",a.$page.data(s.style)),e.vars.opened=!1,e.$menu.trigger(i.closed)},this.conf.transitionDuration),a.$html.removeClass(n.opening),this.$menu.trigger(i.closing),"close"},e[t].prototype.setPage=function(t){t||(t=e(this.conf[o].pageSelector,a.$body),t.length>1&&(t=t.wrapAll("<"+this.conf[o].pageNodetype+" />").parent())),t.addClass(n.page+" "+n.slideout),a.$page=t},e[t].prototype[o+"_initWindow"]=function(){a.$wndw.on(i.keydown,function(e){return a.$html.hasClass(n.opened)&&9==e.keyCode?(e.preventDefault(),!1):void 0});var s=0;a.$wndw.on(i.resize,function(e,t){if(t||a.$html.hasClass(n.opened)){var o=a.$wndw.height();(t||o!=s)&&(s=o,a.$page.css("minHeight",o))}}),e[t].prototype[o+"_initWindow"]=function(){}},e[t].prototype[o+"_initBlocker"]=function(){var s=e('<div id="'+n.blocker+'" class="'+n.slideout+'" />').appendTo(a.$body);s.on(i.touchstart,function(e){e.preventDefault(),e.stopPropagation(),s.trigger(i.mousedown)}).on(i.mousedown,function(e){e.preventDefault(),a.$html.hasClass(n.modal)||a.$allMenus.trigger(i.close)}),e[t].prototype[o+"_initBlocker"]=function(){}};var n,s,i,a}(jQuery);
	/*	
	 * jQuery mmenu buttonbars addon
	 * mmenu.frebsite.nl
	 *
	 * Copyright (c) Fred Heusschen
	 */
	!function(t){var n="mmenu",a="buttonbars";t[n].addons[a]={_init:function(n){this.opts[a],this.conf[a],this.__refactorClass(t("div",n),this.conf.classNames[a].buttonbar,"buttonbar"),t("."+i.buttonbar,n).each(function(){var n=t(this),a=n.children().not("input"),o=n.children().filter("input");n.addClass(i.buttonbar+"-"+a.length),o.each(function(){var n=t(this),i=a.filter('label[for="'+n.attr("id")+'"]');i.length&&n.insertBefore(i)})})},_setup:function(){},_add:function(){i=t[n]._c,o=t[n]._d,r=t[n]._e,i.add("buttonbar"),s=t[n].glbl}},t[n].defaults[a]={},t[n].configuration.classNames[a]={buttonbar:"Buttonbar"};var i,o,r,s}(jQuery);
	/*	
	 * jQuery mmenu counters addon
	 * mmenu.frebsite.nl
	 *
	 * Copyright (c) Fred Heusschen
	 */
	!function(t){var e="mmenu",n="counters";t[e].addons[n]={_init:function(e){var s=this,d=this.opts[n];this.conf[n],this.__refactorClass(t("em",e),this.conf.classNames[n].counter,"counter"),d.add&&e.each(function(){var e=t(this).data(o.parent);e&&(e.find("> em."+a.counter).length||e.prepend(t('<em class="'+a.counter+'" />')))}),d.update&&e.each(function(){var e=t(this),n=e.data(o.parent);if(n){var d=n.find("> em."+a.counter);d.length&&(e.is("."+a.list)||(e=e.find("> ."+a.list)),e.length&&!e.data(o.updatecounter)&&(e.data(o.updatecounter,!0),s._update(function(){var t=e.children().not("."+a.label).not("."+a.subtitle).not("."+a.hidden).not("."+a.search).not("."+a.noresultsmsg);d.html(t.length)})))}})},_setup:function(){var a=this.opts[n];"boolean"==typeof a&&(a={add:a,update:a}),"object"!=typeof a&&(a={}),a=t.extend(!0,{},t[e].defaults[n],a),this.opts[n]=a},_add:function(){a=t[e]._c,o=t[e]._d,s=t[e]._e,a.add("counter search noresultsmsg"),o.add("updatecounter"),d=t[e].glbl}},t[e].defaults[n]={add:!1,update:!1},t[e].configuration.classNames[n]={counter:"Counter"};var a,o,s,d}(jQuery);
	/*	
	 * jQuery mmenu dragOpen addon
	 * mmenu.frebsite.nl
	 *
	 * Copyright (c) Fred Heusschen
	 */
	!function(e){function t(e,t,n){return t>e&&(e=t),e>n&&(e=n),e}var n="mmenu",o="dragOpen";e[n].addons[o]={_init:function(){},_setup:function(){if(this.opts.offCanvas){var s=this,p=this.opts[o],d=this.conf[o];if("boolean"==typeof p&&(p={open:p}),"object"!=typeof p&&(p={}),p=e.extend(!0,{},e[n].defaults[o],p),p.open){if(Hammer.VERSION<2)return;var f,c,h,m,u={},g=0,l=!1,v=!1,_=0,w=0;switch(this.opts.offCanvas.position){case"left":case"right":u.events="panleft panright",u.typeLower="x",u.typeUpper="X",v="width";break;case"top":case"bottom":u.events="panup pandown",u.typeLower="y",u.typeUpper="Y",v="height"}switch(this.opts.offCanvas.position){case"left":case"top":u.negative=!1;break;case"right":case"bottom":u.negative=!0}switch(this.opts.offCanvas.position){case"left":u.open_dir="right",u.close_dir="left";break;case"right":u.open_dir="left",u.close_dir="right";break;case"top":u.open_dir="down",u.close_dir="up";break;case"bottom":u.open_dir="up",u.close_dir="down"}var b=this.__valueOrFn(p.pageNode,this.$menu,r.$page);"string"==typeof b&&(b=e(b));var y=r.$page;switch(this.opts.offCanvas.zposition){case"front":y=this.$menu;break;case"next":y=y.add(this.$menu)}var $=new Hammer(b[0],p.vendors.hammer);$.on("panstart",function(e){switch(m=e.center[u.typeLower],s.opts.offCanvas.position){case"right":case"bottom":m>=r.$wndw[v]()-p.maxStartPos&&(g=1);break;default:m<=p.maxStartPos&&(g=1)}l=u.open_dir}).on(u.events+" panend",function(e){g>0&&e.preventDefault()}).on(u.events,function(e){if(f=e["delta"+u.typeUpper],u.negative&&(f=-f),f!=_&&(l=f>=_?u.open_dir:u.close_dir),_=f,_>p.threshold&&1==g){if(r.$html.hasClass(a.opened))return;g=2,s._openSetup(),s.$menu.trigger(i.opening),r.$html.addClass(a.dragging),w=t(r.$wndw[v]()*d[v].perc,d[v].min,d[v].max)}2==g&&(c=t(_,10,w)-("front"==s.opts.offCanvas.zposition?w:0),u.negative&&(c=-c),h="translate"+u.typeUpper+"("+c+"px )",y.css({"-webkit-transform":"-webkit-"+h,transform:h}))}).on("panend",function(){2==g&&(r.$html.removeClass(a.dragging),y.css("transform",""),s[l==u.open_dir?"_openFinish":"close"]()),g=0})}}},_add:function(){return"function"!=typeof Hammer?(e[n].addons[o]._init=function(){},e[n].addons[o]._setup=function(){},void 0):(a=e[n]._c,s=e[n]._d,i=e[n]._e,a.add("dragging"),r=e[n].glbl,void 0)}},e[n].defaults[o]={open:!1,maxStartPos:100,threshold:50,vendors:{hammer:{}}},e[n].configuration[o]={width:{perc:.8,min:140,max:440},height:{perc:.8,min:140,max:880}};var a,s,i,r}(jQuery);
	/*	
	 * jQuery mmenu fixedElements addon
	 * mmenu.frebsite.nl
	 *
	 * Copyright (c) Fred Heusschen
	 */
	!function(o){var t="mmenu",d="fixedElements";o[t].addons[d]={_init:function(){if(this.opts.offCanvas){var o=this.conf.classNames[d].fixedTop,t=this.conf.classNames[d].fixedBottom,e=this.__refactorClass(a.$page.find("."+o),o,"fixed-top"),s=this.__refactorClass(a.$page.find("."+t),t,"fixed-bottom");e.add(s).appendTo(a.$body).addClass(i.slideout)}},_setup:function(){},_add:function(){i=o[t]._c,e=o[t]._d,s=o[t]._e,i.add("fixed-top fixed-bottom"),a=o[t].glbl}},o[t].defaults[d]={},o[t].configuration.classNames[d]={fixedTop:"FixedTop",fixedBottom:"FixedBottom"};var i,e,s,a}(jQuery);
	/*	
	 * jQuery mmenu footer addon
	 * mmenu.frebsite.nl
	 *
	 * Copyright (c) Fred Heusschen
	 */
	!function(t){var o="mmenu",e="footer";t[o].addons[e]={_init:function(a){var d=this,i=this.opts[e],r=t("div."+n.footer,this.$menu);r.length&&(i.update&&a.each(function(){var o=t(this),a=t("."+d.conf.classNames[e].panelFooter,o),u=a.html();u||(u=i.title);var l=function(){r[u?"show":"hide"](),r.html(u)};o.on(s.open,l),o.hasClass(n.current)&&l()}),t[o].addons.buttonbars&&t[o].addons.buttonbars._init.call(this,r))},_setup:function(){var a=this.opts[e];if("boolean"==typeof a&&(a={add:a,update:a}),"object"!=typeof a&&(a={}),a=t.extend(!0,{},t[o].defaults[e],a),this.opts[e]=a,a.add){var s=a.content?a.content:a.title;t('<div class="'+n.footer+'" />').appendTo(this.$menu).append(s),this.$menu.addClass(n.hasfooter)}},_add:function(){n=t[o]._c,a=t[o]._d,s=t[o]._e,n.add("footer hasfooter"),d=t[o].glbl}},t[o].defaults[e]={add:!1,content:!1,title:"",update:!1},t[o].configuration.classNames[e]={panelFooter:"Footer"};var n,a,s,d}(jQuery);
	/*	
	 * jQuery mmenu header addon
	 * mmenu.frebsite.nl
	 *
	 * Copyright (c) Fred Heusschen
	 */
	!function(e){var t="mmenu",a="header";e[t].addons[a]={_init:function(s){var i=this,o=this.opts[a],l=(this.conf[a],e("."+n.header,this.$menu));if(l.length){if(o.update){var h=l.find("."+n.title),c=l.find("."+n.prev),f=l.find("."+n.next),p=l.find("."+n.close),u=!1;r.$page&&(u="#"+r.$page.attr("id"),p.attr("href",u)),s.each(function(){var t=e(this),s=t.find("."+i.conf.classNames[a].panelHeader),r=t.find("."+i.conf.classNames[a].panelPrev),l=t.find("."+i.conf.classNames[a].panelNext),p=s.html(),u=r.attr("href"),v=l.attr("href"),m=r.html(),b=l.html();p||(p=t.find("."+n.subclose).html()),p||(p=o.title),u||(u=t.find("."+n.subclose).attr("href"));var x=function(){h[p?"show":"hide"](),h.html(p),c[u?"attr":"removeAttr"]("href",u),c[u||m?"show":"hide"](),c.html(m),f[v?"attr":"removeAttr"]("href",v),f[v||b?"show":"hide"](),f.html(b)};t.on(d.open,x),t.hasClass(n.current)&&x()})}e[t].addons.buttonbars&&e[t].addons.buttonbars._init.call(this,l)}},_setup:function(){var s=this.opts[a];if(this.conf[a],"boolean"==typeof s&&(s={add:s,update:s}),"object"!=typeof s&&(s={}),"undefined"==typeof s.content&&(s.content=["prev","title","next"]),s=e.extend(!0,{},e[t].defaults[a],s),this.opts[a]=s,s.add){if(s.content instanceof Array){for(var d=e("<div />"),r=0,i=s.content.length;i>r;r++)switch(s.content[r]){case"prev":case"next":case"close":d.append('<a class="'+n[s.content[r]]+'" href="#"></a>');break;case"title":d.append('<span class="'+n.title+'"></span>');break;default:d.append(s.content[r])}d=d.html()}else var d=s.content;e('<div class="'+n.header+'" />').prependTo(this.$menu).append(d),this.$menu.addClass(n.hasheader)}},_add:function(){n=e[t]._c,s=e[t]._d,d=e[t]._e,n.add("header hasheader prev next close title"),r=e[t].glbl}},e[t].defaults[a]={add:!1,title:"Menu",update:!1},e[t].configuration.classNames[a]={panelHeader:"Header",panelNext:"Next",panelPrev:"Prev"};var n,s,d,r}(jQuery);
	/*	
	 * jQuery mmenu labels addon
	 * mmenu.frebsite.nl
	 *
	 * Copyright (c) Fred Heusschen
	 */
	!function(l){var e="mmenu",s="labels";l[e].addons[s]={_init:function(e){var n=this.opts[s];this.__refactorClass(l("li",this.$menu),this.conf.classNames[s].collapsed,"collapsed"),n.collapse&&l("."+a.label,e).each(function(){var e=l(this),s=e.nextUntil("."+a.label,"."+a.collapsed);s.length&&(e.children("."+a.subopen).length||(e.wrapInner("<span />"),e.prepend('<a href="#" class="'+a.subopen+" "+a.fullsubopen+'" />')))})},_setup:function(){var a=this.opts[s];"boolean"==typeof a&&(a={collapse:a}),"object"!=typeof a&&(a={}),a=l.extend(!0,{},l[e].defaults[s],a),this.opts[s]=a},_add:function(){a=l[e]._c,n=l[e]._d,o=l[e]._e,a.add("collapsed uncollapsed"),t=l[e].glbl},_clickAnchor:function(l,e){if(e){var s=l.parent();if(s.is("."+a.label)){var n=s.nextUntil("."+a.label,"."+a.collapsed);return s.toggleClass(a.opened),n[s.hasClass(a.opened)?"addClass":"removeClass"](a.uncollapsed),!0}}return!1}},l[e].defaults[s]={collapse:!1},l[e].configuration.classNames[s]={collapsed:"Collapsed"};var a,n,o,t}(jQuery);
	/*	
	 * jQuery mmenu searchfield addon
	 * mmenu.frebsite.nl
	 *
	 * Copyright (c) Fred Heusschen
	 */
	!function(e){function s(e){switch(e){case 9:case 16:case 17:case 18:case 37:case 38:case 39:case 40:return!0}return!1}var n="mmenu",t="searchfield";e[n].addons[t]={_init:function(n){var i=this,l=this.opts[t],d=this.conf[t];if(l.add){switch(l.addTo){case"menu":var c=this.$menu;break;case"panels":var c=n;break;default:var c=e(l.addTo,this.$menu).filter("."+a.panel)}c.length&&c.each(function(){var s=e(this),n=s.is("."+a.menu)?d.form?"form":"div":"li";if(!s.children(n+"."+a.search).length){if(s.is("."+a.menu))var t=i.$menu,r="prependTo";else var t=s.children().first(),r=t.is("."+a.subtitle)?"insertAfter":"insertBefore";var o=e("<"+n+' class="'+a.search+'" />');if("form"==n&&"object"==typeof d.form)for(var c in d.form)o.attr(c,d.form[c]);o.append('<input placeholder="'+l.placeholder+'" type="text" autocomplete="off" />'),o[r](t)}l.noResults&&(s.is("."+a.menu)&&(s=s.children("."+a.panel).first()),n=s.is("."+a.list)?"li":"div",s.children(n+"."+a.noresultsmsg).length||e("<"+n+' class="'+a.noresultsmsg+'" />').html(l.noResults).appendTo(s))})}if(this.$menu.children("."+a.search).length&&this.$menu.addClass(a.hassearch),l.search){var h=e("."+a.search,this.$menu);h.length&&h.each(function(){var n=e(this);if("menu"==l.addTo)var t=e("."+a.panel,i.$menu),d=i.$menu;else var t=n.closest("."+a.panel),d=t;var c=n.children("input"),h=i.__findAddBack(t,"."+a.list).children("li"),u=h.filter("."+a.label),f=h.not("."+a.subtitle).not("."+a.label).not("."+a.search).not("."+a.noresultsmsg),p="> a";l.showLinksOnly||(p+=", > span"),c.off(o.keyup+" "+o.change).on(o.keyup,function(e){s(e.keyCode)||n.trigger(o.search)}).on(o.change,function(){n.trigger(o.search)}),n.off(o.reset+" "+o.search).on(o.reset+" "+o.search,function(e){e.stopPropagation()}).on(o.reset,function(){n.trigger(o.search,[""])}).on(o.search,function(s,n){"string"==typeof n?c.val(n):n=c.val(),n=n.toLowerCase(),t.scrollTop(0),f.add(u).addClass(a.hidden),f.each(function(){var s=e(this);e(p,s).text().toLowerCase().indexOf(n)>-1&&s.add(s.prevAll("."+a.label).first()).removeClass(a.hidden)}),e(t.get().reverse()).each(function(s){var n=e(this),t=n.data(r.parent);if(t){var d=n.add(n.find("> ."+a.list)).find("> li").not("."+a.subtitle).not("."+a.search).not("."+a.noresultsmsg).not("."+a.label).not("."+a.hidden);d.length?t.removeClass(a.hidden).removeClass(a.nosubresults).prevAll("."+a.label).first().removeClass(a.hidden):"menu"==l.addTo&&(n.hasClass(a.opened)&&setTimeout(function(){t.trigger(o.open)},1.5*(s+1)*i.conf.openingInterval),t.addClass(a.nosubresults))}}),d[f.not("."+a.hidden).length?"removeClass":"addClass"](a.noresults),i._update()})})}},_setup:function(){var s=this.opts[t];this.conf[t],"boolean"==typeof s&&(s={add:s,search:s}),"object"!=typeof s&&(s={}),s=e.extend(!0,{},e[n].defaults[t],s),"boolean"!=typeof s.showLinksOnly&&(s.showLinksOnly="menu"==s.addTo),this.opts[t]=s},_add:function(){a=e[n]._c,r=e[n]._d,o=e[n]._e,a.add("search hassearch noresultsmsg noresults nosubresults"),o.add("search reset change"),i=e[n].glbl}},e[n].defaults[t]={add:!1,addTo:"menu",search:!1,placeholder:"Search",noResults:"No results found."},e[n].configuration[t]={form:!1};var a,r,o,i}(jQuery);
	/*	
	 * jQuery mmenu toggles addon
	 * mmenu.frebsite.nl
	 *
	 * Copyright (c) Fred Heusschen
	 */
	!function(e){var t="mmenu",s="toggles";e[t].addons[s]={_init:function(t){var a=this;this.opts[s],this.conf[s],this.__refactorClass(e("input",t),this.conf.classNames[s].toggle,"toggle"),this.__refactorClass(e("input",t),this.conf.classNames[s].check,"check"),e("input."+c.toggle+", input."+c.check,t).each(function(){var t=e(this),s=t.closest("li"),l=t.hasClass(c.toggle)?"toggle":"check",n=t.attr("id")||a.__getUniqueId();s.children('label[for="'+n+'"]').length||(t.attr("id",n),s.prepend(t),e('<label for="'+n+'" class="'+c[l]+'"></label>').insertBefore(s.children("a, span").last()))})},_setup:function(){},_add:function(){c=e[t]._c,a=e[t]._d,l=e[t]._e,c.add("toggle check"),n=e[t].glbl}},e[t].defaults[s]={},e[t].configuration.classNames[s]={toggle:"Toggle",check:"Check"};var c,a,l,n}(jQuery);


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var jQuery = __webpack_require__(2);

	/*!
	 * Bootstrap v3.3.2 (http://getbootstrap.com)
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 */

	if (typeof jQuery === 'undefined') {
	  throw new Error('Bootstrap\'s JavaScript requires jQuery')
	}

	+function ($) {
	  'use strict';
	  var version = $.fn.jquery.split(' ')[0].split('.')
	  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1)) {
	    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher')
	  }
	}(jQuery);

	/* ========================================================================
	 * Bootstrap: transition.js v3.3.2
	 * http://getbootstrap.com/javascript/#transitions
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
	  // ============================================================

	  function transitionEnd() {
	    var el = document.createElement('bootstrap')

	    var transEndEventNames = {
	      WebkitTransition : 'webkitTransitionEnd',
	      MozTransition    : 'transitionend',
	      OTransition      : 'oTransitionEnd otransitionend',
	      transition       : 'transitionend'
	    }

	    for (var name in transEndEventNames) {
	      if (el.style[name] !== undefined) {
	        return { end: transEndEventNames[name] }
	      }
	    }

	    return false // explicit for ie8 (  ._.)
	  }

	  // http://blog.alexmaccaw.com/css-transitions
	  $.fn.emulateTransitionEnd = function (duration) {
	    var called = false
	    var $el = this
	    $(this).one('bsTransitionEnd', function () { called = true })
	    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
	    setTimeout(callback, duration)
	    return this
	  }

	  $(function () {
	    $.support.transition = transitionEnd()

	    if (!$.support.transition) return

	    $.event.special.bsTransitionEnd = {
	      bindType: $.support.transition.end,
	      delegateType: $.support.transition.end,
	      handle: function (e) {
	        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
	      }
	    }
	  })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: alert.js v3.3.2
	 * http://getbootstrap.com/javascript/#alerts
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // ALERT CLASS DEFINITION
	  // ======================

	  var dismiss = '[data-dismiss="alert"]'
	  var Alert   = function (el) {
	    $(el).on('click', dismiss, this.close)
	  }

	  Alert.VERSION = '3.3.2'

	  Alert.TRANSITION_DURATION = 150

	  Alert.prototype.close = function (e) {
	    var $this    = $(this)
	    var selector = $this.attr('data-target')

	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }

	    var $parent = $(selector)

	    if (e) e.preventDefault()

	    if (!$parent.length) {
	      $parent = $this.closest('.alert')
	    }

	    $parent.trigger(e = $.Event('close.bs.alert'))

	    if (e.isDefaultPrevented()) return

	    $parent.removeClass('in')

	    function removeElement() {
	      // detach from parent, fire event then clean up data
	      $parent.detach().trigger('closed.bs.alert').remove()
	    }

	    $.support.transition && $parent.hasClass('fade') ?
	      $parent
	        .one('bsTransitionEnd', removeElement)
	        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
	      removeElement()
	  }


	  // ALERT PLUGIN DEFINITION
	  // =======================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.alert')

	      if (!data) $this.data('bs.alert', (data = new Alert(this)))
	      if (typeof option == 'string') data[option].call($this)
	    })
	  }

	  var old = $.fn.alert

	  $.fn.alert             = Plugin
	  $.fn.alert.Constructor = Alert


	  // ALERT NO CONFLICT
	  // =================

	  $.fn.alert.noConflict = function () {
	    $.fn.alert = old
	    return this
	  }


	  // ALERT DATA-API
	  // ==============

	  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: button.js v3.3.2
	 * http://getbootstrap.com/javascript/#buttons
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // BUTTON PUBLIC CLASS DEFINITION
	  // ==============================

	  var Button = function (element, options) {
	    this.$element  = $(element)
	    this.options   = $.extend({}, Button.DEFAULTS, options)
	    this.isLoading = false
	  }

	  Button.VERSION  = '3.3.2'

	  Button.DEFAULTS = {
	    loadingText: 'loading...'
	  }

	  Button.prototype.setState = function (state) {
	    var d    = 'disabled'
	    var $el  = this.$element
	    var val  = $el.is('input') ? 'val' : 'html'
	    var data = $el.data()

	    state = state + 'Text'

	    if (data.resetText == null) $el.data('resetText', $el[val]())

	    // push to event loop to allow forms to submit
	    setTimeout($.proxy(function () {
	      $el[val](data[state] == null ? this.options[state] : data[state])

	      if (state == 'loadingText') {
	        this.isLoading = true
	        $el.addClass(d).attr(d, d)
	      } else if (this.isLoading) {
	        this.isLoading = false
	        $el.removeClass(d).removeAttr(d)
	      }
	    }, this), 0)
	  }

	  Button.prototype.toggle = function () {
	    var changed = true
	    var $parent = this.$element.closest('[data-toggle="buttons"]')

	    if ($parent.length) {
	      var $input = this.$element.find('input')
	      if ($input.prop('type') == 'radio') {
	        if ($input.prop('checked') && this.$element.hasClass('active')) changed = false
	        else $parent.find('.active').removeClass('active')
	      }
	      if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change')
	    } else {
	      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
	    }

	    if (changed) this.$element.toggleClass('active')
	  }


	  // BUTTON PLUGIN DEFINITION
	  // ========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.button')
	      var options = typeof option == 'object' && option

	      if (!data) $this.data('bs.button', (data = new Button(this, options)))

	      if (option == 'toggle') data.toggle()
	      else if (option) data.setState(option)
	    })
	  }

	  var old = $.fn.button

	  $.fn.button             = Plugin
	  $.fn.button.Constructor = Button


	  // BUTTON NO CONFLICT
	  // ==================

	  $.fn.button.noConflict = function () {
	    $.fn.button = old
	    return this
	  }


	  // BUTTON DATA-API
	  // ===============

	  $(document)
	    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
	      var $btn = $(e.target)
	      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
	      Plugin.call($btn, 'toggle')
	      e.preventDefault()
	    })
	    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
	      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
	    })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: carousel.js v3.3.2
	 * http://getbootstrap.com/javascript/#carousel
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // CAROUSEL CLASS DEFINITION
	  // =========================

	  var Carousel = function (element, options) {
	    this.$element    = $(element)
	    this.$indicators = this.$element.find('.carousel-indicators')
	    this.options     = options
	    this.paused      =
	    this.sliding     =
	    this.interval    =
	    this.$active     =
	    this.$items      = null

	    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

	    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
	      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
	      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
	  }

	  Carousel.VERSION  = '3.3.2'

	  Carousel.TRANSITION_DURATION = 600

	  Carousel.DEFAULTS = {
	    interval: 5000,
	    pause: 'hover',
	    wrap: true,
	    keyboard: true
	  }

	  Carousel.prototype.keydown = function (e) {
	    if (/input|textarea/i.test(e.target.tagName)) return
	    switch (e.which) {
	      case 37: this.prev(); break
	      case 39: this.next(); break
	      default: return
	    }

	    e.preventDefault()
	  }

	  Carousel.prototype.cycle = function (e) {
	    e || (this.paused = false)

	    this.interval && clearInterval(this.interval)

	    this.options.interval
	      && !this.paused
	      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

	    return this
	  }

	  Carousel.prototype.getItemIndex = function (item) {
	    this.$items = item.parent().children('.item')
	    return this.$items.index(item || this.$active)
	  }

	  Carousel.prototype.getItemForDirection = function (direction, active) {
	    var activeIndex = this.getItemIndex(active)
	    var willWrap = (direction == 'prev' && activeIndex === 0)
	                || (direction == 'next' && activeIndex == (this.$items.length - 1))
	    if (willWrap && !this.options.wrap) return active
	    var delta = direction == 'prev' ? -1 : 1
	    var itemIndex = (activeIndex + delta) % this.$items.length
	    return this.$items.eq(itemIndex)
	  }

	  Carousel.prototype.to = function (pos) {
	    var that        = this
	    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

	    if (pos > (this.$items.length - 1) || pos < 0) return

	    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
	    if (activeIndex == pos) return this.pause().cycle()

	    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
	  }

	  Carousel.prototype.pause = function (e) {
	    e || (this.paused = true)

	    if (this.$element.find('.next, .prev').length && $.support.transition) {
	      this.$element.trigger($.support.transition.end)
	      this.cycle(true)
	    }

	    this.interval = clearInterval(this.interval)

	    return this
	  }

	  Carousel.prototype.next = function () {
	    if (this.sliding) return
	    return this.slide('next')
	  }

	  Carousel.prototype.prev = function () {
	    if (this.sliding) return
	    return this.slide('prev')
	  }

	  Carousel.prototype.slide = function (type, next) {
	    var $active   = this.$element.find('.item.active')
	    var $next     = next || this.getItemForDirection(type, $active)
	    var isCycling = this.interval
	    var direction = type == 'next' ? 'left' : 'right'
	    var that      = this

	    if ($next.hasClass('active')) return (this.sliding = false)

	    var relatedTarget = $next[0]
	    var slideEvent = $.Event('slide.bs.carousel', {
	      relatedTarget: relatedTarget,
	      direction: direction
	    })
	    this.$element.trigger(slideEvent)
	    if (slideEvent.isDefaultPrevented()) return

	    this.sliding = true

	    isCycling && this.pause()

	    if (this.$indicators.length) {
	      this.$indicators.find('.active').removeClass('active')
	      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
	      $nextIndicator && $nextIndicator.addClass('active')
	    }

	    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
	    if ($.support.transition && this.$element.hasClass('slide')) {
	      $next.addClass(type)
	      $next[0].offsetWidth // force reflow
	      $active.addClass(direction)
	      $next.addClass(direction)
	      $active
	        .one('bsTransitionEnd', function () {
	          $next.removeClass([type, direction].join(' ')).addClass('active')
	          $active.removeClass(['active', direction].join(' '))
	          that.sliding = false
	          setTimeout(function () {
	            that.$element.trigger(slidEvent)
	          }, 0)
	        })
	        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
	    } else {
	      $active.removeClass('active')
	      $next.addClass('active')
	      this.sliding = false
	      this.$element.trigger(slidEvent)
	    }

	    isCycling && this.cycle()

	    return this
	  }


	  // CAROUSEL PLUGIN DEFINITION
	  // ==========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.carousel')
	      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
	      var action  = typeof option == 'string' ? option : options.slide

	      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
	      if (typeof option == 'number') data.to(option)
	      else if (action) data[action]()
	      else if (options.interval) data.pause().cycle()
	    })
	  }

	  var old = $.fn.carousel

	  $.fn.carousel             = Plugin
	  $.fn.carousel.Constructor = Carousel


	  // CAROUSEL NO CONFLICT
	  // ====================

	  $.fn.carousel.noConflict = function () {
	    $.fn.carousel = old
	    return this
	  }


	  // CAROUSEL DATA-API
	  // =================

	  var clickHandler = function (e) {
	    var href
	    var $this   = $(this)
	    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
	    if (!$target.hasClass('carousel')) return
	    var options = $.extend({}, $target.data(), $this.data())
	    var slideIndex = $this.attr('data-slide-to')
	    if (slideIndex) options.interval = false

	    Plugin.call($target, options)

	    if (slideIndex) {
	      $target.data('bs.carousel').to(slideIndex)
	    }

	    e.preventDefault()
	  }

	  $(document)
	    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
	    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

	  $(window).on('load', function () {
	    $('[data-ride="carousel"]').each(function () {
	      var $carousel = $(this)
	      Plugin.call($carousel, $carousel.data())
	    })
	  })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: collapse.js v3.3.2
	 * http://getbootstrap.com/javascript/#collapse
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // COLLAPSE PUBLIC CLASS DEFINITION
	  // ================================

	  var Collapse = function (element, options) {
	    this.$element      = $(element)
	    this.options       = $.extend({}, Collapse.DEFAULTS, options)
	    this.$trigger      = $(this.options.trigger).filter('[href="#' + element.id + '"], [data-target="#' + element.id + '"]')
	    this.transitioning = null

	    if (this.options.parent) {
	      this.$parent = this.getParent()
	    } else {
	      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
	    }

	    if (this.options.toggle) this.toggle()
	  }

	  Collapse.VERSION  = '3.3.2'

	  Collapse.TRANSITION_DURATION = 350

	  Collapse.DEFAULTS = {
	    toggle: true,
	    trigger: '[data-toggle="collapse"]'
	  }

	  Collapse.prototype.dimension = function () {
	    var hasWidth = this.$element.hasClass('width')
	    return hasWidth ? 'width' : 'height'
	  }

	  Collapse.prototype.show = function () {
	    if (this.transitioning || this.$element.hasClass('in')) return

	    var activesData
	    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

	    if (actives && actives.length) {
	      activesData = actives.data('bs.collapse')
	      if (activesData && activesData.transitioning) return
	    }

	    var startEvent = $.Event('show.bs.collapse')
	    this.$element.trigger(startEvent)
	    if (startEvent.isDefaultPrevented()) return

	    if (actives && actives.length) {
	      Plugin.call(actives, 'hide')
	      activesData || actives.data('bs.collapse', null)
	    }

	    var dimension = this.dimension()

	    this.$element
	      .removeClass('collapse')
	      .addClass('collapsing')[dimension](0)
	      .attr('aria-expanded', true)

	    this.$trigger
	      .removeClass('collapsed')
	      .attr('aria-expanded', true)

	    this.transitioning = 1

	    var complete = function () {
	      this.$element
	        .removeClass('collapsing')
	        .addClass('collapse in')[dimension]('')
	      this.transitioning = 0
	      this.$element
	        .trigger('shown.bs.collapse')
	    }

	    if (!$.support.transition) return complete.call(this)

	    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

	    this.$element
	      .one('bsTransitionEnd', $.proxy(complete, this))
	      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
	  }

	  Collapse.prototype.hide = function () {
	    if (this.transitioning || !this.$element.hasClass('in')) return

	    var startEvent = $.Event('hide.bs.collapse')
	    this.$element.trigger(startEvent)
	    if (startEvent.isDefaultPrevented()) return

	    var dimension = this.dimension()

	    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

	    this.$element
	      .addClass('collapsing')
	      .removeClass('collapse in')
	      .attr('aria-expanded', false)

	    this.$trigger
	      .addClass('collapsed')
	      .attr('aria-expanded', false)

	    this.transitioning = 1

	    var complete = function () {
	      this.transitioning = 0
	      this.$element
	        .removeClass('collapsing')
	        .addClass('collapse')
	        .trigger('hidden.bs.collapse')
	    }

	    if (!$.support.transition) return complete.call(this)

	    this.$element
	      [dimension](0)
	      .one('bsTransitionEnd', $.proxy(complete, this))
	      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
	  }

	  Collapse.prototype.toggle = function () {
	    this[this.$element.hasClass('in') ? 'hide' : 'show']()
	  }

	  Collapse.prototype.getParent = function () {
	    return $(this.options.parent)
	      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
	      .each($.proxy(function (i, element) {
	        var $element = $(element)
	        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
	      }, this))
	      .end()
	  }

	  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
	    var isOpen = $element.hasClass('in')

	    $element.attr('aria-expanded', isOpen)
	    $trigger
	      .toggleClass('collapsed', !isOpen)
	      .attr('aria-expanded', isOpen)
	  }

	  function getTargetFromTrigger($trigger) {
	    var href
	    var target = $trigger.attr('data-target')
	      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

	    return $(target)
	  }


	  // COLLAPSE PLUGIN DEFINITION
	  // ==========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.collapse')
	      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

	      if (!data && options.toggle && option == 'show') options.toggle = false
	      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.collapse

	  $.fn.collapse             = Plugin
	  $.fn.collapse.Constructor = Collapse


	  // COLLAPSE NO CONFLICT
	  // ====================

	  $.fn.collapse.noConflict = function () {
	    $.fn.collapse = old
	    return this
	  }


	  // COLLAPSE DATA-API
	  // =================

	  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
	    var $this   = $(this)

	    if (!$this.attr('data-target')) e.preventDefault()

	    var $target = getTargetFromTrigger($this)
	    var data    = $target.data('bs.collapse')
	    var option  = data ? 'toggle' : $.extend({}, $this.data(), { trigger: this })

	    Plugin.call($target, option)
	  })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: dropdown.js v3.3.2
	 * http://getbootstrap.com/javascript/#dropdowns
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // DROPDOWN CLASS DEFINITION
	  // =========================

	  var backdrop = '.dropdown-backdrop'
	  var toggle   = '[data-toggle="dropdown"]'
	  var Dropdown = function (element) {
	    $(element).on('click.bs.dropdown', this.toggle)
	  }

	  Dropdown.VERSION = '3.3.2'

	  Dropdown.prototype.toggle = function (e) {
	    var $this = $(this)

	    if ($this.is('.disabled, :disabled')) return

	    var $parent  = getParent($this)
	    var isActive = $parent.hasClass('open')

	    clearMenus()

	    if (!isActive) {
	      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
	        // if mobile we use a backdrop because click events don't delegate
	        $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus)
	      }

	      var relatedTarget = { relatedTarget: this }
	      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

	      if (e.isDefaultPrevented()) return

	      $this
	        .trigger('focus')
	        .attr('aria-expanded', 'true')

	      $parent
	        .toggleClass('open')
	        .trigger('shown.bs.dropdown', relatedTarget)
	    }

	    return false
	  }

	  Dropdown.prototype.keydown = function (e) {
	    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

	    var $this = $(this)

	    e.preventDefault()
	    e.stopPropagation()

	    if ($this.is('.disabled, :disabled')) return

	    var $parent  = getParent($this)
	    var isActive = $parent.hasClass('open')

	    if ((!isActive && e.which != 27) || (isActive && e.which == 27)) {
	      if (e.which == 27) $parent.find(toggle).trigger('focus')
	      return $this.trigger('click')
	    }

	    var desc = ' li:not(.divider):visible a'
	    var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc)

	    if (!$items.length) return

	    var index = $items.index(e.target)

	    if (e.which == 38 && index > 0)                 index--                        // up
	    if (e.which == 40 && index < $items.length - 1) index++                        // down
	    if (!~index)                                      index = 0

	    $items.eq(index).trigger('focus')
	  }

	  function clearMenus(e) {
	    if (e && e.which === 3) return
	    $(backdrop).remove()
	    $(toggle).each(function () {
	      var $this         = $(this)
	      var $parent       = getParent($this)
	      var relatedTarget = { relatedTarget: this }

	      if (!$parent.hasClass('open')) return

	      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

	      if (e.isDefaultPrevented()) return

	      $this.attr('aria-expanded', 'false')
	      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)
	    })
	  }

	  function getParent($this) {
	    var selector = $this.attr('data-target')

	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }

	    var $parent = selector && $(selector)

	    return $parent && $parent.length ? $parent : $this.parent()
	  }


	  // DROPDOWN PLUGIN DEFINITION
	  // ==========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.dropdown')

	      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
	      if (typeof option == 'string') data[option].call($this)
	    })
	  }

	  var old = $.fn.dropdown

	  $.fn.dropdown             = Plugin
	  $.fn.dropdown.Constructor = Dropdown


	  // DROPDOWN NO CONFLICT
	  // ====================

	  $.fn.dropdown.noConflict = function () {
	    $.fn.dropdown = old
	    return this
	  }


	  // APPLY TO STANDARD DROPDOWN ELEMENTS
	  // ===================================

	  $(document)
	    .on('click.bs.dropdown.data-api', clearMenus)
	    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
	    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
	    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
	    .on('keydown.bs.dropdown.data-api', '[role="menu"]', Dropdown.prototype.keydown)
	    .on('keydown.bs.dropdown.data-api', '[role="listbox"]', Dropdown.prototype.keydown)

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: modal.js v3.3.2
	 * http://getbootstrap.com/javascript/#modals
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // MODAL CLASS DEFINITION
	  // ======================

	  var Modal = function (element, options) {
	    this.options        = options
	    this.$body          = $(document.body)
	    this.$element       = $(element)
	    this.$backdrop      =
	    this.isShown        = null
	    this.scrollbarWidth = 0

	    if (this.options.remote) {
	      this.$element
	        .find('.modal-content')
	        .load(this.options.remote, $.proxy(function () {
	          this.$element.trigger('loaded.bs.modal')
	        }, this))
	    }
	  }

	  Modal.VERSION  = '3.3.2'

	  Modal.TRANSITION_DURATION = 300
	  Modal.BACKDROP_TRANSITION_DURATION = 150

	  Modal.DEFAULTS = {
	    backdrop: true,
	    keyboard: true,
	    show: true
	  }

	  Modal.prototype.toggle = function (_relatedTarget) {
	    return this.isShown ? this.hide() : this.show(_relatedTarget)
	  }

	  Modal.prototype.show = function (_relatedTarget) {
	    var that = this
	    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

	    this.$element.trigger(e)

	    if (this.isShown || e.isDefaultPrevented()) return

	    this.isShown = true

	    this.checkScrollbar()
	    this.setScrollbar()
	    this.$body.addClass('modal-open')

	    this.escape()
	    this.resize()

	    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

	    this.backdrop(function () {
	      var transition = $.support.transition && that.$element.hasClass('fade')

	      if (!that.$element.parent().length) {
	        that.$element.appendTo(that.$body) // don't move modals dom position
	      }

	      that.$element
	        .show()
	        .scrollTop(0)

	      if (that.options.backdrop) that.adjustBackdrop()
	      that.adjustDialog()

	      if (transition) {
	        that.$element[0].offsetWidth // force reflow
	      }

	      that.$element
	        .addClass('in')
	        .attr('aria-hidden', false)

	      that.enforceFocus()

	      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

	      transition ?
	        that.$element.find('.modal-dialog') // wait for modal to slide in
	          .one('bsTransitionEnd', function () {
	            that.$element.trigger('focus').trigger(e)
	          })
	          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
	        that.$element.trigger('focus').trigger(e)
	    })
	  }

	  Modal.prototype.hide = function (e) {
	    if (e) e.preventDefault()

	    e = $.Event('hide.bs.modal')

	    this.$element.trigger(e)

	    if (!this.isShown || e.isDefaultPrevented()) return

	    this.isShown = false

	    this.escape()
	    this.resize()

	    $(document).off('focusin.bs.modal')

	    this.$element
	      .removeClass('in')
	      .attr('aria-hidden', true)
	      .off('click.dismiss.bs.modal')

	    $.support.transition && this.$element.hasClass('fade') ?
	      this.$element
	        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
	        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
	      this.hideModal()
	  }

	  Modal.prototype.enforceFocus = function () {
	    $(document)
	      .off('focusin.bs.modal') // guard against infinite focus loop
	      .on('focusin.bs.modal', $.proxy(function (e) {
	        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
	          this.$element.trigger('focus')
	        }
	      }, this))
	  }

	  Modal.prototype.escape = function () {
	    if (this.isShown && this.options.keyboard) {
	      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
	        e.which == 27 && this.hide()
	      }, this))
	    } else if (!this.isShown) {
	      this.$element.off('keydown.dismiss.bs.modal')
	    }
	  }

	  Modal.prototype.resize = function () {
	    if (this.isShown) {
	      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
	    } else {
	      $(window).off('resize.bs.modal')
	    }
	  }

	  Modal.prototype.hideModal = function () {
	    var that = this
	    this.$element.hide()
	    this.backdrop(function () {
	      that.$body.removeClass('modal-open')
	      that.resetAdjustments()
	      that.resetScrollbar()
	      that.$element.trigger('hidden.bs.modal')
	    })
	  }

	  Modal.prototype.removeBackdrop = function () {
	    this.$backdrop && this.$backdrop.remove()
	    this.$backdrop = null
	  }

	  Modal.prototype.backdrop = function (callback) {
	    var that = this
	    var animate = this.$element.hasClass('fade') ? 'fade' : ''

	    if (this.isShown && this.options.backdrop) {
	      var doAnimate = $.support.transition && animate

	      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
	        .prependTo(this.$element)
	        .on('click.dismiss.bs.modal', $.proxy(function (e) {
	          if (e.target !== e.currentTarget) return
	          this.options.backdrop == 'static'
	            ? this.$element[0].focus.call(this.$element[0])
	            : this.hide.call(this)
	        }, this))

	      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

	      this.$backdrop.addClass('in')

	      if (!callback) return

	      doAnimate ?
	        this.$backdrop
	          .one('bsTransitionEnd', callback)
	          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
	        callback()

	    } else if (!this.isShown && this.$backdrop) {
	      this.$backdrop.removeClass('in')

	      var callbackRemove = function () {
	        that.removeBackdrop()
	        callback && callback()
	      }
	      $.support.transition && this.$element.hasClass('fade') ?
	        this.$backdrop
	          .one('bsTransitionEnd', callbackRemove)
	          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
	        callbackRemove()

	    } else if (callback) {
	      callback()
	    }
	  }

	  // these following methods are used to handle overflowing modals

	  Modal.prototype.handleUpdate = function () {
	    if (this.options.backdrop) this.adjustBackdrop()
	    this.adjustDialog()
	  }

	  Modal.prototype.adjustBackdrop = function () {
	    this.$backdrop
	      .css('height', 0)
	      .css('height', this.$element[0].scrollHeight)
	  }

	  Modal.prototype.adjustDialog = function () {
	    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

	    this.$element.css({
	      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
	      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
	    })
	  }

	  Modal.prototype.resetAdjustments = function () {
	    this.$element.css({
	      paddingLeft: '',
	      paddingRight: ''
	    })
	  }

	  Modal.prototype.checkScrollbar = function () {
	    this.bodyIsOverflowing = document.body.scrollHeight > document.documentElement.clientHeight
	    this.scrollbarWidth = this.measureScrollbar()
	  }

	  Modal.prototype.setScrollbar = function () {
	    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
	    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
	  }

	  Modal.prototype.resetScrollbar = function () {
	    this.$body.css('padding-right', '')
	  }

	  Modal.prototype.measureScrollbar = function () { // thx walsh
	    var scrollDiv = document.createElement('div')
	    scrollDiv.className = 'modal-scrollbar-measure'
	    this.$body.append(scrollDiv)
	    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
	    this.$body[0].removeChild(scrollDiv)
	    return scrollbarWidth
	  }


	  // MODAL PLUGIN DEFINITION
	  // =======================

	  function Plugin(option, _relatedTarget) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.modal')
	      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

	      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
	      if (typeof option == 'string') data[option](_relatedTarget)
	      else if (options.show) data.show(_relatedTarget)
	    })
	  }

	  var old = $.fn.modal

	  $.fn.modal             = Plugin
	  $.fn.modal.Constructor = Modal


	  // MODAL NO CONFLICT
	  // =================

	  $.fn.modal.noConflict = function () {
	    $.fn.modal = old
	    return this
	  }


	  // MODAL DATA-API
	  // ==============

	  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
	    var $this   = $(this)
	    var href    = $this.attr('href')
	    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
	    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

	    if ($this.is('a')) e.preventDefault()

	    $target.one('show.bs.modal', function (showEvent) {
	      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
	      $target.one('hidden.bs.modal', function () {
	        $this.is(':visible') && $this.trigger('focus')
	      })
	    })
	    Plugin.call($target, option, this)
	  })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: tooltip.js v3.3.2
	 * http://getbootstrap.com/javascript/#tooltip
	 * Inspired by the original jQuery.tipsy by Jason Frame
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // TOOLTIP PUBLIC CLASS DEFINITION
	  // ===============================

	  var Tooltip = function (element, options) {
	    this.type       =
	    this.options    =
	    this.enabled    =
	    this.timeout    =
	    this.hoverState =
	    this.$element   = null

	    this.init('tooltip', element, options)
	  }

	  Tooltip.VERSION  = '3.3.2'

	  Tooltip.TRANSITION_DURATION = 150

	  Tooltip.DEFAULTS = {
	    animation: true,
	    placement: 'top',
	    selector: false,
	    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
	    trigger: 'hover focus',
	    title: '',
	    delay: 0,
	    html: false,
	    container: false,
	    viewport: {
	      selector: 'body',
	      padding: 0
	    }
	  }

	  Tooltip.prototype.init = function (type, element, options) {
	    this.enabled   = true
	    this.type      = type
	    this.$element  = $(element)
	    this.options   = this.getOptions(options)
	    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)

	    var triggers = this.options.trigger.split(' ')

	    for (var i = triggers.length; i--;) {
	      var trigger = triggers[i]

	      if (trigger == 'click') {
	        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
	      } else if (trigger != 'manual') {
	        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
	        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

	        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
	        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
	      }
	    }

	    this.options.selector ?
	      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
	      this.fixTitle()
	  }

	  Tooltip.prototype.getDefaults = function () {
	    return Tooltip.DEFAULTS
	  }

	  Tooltip.prototype.getOptions = function (options) {
	    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

	    if (options.delay && typeof options.delay == 'number') {
	      options.delay = {
	        show: options.delay,
	        hide: options.delay
	      }
	    }

	    return options
	  }

	  Tooltip.prototype.getDelegateOptions = function () {
	    var options  = {}
	    var defaults = this.getDefaults()

	    this._options && $.each(this._options, function (key, value) {
	      if (defaults[key] != value) options[key] = value
	    })

	    return options
	  }

	  Tooltip.prototype.enter = function (obj) {
	    var self = obj instanceof this.constructor ?
	      obj : $(obj.currentTarget).data('bs.' + this.type)

	    if (self && self.$tip && self.$tip.is(':visible')) {
	      self.hoverState = 'in'
	      return
	    }

	    if (!self) {
	      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
	      $(obj.currentTarget).data('bs.' + this.type, self)
	    }

	    clearTimeout(self.timeout)

	    self.hoverState = 'in'

	    if (!self.options.delay || !self.options.delay.show) return self.show()

	    self.timeout = setTimeout(function () {
	      if (self.hoverState == 'in') self.show()
	    }, self.options.delay.show)
	  }

	  Tooltip.prototype.leave = function (obj) {
	    var self = obj instanceof this.constructor ?
	      obj : $(obj.currentTarget).data('bs.' + this.type)

	    if (!self) {
	      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
	      $(obj.currentTarget).data('bs.' + this.type, self)
	    }

	    clearTimeout(self.timeout)

	    self.hoverState = 'out'

	    if (!self.options.delay || !self.options.delay.hide) return self.hide()

	    self.timeout = setTimeout(function () {
	      if (self.hoverState == 'out') self.hide()
	    }, self.options.delay.hide)
	  }

	  Tooltip.prototype.show = function () {
	    var e = $.Event('show.bs.' + this.type)

	    if (this.hasContent() && this.enabled) {
	      this.$element.trigger(e)

	      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
	      if (e.isDefaultPrevented() || !inDom) return
	      var that = this

	      var $tip = this.tip()

	      var tipId = this.getUID(this.type)

	      this.setContent()
	      $tip.attr('id', tipId)
	      this.$element.attr('aria-describedby', tipId)

	      if (this.options.animation) $tip.addClass('fade')

	      var placement = typeof this.options.placement == 'function' ?
	        this.options.placement.call(this, $tip[0], this.$element[0]) :
	        this.options.placement

	      var autoToken = /\s?auto?\s?/i
	      var autoPlace = autoToken.test(placement)
	      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

	      $tip
	        .detach()
	        .css({ top: 0, left: 0, display: 'block' })
	        .addClass(placement)
	        .data('bs.' + this.type, this)

	      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

	      var pos          = this.getPosition()
	      var actualWidth  = $tip[0].offsetWidth
	      var actualHeight = $tip[0].offsetHeight

	      if (autoPlace) {
	        var orgPlacement = placement
	        var $container   = this.options.container ? $(this.options.container) : this.$element.parent()
	        var containerDim = this.getPosition($container)

	        placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top'    :
	                    placement == 'top'    && pos.top    - actualHeight < containerDim.top    ? 'bottom' :
	                    placement == 'right'  && pos.right  + actualWidth  > containerDim.width  ? 'left'   :
	                    placement == 'left'   && pos.left   - actualWidth  < containerDim.left   ? 'right'  :
	                    placement

	        $tip
	          .removeClass(orgPlacement)
	          .addClass(placement)
	      }

	      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

	      this.applyPlacement(calculatedOffset, placement)

	      var complete = function () {
	        var prevHoverState = that.hoverState
	        that.$element.trigger('shown.bs.' + that.type)
	        that.hoverState = null

	        if (prevHoverState == 'out') that.leave(that)
	      }

	      $.support.transition && this.$tip.hasClass('fade') ?
	        $tip
	          .one('bsTransitionEnd', complete)
	          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
	        complete()
	    }
	  }

	  Tooltip.prototype.applyPlacement = function (offset, placement) {
	    var $tip   = this.tip()
	    var width  = $tip[0].offsetWidth
	    var height = $tip[0].offsetHeight

	    // manually read margins because getBoundingClientRect includes difference
	    var marginTop = parseInt($tip.css('margin-top'), 10)
	    var marginLeft = parseInt($tip.css('margin-left'), 10)

	    // we must check for NaN for ie 8/9
	    if (isNaN(marginTop))  marginTop  = 0
	    if (isNaN(marginLeft)) marginLeft = 0

	    offset.top  = offset.top  + marginTop
	    offset.left = offset.left + marginLeft

	    // $.fn.offset doesn't round pixel values
	    // so we use setOffset directly with our own function B-0
	    $.offset.setOffset($tip[0], $.extend({
	      using: function (props) {
	        $tip.css({
	          top: Math.round(props.top),
	          left: Math.round(props.left)
	        })
	      }
	    }, offset), 0)

	    $tip.addClass('in')

	    // check to see if placing tip in new offset caused the tip to resize itself
	    var actualWidth  = $tip[0].offsetWidth
	    var actualHeight = $tip[0].offsetHeight

	    if (placement == 'top' && actualHeight != height) {
	      offset.top = offset.top + height - actualHeight
	    }

	    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

	    if (delta.left) offset.left += delta.left
	    else offset.top += delta.top

	    var isVertical          = /top|bottom/.test(placement)
	    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
	    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

	    $tip.offset(offset)
	    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
	  }

	  Tooltip.prototype.replaceArrow = function (delta, dimension, isHorizontal) {
	    this.arrow()
	      .css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
	      .css(isHorizontal ? 'top' : 'left', '')
	  }

	  Tooltip.prototype.setContent = function () {
	    var $tip  = this.tip()
	    var title = this.getTitle()

	    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
	    $tip.removeClass('fade in top bottom left right')
	  }

	  Tooltip.prototype.hide = function (callback) {
	    var that = this
	    var $tip = this.tip()
	    var e    = $.Event('hide.bs.' + this.type)

	    function complete() {
	      if (that.hoverState != 'in') $tip.detach()
	      that.$element
	        .removeAttr('aria-describedby')
	        .trigger('hidden.bs.' + that.type)
	      callback && callback()
	    }

	    this.$element.trigger(e)

	    if (e.isDefaultPrevented()) return

	    $tip.removeClass('in')

	    $.support.transition && this.$tip.hasClass('fade') ?
	      $tip
	        .one('bsTransitionEnd', complete)
	        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
	      complete()

	    this.hoverState = null

	    return this
	  }

	  Tooltip.prototype.fixTitle = function () {
	    var $e = this.$element
	    if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
	      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
	    }
	  }

	  Tooltip.prototype.hasContent = function () {
	    return this.getTitle()
	  }

	  Tooltip.prototype.getPosition = function ($element) {
	    $element   = $element || this.$element

	    var el     = $element[0]
	    var isBody = el.tagName == 'BODY'

	    var elRect    = el.getBoundingClientRect()
	    if (elRect.width == null) {
	      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
	      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
	    }
	    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
	    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
	    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

	    return $.extend({}, elRect, scroll, outerDims, elOffset)
	  }

	  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
	    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
	           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
	           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
	        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }

	  }

	  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
	    var delta = { top: 0, left: 0 }
	    if (!this.$viewport) return delta

	    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
	    var viewportDimensions = this.getPosition(this.$viewport)

	    if (/right|left/.test(placement)) {
	      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
	      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
	      if (topEdgeOffset < viewportDimensions.top) { // top overflow
	        delta.top = viewportDimensions.top - topEdgeOffset
	      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
	        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
	      }
	    } else {
	      var leftEdgeOffset  = pos.left - viewportPadding
	      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
	      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
	        delta.left = viewportDimensions.left - leftEdgeOffset
	      } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow
	        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
	      }
	    }

	    return delta
	  }

	  Tooltip.prototype.getTitle = function () {
	    var title
	    var $e = this.$element
	    var o  = this.options

	    title = $e.attr('data-original-title')
	      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

	    return title
	  }

	  Tooltip.prototype.getUID = function (prefix) {
	    do prefix += ~~(Math.random() * 1000000)
	    while (document.getElementById(prefix))
	    return prefix
	  }

	  Tooltip.prototype.tip = function () {
	    return (this.$tip = this.$tip || $(this.options.template))
	  }

	  Tooltip.prototype.arrow = function () {
	    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
	  }

	  Tooltip.prototype.enable = function () {
	    this.enabled = true
	  }

	  Tooltip.prototype.disable = function () {
	    this.enabled = false
	  }

	  Tooltip.prototype.toggleEnabled = function () {
	    this.enabled = !this.enabled
	  }

	  Tooltip.prototype.toggle = function (e) {
	    var self = this
	    if (e) {
	      self = $(e.currentTarget).data('bs.' + this.type)
	      if (!self) {
	        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
	        $(e.currentTarget).data('bs.' + this.type, self)
	      }
	    }

	    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
	  }

	  Tooltip.prototype.destroy = function () {
	    var that = this
	    clearTimeout(this.timeout)
	    this.hide(function () {
	      that.$element.off('.' + that.type).removeData('bs.' + that.type)
	    })
	  }


	  // TOOLTIP PLUGIN DEFINITION
	  // =========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.tooltip')
	      var options = typeof option == 'object' && option

	      if (!data && option == 'destroy') return
	      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.tooltip

	  $.fn.tooltip             = Plugin
	  $.fn.tooltip.Constructor = Tooltip


	  // TOOLTIP NO CONFLICT
	  // ===================

	  $.fn.tooltip.noConflict = function () {
	    $.fn.tooltip = old
	    return this
	  }

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: popover.js v3.3.2
	 * http://getbootstrap.com/javascript/#popovers
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // POPOVER PUBLIC CLASS DEFINITION
	  // ===============================

	  var Popover = function (element, options) {
	    this.init('popover', element, options)
	  }

	  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

	  Popover.VERSION  = '3.3.2'

	  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
	    placement: 'right',
	    trigger: 'click',
	    content: '',
	    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
	  })


	  // NOTE: POPOVER EXTENDS tooltip.js
	  // ================================

	  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

	  Popover.prototype.constructor = Popover

	  Popover.prototype.getDefaults = function () {
	    return Popover.DEFAULTS
	  }

	  Popover.prototype.setContent = function () {
	    var $tip    = this.tip()
	    var title   = this.getTitle()
	    var content = this.getContent()

	    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
	    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
	      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
	    ](content)

	    $tip.removeClass('fade top bottom left right in')

	    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
	    // this manually by checking the contents.
	    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
	  }

	  Popover.prototype.hasContent = function () {
	    return this.getTitle() || this.getContent()
	  }

	  Popover.prototype.getContent = function () {
	    var $e = this.$element
	    var o  = this.options

	    return $e.attr('data-content')
	      || (typeof o.content == 'function' ?
	            o.content.call($e[0]) :
	            o.content)
	  }

	  Popover.prototype.arrow = function () {
	    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
	  }

	  Popover.prototype.tip = function () {
	    if (!this.$tip) this.$tip = $(this.options.template)
	    return this.$tip
	  }


	  // POPOVER PLUGIN DEFINITION
	  // =========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.popover')
	      var options = typeof option == 'object' && option

	      if (!data && option == 'destroy') return
	      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.popover

	  $.fn.popover             = Plugin
	  $.fn.popover.Constructor = Popover


	  // POPOVER NO CONFLICT
	  // ===================

	  $.fn.popover.noConflict = function () {
	    $.fn.popover = old
	    return this
	  }

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: scrollspy.js v3.3.2
	 * http://getbootstrap.com/javascript/#scrollspy
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // SCROLLSPY CLASS DEFINITION
	  // ==========================

	  function ScrollSpy(element, options) {
	    var process  = $.proxy(this.process, this)

	    this.$body          = $('body')
	    this.$scrollElement = $(element).is('body') ? $(window) : $(element)
	    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
	    this.selector       = (this.options.target || '') + ' .nav li > a'
	    this.offsets        = []
	    this.targets        = []
	    this.activeTarget   = null
	    this.scrollHeight   = 0

	    this.$scrollElement.on('scroll.bs.scrollspy', process)
	    this.refresh()
	    this.process()
	  }

	  ScrollSpy.VERSION  = '3.3.2'

	  ScrollSpy.DEFAULTS = {
	    offset: 10
	  }

	  ScrollSpy.prototype.getScrollHeight = function () {
	    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
	  }

	  ScrollSpy.prototype.refresh = function () {
	    var offsetMethod = 'offset'
	    var offsetBase   = 0

	    if (!$.isWindow(this.$scrollElement[0])) {
	      offsetMethod = 'position'
	      offsetBase   = this.$scrollElement.scrollTop()
	    }

	    this.offsets = []
	    this.targets = []
	    this.scrollHeight = this.getScrollHeight()

	    var self     = this

	    this.$body
	      .find(this.selector)
	      .map(function () {
	        var $el   = $(this)
	        var href  = $el.data('target') || $el.attr('href')
	        var $href = /^#./.test(href) && $(href)

	        return ($href
	          && $href.length
	          && $href.is(':visible')
	          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
	      })
	      .sort(function (a, b) { return a[0] - b[0] })
	      .each(function () {
	        self.offsets.push(this[0])
	        self.targets.push(this[1])
	      })
	  }

	  ScrollSpy.prototype.process = function () {
	    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
	    var scrollHeight = this.getScrollHeight()
	    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
	    var offsets      = this.offsets
	    var targets      = this.targets
	    var activeTarget = this.activeTarget
	    var i

	    if (this.scrollHeight != scrollHeight) {
	      this.refresh()
	    }

	    if (scrollTop >= maxScroll) {
	      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
	    }

	    if (activeTarget && scrollTop < offsets[0]) {
	      this.activeTarget = null
	      return this.clear()
	    }

	    for (i = offsets.length; i--;) {
	      activeTarget != targets[i]
	        && scrollTop >= offsets[i]
	        && (!offsets[i + 1] || scrollTop <= offsets[i + 1])
	        && this.activate(targets[i])
	    }
	  }

	  ScrollSpy.prototype.activate = function (target) {
	    this.activeTarget = target

	    this.clear()

	    var selector = this.selector +
	        '[data-target="' + target + '"],' +
	        this.selector + '[href="' + target + '"]'

	    var active = $(selector)
	      .parents('li')
	      .addClass('active')

	    if (active.parent('.dropdown-menu').length) {
	      active = active
	        .closest('li.dropdown')
	        .addClass('active')
	    }

	    active.trigger('activate.bs.scrollspy')
	  }

	  ScrollSpy.prototype.clear = function () {
	    $(this.selector)
	      .parentsUntil(this.options.target, '.active')
	      .removeClass('active')
	  }


	  // SCROLLSPY PLUGIN DEFINITION
	  // ===========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.scrollspy')
	      var options = typeof option == 'object' && option

	      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.scrollspy

	  $.fn.scrollspy             = Plugin
	  $.fn.scrollspy.Constructor = ScrollSpy


	  // SCROLLSPY NO CONFLICT
	  // =====================

	  $.fn.scrollspy.noConflict = function () {
	    $.fn.scrollspy = old
	    return this
	  }


	  // SCROLLSPY DATA-API
	  // ==================

	  $(window).on('load.bs.scrollspy.data-api', function () {
	    $('[data-spy="scroll"]').each(function () {
	      var $spy = $(this)
	      Plugin.call($spy, $spy.data())
	    })
	  })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: tab.js v3.3.2
	 * http://getbootstrap.com/javascript/#tabs
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // TAB CLASS DEFINITION
	  // ====================

	  var Tab = function (element) {
	    this.element = $(element)
	  }

	  Tab.VERSION = '3.3.2'

	  Tab.TRANSITION_DURATION = 150

	  Tab.prototype.show = function () {
	    var $this    = this.element
	    var $ul      = $this.closest('ul:not(.dropdown-menu)')
	    var selector = $this.data('target')

	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }

	    if ($this.parent('li').hasClass('active')) return

	    var $previous = $ul.find('.active:last a')
	    var hideEvent = $.Event('hide.bs.tab', {
	      relatedTarget: $this[0]
	    })
	    var showEvent = $.Event('show.bs.tab', {
	      relatedTarget: $previous[0]
	    })

	    $previous.trigger(hideEvent)
	    $this.trigger(showEvent)

	    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

	    var $target = $(selector)

	    this.activate($this.closest('li'), $ul)
	    this.activate($target, $target.parent(), function () {
	      $previous.trigger({
	        type: 'hidden.bs.tab',
	        relatedTarget: $this[0]
	      })
	      $this.trigger({
	        type: 'shown.bs.tab',
	        relatedTarget: $previous[0]
	      })
	    })
	  }

	  Tab.prototype.activate = function (element, container, callback) {
	    var $active    = container.find('> .active')
	    var transition = callback
	      && $.support.transition
	      && (($active.length && $active.hasClass('fade')) || !!container.find('> .fade').length)

	    function next() {
	      $active
	        .removeClass('active')
	        .find('> .dropdown-menu > .active')
	          .removeClass('active')
	        .end()
	        .find('[data-toggle="tab"]')
	          .attr('aria-expanded', false)

	      element
	        .addClass('active')
	        .find('[data-toggle="tab"]')
	          .attr('aria-expanded', true)

	      if (transition) {
	        element[0].offsetWidth // reflow for transition
	        element.addClass('in')
	      } else {
	        element.removeClass('fade')
	      }

	      if (element.parent('.dropdown-menu')) {
	        element
	          .closest('li.dropdown')
	            .addClass('active')
	          .end()
	          .find('[data-toggle="tab"]')
	            .attr('aria-expanded', true)
	      }

	      callback && callback()
	    }

	    $active.length && transition ?
	      $active
	        .one('bsTransitionEnd', next)
	        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
	      next()

	    $active.removeClass('in')
	  }


	  // TAB PLUGIN DEFINITION
	  // =====================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.tab')

	      if (!data) $this.data('bs.tab', (data = new Tab(this)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.tab

	  $.fn.tab             = Plugin
	  $.fn.tab.Constructor = Tab


	  // TAB NO CONFLICT
	  // ===============

	  $.fn.tab.noConflict = function () {
	    $.fn.tab = old
	    return this
	  }


	  // TAB DATA-API
	  // ============

	  var clickHandler = function (e) {
	    e.preventDefault()
	    Plugin.call($(this), 'show')
	  }

	  $(document)
	    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
	    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: affix.js v3.3.2
	 * http://getbootstrap.com/javascript/#affix
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // AFFIX CLASS DEFINITION
	  // ======================

	  var Affix = function (element, options) {
	    this.options = $.extend({}, Affix.DEFAULTS, options)

	    this.$target = $(this.options.target)
	      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
	      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

	    this.$element     = $(element)
	    this.affixed      =
	    this.unpin        =
	    this.pinnedOffset = null

	    this.checkPosition()
	  }

	  Affix.VERSION  = '3.3.2'

	  Affix.RESET    = 'affix affix-top affix-bottom'

	  Affix.DEFAULTS = {
	    offset: 0,
	    target: window
	  }

	  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
	    var scrollTop    = this.$target.scrollTop()
	    var position     = this.$element.offset()
	    var targetHeight = this.$target.height()

	    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

	    if (this.affixed == 'bottom') {
	      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
	      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
	    }

	    var initializing   = this.affixed == null
	    var colliderTop    = initializing ? scrollTop : position.top
	    var colliderHeight = initializing ? targetHeight : height

	    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
	    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

	    return false
	  }

	  Affix.prototype.getPinnedOffset = function () {
	    if (this.pinnedOffset) return this.pinnedOffset
	    this.$element.removeClass(Affix.RESET).addClass('affix')
	    var scrollTop = this.$target.scrollTop()
	    var position  = this.$element.offset()
	    return (this.pinnedOffset = position.top - scrollTop)
	  }

	  Affix.prototype.checkPositionWithEventLoop = function () {
	    setTimeout($.proxy(this.checkPosition, this), 1)
	  }

	  Affix.prototype.checkPosition = function () {
	    if (!this.$element.is(':visible')) return

	    var height       = this.$element.height()
	    var offset       = this.options.offset
	    var offsetTop    = offset.top
	    var offsetBottom = offset.bottom
	    var scrollHeight = $('body').height()

	    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
	    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
	    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

	    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

	    if (this.affixed != affix) {
	      if (this.unpin != null) this.$element.css('top', '')

	      var affixType = 'affix' + (affix ? '-' + affix : '')
	      var e         = $.Event(affixType + '.bs.affix')

	      this.$element.trigger(e)

	      if (e.isDefaultPrevented()) return

	      this.affixed = affix
	      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

	      this.$element
	        .removeClass(Affix.RESET)
	        .addClass(affixType)
	        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
	    }

	    if (affix == 'bottom') {
	      this.$element.offset({
	        top: scrollHeight - height - offsetBottom
	      })
	    }
	  }


	  // AFFIX PLUGIN DEFINITION
	  // =======================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.affix')
	      var options = typeof option == 'object' && option

	      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.affix

	  $.fn.affix             = Plugin
	  $.fn.affix.Constructor = Affix


	  // AFFIX NO CONFLICT
	  // =================

	  $.fn.affix.noConflict = function () {
	    $.fn.affix = old
	    return this
	  }


	  // AFFIX DATA-API
	  // ==============

	  $(window).on('load', function () {
	    $('[data-spy="affix"]').each(function () {
	      var $spy = $(this)
	      var data = $spy.data()

	      data.offset = data.offset || {}

	      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
	      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

	      Plugin.call($spy, data)
	    })
	  })

	}(jQuery);



/***/ }
/******/ ]);